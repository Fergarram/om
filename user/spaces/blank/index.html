<!doctype html>
<html>
	<head>
		<meta charset="UTF-8" />
		<!-- Browser Support -->
		<!--
			Determining browser support is hard.
			LLMs are useful for this task.
			I wonder how much would it cost to implement a browser support API that uses an LLM.
			Or even using a local one.
		-->
		<script type="application/json+browser-support">
			{
				"html+css": {
					"chrome": "29 (2013)",
					"firefox": "28 (2014)",
					"safari": "9 (2015)",
					"min": "2013",
					"max": "2015"
				},
				"javascript": {
					"chrome": "89 (2021)",
					"firefox": "108 (2022)",
					"safari": "16.4 (2023)",
					"min": "2021",
					"max": "2023"
				}
			}
		</script>

		<!-- Blob Module Handler -->
		<script>
			window.addEventListener("load", async () => {
				const load_start_time = performance.now();
				const blob_modules = new Map();
				const blob_urls = new Map();
				const remote_modules = new Map();

				//
				// Remote Blob Module Cache
				//

				function openCache() {
					return new Promise((resolve, reject) => {
						const request = indexedDB.open("blob_module_cache", 1);

						request.onerror = () => reject(request.error);
						request.onsuccess = () => resolve(request.result);

						request.onupgradeneeded = (event) => {
							const db = event.target.result;
							if (!db.objectStoreNames.contains("modules")) {
								const store = db.createObjectStore("modules", { keyPath: "url" });
								store.createIndex("timestamp", "timestamp", { unique: false });
							}
						};
					});
				}

				async function getCachedModule(url) {
					try {
						const db = await openCache();
						const transaction = db.transaction(["modules"], "readonly");
						const store = transaction.objectStore("modules");

						return new Promise((resolve, reject) => {
							const request = store.get(url);
							request.onerror = () => reject(request.error);
							request.onsuccess = () => resolve(request.result);
						});
					} catch (error) {
						console.warn("Failed to get cached module:", error);
						return null;
					}
				}

				async function setCachedModule(url, content) {
					try {
						const db = await openCache();
						const transaction = db.transaction(["modules"], "readwrite");
						const store = transaction.objectStore("modules");

						const cache_entry = {
							url: url,
							content: content,
							timestamp: Date.now(),
						};

						return new Promise((resolve, reject) => {
							const request = store.put(cache_entry);
							request.onerror = () => reject(request.error);
							request.onsuccess = () => resolve();
						});
					} catch (error) {
						console.warn("Failed to cache module:", error);
					}
				}

				// Cache busting function - exposing globally
				window.clearBlobModuleCache = async function (url = null) {
					try {
						const db = await openCache();
						const transaction = db.transaction(["modules"], "readwrite");
						const store = transaction.objectStore("modules");

						return new Promise((resolve, reject) => {
							let request;

							if (url) {
								// Clear specific URL
								request = store.delete(url);
								request.onsuccess = () => {
									console.log(`Cleared cache for: ${url}`);
									resolve();
								};
							} else {
								// Clear all cached modules
								request = store.clear();
								request.onsuccess = () => {
									console.log("Cleared all blob module cache");
									resolve();
								};
							}

							request.onerror = () => reject(request.error);
						});
					} catch (error) {
						console.warn("Failed to clear cache:", error);
					}
				};

				//
				// Blob Module Processing
				//

				const blob_scripts = document.querySelectorAll('script[type="blob-module"]');

				// First pass: collect all module contents and remote URLs
				blob_scripts.forEach((script) => {
					const module_name = script.getAttribute("name");
					const remote_url = script.getAttribute("remote");

					if (!module_name) {
						console.warn("blob-module script missing name attribute");
						return;
					}

					// Check for name collisions
					if (blob_modules.has(module_name) || remote_modules.has(module_name)) {
						console.warn(`Module name collision detected: "${module_name}" already exists. Skipping duplicate.`);
						return;
					}

					// @TODO: We could minify or format here since this will be the source map from blobs
					const content = script.textContent.trim();

					if (remote_url) {
						if (!content) {
							// Empty content with remote URL - fetch remote
							remote_modules.set(module_name, remote_url);
							return;
						} else {
							// Both remote and content exist - store local, compare later
							blob_modules.set(module_name, content);
							remote_modules.set(module_name, remote_url);
							return;
						}
					}

					// No remote URL, just store content
					blob_modules.set(module_name, content);
				});

				// Fetch remote modules (with caching) and create local copies before proceeding
				for (const [module_name, remote_url] of remote_modules) {
					try {
						// Check cache first
						const cached_module = await getCachedModule(remote_url);
						let remote_content;

						if (cached_module) {
							console.log(`Using cached module "${module_name}" from ${remote_url}`);
							remote_content = cached_module.content;
						} else {
							console.log(`Fetching remote module "${module_name}" from ${remote_url}`);
							const response = await fetch(remote_url);
							remote_content = await response.text();

							// Cache the fetched content
							await setCachedModule(remote_url, remote_content);
							console.log(`Cached remote module "${module_name}"`);
						}

						if (blob_modules.has(module_name)) {
							// Compare with existing local content
							// @TODO: Minify and compare minified content instead
							const local_content = blob_modules.get(module_name);
							if (remote_content.trim() !== local_content.trim()) {
								console.warn(
									`Remote and local content are different for module "${module_name}". Using local content.`,
								);
							}
							// Keep local content
						} else {
							// No local content, use fetched remote content
							blob_modules.set(module_name, remote_content);
							console.log(`Successfully loaded remote module "${module_name}"`);
						}
					} catch (error) {
						console.warn(`Failed to fetch remote module "${module_name}":`, error);
						if (!blob_modules.has(module_name)) {
							// Use remote URL directly in importmap
							blob_urls.set(module_name, remote_url);
							console.log(`Will use remote URL directly for module "${module_name}"`);
						} else if (blob_modules.has(module_name)) {
							console.log(`Using local module "${module_name}"`);
						}
					}
				}

				// Create blob URLs for all modules
				blob_modules.forEach((content, module_name) => {
					const module_blob = new Blob([content], { type: "text/javascript" });
					const blob_url = URL.createObjectURL(module_blob);
					blob_urls.set(module_name, blob_url);
				});

				// Clear script tag contents and add blob URL attributes
				blob_scripts.forEach((script) => {
					const module_name = script.getAttribute("name");
					const blob_url = blob_urls.get(module_name);

					if (blob_url) {
						// Clear the textContent to free up memory
						script.textContent = "";
						// Add blob URL as attribute for reference
						script.setAttribute("blob", blob_url);
					}
				});

				// Create import map with all blob URLs
				const imports = {};
				blob_urls.forEach((url, name) => {
					imports[name] = url;
				});

				const import_map = document.createElement("script");
				import_map.type = "importmap";
				import_map.textContent = JSON.stringify({ imports }, null, 2);
				document.head.appendChild(import_map);

				// Run the main module if it exists
				if (blob_modules.has("main")) {
					setTimeout(() => {
						const main_script = document.createElement("script");
						main_script.type = "module";
						main_script.setAttribute("entrypoint", "");
						main_script.textContent = `
							const main_start_time = performance.now();
							const load_duration = main_start_time - ${load_start_time};
							console.log(\`Main module started \${load_duration.toFixed(2)}ms after page load\`);
							import("main");
						`;
						document.head.appendChild(main_script);
					}, 0);
				}

				// Expose blob module metadata map
				window.__blob_module_map__ = new Map();

				// Populate the metadata map
				blob_scripts.forEach((script) => {
					const module_name = script.getAttribute("name");
					const remote_url = script.getAttribute("remote") || null;
					const blob_url = blob_urls.get(module_name) || null;
					const content = blob_modules.get(module_name) || "";

					// Calculate source size in bytes
					const src_bytes = new Blob([content]).size;

					const metadata = {
						module_name,
						src_bytes,
						remote_url,
						blob_url,
					};

					window.__blob_module_map__.set(module_name, metadata);
				});

				//
				// Editable HTML Export
				//

				window.downloadHtmlFile = function () {
					// Clone the current document
					const doc_clone = document.cloneNode(true);

					// Remove the importmap script we added
					const import_map_script = doc_clone.querySelector('script[type="importmap"]');
					if (import_map_script) {
						import_map_script.remove();
					}

					// Remove the main execution script we added
					const main_execution_script = doc_clone.querySelector("script[entrypoint]");
					main_execution_script.remove();

					// Process blob-module scripts
					const cloned_blob_scripts = doc_clone.querySelectorAll('script[type="blob-module"]');

					cloned_blob_scripts.forEach((script) => {
						const module_name = script.getAttribute("name");
						const remote_url = script.getAttribute("remote");
						const no_download = script.hasAttribute("nodownload");

						// Remove blob attribute if it exists
						if (script.hasAttribute("blob")) {
							script.removeAttribute("blob");
						}

						// Get the module content
						const module_content = blob_modules.get(module_name);

						// Check for nodownload modules
						if (module_content && !no_download) {
							script.textContent = module_content;
						} else if (no_download) {
							// Keep the remote URL but clear any local content
							script.textContent = "";
						}
					});

					// Get the full HTML
					const html_content = `<!DOCTYPE html>\n${doc_clone.documentElement.outerHTML}`;

					// Create and trigger download
					const blob = new Blob([html_content], { type: "text/html" });
					const url = URL.createObjectURL(blob);

					const download_link = document.createElement("a");
					download_link.href = url;
					download_link.download = "index.html";
					download_link.click();

					// Clean up the blob URL
					URL.revokeObjectURL(url);

					console.log("HTML file download initiated");
				};
			});
		</script>

		<!-- Main Entry -->
		<script type="blob-module" name="main">
			import { sayHello } from "@/some/module";
			import { useTags } from "ima";
			const { canvas, div } = useTags();

			// Create a 32x32 canvas for the cursor
			const cursor_canvas = canvas({
				width: 32,
				height: 32,
				style: "display: none;" // Hide the canvas since we only need its data
			});

			document.body.appendChild(cursor_canvas);

			const ctx = cursor_canvas.getContext('2d');
			let frame = 0;

			function drawCursor() {
				// Clear canvas
				ctx.clearRect(0, 0, 32, 32);

				// Animate the cursor shape - a pulsing circle
				const pulse = Math.sin(frame * 0.1) * 0.3 + 0.7; // oscillate between 0.4 and 1.0
				const radius = 8 * pulse;

				// Draw cursor shape
				ctx.fillStyle = '#ffffff';
				ctx.strokeStyle = '#000000';
				ctx.lineWidth = 2;

				// Draw a circle at center
				ctx.beginPath();
				ctx.arc(16, 16, radius, 0, Math.PI * 2);
				ctx.fill();
				ctx.stroke();

				// Convert canvas to base64 data URL
				const data_url = cursor_canvas.toDataURL('image/png');

				// Set as cursor
				document.body.style.willChange = 'cursor';
				document.body.style.cursor = `url(${data_url}) 16 16, auto`;

				frame++;
				requestAnimationFrame(drawCursor);
			}

			// Start the animation
			drawCursor();

			const content = div({
				style: `
					display: flex;
					align-items: center;
					justify-content: center;
					height: 100vh;
					color: white;
					background: #222;
					font-family: monospace;
					font-size: 24px;
				`
			}, "Move your cursor around!");

			document.body.replaceChildren(content);

			console.log(sayHello("World"));
		</script>

		<!-- Local Modules -->
		<script type="blob-module" name="@/some/module">
			export function sayHello(name) {
				return `Hello, ${name}!`;
			}
		</script>

		<!-- Remote Modules -->
		<script type="blob-module" name="ima" remote="https://cdn.jsdelivr.net/gh/Fergarram/ima@main/ima-0.6.0.esm.js"></script>
		<!-- <script
			type="blob-module"
			name="tsc"
			remote="file:///Users/fernando/repos/om/user/spaces/blank/tsc.js"
			nodownload
		></script>
		<script
			type="blob-module"
			name="assemblyscript"
			remote="https://cdn.jsdelivr.net/npm/assemblyscript@0.28.4/dist/assemblyscript.js"
			nodownload
		></script>
		<script
			type="blob-module"
			name="asc"
			remote="https://cdn.jsdelivr.net/npm/assemblyscript@0.28.4/dist/asc.js"
			nodownload
		></script>
		<script
			type="blob-module"
			name="binaryen"
			remote="https://cdn.jsdelivr.net/npm/binaryen@123.0.0-nightly.20250530/index.js"
			nodownload
		></script>
		<script type="blob-module" name="long" remote="https://cdn.jsdelivr.net/npm/long@5.2.4/index.js" nodownload></script> -->
	</head>
	<body></body>
</html>
