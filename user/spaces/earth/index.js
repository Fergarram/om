var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);

// node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.maplibregl = factory());
  })(exports, function() {
    var maplibregl = {};
    var modules = {};
    function define2(moduleName, _dependencies, moduleFactory) {
      modules[moduleName] = moduleFactory;
      if (moduleName !== "index") {
        return;
      }
      var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
      var sharedModule = {};
      modules.shared(sharedModule);
      modules.index(maplibregl, sharedModule);
      if (typeof window !== "undefined") {
        maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
      }
      return maplibregl;
    }
    define2("shared", ["exports"], function(t) {
      function e(t2, e2, r2, n2) {
        return new (r2 || (r2 = Promise))(function(i2, s2) {
          function a2(t3) {
            try {
              l3(n2.next(t3));
            } catch (t4) {
              s2(t4);
            }
          }
          function o2(t3) {
            try {
              l3(n2.throw(t3));
            } catch (t4) {
              s2(t4);
            }
          }
          function l3(t3) {
            var e3;
            t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
              t4(e3);
            })).then(a2, o2);
          }
          l3((n2 = n2.apply(t2, e2 || [])).next());
        });
      }
      function r(t2) {
        return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
      }
      var n, i;
      function s() {
        if (i)
          return n;
        function t2(t3, e2) {
          this.x = t3, this.y = e2;
        }
        return i = 1, n = t2, t2.prototype = { clone: function() {
          return new t2(this.x, this.y);
        }, add: function(t3) {
          return this.clone()._add(t3);
        }, sub: function(t3) {
          return this.clone()._sub(t3);
        }, multByPoint: function(t3) {
          return this.clone()._multByPoint(t3);
        }, divByPoint: function(t3) {
          return this.clone()._divByPoint(t3);
        }, mult: function(t3) {
          return this.clone()._mult(t3);
        }, div: function(t3) {
          return this.clone()._div(t3);
        }, rotate: function(t3) {
          return this.clone()._rotate(t3);
        }, rotateAround: function(t3, e2) {
          return this.clone()._rotateAround(t3, e2);
        }, matMult: function(t3) {
          return this.clone()._matMult(t3);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t3) {
          return this.x === t3.x && this.y === t3.y;
        }, dist: function(t3) {
          return Math.sqrt(this.distSqr(t3));
        }, distSqr: function(t3) {
          var e2 = t3.x - this.x, r2 = t3.y - this.y;
          return e2 * e2 + r2 * r2;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t3) {
          return Math.atan2(this.y - t3.y, this.x - t3.x);
        }, angleWith: function(t3) {
          return this.angleWithSep(t3.x, t3.y);
        }, angleWithSep: function(t3, e2) {
          return Math.atan2(this.x * e2 - this.y * t3, this.x * t3 + this.y * e2);
        }, _matMult: function(t3) {
          var e2 = t3[2] * this.x + t3[3] * this.y;
          return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e2, this;
        }, _add: function(t3) {
          return this.x += t3.x, this.y += t3.y, this;
        }, _sub: function(t3) {
          return this.x -= t3.x, this.y -= t3.y, this;
        }, _mult: function(t3) {
          return this.x *= t3, this.y *= t3, this;
        }, _div: function(t3) {
          return this.x /= t3, this.y /= t3, this;
        }, _multByPoint: function(t3) {
          return this.x *= t3.x, this.y *= t3.y, this;
        }, _divByPoint: function(t3) {
          return this.x /= t3.x, this.y /= t3.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t3 = this.y;
          return this.y = this.x, this.x = -t3, this;
        }, _rotate: function(t3) {
          var e2 = Math.cos(t3), r2 = Math.sin(t3), n2 = r2 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
        }, _rotateAround: function(t3, e2) {
          var r2 = Math.cos(t3), n2 = Math.sin(t3), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, t2.convert = function(e2) {
          return e2 instanceof t2 ? e2 : Array.isArray(e2) ? new t2(e2[0], e2[1]) : e2;
        }, n;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var a, o, l2 = r(s()), u = function() {
        if (o)
          return a;
        function t2(t3, e2, r2, n2) {
          this.cx = 3 * t3, this.bx = 3 * (r2 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r2, this.p2y = n2;
        }
        return o = 1, a = t2, t2.prototype = { sampleCurveX: function(t3) {
          return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
        }, sampleCurveY: function(t3) {
          return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
        }, sampleCurveDerivativeX: function(t3) {
          return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
        }, solveCurveX: function(t3, e2) {
          if (e2 === undefined && (e2 = 0.000001), t3 < 0)
            return 0;
          if (t3 > 1)
            return 1;
          for (var r2 = t3, n2 = 0;n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r2) - t3;
            if (Math.abs(i2) < e2)
              return r2;
            var s2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(s2) < 0.000001)
              break;
            r2 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r2 = t3, n2 = 0;n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t3) < e2)); n2++)
            t3 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
          return r2;
        }, solve: function(t3, e2) {
          return this.sampleCurveY(this.solveCurveX(t3, e2));
        } }, a;
      }(), c = r(u);
      let h, p;
      function f() {
        return h == null && (h = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), h;
      }
      function d() {
        if (p == null && (p = false, f())) {
          const t2 = 5, e2 = new OffscreenCanvas(t2, t2).getContext("2d", { willReadFrequently: true });
          if (e2) {
            for (let r3 = 0;r3 < t2 * t2; r3++) {
              const n2 = 4 * r3;
              e2.fillStyle = `rgb(${n2},${n2 + 1},${n2 + 2})`, e2.fillRect(r3 % t2, Math.floor(r3 / t2), 1, 1);
            }
            const r2 = e2.getImageData(0, 0, t2, t2).data;
            for (let e3 = 0;e3 < t2 * t2 * 4; e3++)
              if (e3 % 4 != 3 && r2[e3] !== e3) {
                p = true;
                break;
              }
          }
        }
        return p || false;
      }
      var y = 0.000001, m = typeof Float32Array != "undefined" ? Float32Array : Array;
      function g() {
        var t2 = new m(9);
        return m != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
      }
      function x(t2) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }
      function v() {
        var t2 = new m(3);
        return m != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
      }
      function b(t2) {
        return Math.hypot(t2[0], t2[1], t2[2]);
      }
      function w(t2, e2, r2) {
        var n2 = new m(3);
        return n2[0] = t2, n2[1] = e2, n2[2] = r2, n2;
      }
      Math.hypot || (Math.hypot = function() {
        for (var t2 = 0, e2 = arguments.length;e2--; )
          t2 += arguments[e2] * arguments[e2];
        return Math.sqrt(t2);
      });
      var _, A = b;
      function S(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
        return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
      }
      function k() {
        var t2 = new m(4);
        return m != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
      }
      function M2() {
        var t2 = new m(2);
        return m != Float32Array && (t2[0] = 0, t2[1] = 0), t2;
      }
      function I(t2, e2) {
        var r2 = new m(2);
        return r2[0] = t2, r2[1] = e2, r2;
      }
      v(), _ = new m(4), m != Float32Array && (_[0] = 0, _[1] = 0, _[2] = 0, _[3] = 0), v(), w(1, 0, 0), w(0, 1, 0), k(), k(), g(), M2();
      const z2 = 8192;
      function P(t2, e2, r2) {
        return e2 * (z2 / (t2.tileSize * Math.pow(2, r2 - t2.tileID.overscaledZ)));
      }
      function C(t2, e2) {
        return (t2 % e2 + e2) % e2;
      }
      function B2(t2, e2, r2) {
        return t2 * (1 - r2) + e2 * r2;
      }
      function V(t2) {
        if (t2 <= 0)
          return 0;
        if (t2 >= 1)
          return 1;
        const e2 = t2 * t2, r2 = e2 * t2;
        return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e2) + r2 - 0.75);
      }
      function E2(t2, e2, r2, n2) {
        const i2 = new c(t2, e2, r2, n2);
        return (t3) => i2.solve(t3);
      }
      const T = E2(0.25, 0.1, 0.25, 1);
      function F2(t2, e2, r2) {
        return Math.min(r2, Math.max(e2, t2));
      }
      function $2(t2, e2, r2) {
        const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
        return i2 === e2 ? r2 : i2;
      }
      function L(t2, ...e2) {
        for (const r2 of e2)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }
      let O = 1;
      function D2(t2, e2, r2) {
        const n2 = {};
        for (const r3 in t2)
          n2[r3] = e2.call(this, t2[r3], r3, t2);
        return n2;
      }
      function j2(t2, e2, r2) {
        const n2 = {};
        for (const r3 in t2)
          e2.call(this, t2[r3], r3, t2) && (n2[r3] = t2[r3]);
        return n2;
      }
      function R(t2) {
        return Array.isArray(t2) ? t2.map(R) : typeof t2 == "object" && t2 ? D2(t2, R) : t2;
      }
      const N = {};
      function U(t2) {
        N[t2] || (typeof console != "undefined" && console.warn(t2), N[t2] = true);
      }
      function q(t2, e2, r2) {
        return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
      }
      function G2(t2) {
        return typeof WorkerGlobalScope != "undefined" && t2 !== undefined && t2 instanceof WorkerGlobalScope;
      }
      let Z2 = null;
      function K(t2) {
        return typeof ImageBitmap != "undefined" && t2 instanceof ImageBitmap;
      }
      const X = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function H(t2, r2, n2, i2, s2) {
        return e(this, undefined, undefined, function* () {
          if (typeof VideoFrame == "undefined")
            throw new Error("VideoFrame not supported");
          const e2 = new VideoFrame(t2, { timestamp: 0 });
          try {
            const a2 = e2 == null ? undefined : e2.format;
            if (!a2 || !a2.startsWith("BGR") && !a2.startsWith("RGB"))
              throw new Error(`Unrecognized format ${a2}`);
            const o2 = a2.startsWith("BGR"), l3 = new Uint8ClampedArray(i2 * s2 * 4);
            if (yield e2.copyTo(l3, function(t3, e3, r3, n3, i3) {
              const s3 = 4 * Math.max(1, 0), a3 = (Math.max(0, r3) - r3) * n3 * 4 + s3, o3 = 4 * n3, l4 = Math.max(0, e3), u2 = Math.max(0, r3);
              return { rect: { x: l4, y: u2, width: Math.min(t3.width, e3 + n3) - l4, height: Math.min(t3.height, r3 + i3) - u2 }, layout: [{ offset: a3, stride: o3 }] };
            }(t2, r2, n2, i2, s2)), o2)
              for (let t3 = 0;t3 < l3.length; t3 += 4) {
                const e3 = l3[t3];
                l3[t3] = l3[t3 + 2], l3[t3 + 2] = e3;
              }
            return l3;
          } finally {
            e2.close();
          }
        });
      }
      let Y2, J2;
      function W2(t2, e2, r2, n2) {
        return t2.addEventListener(e2, r2, n2), { unsubscribe: () => {
          t2.removeEventListener(e2, r2, n2);
        } };
      }
      function Q2(t2) {
        return t2 * Math.PI / 180;
      }
      function tt2(t2) {
        return t2 / Math.PI * 180;
      }
      const et = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, rt2 = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, nt2 = "AbortError";
      function it2() {
        return new Error(nt2);
      }
      const st2 = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function at2(t2) {
        return st2.REGISTERED_PROTOCOLS[t2.substring(0, t2.indexOf("://"))];
      }
      const ot2 = "global-dispatcher";

      class lt2 extends Error {
        constructor(t2, e2, r2, n2) {
          super(`AJAXError: ${e2} (${t2}): ${r2}`), this.status = t2, this.statusText = e2, this.url = r2, this.body = n2;
        }
      }
      const ut2 = () => G2(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, ct2 = function(t2, r2) {
        if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
          const e2 = at2(t2.url);
          if (e2)
            return e2(t2, r2);
          if (G2(self) && self.worker && self.worker.actor)
            return self.worker.actor.sendAsync({ type: "GR", data: t2, targetMapId: ot2 }, r2);
        }
        if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(ut2()) && !/^\w+:/.test(n2))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
            return function(t3, r3) {
              return e(this, undefined, undefined, function* () {
                const e2 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, cache: t3.cache, referrer: ut2(), signal: r3.signal });
                let n3, i2;
                t3.type !== "json" || e2.headers.has("Accept") || e2.headers.set("Accept", "application/json");
                try {
                  n3 = yield fetch(e2);
                } catch (e3) {
                  throw new lt2(0, e3.message, t3.url, new Blob);
                }
                if (!n3.ok) {
                  const e3 = yield n3.blob();
                  throw new lt2(n3.status, n3.statusText, t3.url, e3);
                }
                i2 = t3.type === "arrayBuffer" || t3.type === "image" ? n3.arrayBuffer() : t3.type === "json" ? n3.json() : n3.text();
                const s2 = yield i2;
                if (r3.signal.aborted)
                  throw it2();
                return { data: s2, cacheControl: n3.headers.get("Cache-Control"), expires: n3.headers.get("Expires") };
              });
            }(t2, r2);
          if (G2(self) && self.worker && self.worker.actor)
            return self.worker.actor.sendAsync({ type: "GR", data: t2, mustQueue: true, targetMapId: ot2 }, r2);
        }
        var n2;
        return function(t3, e2) {
          return new Promise((r3, n3) => {
            var i2;
            const s2 = new XMLHttpRequest;
            s2.open(t3.method || "GET", t3.url, true), t3.type !== "arrayBuffer" && t3.type !== "image" || (s2.responseType = "arraybuffer");
            for (const e3 in t3.headers)
              s2.setRequestHeader(e3, t3.headers[e3]);
            t3.type === "json" && (s2.responseType = "text", ((i2 = t3.headers) === null || i2 === undefined ? undefined : i2.Accept) || s2.setRequestHeader("Accept", "application/json")), s2.withCredentials = t3.credentials === "include", s2.onerror = () => {
              n3(new Error(s2.statusText));
            }, s2.onload = () => {
              if (!e2.signal.aborted)
                if ((s2.status >= 200 && s2.status < 300 || s2.status === 0) && s2.response !== null) {
                  let e3 = s2.response;
                  if (t3.type === "json")
                    try {
                      e3 = JSON.parse(s2.response);
                    } catch (t4) {
                      return void n3(t4);
                    }
                  r3({ data: e3, cacheControl: s2.getResponseHeader("Cache-Control"), expires: s2.getResponseHeader("Expires") });
                } else {
                  const e3 = new Blob([s2.response], { type: s2.getResponseHeader("Content-Type") });
                  n3(new lt2(s2.status, s2.statusText, t3.url, e3));
                }
            }, e2.signal.addEventListener("abort", () => {
              s2.abort(), n3(it2());
            }), s2.send(t3.body);
          });
        }(t2, r2);
      };
      function ht2(t2) {
        if (!t2 || t2.indexOf("://") <= 0 || t2.indexOf("data:image/") === 0 || t2.indexOf("blob:") === 0)
          return true;
        const e2 = new URL(t2), r2 = window.location;
        return e2.protocol === r2.protocol && e2.host === r2.host;
      }
      function pt2(t2, e2, r2) {
        r2[t2] && r2[t2].indexOf(e2) !== -1 || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
      }
      function ft2(t2, e2, r2) {
        if (r2 && r2[t2]) {
          const n2 = r2[t2].indexOf(e2);
          n2 !== -1 && r2[t2].splice(n2, 1);
        }
      }

      class dt2 {
        constructor(t2, e2 = {}) {
          L(this, e2), this.type = t2;
        }
      }

      class yt2 extends dt2 {
        constructor(t2, e2 = {}) {
          super("error", L({ error: t2 }, e2));
        }
      }

      class mt2 {
        on(t2, e2) {
          return this._listeners = this._listeners || {}, pt2(t2, e2, this._listeners), { unsubscribe: () => {
            this.off(t2, e2);
          } };
        }
        off(t2, e2) {
          return ft2(t2, e2, this._listeners), ft2(t2, e2, this._oneTimeListeners), this;
        }
        once(t2, e2) {
          return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, pt2(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
        }
        fire(t2, e2) {
          typeof t2 == "string" && (t2 = new dt2(t2, e2 || {}));
          const r2 = t2.type;
          if (this.listens(r2)) {
            t2.target = this;
            const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
            for (const r3 of e3)
              r3.call(this, t2);
            const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
            for (const e4 of n2)
              ft2(r2, e4, this._oneTimeListeners), e4.call(this, t2);
            const i2 = this._eventedParent;
            i2 && (L(t2, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
          } else
            t2 instanceof yt2 && console.error(t2.error);
          return this;
        }
        listens(t2) {
          return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
        }
        setEventedParent(t2, e2) {
          return this._eventedParent = t2, this._eventedParentData = e2, this;
        }
      }
      var gt2 = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const xt2 = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function vt2(t2, e2) {
        const r2 = {};
        for (const e3 in t2)
          e3 !== "ref" && (r2[e3] = t2[e3]);
        return xt2.forEach((t3) => {
          t3 in e2 && (r2[t3] = e2[t3]);
        }), r2;
      }
      function bt2(t2, e2) {
        if (Array.isArray(t2)) {
          if (!Array.isArray(e2) || t2.length !== e2.length)
            return false;
          for (let r2 = 0;r2 < t2.length; r2++)
            if (!bt2(t2[r2], e2[r2]))
              return false;
          return true;
        }
        if (typeof t2 == "object" && t2 !== null && e2 !== null) {
          if (typeof e2 != "object")
            return false;
          if (Object.keys(t2).length !== Object.keys(e2).length)
            return false;
          for (const r2 in t2)
            if (!bt2(t2[r2], e2[r2]))
              return false;
          return true;
        }
        return t2 === e2;
      }
      function wt(t2, e2) {
        t2.push(e2);
      }
      function _t2(t2, e2, r2) {
        wt(r2, { command: "addSource", args: [t2, e2[t2]] });
      }
      function At2(t2, e2, r2) {
        wt(e2, { command: "removeSource", args: [t2] }), r2[t2] = true;
      }
      function St2(t2, e2, r2, n2) {
        At2(t2, r2, n2), _t2(t2, e2, r2);
      }
      function kt2(t2, e2, r2) {
        let n2;
        for (n2 in t2[r2])
          if (Object.prototype.hasOwnProperty.call(t2[r2], n2) && n2 !== "data" && !bt2(t2[r2][n2], e2[r2][n2]))
            return false;
        for (n2 in e2[r2])
          if (Object.prototype.hasOwnProperty.call(e2[r2], n2) && n2 !== "data" && !bt2(t2[r2][n2], e2[r2][n2]))
            return false;
        return true;
      }
      function Mt2(t2, e2, r2, n2, i2, s2) {
        t2 = t2 || {}, e2 = e2 || {};
        for (const a2 in t2)
          Object.prototype.hasOwnProperty.call(t2, a2) && (bt2(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
        for (const a2 in e2)
          Object.prototype.hasOwnProperty.call(e2, a2) && !Object.prototype.hasOwnProperty.call(t2, a2) && (bt2(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
      }
      function It2(t2) {
        return t2.id;
      }
      function zt2(t2, e2) {
        return t2[e2.id] = e2, t2;
      }

      class Pt2 {
        constructor(t2, e2, r2, n2) {
          this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), e2 != null && e2.__line__ && (this.line = e2.__line__);
        }
      }
      function Ct(t2, ...e2) {
        for (const r2 of e2)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }

      class Bt2 extends Error {
        constructor(t2, e2) {
          super(e2), this.message = e2, this.key = t2;
        }
      }

      class Vt2 {
        constructor(t2, e2 = []) {
          this.parent = t2, this.bindings = {};
          for (const [t3, r2] of e2)
            this.bindings[t3] = r2;
        }
        concat(t2) {
          return new Vt2(this, t2);
        }
        get(t2) {
          if (this.bindings[t2])
            return this.bindings[t2];
          if (this.parent)
            return this.parent.get(t2);
          throw new Error(`${t2} not found in scope.`);
        }
        has(t2) {
          return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
        }
      }
      const Et2 = { kind: "null" }, Tt2 = { kind: "number" }, Ft2 = { kind: "string" }, $t2 = { kind: "boolean" }, Lt2 = { kind: "color" }, Ot2 = { kind: "projectionDefinition" }, Dt2 = { kind: "object" }, jt2 = { kind: "value" }, Rt2 = { kind: "collator" }, Nt2 = { kind: "formatted" }, Ut = { kind: "padding" }, qt2 = { kind: "colorArray" }, Gt2 = { kind: "numberArray" }, Zt2 = { kind: "resolvedImage" }, Kt2 = { kind: "variableAnchorOffsetCollection" };
      function Xt2(t2, e2) {
        return { kind: "array", itemType: t2, N: e2 };
      }
      function Ht2(t2) {
        if (t2.kind === "array") {
          const e2 = Ht2(t2.itemType);
          return typeof t2.N == "number" ? `array<${e2}, ${t2.N}>` : t2.itemType.kind === "value" ? "array" : `array<${e2}>`;
        }
        return t2.kind;
      }
      const Yt2 = [Et2, Tt2, Ft2, $t2, Lt2, Ot2, Nt2, Dt2, Xt2(jt2), Ut, Gt2, qt2, Zt2, Kt2];
      function Jt2(t2, e2) {
        if (e2.kind === "error")
          return null;
        if (t2.kind === "array") {
          if (e2.kind === "array" && (e2.N === 0 && e2.itemType.kind === "value" || !Jt2(t2.itemType, e2.itemType)) && (typeof t2.N != "number" || t2.N === e2.N))
            return null;
        } else {
          if (t2.kind === e2.kind)
            return null;
          if (t2.kind === "value") {
            for (const t3 of Yt2)
              if (!Jt2(t3, e2))
                return null;
          }
        }
        return `Expected ${Ht2(t2)} but found ${Ht2(e2)} instead.`;
      }
      function Wt2(t2, e2) {
        return e2.some((e3) => e3.kind === t2.kind);
      }
      function Qt2(t2, e2) {
        return e2.some((e3) => e3 === "null" ? t2 === null : e3 === "array" ? Array.isArray(t2) : e3 === "object" ? t2 && !Array.isArray(t2) && typeof t2 == "object" : e3 === typeof t2);
      }
      function te2(t2, e2) {
        return t2.kind === "array" && e2.kind === "array" ? t2.itemType.kind === e2.itemType.kind && typeof t2.N == "number" : t2.kind === e2.kind;
      }
      const ee2 = 0.96422, re2 = 0.82521, ne2 = 4 / 29, ie2 = 6 / 29, se2 = 3 * ie2 * ie2, ae = ie2 * ie2 * ie2, oe = Math.PI / 180, le2 = 180 / Math.PI;
      function ue2(t2) {
        return (t2 %= 360) < 0 && (t2 += 360), t2;
      }
      function ce2([t2, e2, r2, n2]) {
        let i2, s2;
        const a2 = pe2((0.2225045 * (t2 = he2(t2)) + 0.7168786 * (e2 = he2(e2)) + 0.0606169 * (r2 = he2(r2))) / 1);
        t2 === e2 && e2 === r2 ? i2 = s2 = a2 : (i2 = pe2((0.4360747 * t2 + 0.3850649 * e2 + 0.1430804 * r2) / ee2), s2 = pe2((0.0139322 * t2 + 0.0971045 * e2 + 0.7141733 * r2) / re2));
        const o2 = 116 * a2 - 16;
        return [o2 < 0 ? 0 : o2, 500 * (i2 - a2), 200 * (a2 - s2), n2];
      }
      function he2(t2) {
        return t2 <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
      }
      function pe2(t2) {
        return t2 > ae ? Math.pow(t2, 1 / 3) : t2 / se2 + ne2;
      }
      function fe2([t2, e2, r2, n2]) {
        let i2 = (t2 + 16) / 116, s2 = isNaN(e2) ? i2 : i2 + e2 / 500, a2 = isNaN(r2) ? i2 : i2 - r2 / 200;
        return i2 = 1 * ye2(i2), s2 = ee2 * ye2(s2), a2 = re2 * ye2(a2), [de2(3.1338561 * s2 - 1.6168667 * i2 - 0.4906146 * a2), de2(-0.9787684 * s2 + 1.9161415 * i2 + 0.033454 * a2), de2(0.0719453 * s2 - 0.2289914 * i2 + 1.4052427 * a2), n2];
      }
      function de2(t2) {
        return (t2 = t2 <= 0.00304 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055) < 0 ? 0 : t2 > 1 ? 1 : t2;
      }
      function ye2(t2) {
        return t2 > ie2 ? t2 * t2 * t2 : se2 * (t2 - ne2);
      }
      const me2 = Object.hasOwn || function(t2, e2) {
        return Object.prototype.hasOwnProperty.call(t2, e2);
      };
      function ge2(t2, e2) {
        return me2(t2, e2) ? t2[e2] : undefined;
      }
      function xe2(t2) {
        return parseInt(t2.padEnd(2, t2), 16) / 255;
      }
      function ve2(t2, e2) {
        return be2(e2 ? t2 / 100 : t2, 0, 1);
      }
      function be2(t2, e2, r2) {
        return Math.min(Math.max(e2, t2), r2);
      }
      function we(t2) {
        return !t2.some(Number.isNaN);
      }
      const _e2 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      function Ae2(t2, e2, r2) {
        return t2 + r2 * (e2 - t2);
      }
      function Se2(t2, e2, r2) {
        return t2.map((t3, n2) => Ae2(t3, e2[n2], r2));
      }

      class ke2 {
        constructor(t2, e2, r2, n2 = 1, i2 = true) {
          this.r = t2, this.g = e2, this.b = r2, this.a = n2, i2 || (this.r *= n2, this.g *= n2, this.b *= n2, n2 || this.overwriteGetter("rgb", [t2, e2, r2, n2]));
        }
        static parse(t2) {
          if (t2 instanceof ke2)
            return t2;
          if (typeof t2 != "string")
            return;
          const e2 = function(t3) {
            if ((t3 = t3.toLowerCase().trim()) === "transparent")
              return [0, 0, 0, 0];
            const e3 = ge2(_e2, t3);
            if (e3) {
              const [t4, r3, n2] = e3;
              return [t4 / 255, r3 / 255, n2 / 255, 1];
            }
            if (t3.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t3)) {
              const e4 = t3.length < 6 ? 1 : 2;
              let r3 = 1;
              return [xe2(t3.slice(r3, r3 += e4)), xe2(t3.slice(r3, r3 += e4)), xe2(t3.slice(r3, r3 += e4)), xe2(t3.slice(r3, r3 + e4) || "ff")];
            }
            if (t3.startsWith("rgb")) {
              const e4 = t3.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (e4) {
                const [t4, r3, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2] = e4, f2 = [i2 || " ", o2 || " ", c2].join("");
                if (f2 === "  " || f2 === "  /" || f2 === ",," || f2 === ",,,") {
                  const t5 = [n2, a2, u2].join(""), e5 = t5 === "%%%" ? 100 : t5 === "" ? 255 : 0;
                  if (e5) {
                    const t6 = [be2(+r3 / e5, 0, 1), be2(+s2 / e5, 0, 1), be2(+l3 / e5, 0, 1), h2 ? ve2(+h2, p2) : 1];
                    if (we(t6))
                      return t6;
                  }
                }
                return;
              }
            }
            const r2 = t3.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (r2) {
              const [t4, e4, n2, i2, s2, a2, o2, l3, u2] = r2, c2 = [n2 || " ", s2 || " ", o2].join("");
              if (c2 === "  " || c2 === "  /" || c2 === ",," || c2 === ",,,") {
                const t5 = [+e4, be2(+i2, 0, 100), be2(+a2, 0, 100), l3 ? ve2(+l3, u2) : 1];
                if (we(t5))
                  return function([t6, e5, r3, n3]) {
                    function i3(n4) {
                      const i4 = (n4 + t6 / 30) % 12, s3 = e5 * Math.min(r3, 1 - r3);
                      return r3 - s3 * Math.max(-1, Math.min(i4 - 3, 9 - i4, 1));
                    }
                    return t6 = ue2(t6), e5 /= 100, r3 /= 100, [i3(0), i3(8), i3(4), n3];
                  }(t5);
              }
            }
          }(t2);
          return e2 ? new ke2(...e2, false) : undefined;
        }
        get rgb() {
          const { r: t2, g: e2, b: r2, a: n2 } = this, i2 = n2 || 1 / 0;
          return this.overwriteGetter("rgb", [t2 / i2, e2 / i2, r2 / i2, n2]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(t2) {
            const [e2, r2, n2, i2] = ce2(t2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
            return [Math.round(1e4 * s2) ? ue2(Math.atan2(n2, r2) * le2) : NaN, s2, e2, i2];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", ce2(this.rgb));
        }
        overwriteGetter(t2, e2) {
          return Object.defineProperty(this, t2, { value: e2 }), e2;
        }
        toString() {
          const [t2, e2, r2, n2] = this.rgb;
          return `rgba(${[t2, e2, r2].map((t3) => Math.round(255 * t3)).join(",")},${n2})`;
        }
        static interpolate(t2, e2, r2, n2 = "rgb") {
          switch (n2) {
            case "rgb": {
              const [n3, i2, s2, a2] = Se2(t2.rgb, e2.rgb, r2);
              return new ke2(n3, i2, s2, a2, false);
            }
            case "hcl": {
              const [n3, i2, s2, a2] = t2.hcl, [o2, l3, u2, c2] = e2.hcl;
              let h2, p2;
              if (isNaN(n3) || isNaN(o2))
                isNaN(n3) ? isNaN(o2) ? h2 = NaN : (h2 = o2, s2 !== 1 && s2 !== 0 || (p2 = l3)) : (h2 = n3, u2 !== 1 && u2 !== 0 || (p2 = i2));
              else {
                let t3 = o2 - n3;
                o2 > n3 && t3 > 180 ? t3 -= 360 : o2 < n3 && n3 - o2 > 180 && (t3 += 360), h2 = n3 + r2 * t3;
              }
              const [f2, d2, y2, m2] = function([t3, e3, r3, n4]) {
                return t3 = isNaN(t3) ? 0 : t3 * oe, fe2([r3, Math.cos(t3) * e3, Math.sin(t3) * e3, n4]);
              }([h2, p2 != null ? p2 : Ae2(i2, l3, r2), Ae2(s2, u2, r2), Ae2(a2, c2, r2)]);
              return new ke2(f2, d2, y2, m2, false);
            }
            case "lab": {
              const [n3, i2, s2, a2] = fe2(Se2(t2.lab, e2.lab, r2));
              return new ke2(n3, i2, s2, a2, false);
            }
          }
        }
      }
      ke2.black = new ke2(0, 0, 0, 1), ke2.white = new ke2(1, 1, 1, 1), ke2.transparent = new ke2(0, 0, 0, 0), ke2.red = new ke2(1, 0, 0, 1);

      class Me2 {
        constructor(t2, e2, r2) {
          this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t2, e2) {
          return this.collator.compare(t2, e2);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      const Ie2 = ["bottom", "center", "top"];

      class ze2 {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2, this.verticalAlign = s2;
        }
      }

      class Pe2 {
        constructor(t2) {
          this.sections = t2;
        }
        static fromString(t2) {
          return new Pe2([new ze2(t2, null, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((t2) => t2.text.length !== 0 || t2.image && t2.image.name.length !== 0);
        }
        static factory(t2) {
          return t2 instanceof Pe2 ? t2 : Pe2.fromString(t2);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((t2) => t2.text).join("");
        }
      }

      class Ce2 {
        constructor(t2) {
          this.values = t2.slice();
        }
        static parse(t2) {
          if (t2 instanceof Ce2)
            return t2;
          if (typeof t2 == "number")
            return new Ce2([t2, t2, t2, t2]);
          if (Array.isArray(t2) && !(t2.length < 1 || t2.length > 4)) {
            for (const e2 of t2)
              if (typeof e2 != "number")
                return;
            switch (t2.length) {
              case 1:
                t2 = [t2[0], t2[0], t2[0], t2[0]];
                break;
              case 2:
                t2 = [t2[0], t2[1], t2[0], t2[1]];
                break;
              case 3:
                t2 = [t2[0], t2[1], t2[2], t2[1]];
            }
            return new Ce2(t2);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(t2, e2, r2) {
          return new Ce2(Se2(t2.values, e2.values, r2));
        }
      }

      class Be2 {
        constructor(t2) {
          this.values = t2.slice();
        }
        static parse(t2) {
          if (t2 instanceof Be2)
            return t2;
          if (typeof t2 == "number")
            return new Be2([t2]);
          if (Array.isArray(t2)) {
            for (const e2 of t2)
              if (typeof e2 != "number")
                return;
            return new Be2(t2);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(t2, e2, r2) {
          return new Be2(Se2(t2.values, e2.values, r2));
        }
      }

      class Ve2 {
        constructor(t2) {
          this.values = t2.slice();
        }
        static parse(t2) {
          if (t2 instanceof Ve2)
            return t2;
          if (typeof t2 == "string") {
            const e3 = ke2.parse(t2);
            if (!e3)
              return;
            return new Ve2([e3]);
          }
          if (!Array.isArray(t2))
            return;
          const e2 = [];
          for (const r2 of t2) {
            if (typeof r2 != "string")
              return;
            const t3 = ke2.parse(r2);
            if (!t3)
              return;
            e2.push(t3);
          }
          return new Ve2(e2);
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(t2, e2, r2, n2 = "rgb") {
          const i2 = [];
          if (t2.values.length != e2.values.length)
            throw new Error(`colorArray: Arrays have mismatched length (${t2.values.length} vs. ${e2.values.length}), cannot interpolate.`);
          for (let s2 = 0;s2 < t2.values.length; s2++)
            i2.push(ke2.interpolate(t2.values[s2], e2.values[s2], r2, n2));
          return new Ve2(i2);
        }
      }

      class Ee2 extends Error {
        constructor(t2) {
          super(t2), this.name = "RuntimeError";
        }
        toJSON() {
          return this.message;
        }
      }
      const Te2 = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);

      class Fe2 {
        constructor(t2) {
          this.values = t2.slice();
        }
        static parse(t2) {
          if (t2 instanceof Fe2)
            return t2;
          if (Array.isArray(t2) && !(t2.length < 1) && t2.length % 2 == 0) {
            for (let e2 = 0;e2 < t2.length; e2 += 2) {
              const r2 = t2[e2], n2 = t2[e2 + 1];
              if (typeof r2 != "string" || !Te2.has(r2))
                return;
              if (!Array.isArray(n2) || n2.length !== 2 || typeof n2[0] != "number" || typeof n2[1] != "number")
                return;
            }
            return new Fe2(t2);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(t2, e2, r2) {
          const n2 = t2.values, i2 = e2.values;
          if (n2.length !== i2.length)
            throw new Ee2(`Cannot interpolate values of different length. from: ${t2.toString()}, to: ${e2.toString()}`);
          const s2 = [];
          for (let t3 = 0;t3 < n2.length; t3 += 2) {
            if (n2[t3] !== i2[t3])
              throw new Ee2(`Cannot interpolate values containing mismatched anchors. from[${t3}]: ${n2[t3]}, to[${t3}]: ${i2[t3]}`);
            s2.push(n2[t3]);
            const [e3, a2] = n2[t3 + 1], [o2, l3] = i2[t3 + 1];
            s2.push([Ae2(e3, o2, r2), Ae2(a2, l3, r2)]);
          }
          return new Fe2(s2);
        }
      }

      class $e2 {
        constructor(t2) {
          this.name = t2.name, this.available = t2.available;
        }
        toString() {
          return this.name;
        }
        static fromString(t2) {
          return t2 ? new $e2({ name: t2, available: false }) : null;
        }
      }

      class Le2 {
        constructor(t2, e2, r2) {
          this.from = t2, this.to = e2, this.transition = r2;
        }
        static interpolate(t2, e2, r2) {
          return new Le2(t2, e2, r2);
        }
        static parse(t2) {
          return t2 instanceof Le2 ? t2 : Array.isArray(t2) && t2.length === 3 && typeof t2[0] == "string" && typeof t2[1] == "string" && typeof t2[2] == "number" ? new Le2(t2[0], t2[1], t2[2]) : typeof t2 == "object" && typeof t2.from == "string" && typeof t2.to == "string" && typeof t2.transition == "number" ? new Le2(t2.from, t2.to, t2.transition) : typeof t2 == "string" ? new Le2(t2, t2, 1) : undefined;
        }
      }
      function Oe2(t2, e2, r2, n2) {
        return typeof t2 == "number" && t2 >= 0 && t2 <= 255 && typeof e2 == "number" && e2 >= 0 && e2 <= 255 && typeof r2 == "number" && r2 >= 0 && r2 <= 255 ? n2 === undefined || typeof n2 == "number" && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n2 == "number" ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function De(t2) {
        if (t2 === null || typeof t2 == "string" || typeof t2 == "boolean" || typeof t2 == "number" || t2 instanceof Le2 || t2 instanceof ke2 || t2 instanceof Me2 || t2 instanceof Pe2 || t2 instanceof Ce2 || t2 instanceof Be2 || t2 instanceof Ve2 || t2 instanceof Fe2 || t2 instanceof $e2)
          return true;
        if (Array.isArray(t2)) {
          for (const e2 of t2)
            if (!De(e2))
              return false;
          return true;
        }
        if (typeof t2 == "object") {
          for (const e2 in t2)
            if (!De(t2[e2]))
              return false;
          return true;
        }
        return false;
      }
      function je2(t2) {
        if (t2 === null)
          return Et2;
        if (typeof t2 == "string")
          return Ft2;
        if (typeof t2 == "boolean")
          return $t2;
        if (typeof t2 == "number")
          return Tt2;
        if (t2 instanceof ke2)
          return Lt2;
        if (t2 instanceof Le2)
          return Ot2;
        if (t2 instanceof Me2)
          return Rt2;
        if (t2 instanceof Pe2)
          return Nt2;
        if (t2 instanceof Ce2)
          return Ut;
        if (t2 instanceof Be2)
          return Gt2;
        if (t2 instanceof Ve2)
          return qt2;
        if (t2 instanceof Fe2)
          return Kt2;
        if (t2 instanceof $e2)
          return Zt2;
        if (Array.isArray(t2)) {
          const e2 = t2.length;
          let r2;
          for (const e3 of t2) {
            const t3 = je2(e3);
            if (r2) {
              if (r2 === t3)
                continue;
              r2 = jt2;
              break;
            }
            r2 = t3;
          }
          return Xt2(r2 || jt2, e2);
        }
        return Dt2;
      }
      function Re2(t2) {
        const e2 = typeof t2;
        return t2 === null ? "" : e2 === "string" || e2 === "number" || e2 === "boolean" ? String(t2) : t2 instanceof ke2 || t2 instanceof Le2 || t2 instanceof Pe2 || t2 instanceof Ce2 || t2 instanceof Be2 || t2 instanceof Ve2 || t2 instanceof Fe2 || t2 instanceof $e2 ? t2.toString() : JSON.stringify(t2);
      }

      class Ne2 {
        constructor(t2, e2) {
          this.type = t2, this.value = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (!De(t2[1]))
            return e2.error("invalid value");
          const r2 = t2[1];
          let n2 = je2(r2);
          const i2 = e2.expectedType;
          return n2.kind !== "array" || n2.N !== 0 || !i2 || i2.kind !== "array" || typeof i2.N == "number" && i2.N !== 0 || (n2 = i2), new Ne2(n2, r2);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      const Ue2 = { string: Ft2, number: Tt2, boolean: $t2, object: Dt2 };

      class qe2 {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          let r2, n2 = 1;
          const i2 = t2[0];
          if (i2 === "array") {
            let i3, s3;
            if (t2.length > 2) {
              const r3 = t2[1];
              if (typeof r3 != "string" || !(r3 in Ue2) || r3 === "object")
                return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
              i3 = Ue2[r3], n2++;
            } else
              i3 = jt2;
            if (t2.length > 3) {
              if (t2[2] !== null && (typeof t2[2] != "number" || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                return e2.error('The length argument to "array" must be a positive integer literal', 2);
              s3 = t2[2], n2++;
            }
            r2 = Xt2(i3, s3);
          } else {
            if (!Ue2[i2])
              throw new Error(`Types doesn't contain name = ${i2}`);
            r2 = Ue2[i2];
          }
          const s2 = [];
          for (;n2 < t2.length; n2++) {
            const r3 = e2.parse(t2[n2], n2, jt2);
            if (!r3)
              return null;
            s2.push(r3);
          }
          return new qe2(r2, s2);
        }
        evaluate(t2) {
          for (let e2 = 0;e2 < this.args.length; e2++) {
            const r2 = this.args[e2].evaluate(t2);
            if (!Jt2(this.type, je2(r2)))
              return r2;
            if (e2 === this.args.length - 1)
              throw new Ee2(`Expected value to be of type ${Ht2(this.type)}, but found ${Ht2(je2(r2))} instead.`);
          }
          throw new Error;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
      }
      const Ge2 = { "to-boolean": $t2, "to-color": Lt2, "to-number": Tt2, "to-string": Ft2 };

      class Ze2 {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          const r2 = t2[0];
          if (!Ge2[r2])
            throw new Error(`Can't parse ${r2} as it is not part of the known types`);
          if ((r2 === "to-boolean" || r2 === "to-string") && t2.length !== 2)
            return e2.error("Expected one argument.");
          const n2 = Ge2[r2], i2 = [];
          for (let r3 = 1;r3 < t2.length; r3++) {
            const n3 = e2.parse(t2[r3], r3, jt2);
            if (!n3)
              return null;
            i2.push(n3);
          }
          return new Ze2(n2, i2);
        }
        evaluate(t2) {
          switch (this.type.kind) {
            case "boolean":
              return Boolean(this.args[0].evaluate(t2));
            case "color": {
              let e2, r2;
              for (const n2 of this.args) {
                if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof ke2)
                  return e2;
                if (typeof e2 == "string") {
                  const r3 = t2.parseColor(e2);
                  if (r3)
                    return r3;
                } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rgba value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Oe2(e2[0], e2[1], e2[2], e2[3]), !r2))
                  return new ke2(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
              }
              throw new Ee2(r2 || `Could not parse color from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "padding": {
              let e2;
              for (const r2 of this.args) {
                e2 = r2.evaluate(t2);
                const n2 = Ce2.parse(e2);
                if (n2)
                  return n2;
              }
              throw new Ee2(`Could not parse padding from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "numberArray": {
              let e2;
              for (const r2 of this.args) {
                e2 = r2.evaluate(t2);
                const n2 = Be2.parse(e2);
                if (n2)
                  return n2;
              }
              throw new Ee2(`Could not parse numberArray from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "colorArray": {
              let e2;
              for (const r2 of this.args) {
                e2 = r2.evaluate(t2);
                const n2 = Ve2.parse(e2);
                if (n2)
                  return n2;
              }
              throw new Ee2(`Could not parse colorArray from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let e2;
              for (const r2 of this.args) {
                e2 = r2.evaluate(t2);
                const n2 = Fe2.parse(e2);
                if (n2)
                  return n2;
              }
              throw new Ee2(`Could not parse variableAnchorOffsetCollection from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "number": {
              let e2 = null;
              for (const r2 of this.args) {
                if (e2 = r2.evaluate(t2), e2 === null)
                  return 0;
                const n2 = Number(e2);
                if (!isNaN(n2))
                  return n2;
              }
              throw new Ee2(`Could not convert ${JSON.stringify(e2)} to number.`);
            }
            case "formatted":
              return Pe2.fromString(Re2(this.args[0].evaluate(t2)));
            case "resolvedImage":
              return $e2.fromString(Re2(this.args[0].evaluate(t2)));
            case "projectionDefinition":
              return this.args[0].evaluate(t2);
            default:
              return Re2(this.args[0].evaluate(t2));
          }
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
      }
      const Ke2 = ["Unknown", "Point", "LineString", "Polygon"];

      class Xe2 {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Ke2[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(t2) {
          let e2 = this._parseColorCache.get(t2);
          return e2 || (e2 = ke2.parse(t2), this._parseColorCache.set(t2, e2)), e2;
        }
      }

      class He2 {
        constructor(t2, e2, r2 = [], n2, i2 = new Vt2, s2 = []) {
          this.registry = t2, this.path = r2, this.key = r2.map((t3) => `[${t3}]`).join(""), this.scope = i2, this.errors = s2, this.expectedType = n2, this._isConstant = e2;
        }
        parse(t2, e2, r2, n2, i2 = {}) {
          return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
        }
        _parse(t2, e2) {
          function r2(t3, e3, r3) {
            return r3 === "assert" ? new qe2(e3, [t3]) : r3 === "coerce" ? new Ze2(e3, [t3]) : t3;
          }
          if (t2 !== null && typeof t2 != "string" && typeof t2 != "boolean" && typeof t2 != "number" || (t2 = ["literal", t2]), Array.isArray(t2)) {
            if (t2.length === 0)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n2 = t2[0];
            if (typeof n2 != "string")
              return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const i2 = this.registry[n2];
            if (i2) {
              let n3 = i2.parse(t2, this);
              if (!n3)
                return null;
              if (this.expectedType) {
                const t3 = this.expectedType, i3 = n3.type;
                if (t3.kind !== "string" && t3.kind !== "number" && t3.kind !== "boolean" && t3.kind !== "object" && t3.kind !== "array" || i3.kind !== "value") {
                  if (t3.kind === "projectionDefinition" && ["string", "array"].includes(i3.kind) || ["color", "formatted", "resolvedImage"].includes(t3.kind) && ["value", "string"].includes(i3.kind) || ["padding", "numberArray"].includes(t3.kind) && ["value", "number", "array"].includes(i3.kind) || t3.kind === "colorArray" && ["value", "string", "array"].includes(i3.kind) || t3.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(i3.kind))
                    n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                  else if (this.checkSubtype(t3, i3))
                    return null;
                } else
                  n3 = r2(n3, t3, e2.typeAnnotation || "assert");
              }
              if (!(n3 instanceof Ne2) && n3.type.kind !== "resolvedImage" && this._isConstant(n3)) {
                const t3 = new Xe2;
                try {
                  n3 = new Ne2(n3.type, n3.evaluate(t3));
                } catch (t4) {
                  return this.error(t4.message), null;
                }
              }
              return n3;
            }
            return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(t2 === undefined ? "'undefined' value invalid. Use null instead." : typeof t2 == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
        }
        concat(t2, e2, r2) {
          const n2 = typeof t2 == "number" ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
          return new He2(this.registry, this._isConstant, n2, e2 || null, i2, this.errors);
        }
        error(t2, ...e2) {
          const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
          this.errors.push(new Bt2(r2, t2));
        }
        checkSubtype(t2, e2) {
          const r2 = Jt2(t2, e2);
          return r2 && this.error(r2), r2;
        }
      }

      class Ye2 {
        constructor(t2, e2) {
          this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
        }
        evaluate(t2) {
          return this.result.evaluate(t2);
        }
        eachChild(t2) {
          for (const e2 of this.bindings)
            t2(e2[1]);
          t2(this.result);
        }
        static parse(t2, e2) {
          if (t2.length < 4)
            return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
          const r2 = [];
          for (let n3 = 1;n3 < t2.length - 1; n3 += 2) {
            const i2 = t2[n3];
            if (typeof i2 != "string")
              return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
            if (/[^a-zA-Z0-9_]/.test(i2))
              return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
            const s2 = e2.parse(t2[n3 + 1], n3 + 1);
            if (!s2)
              return null;
            r2.push([i2, s2]);
          }
          const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
          return n2 ? new Ye2(r2, n2) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }

      class Je2 {
        constructor(t2, e2) {
          this.type = e2.type, this.name = t2, this.boundExpression = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2 || typeof t2[1] != "string")
            return e2.error("'var' expression requires exactly one string literal argument.");
          const r2 = t2[1];
          return e2.scope.has(r2) ? new Je2(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t2) {
          return this.boundExpression.evaluate(t2);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
      }

      class We2 {
        constructor(t2, e2, r2) {
          this.type = t2, this.index = e2, this.input = r2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, Tt2), n2 = e2.parse(t2[2], 2, Xt2(e2.expectedType || jt2));
          return r2 && n2 ? new We2(n2.type.itemType, r2, n2) : null;
        }
        evaluate(t2) {
          const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
          if (e2 < 0)
            throw new Ee2(`Array index out of bounds: ${e2} < 0.`);
          if (e2 >= r2.length)
            throw new Ee2(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
          if (e2 !== Math.floor(e2))
            throw new Ee2(`Array index must be an integer, but found ${e2} instead.`);
          return r2[e2];
        }
        eachChild(t2) {
          t2(this.index), t2(this.input);
        }
        outputDefined() {
          return false;
        }
      }

      class Qe2 {
        constructor(t2, e2) {
          this.type = $t2, this.needle = t2, this.haystack = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, jt2), n2 = e2.parse(t2[2], 2, jt2);
          return r2 && n2 ? Wt2(r2.type, [$t2, Ft2, Tt2, Et2, jt2]) ? new Qe2(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ht2(r2.type)} instead`) : null;
        }
        evaluate(t2) {
          const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!r2)
            return false;
          if (!Qt2(e2, ["boolean", "string", "number", "null"]))
            throw new Ee2(`Expected first argument to be of type boolean, string, number or null, but found ${Ht2(je2(e2))} instead.`);
          if (!Qt2(r2, ["string", "array"]))
            throw new Ee2(`Expected second argument to be of type array or string, but found ${Ht2(je2(r2))} instead.`);
          return r2.indexOf(e2) >= 0;
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack);
        }
        outputDefined() {
          return true;
        }
      }

      class tr2 {
        constructor(t2, e2, r2) {
          this.type = Tt2, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
        }
        static parse(t2, e2) {
          if (t2.length <= 2 || t2.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, jt2), n2 = e2.parse(t2[2], 2, jt2);
          if (!r2 || !n2)
            return null;
          if (!Wt2(r2.type, [$t2, Ft2, Tt2, Et2, jt2]))
            return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ht2(r2.type)} instead`);
          if (t2.length === 4) {
            const i2 = e2.parse(t2[3], 3, Tt2);
            return i2 ? new tr2(r2, n2, i2) : null;
          }
          return new tr2(r2, n2);
        }
        evaluate(t2) {
          const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!Qt2(e2, ["boolean", "string", "number", "null"]))
            throw new Ee2(`Expected first argument to be of type boolean, string, number or null, but found ${Ht2(je2(e2))} instead.`);
          let n2;
          if (this.fromIndex && (n2 = this.fromIndex.evaluate(t2)), Qt2(r2, ["string"])) {
            const t3 = r2.indexOf(e2, n2);
            return t3 === -1 ? -1 : [...r2.slice(0, t3)].length;
          }
          if (Qt2(r2, ["array"]))
            return r2.indexOf(e2, n2);
          throw new Ee2(`Expected second argument to be of type array or string, but found ${Ht2(je2(r2))} instead.`);
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
      }

      class er2 {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
        }
        static parse(t2, e2) {
          if (t2.length < 5)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 1)
            return e2.error("Expected an even number of arguments.");
          let r2, n2;
          e2.expectedType && e2.expectedType.kind !== "value" && (n2 = e2.expectedType);
          const i2 = {}, s2 = [];
          for (let a3 = 2;a3 < t2.length - 1; a3 += 2) {
            let o3 = t2[a3];
            const l3 = t2[a3 + 1];
            Array.isArray(o3) || (o3 = [o3]);
            const u2 = e2.concat(a3);
            if (o3.length === 0)
              return u2.error("Expected at least one branch label.");
            for (const t3 of o3) {
              if (typeof t3 != "number" && typeof t3 != "string")
                return u2.error("Branch labels must be numbers or strings.");
              if (typeof t3 == "number" && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof t3 == "number" && Math.floor(t3) !== t3)
                return u2.error("Numeric branch labels must be integer values.");
              if (r2) {
                if (u2.checkSubtype(r2, je2(t3)))
                  return null;
              } else
                r2 = je2(t3);
              if (i2[String(t3)] !== undefined)
                return u2.error("Branch labels must be unique.");
              i2[String(t3)] = s2.length;
            }
            const c2 = e2.parse(l3, a3, n2);
            if (!c2)
              return null;
            n2 = n2 || c2.type, s2.push(c2);
          }
          const a2 = e2.parse(t2[1], 1, jt2);
          if (!a2)
            return null;
          const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
          return o2 ? a2.type.kind !== "value" && e2.concat(1).checkSubtype(r2, a2.type) ? null : new er2(r2, n2, a2, i2, s2, o2) : null;
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2);
          return (je2(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
        }
      }

      class rr2 {
        constructor(t2, e2, r2) {
          this.type = t2, this.branches = e2, this.otherwise = r2;
        }
        static parse(t2, e2) {
          if (t2.length < 4)
            return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 0)
            return e2.error("Expected an odd number of arguments.");
          let r2;
          e2.expectedType && e2.expectedType.kind !== "value" && (r2 = e2.expectedType);
          const n2 = [];
          for (let i3 = 1;i3 < t2.length - 1; i3 += 2) {
            const s2 = e2.parse(t2[i3], i3, $t2);
            if (!s2)
              return null;
            const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
            if (!a2)
              return null;
            n2.push([s2, a2]), r2 = r2 || a2.type;
          }
          const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
          if (!i2)
            return null;
          if (!r2)
            throw new Error("Can't infer output type");
          return new rr2(r2, n2, i2);
        }
        evaluate(t2) {
          for (const [e2, r2] of this.branches)
            if (e2.evaluate(t2))
              return r2.evaluate(t2);
          return this.otherwise.evaluate(t2);
        }
        eachChild(t2) {
          for (const [e2, r2] of this.branches)
            t2(e2), t2(r2);
          t2(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
        }
      }

      class nr2 {
        constructor(t2, e2, r2, n2) {
          this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
        }
        static parse(t2, e2) {
          if (t2.length <= 2 || t2.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, jt2), n2 = e2.parse(t2[2], 2, Tt2);
          if (!r2 || !n2)
            return null;
          if (!Wt2(r2.type, [Xt2(jt2), Ft2, jt2]))
            return e2.error(`Expected first argument to be of type array or string, but found ${Ht2(r2.type)} instead`);
          if (t2.length === 4) {
            const i2 = e2.parse(t2[3], 3, Tt2);
            return i2 ? new nr2(r2.type, r2, n2, i2) : null;
          }
          return new nr2(r2.type, r2, n2);
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
          let n2;
          if (this.endIndex && (n2 = this.endIndex.evaluate(t2)), Qt2(e2, ["string"]))
            return [...e2].slice(r2, n2).join("");
          if (Qt2(e2, ["array"]))
            return e2.slice(r2, n2);
          throw new Ee2(`Expected first argument to be of type array or string, but found ${Ht2(je2(e2))} instead.`);
        }
        eachChild(t2) {
          t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
        }
        outputDefined() {
          return false;
        }
      }
      function ir2(t2, e2) {
        const r2 = t2.length - 1;
        let n2, i2, s2 = 0, a2 = r2, o2 = 0;
        for (;s2 <= a2; )
          if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
            if (o2 === r2 || e2 < i2)
              return o2;
            s2 = o2 + 1;
          } else {
            if (!(n2 > e2))
              throw new Ee2("Input is not a number.");
            a2 = o2 - 1;
          }
        return 0;
      }

      class sr2 {
        constructor(t2, e2, r2) {
          this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of r2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static parse(t2, e2) {
          if (t2.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          const r2 = e2.parse(t2[1], 1, Tt2);
          if (!r2)
            return null;
          const n2 = [];
          let i2 = null;
          e2.expectedType && e2.expectedType.kind !== "value" && (i2 = e2.expectedType);
          for (let r3 = 1;r3 < t2.length; r3 += 2) {
            const s2 = r3 === 1 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l3 = r3 + 1;
            if (typeof s2 != "number")
              return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
            if (n2.length && n2[n2.length - 1][0] >= s2)
              return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
            const u2 = e2.parse(a2, l3, i2);
            if (!u2)
              return null;
            i2 = i2 || u2.type, n2.push([s2, u2]);
          }
          return new sr2(i2, r2, n2);
        }
        evaluate(t2) {
          const e2 = this.labels, r2 = this.outputs;
          if (e2.length === 1)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          const i2 = e2.length;
          return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[ir2(e2, n2)].evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input);
          for (const e2 of this.outputs)
            t2(e2);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
      }
      function ar2(t2) {
        return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
      }
      var or2, lr2, ur2 = function() {
        if (lr2)
          return or2;
        function t2(t3, e2, r2, n2) {
          this.cx = 3 * t3, this.bx = 3 * (r2 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r2, this.p2y = n2;
        }
        return lr2 = 1, or2 = t2, t2.prototype = { sampleCurveX: function(t3) {
          return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
        }, sampleCurveY: function(t3) {
          return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
        }, sampleCurveDerivativeX: function(t3) {
          return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
        }, solveCurveX: function(t3, e2) {
          if (e2 === undefined && (e2 = 0.000001), t3 < 0)
            return 0;
          if (t3 > 1)
            return 1;
          for (var r2 = t3, n2 = 0;n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r2) - t3;
            if (Math.abs(i2) < e2)
              return r2;
            var s2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(s2) < 0.000001)
              break;
            r2 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r2 = t3, n2 = 0;n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t3) < e2)); n2++)
            t3 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
          return r2;
        }, solve: function(t3, e2) {
          return this.sampleCurveY(this.solveCurveX(t3, e2));
        } }, or2;
      }(), cr2 = ar2(ur2);

      class hr2 {
        constructor(t2, e2, r2, n2, i2) {
          this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of i2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static interpolationFactor(t2, e2, r2, n2) {
          let i2 = 0;
          if (t2.name === "exponential")
            i2 = pr2(e2, t2.base, r2, n2);
          else if (t2.name === "linear")
            i2 = pr2(e2, 1, r2, n2);
          else if (t2.name === "cubic-bezier") {
            const s2 = t2.controlPoints;
            i2 = new cr2(s2[0], s2[1], s2[2], s2[3]).solve(pr2(e2, 1, r2, n2));
          }
          return i2;
        }
        static parse(t2, e2) {
          let [r2, n2, i2, ...s2] = t2;
          if (!Array.isArray(n2) || n2.length === 0)
            return e2.error("Expected an interpolation type expression.", 1);
          if (n2[0] === "linear")
            n2 = { name: "linear" };
          else if (n2[0] === "exponential") {
            const t3 = n2[1];
            if (typeof t3 != "number")
              return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
            n2 = { name: "exponential", base: t3 };
          } else {
            if (n2[0] !== "cubic-bezier")
              return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
            {
              const t3 = n2.slice(1);
              if (t3.length !== 4 || t3.some((t4) => typeof t4 != "number" || t4 < 0 || t4 > 1))
                return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n2 = { name: "cubic-bezier", controlPoints: t3 };
            }
          }
          if (t2.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          if (i2 = e2.parse(i2, 2, Tt2), !i2)
            return null;
          const a2 = [];
          let o2 = null;
          r2 !== "interpolate-hcl" && r2 !== "interpolate-lab" || e2.expectedType == qt2 ? e2.expectedType && e2.expectedType.kind !== "value" && (o2 = e2.expectedType) : o2 = Lt2;
          for (let t3 = 0;t3 < s2.length; t3 += 2) {
            const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l3 = t3 + 4;
            if (typeof r3 != "number")
              return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
            if (a2.length && a2[a2.length - 1][0] >= r3)
              return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
            const u2 = e2.parse(n3, l3, o2);
            if (!u2)
              return null;
            o2 = o2 || u2.type, a2.push([r3, u2]);
          }
          return te2(o2, Tt2) || te2(o2, Ot2) || te2(o2, Lt2) || te2(o2, Ut) || te2(o2, Gt2) || te2(o2, qt2) || te2(o2, Kt2) || te2(o2, Xt2(Tt2)) ? new hr2(o2, r2, n2, i2, a2) : e2.error(`Type ${Ht2(o2)} is not interpolatable.`);
        }
        evaluate(t2) {
          const e2 = this.labels, r2 = this.outputs;
          if (e2.length === 1)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          const i2 = e2.length;
          if (n2 >= e2[i2 - 1])
            return r2[i2 - 1].evaluate(t2);
          const s2 = ir2(e2, n2), a2 = hr2.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l3 = r2[s2 + 1].evaluate(t2);
          switch (this.operator) {
            case "interpolate":
              switch (this.type.kind) {
                case "number":
                  return Ae2(o2, l3, a2);
                case "color":
                  return ke2.interpolate(o2, l3, a2);
                case "padding":
                  return Ce2.interpolate(o2, l3, a2);
                case "colorArray":
                  return Ve2.interpolate(o2, l3, a2);
                case "numberArray":
                  return Be2.interpolate(o2, l3, a2);
                case "variableAnchorOffsetCollection":
                  return Fe2.interpolate(o2, l3, a2);
                case "array":
                  return Se2(o2, l3, a2);
                case "projectionDefinition":
                  return Le2.interpolate(o2, l3, a2);
              }
            case "interpolate-hcl":
              switch (this.type.kind) {
                case "color":
                  return ke2.interpolate(o2, l3, a2, "hcl");
                case "colorArray":
                  return Ve2.interpolate(o2, l3, a2, "hcl");
              }
            case "interpolate-lab":
              switch (this.type.kind) {
                case "color":
                  return ke2.interpolate(o2, l3, a2, "lab");
                case "colorArray":
                  return Ve2.interpolate(o2, l3, a2, "lab");
              }
          }
        }
        eachChild(t2) {
          t2(this.input);
          for (const e2 of this.outputs)
            t2(e2);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
      }
      function pr2(t2, e2, r2, n2) {
        const i2 = n2 - r2, s2 = t2 - r2;
        return i2 === 0 ? 0 : e2 === 1 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
      }
      const fr2 = { color: ke2.interpolate, number: Ae2, padding: Ce2.interpolate, numberArray: Be2.interpolate, colorArray: Ve2.interpolate, variableAnchorOffsetCollection: Fe2.interpolate, array: Se2 };

      class dr2 {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          let r2 = null;
          const n2 = e2.expectedType;
          n2 && n2.kind !== "value" && (r2 = n2);
          const i2 = [];
          for (const n3 of t2.slice(1)) {
            const t3 = e2.parse(n3, 1 + i2.length, r2, undefined, { typeAnnotation: "omit" });
            if (!t3)
              return null;
            r2 = r2 || t3.type, i2.push(t3);
          }
          if (!r2)
            throw new Error("No output type");
          const s2 = n2 && i2.some((t3) => Jt2(n2, t3.type));
          return new dr2(s2 ? jt2 : r2, i2);
        }
        evaluate(t2) {
          let e2, r2 = null, n2 = 0;
          for (const i2 of this.args)
            if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof $e2 && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), r2 !== null)
              break;
          return r2;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
      }
      function yr2(t2, e2) {
        return t2 === "==" || t2 === "!=" ? e2.kind === "boolean" || e2.kind === "string" || e2.kind === "number" || e2.kind === "null" || e2.kind === "value" : e2.kind === "string" || e2.kind === "number" || e2.kind === "value";
      }
      function mr2(t2, e2, r2, n2) {
        return n2.compare(e2, r2) === 0;
      }
      function gr2(t2, e2, r2) {
        const n2 = t2 !== "==" && t2 !== "!=";
        return class i2 {
          constructor(t3, e3, r3) {
            this.type = $t2, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = t3.type.kind === "value" || e3.type.kind === "value";
          }
          static parse(t3, e3) {
            if (t3.length !== 3 && t3.length !== 4)
              return e3.error("Expected two or three arguments.");
            const r3 = t3[0];
            let s2 = e3.parse(t3[1], 1, jt2);
            if (!s2)
              return null;
            if (!yr2(r3, s2.type))
              return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${Ht2(s2.type)}'.`);
            let a2 = e3.parse(t3[2], 2, jt2);
            if (!a2)
              return null;
            if (!yr2(r3, a2.type))
              return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${Ht2(a2.type)}'.`);
            if (s2.type.kind !== a2.type.kind && s2.type.kind !== "value" && a2.type.kind !== "value")
              return e3.error(`Cannot compare types '${Ht2(s2.type)}' and '${Ht2(a2.type)}'.`);
            n2 && (s2.type.kind === "value" && a2.type.kind !== "value" ? s2 = new qe2(a2.type, [s2]) : s2.type.kind !== "value" && a2.type.kind === "value" && (a2 = new qe2(s2.type, [a2])));
            let o2 = null;
            if (t3.length === 4) {
              if (s2.type.kind !== "string" && a2.type.kind !== "string" && s2.type.kind !== "value" && a2.type.kind !== "value")
                return e3.error("Cannot use collator to compare non-string types.");
              if (o2 = e3.parse(t3[3], 3, Rt2), !o2)
                return null;
            }
            return new i2(s2, a2, o2);
          }
          evaluate(i3) {
            const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
            if (n2 && this.hasUntypedArgument) {
              const e3 = je2(s2), r3 = je2(a2);
              if (e3.kind !== r3.kind || e3.kind !== "string" && e3.kind !== "number")
                throw new Ee2(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
            }
            if (this.collator && !n2 && this.hasUntypedArgument) {
              const t3 = je2(s2), r3 = je2(a2);
              if (t3.kind !== "string" || r3.kind !== "string")
                return e2(i3, s2, a2);
            }
            return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
          }
          eachChild(t3) {
            t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
          }
          outputDefined() {
            return true;
          }
        };
      }
      const xr2 = gr2("==", function(t2, e2, r2) {
        return e2 === r2;
      }, mr2), vr2 = gr2("!=", function(t2, e2, r2) {
        return e2 !== r2;
      }, function(t2, e2, r2, n2) {
        return !mr2(0, e2, r2, n2);
      }), br2 = gr2("<", function(t2, e2, r2) {
        return e2 < r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) < 0;
      }), wr2 = gr2(">", function(t2, e2, r2) {
        return e2 > r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) > 0;
      }), _r2 = gr2("<=", function(t2, e2, r2) {
        return e2 <= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) <= 0;
      }), Ar2 = gr2(">=", function(t2, e2, r2) {
        return e2 >= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) >= 0;
      });

      class Sr2 {
        constructor(t2, e2, r2) {
          this.type = Rt2, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error("Expected one argument.");
          const r2 = t2[1];
          if (typeof r2 != "object" || Array.isArray(r2))
            return e2.error("Collator options argument must be an object.");
          const n2 = e2.parse(r2["case-sensitive"] !== undefined && r2["case-sensitive"], 1, $t2);
          if (!n2)
            return null;
          const i2 = e2.parse(r2["diacritic-sensitive"] !== undefined && r2["diacritic-sensitive"], 1, $t2);
          if (!i2)
            return null;
          let s2 = null;
          return r2.locale && (s2 = e2.parse(r2.locale, 1, Ft2), !s2) ? null : new Sr2(n2, i2, s2);
        }
        evaluate(t2) {
          return new Me2(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
        }
        eachChild(t2) {
          t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
        }
        outputDefined() {
          return false;
        }
      }

      class kr2 {
        constructor(t2, e2, r2, n2, i2) {
          this.type = Ft2, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error("Expected two arguments.");
          const r2 = e2.parse(t2[1], 1, Tt2);
          if (!r2)
            return null;
          const n2 = t2[2];
          if (typeof n2 != "object" || Array.isArray(n2))
            return e2.error("NumberFormat options argument must be an object.");
          let i2 = null;
          if (n2.locale && (i2 = e2.parse(n2.locale, 1, Ft2), !i2))
            return null;
          let s2 = null;
          if (n2.currency && (s2 = e2.parse(n2.currency, 1, Ft2), !s2))
            return null;
          let a2 = null;
          if (n2["min-fraction-digits"] && (a2 = e2.parse(n2["min-fraction-digits"], 1, Tt2), !a2))
            return null;
          let o2 = null;
          return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, Tt2), !o2) ? null : new kr2(r2, i2, s2, a2, o2);
        }
        evaluate(t2) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : undefined, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : undefined, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : undefined }).format(this.number.evaluate(t2));
        }
        eachChild(t2) {
          t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
      }

      class Mr2 {
        constructor(t2) {
          this.type = Nt2, this.sections = t2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          const r2 = t2[1];
          if (!Array.isArray(r2) && typeof r2 == "object")
            return e2.error("First argument must be an image or text section.");
          const n2 = [];
          let i2 = false;
          for (let r3 = 1;r3 <= t2.length - 1; ++r3) {
            const s2 = t2[r3];
            if (i2 && typeof s2 == "object" && !Array.isArray(s2)) {
              i2 = false;
              let t3 = null;
              if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, Tt2), !t3))
                return null;
              let r4 = null;
              if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, Xt2(Ft2)), !r4))
                return null;
              let a2 = null;
              if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, Lt2), !a2))
                return null;
              let o2 = null;
              if (s2["vertical-align"]) {
                if (typeof s2["vertical-align"] == "string" && !Ie2.includes(s2["vertical-align"]))
                  return e2.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s2["vertical-align"]}' instead.`);
                if (o2 = e2.parse(s2["vertical-align"], 1, Ft2), !o2)
                  return null;
              }
              const l3 = n2[n2.length - 1];
              l3.scale = t3, l3.font = r4, l3.textColor = a2, l3.verticalAlign = o2;
            } else {
              const s3 = e2.parse(t2[r3], 1, jt2);
              if (!s3)
                return null;
              const a2 = s3.type.kind;
              if (a2 !== "string" && a2 !== "value" && a2 !== "null" && a2 !== "resolvedImage")
                return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null, verticalAlign: null });
            }
          }
          return new Mr2(n2);
        }
        evaluate(t2) {
          return new Pe2(this.sections.map((e2) => {
            const r2 = e2.content.evaluate(t2);
            return je2(r2) === Zt2 ? new ze2("", r2, null, null, null, e2.verticalAlign ? e2.verticalAlign.evaluate(t2) : null) : new ze2(Re2(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null, e2.verticalAlign ? e2.verticalAlign.evaluate(t2) : null);
          }));
        }
        eachChild(t2) {
          for (const e2 of this.sections)
            t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor), e2.verticalAlign && t2(e2.verticalAlign);
        }
        outputDefined() {
          return false;
        }
      }

      class Ir2 {
        constructor(t2) {
          this.type = Zt2, this.input = t2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error("Expected two arguments.");
          const r2 = e2.parse(t2[1], 1, Ft2);
          return r2 ? new Ir2(r2) : e2.error("No image name provided.");
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2), r2 = $e2.fromString(e2);
          return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
      }

      class zr2 {
        constructor(t2) {
          this.type = Tt2, this.input = t2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1);
          return r2 ? r2.type.kind !== "array" && r2.type.kind !== "string" && r2.type.kind !== "value" ? e2.error(`Expected argument of type string or array, but found ${Ht2(r2.type)} instead.`) : new zr2(r2) : null;
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2);
          if (typeof e2 == "string")
            return [...e2].length;
          if (Array.isArray(e2))
            return e2.length;
          throw new Ee2(`Expected value to be of type string or array, but found ${Ht2(je2(e2))} instead.`);
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
      }
      const Pr2 = 8192;
      function Cr2(t2, e2) {
        const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
        return [Math.round(r2 * i2 * Pr2), Math.round(n2 * i2 * Pr2)];
      }
      function Br2(t2, e2) {
        const r2 = Math.pow(2, e2.z);
        return [(i2 = (t2[0] / Pr2 + e2.x) / r2, 360 * i2 - 180), (n2 = (t2[1] / Pr2 + e2.y) / r2, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n2) * Math.PI / 180)) - 90)];
        var n2, i2;
      }
      function Vr2(t2, e2) {
        t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
      }
      function Er2(t2, e2) {
        return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
      }
      function Tr2(t2, e2, r2) {
        const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
        return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
      }
      function Fr2(t2, e2, r2, n2) {
        return (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [e2[0] - t2[0], e2[1] - t2[1]])[1] - i2[1] * s2[0] != 0 && !(!Rr2(t2, e2, r2, n2) || !Rr2(r2, n2, t2, e2));
        var i2, s2;
      }
      function $r2(t2, e2, r2) {
        for (const n2 of r2)
          for (let r3 = 0;r3 < n2.length - 1; ++r3)
            if (Fr2(t2, e2, n2[r3], n2[r3 + 1]))
              return true;
        return false;
      }
      function Lr2(t2, e2, r2 = false) {
        let n2 = false;
        for (const o2 of e2)
          for (let e3 = 0;e3 < o2.length - 1; e3++) {
            if (Tr2(t2, o2[e3], o2[e3 + 1]))
              return r2;
            (s2 = o2[e3])[1] > (i2 = t2)[1] != (a2 = o2[e3 + 1])[1] > i2[1] && i2[0] < (a2[0] - s2[0]) * (i2[1] - s2[1]) / (a2[1] - s2[1]) + s2[0] && (n2 = !n2);
          }
        var i2, s2, a2;
        return n2;
      }
      function Or2(t2, e2) {
        for (const r2 of e2)
          if (Lr2(t2, r2))
            return true;
        return false;
      }
      function Dr2(t2, e2) {
        for (const r2 of t2)
          if (!Lr2(r2, e2))
            return false;
        for (let r2 = 0;r2 < t2.length - 1; ++r2)
          if ($r2(t2[r2], t2[r2 + 1], e2))
            return false;
        return true;
      }
      function jr2(t2, e2) {
        for (const r2 of e2)
          if (Dr2(t2, r2))
            return true;
        return false;
      }
      function Rr2(t2, e2, r2, n2) {
        const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
        return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
      }
      function Nr2(t2, e2, r2) {
        const n2 = [];
        for (let i2 = 0;i2 < t2.length; i2++) {
          const s2 = [];
          for (let n3 = 0;n3 < t2[i2].length; n3++) {
            const a2 = Cr2(t2[i2][n3], r2);
            Vr2(e2, a2), s2.push(a2);
          }
          n2.push(s2);
        }
        return n2;
      }
      function Ur2(t2, e2, r2) {
        const n2 = [];
        for (let i2 = 0;i2 < t2.length; i2++) {
          const s2 = Nr2(t2[i2], e2, r2);
          n2.push(s2);
        }
        return n2;
      }
      function qr2(t2, e2, r2, n2) {
        if (t2[0] < r2[0] || t2[0] > r2[2]) {
          const e3 = 0.5 * n2;
          let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
          i2 === 0 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
        }
        Vr2(e2, t2);
      }
      function Gr2(t2, e2, r2, n2) {
        const i2 = Math.pow(2, n2.z) * Pr2, s2 = [n2.x * Pr2, n2.y * Pr2], a2 = [];
        for (const n3 of t2)
          for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            qr2(n4, e2, r2, i2), a2.push(n4);
          }
        return a2;
      }
      function Zr2(t2, e2, r2, n2) {
        const i2 = Math.pow(2, n2.z) * Pr2, s2 = [n2.x * Pr2, n2.y * Pr2], a2 = [];
        for (const r3 of t2) {
          const t3 = [];
          for (const n3 of r3) {
            const r4 = [n3.x + s2[0], n3.y + s2[1]];
            Vr2(e2, r4), t3.push(r4);
          }
          a2.push(t3);
        }
        if (e2[2] - e2[0] <= i2 / 2) {
          (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
          for (const t3 of a2)
            for (const n3 of t3)
              qr2(n3, e2, r2, i2);
        }
        var o2;
        return a2;
      }

      class Kr2 {
        constructor(t2, e2) {
          this.type = $t2, this.geojson = t2, this.geometries = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (De(t2[1])) {
            const e3 = t2[1];
            if (e3.type === "FeatureCollection") {
              const t3 = [];
              for (const r2 of e3.features) {
                const { type: e4, coordinates: n2 } = r2.geometry;
                e4 === "Polygon" && t3.push(n2), e4 === "MultiPolygon" && t3.push(...n2);
              }
              if (t3.length)
                return new Kr2(e3, { type: "MultiPolygon", coordinates: t3 });
            } else if (e3.type === "Feature") {
              const t3 = e3.geometry.type;
              if (t3 === "Polygon" || t3 === "MultiPolygon")
                return new Kr2(e3, e3.geometry);
            } else if (e3.type === "Polygon" || e3.type === "MultiPolygon")
              return new Kr2(e3, e3);
          }
          return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t2) {
          if (t2.geometry() != null && t2.canonicalID() != null) {
            if (t2.geometryType() === "Point")
              return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (e2.type === "Polygon") {
                  const s2 = Nr2(e2.coordinates, n2, i2), a2 = Gr2(t3.geometry(), r2, n2, i2);
                  if (!Er2(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!Lr2(t4, s2))
                      return false;
                }
                if (e2.type === "MultiPolygon") {
                  const s2 = Ur2(e2.coordinates, n2, i2), a2 = Gr2(t3.geometry(), r2, n2, i2);
                  if (!Er2(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!Or2(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
            if (t2.geometryType() === "LineString")
              return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (e2.type === "Polygon") {
                  const s2 = Nr2(e2.coordinates, n2, i2), a2 = Zr2(t3.geometry(), r2, n2, i2);
                  if (!Er2(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!Dr2(t4, s2))
                      return false;
                }
                if (e2.type === "MultiPolygon") {
                  const s2 = Ur2(e2.coordinates, n2, i2), a2 = Zr2(t3.geometry(), r2, n2, i2);
                  if (!Er2(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!jr2(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      let Xr2 = class {
        constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
          if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (let t3 = (this.length >> 1) - 1;t3 >= 0; t3--)
              this._down(t3);
        }
        push(t2) {
          this.data.push(t2), this._up(this.length++);
        }
        pop() {
          if (this.length === 0)
            return;
          const t2 = this.data[0], e2 = this.data.pop();
          return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
        }
        peek() {
          return this.data[0];
        }
        _up(t2) {
          const { data: e2, compare: r2 } = this, n2 = e2[t2];
          for (;t2 > 0; ) {
            const i2 = t2 - 1 >> 1, s2 = e2[i2];
            if (r2(n2, s2) >= 0)
              break;
            e2[t2] = s2, t2 = i2;
          }
          e2[t2] = n2;
        }
        _down(t2) {
          const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
          for (;t2 < n2; ) {
            let n3 = 1 + (t2 << 1);
            const s2 = n3 + 1;
            if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0)
              break;
            e2[t2] = e2[n3], t2 = n3;
          }
          e2[t2] = i2;
        }
      };
      function Hr2(t2, e2, r2 = 0, n2 = t2.length - 1, i2 = Jr2) {
        for (;n2 > r2; ) {
          if (n2 - r2 > 600) {
            const s3 = n2 - r2 + 1, a3 = e2 - r2 + 1, o3 = Math.log(s3), l3 = 0.5 * Math.exp(2 * o3 / 3), u2 = 0.5 * Math.sqrt(o3 * l3 * (s3 - l3) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
            Hr2(t2, e2, Math.max(r2, Math.floor(e2 - a3 * l3 / s3 + u2)), Math.min(n2, Math.floor(e2 + (s3 - a3) * l3 / s3 + u2)), i2);
          }
          const s2 = t2[e2];
          let a2 = r2, o2 = n2;
          for (Yr2(t2, r2, e2), i2(t2[n2], s2) > 0 && Yr2(t2, r2, n2);a2 < o2; ) {
            for (Yr2(t2, a2, o2), a2++, o2--;i2(t2[a2], s2) < 0; )
              a2++;
            for (;i2(t2[o2], s2) > 0; )
              o2--;
          }
          i2(t2[r2], s2) === 0 ? Yr2(t2, r2, o2) : (o2++, Yr2(t2, o2, n2)), o2 <= e2 && (r2 = o2 + 1), e2 <= o2 && (n2 = o2 - 1);
        }
      }
      function Yr2(t2, e2, r2) {
        const n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      function Jr2(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function Wr2(t2, e2) {
        if (t2.length <= 1)
          return [t2];
        const r2 = [];
        let n2, i2;
        for (const e3 of t2) {
          const t3 = tn2(e3);
          t3 !== 0 && (e3.area = Math.abs(t3), i2 === undefined && (i2 = t3 < 0), i2 === t3 < 0 ? (n2 && r2.push(n2), n2 = [e3]) : n2.push(e3));
        }
        if (n2 && r2.push(n2), e2 > 1)
          for (let t3 = 0;t3 < r2.length; t3++)
            r2[t3].length <= e2 || (Hr2(r2[t3], e2, 1, r2[t3].length - 1, Qr2), r2[t3] = r2[t3].slice(0, e2));
        return r2;
      }
      function Qr2(t2, e2) {
        return e2.area - t2.area;
      }
      function tn2(t2) {
        let e2 = 0;
        for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1;i2 < s2; a2 = i2++)
          r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
        return e2;
      }
      const en2 = 1 / 298.257223563, rn = en2 * (2 - en2), nn2 = Math.PI / 180;

      class sn2 {
        constructor(t2) {
          const e2 = 6378.137 * nn2 * 1000, r2 = Math.cos(t2 * nn2), n2 = 1 / (1 - rn * (1 - r2 * r2)), i2 = Math.sqrt(n2);
          this.kx = e2 * i2 * r2, this.ky = e2 * i2 * n2 * (1 - rn);
        }
        distance(t2, e2) {
          const r2 = this.wrap(t2[0] - e2[0]) * this.kx, n2 = (t2[1] - e2[1]) * this.ky;
          return Math.sqrt(r2 * r2 + n2 * n2);
        }
        pointOnLine(t2, e2) {
          let r2, n2, i2, s2, a2 = 1 / 0;
          for (let o2 = 0;o2 < t2.length - 1; o2++) {
            let l3 = t2[o2][0], u2 = t2[o2][1], c2 = this.wrap(t2[o2 + 1][0] - l3) * this.kx, h2 = (t2[o2 + 1][1] - u2) * this.ky, p2 = 0;
            c2 === 0 && h2 === 0 || (p2 = (this.wrap(e2[0] - l3) * this.kx * c2 + (e2[1] - u2) * this.ky * h2) / (c2 * c2 + h2 * h2), p2 > 1 ? (l3 = t2[o2 + 1][0], u2 = t2[o2 + 1][1]) : p2 > 0 && (l3 += c2 / this.kx * p2, u2 += h2 / this.ky * p2)), c2 = this.wrap(e2[0] - l3) * this.kx, h2 = (e2[1] - u2) * this.ky;
            const f2 = c2 * c2 + h2 * h2;
            f2 < a2 && (a2 = f2, r2 = l3, n2 = u2, i2 = o2, s2 = p2);
          }
          return { point: [r2, n2], index: i2, t: Math.max(0, Math.min(1, s2)) };
        }
        wrap(t2) {
          for (;t2 < -180; )
            t2 += 360;
          for (;t2 > 180; )
            t2 -= 360;
          return t2;
        }
      }
      function an2(t2, e2) {
        return e2[0] - t2[0];
      }
      function on2(t2) {
        return t2[1] - t2[0] + 1;
      }
      function ln2(t2, e2) {
        return t2[1] >= t2[0] && t2[1] < e2;
      }
      function un2(t2, e2) {
        if (t2[0] > t2[1])
          return [null, null];
        const r2 = on2(t2);
        if (e2) {
          if (r2 === 2)
            return [t2, null];
          const e3 = Math.floor(r2 / 2);
          return [[t2[0], t2[0] + e3], [t2[0] + e3, t2[1]]];
        }
        if (r2 === 1)
          return [t2, null];
        const n2 = Math.floor(r2 / 2) - 1;
        return [[t2[0], t2[0] + n2], [t2[0] + n2 + 1, t2[1]]];
      }
      function cn2(t2, e2) {
        if (!ln2(e2, t2.length))
          return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let n2 = e2[0];n2 <= e2[1]; ++n2)
          Vr2(r2, t2[n2]);
        return r2;
      }
      function hn2(t2) {
        const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const r2 of t2)
          for (const t3 of r2)
            Vr2(e2, t3);
        return e2;
      }
      function pn2(t2) {
        return t2[0] !== -1 / 0 && t2[1] !== -1 / 0 && t2[2] !== 1 / 0 && t2[3] !== 1 / 0;
      }
      function fn2(t2, e2, r2) {
        if (!pn2(t2) || !pn2(e2))
          return NaN;
        let n2 = 0, i2 = 0;
        return t2[2] < e2[0] && (n2 = e2[0] - t2[2]), t2[0] > e2[2] && (n2 = t2[0] - e2[2]), t2[1] > e2[3] && (i2 = t2[1] - e2[3]), t2[3] < e2[1] && (i2 = e2[1] - t2[3]), r2.distance([0, 0], [n2, i2]);
      }
      function dn2(t2, e2, r2) {
        const n2 = r2.pointOnLine(e2, t2);
        return r2.distance(t2, n2.point);
      }
      function yn(t2, e2, r2, n2, i2) {
        const s2 = Math.min(dn2(t2, [r2, n2], i2), dn2(e2, [r2, n2], i2)), a2 = Math.min(dn2(r2, [t2, e2], i2), dn2(n2, [t2, e2], i2));
        return Math.min(s2, a2);
      }
      function mn2(t2, e2, r2, n2, i2) {
        if (!ln2(e2, t2.length) || !ln2(n2, r2.length))
          return 1 / 0;
        let s2 = 1 / 0;
        for (let a2 = e2[0];a2 < e2[1]; ++a2) {
          const e3 = t2[a2], o2 = t2[a2 + 1];
          for (let t3 = n2[0];t3 < n2[1]; ++t3) {
            const n3 = r2[t3], a3 = r2[t3 + 1];
            if (Fr2(e3, o2, n3, a3))
              return 0;
            s2 = Math.min(s2, yn(e3, o2, n3, a3, i2));
          }
        }
        return s2;
      }
      function gn2(t2, e2, r2, n2, i2) {
        if (!ln2(e2, t2.length) || !ln2(n2, r2.length))
          return NaN;
        let s2 = 1 / 0;
        for (let a2 = e2[0];a2 <= e2[1]; ++a2)
          for (let e3 = n2[0];e3 <= n2[1]; ++e3)
            if (s2 = Math.min(s2, i2.distance(t2[a2], r2[e3])), s2 === 0)
              return s2;
        return s2;
      }
      function xn(t2, e2, r2) {
        if (Lr2(t2, e2, true))
          return 0;
        let n2 = 1 / 0;
        for (const i2 of e2) {
          const e3 = i2[0], s2 = i2[i2.length - 1];
          if (e3 !== s2 && (n2 = Math.min(n2, dn2(t2, [s2, e3], r2)), n2 === 0))
            return n2;
          const a2 = r2.pointOnLine(i2, t2);
          if (n2 = Math.min(n2, r2.distance(t2, a2.point)), n2 === 0)
            return n2;
        }
        return n2;
      }
      function vn2(t2, e2, r2, n2) {
        if (!ln2(e2, t2.length))
          return NaN;
        for (let n3 = e2[0];n3 <= e2[1]; ++n3)
          if (Lr2(t2[n3], r2, true))
            return 0;
        let i2 = 1 / 0;
        for (let s2 = e2[0];s2 < e2[1]; ++s2) {
          const e3 = t2[s2], a2 = t2[s2 + 1];
          for (const t3 of r2)
            for (let r3 = 0, s3 = t3.length, o2 = s3 - 1;r3 < s3; o2 = r3++) {
              const s4 = t3[o2], l3 = t3[r3];
              if (Fr2(e3, a2, s4, l3))
                return 0;
              i2 = Math.min(i2, yn(e3, a2, s4, l3, n2));
            }
        }
        return i2;
      }
      function bn(t2, e2) {
        for (const r2 of t2)
          for (const t3 of r2)
            if (Lr2(t3, e2, true))
              return true;
        return false;
      }
      function wn2(t2, e2, r2, n2 = 1 / 0) {
        const i2 = hn2(t2), s2 = hn2(e2);
        if (n2 !== 1 / 0 && fn2(i2, s2, r2) >= n2)
          return n2;
        if (Er2(i2, s2)) {
          if (bn(t2, e2))
            return 0;
        } else if (bn(e2, t2))
          return 0;
        let a2 = 1 / 0;
        for (const n3 of t2)
          for (let t3 = 0, i3 = n3.length, s3 = i3 - 1;t3 < i3; s3 = t3++) {
            const i4 = n3[s3], o2 = n3[t3];
            for (const t4 of e2)
              for (let e3 = 0, n4 = t4.length, s4 = n4 - 1;e3 < n4; s4 = e3++) {
                const n5 = t4[s4], l3 = t4[e3];
                if (Fr2(i4, o2, n5, l3))
                  return 0;
                a2 = Math.min(a2, yn(i4, o2, n5, l3, r2));
              }
          }
        return a2;
      }
      function _n(t2, e2, r2, n2, i2, s2) {
        if (!s2)
          return;
        const a2 = fn2(cn2(n2, s2), i2, r2);
        a2 < e2 && t2.push([a2, s2, [0, 0]]);
      }
      function An(t2, e2, r2, n2, i2, s2, a2) {
        if (!s2 || !a2)
          return;
        const o2 = fn2(cn2(n2, s2), cn2(i2, a2), r2);
        o2 < e2 && t2.push([o2, s2, a2]);
      }
      function Sn2(t2, e2, r2, n2, i2 = 1 / 0) {
        let s2 = Math.min(n2.distance(t2[0], r2[0][0]), i2);
        if (s2 === 0)
          return s2;
        const a2 = new Xr2([[0, [0, t2.length - 1], [0, 0]]], an2), o2 = hn2(r2);
        for (;a2.length > 0; ) {
          const i3 = a2.pop();
          if (i3[0] >= s2)
            continue;
          const l3 = i3[1], u2 = e2 ? 50 : 100;
          if (on2(l3) <= u2) {
            if (!ln2(l3, t2.length))
              return NaN;
            if (e2) {
              const e3 = vn2(t2, l3, r2, n2);
              if (isNaN(e3) || e3 === 0)
                return e3;
              s2 = Math.min(s2, e3);
            } else
              for (let e3 = l3[0];e3 <= l3[1]; ++e3) {
                const i4 = xn(t2[e3], r2, n2);
                if (s2 = Math.min(s2, i4), s2 === 0)
                  return 0;
              }
          } else {
            const r3 = un2(l3, e2);
            _n(a2, s2, n2, t2, o2, r3[0]), _n(a2, s2, n2, t2, o2, r3[1]);
          }
        }
        return s2;
      }
      function kn2(t2, e2, r2, n2, i2, s2 = 1 / 0) {
        let a2 = Math.min(s2, i2.distance(t2[0], r2[0]));
        if (a2 === 0)
          return a2;
        const o2 = new Xr2([[0, [0, t2.length - 1], [0, r2.length - 1]]], an2);
        for (;o2.length > 0; ) {
          const s3 = o2.pop();
          if (s3[0] >= a2)
            continue;
          const l3 = s3[1], u2 = s3[2], c2 = e2 ? 50 : 100, h2 = n2 ? 50 : 100;
          if (on2(l3) <= c2 && on2(u2) <= h2) {
            if (!ln2(l3, t2.length) && ln2(u2, r2.length))
              return NaN;
            let s4;
            if (e2 && n2)
              s4 = mn2(t2, l3, r2, u2, i2), a2 = Math.min(a2, s4);
            else if (e2 && !n2) {
              const e3 = t2.slice(l3[0], l3[1] + 1);
              for (let t3 = u2[0];t3 <= u2[1]; ++t3)
                if (s4 = dn2(r2[t3], e3, i2), a2 = Math.min(a2, s4), a2 === 0)
                  return a2;
            } else if (!e2 && n2) {
              const e3 = r2.slice(u2[0], u2[1] + 1);
              for (let r3 = l3[0];r3 <= l3[1]; ++r3)
                if (s4 = dn2(t2[r3], e3, i2), a2 = Math.min(a2, s4), a2 === 0)
                  return a2;
            } else
              s4 = gn2(t2, l3, r2, u2, i2), a2 = Math.min(a2, s4);
          } else {
            const s4 = un2(l3, e2), c3 = un2(u2, n2);
            An(o2, a2, i2, t2, r2, s4[0], c3[0]), An(o2, a2, i2, t2, r2, s4[0], c3[1]), An(o2, a2, i2, t2, r2, s4[1], c3[0]), An(o2, a2, i2, t2, r2, s4[1], c3[1]);
          }
        }
        return a2;
      }
      function Mn(t2) {
        return t2.type === "MultiPolygon" ? t2.coordinates.map((t3) => ({ type: "Polygon", coordinates: t3 })) : t2.type === "MultiLineString" ? t2.coordinates.map((t3) => ({ type: "LineString", coordinates: t3 })) : t2.type === "MultiPoint" ? t2.coordinates.map((t3) => ({ type: "Point", coordinates: t3 })) : [t2];
      }

      class In {
        constructor(t2, e2) {
          this.type = Tt2, this.geojson = t2, this.geometries = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'distance' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (De(t2[1])) {
            const e3 = t2[1];
            if (e3.type === "FeatureCollection")
              return new In(e3, e3.features.map((t3) => Mn(t3.geometry)).flat());
            if (e3.type === "Feature")
              return new In(e3, Mn(e3.geometry));
            if ("type" in e3 && "coordinates" in e3)
              return new In(e3, Mn(e3));
          }
          return e2.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t2) {
          if (t2.geometry() != null && t2.canonicalID() != null) {
            if (t2.geometryType() === "Point")
              return function(t3, e2) {
                const r2 = t3.geometry(), n2 = r2.flat().map((e3) => Br2([e3.x, e3.y], t3.canonical));
                if (r2.length === 0)
                  return NaN;
                const i2 = new sn2(n2[0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, kn2(n2, false, [t4.coordinates], false, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, kn2(n2, false, t4.coordinates, true, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, Sn2(n2, false, t4.coordinates, i2, s2));
                  }
                  if (s2 === 0)
                    return s2;
                }
                return s2;
              }(t2, this.geometries);
            if (t2.geometryType() === "LineString")
              return function(t3, e2) {
                const r2 = t3.geometry(), n2 = r2.flat().map((e3) => Br2([e3.x, e3.y], t3.canonical));
                if (r2.length === 0)
                  return NaN;
                const i2 = new sn2(n2[0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, kn2(n2, true, [t4.coordinates], false, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, kn2(n2, true, t4.coordinates, true, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, Sn2(n2, true, t4.coordinates, i2, s2));
                  }
                  if (s2 === 0)
                    return s2;
                }
                return s2;
              }(t2, this.geometries);
            if (t2.geometryType() === "Polygon")
              return function(t3, e2) {
                const r2 = t3.geometry();
                if (r2.length === 0 || r2[0].length === 0)
                  return NaN;
                const n2 = Wr2(r2, 0).map((e3) => e3.map((e4) => e4.map((e5) => Br2([e5.x, e5.y], t3.canonical)))), i2 = new sn2(n2[0][0][0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2)
                  for (const e3 of n2) {
                    switch (t4.type) {
                      case "Point":
                        s2 = Math.min(s2, Sn2([t4.coordinates], false, e3, i2, s2));
                        break;
                      case "LineString":
                        s2 = Math.min(s2, Sn2(t4.coordinates, true, e3, i2, s2));
                        break;
                      case "Polygon":
                        s2 = Math.min(s2, wn2(e3, t4.coordinates, i2, s2));
                    }
                    if (s2 === 0)
                      return s2;
                  }
                return s2;
              }(t2, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }

      class zn {
        constructor(t2) {
          this.type = jt2, this.key = t2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
          const r2 = t2[1];
          return r2 == null ? e2.error("Global state property must be defined.") : typeof r2 != "string" ? e2.error(`Global state property must be string, but found ${typeof t2[1]} instead.`) : new zn(r2);
        }
        evaluate(t2) {
          var e2;
          const r2 = (e2 = t2.globals) === null || e2 === undefined ? undefined : e2.globalState;
          return r2 && Object.keys(r2).length !== 0 ? ge2(r2, this.key) : null;
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
      }
      const Pn = { "==": xr2, "!=": vr2, ">": wr2, "<": br2, ">=": Ar2, "<=": _r2, array: qe2, at: We2, boolean: qe2, case: rr2, coalesce: dr2, collator: Sr2, format: Mr2, image: Ir2, in: Qe2, "index-of": tr2, interpolate: hr2, "interpolate-hcl": hr2, "interpolate-lab": hr2, length: zr2, let: Ye2, literal: Ne2, match: er2, number: qe2, "number-format": kr2, object: qe2, slice: nr2, step: sr2, string: qe2, "to-boolean": Ze2, "to-color": Ze2, "to-number": Ze2, "to-string": Ze2, var: Je2, within: Kr2, distance: In, "global-state": zn };

      class Cn {
        constructor(t2, e2, r2, n2) {
          this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
        }
        evaluate(t2) {
          return this._evaluate(t2, this.args);
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return false;
        }
        static parse(t2, e2) {
          const r2 = t2[0], n2 = Cn.definitions[r2];
          if (!n2)
            return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
          let o2 = null;
          for (const [n3, s3] of a2) {
            o2 = new He2(e2.registry, Fn, e2.path, null, e2.scope);
            const a3 = [];
            let l3 = false;
            for (let e3 = 1;e3 < t2.length; e3++) {
              const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
              if (!s4) {
                l3 = true;
                break;
              }
              a3.push(s4);
            }
            if (!l3)
              if (Array.isArray(n3) && n3.length !== a3.length)
                o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
              else {
                for (let t3 = 0;t3 < a3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                }
                if (o2.errors.length === 0)
                  return new Cn(r2, i2, s3, a3);
              }
          }
          if (a2.length === 1)
            e2.errors.push(...o2.errors);
          else {
            const r3 = (a2.length ? a2 : s2).map(([t3]) => {
              return e3 = t3, Array.isArray(e3) ? `(${e3.map(Ht2).join(", ")})` : `(${Ht2(e3.type)}...)`;
              var e3;
            }).join(" | "), n3 = [];
            for (let r4 = 1;r4 < t2.length; r4++) {
              const i3 = e2.parse(t2[r4], 1 + n3.length);
              if (!i3)
                return null;
              n3.push(Ht2(i3.type));
            }
            e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t2, e2) {
          Cn.definitions = e2;
          for (const r2 in e2)
            t2[r2] = Cn;
        }
      }
      function Bn(t2, [e2, r2, n2, i2]) {
        e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
        const s2 = i2 ? i2.evaluate(t2) : 1, a2 = Oe2(e2, r2, n2, s2);
        if (a2)
          throw new Ee2(a2);
        return new ke2(e2 / 255, r2 / 255, n2 / 255, s2, false);
      }
      function Vn2(t2, e2) {
        return t2 in e2;
      }
      function En(t2, e2) {
        const r2 = e2[t2];
        return r2 === undefined ? null : r2;
      }
      function Tn2(t2) {
        return { type: t2 };
      }
      function Fn(t2) {
        if (t2 instanceof Je2)
          return Fn(t2.boundExpression);
        if (t2 instanceof Cn && t2.name === "error")
          return false;
        if (t2 instanceof Sr2)
          return false;
        if (t2 instanceof Kr2)
          return false;
        if (t2 instanceof In)
          return false;
        if (t2 instanceof zn)
          return false;
        const e2 = t2 instanceof Ze2 || t2 instanceof qe2;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 = e2 ? r2 && Fn(t3) : r2 && t3 instanceof Ne2;
        }), !!r2 && $n(t2) && On(t2, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function $n(t2) {
        if (t2 instanceof Cn) {
          if (t2.name === "get" && t2.args.length === 1)
            return false;
          if (t2.name === "feature-state")
            return false;
          if (t2.name === "has" && t2.args.length === 1)
            return false;
          if (t2.name === "properties" || t2.name === "geometry-type" || t2.name === "id")
            return false;
          if (/^filter-/.test(t2.name))
            return false;
        }
        if (t2 instanceof Kr2)
          return false;
        if (t2 instanceof In)
          return false;
        let e2 = true;
        return t2.eachChild((t3) => {
          e2 && !$n(t3) && (e2 = false);
        }), e2;
      }
      function Ln(t2) {
        if (t2 instanceof Cn && t2.name === "feature-state")
          return false;
        let e2 = true;
        return t2.eachChild((t3) => {
          e2 && !Ln(t3) && (e2 = false);
        }), e2;
      }
      function On(t2, e2) {
        if (t2 instanceof Cn && e2.indexOf(t2.name) >= 0)
          return false;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 && !On(t3, e2) && (r2 = false);
        }), r2;
      }
      function Dn(t2) {
        return { result: "success", value: t2 };
      }
      function jn(t2) {
        return { result: "error", value: t2 };
      }
      function Rn(t2) {
        return t2["property-type"] === "data-driven" || t2["property-type"] === "cross-faded-data-driven";
      }
      function Nn2(t2) {
        return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
      }
      function Un(t2) {
        return !!t2.expression && t2.expression.interpolated;
      }
      function qn(t2) {
        return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : t2 === null ? "null" : typeof t2;
      }
      function Gn(t2) {
        return typeof t2 == "object" && t2 !== null && !Array.isArray(t2) && je2(t2) === Dt2;
      }
      function Zn(t2) {
        return t2;
      }
      function Kn(t2, e2) {
        const r2 = t2.stops && typeof t2.stops[0][0] == "object", n2 = r2 || !(r2 || t2.property !== undefined), i2 = t2.type || (Un(e2) ? "exponential" : "interval"), s2 = function(t3) {
          switch (t3.type) {
            case "color":
              return ke2.parse;
            case "padding":
              return Ce2.parse;
            case "numberArray":
              return Be2.parse;
            case "colorArray":
              return Ve2.parse;
            default:
              return null;
          }
        }(e2);
        if (s2 && ((t2 = Ct({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], s2(t3[1])])), t2.default = s2(t2.default ? t2.default : e2.default)), t2.colorSpace && (a2 = t2.colorSpace) !== "rgb" && a2 !== "hcl" && a2 !== "lab")
          throw new Error(`Unknown color space: "${t2.colorSpace}"`);
        var a2;
        const o2 = function(t3) {
          switch (t3) {
            case "exponential":
              return Jn;
            case "interval":
              return Yn;
            case "categorical":
              return Hn;
            case "identity":
              return Wn;
            default:
              throw new Error(`Unknown function type "${t3}"`);
          }
        }(i2);
        let l3, u2;
        if (i2 === "categorical") {
          l3 = Object.create(null);
          for (const e3 of t2.stops)
            l3[e3[0]] = e3[1];
          u2 = typeof t2.stops[0][0];
        }
        if (r2) {
          const r3 = {}, n3 = [];
          for (let e3 = 0;e3 < t2.stops.length; e3++) {
            const i4 = t2.stops[e3], s4 = i4[0].zoom;
            r3[s4] === undefined && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
          }
          const i3 = [];
          for (const t3 of n3)
            i3.push([r3[t3].zoom, Kn(r3[t3], e2)]);
          const s3 = { name: "linear" };
          return { kind: "composite", interpolationType: s3, interpolationFactor: hr2.interpolationFactor.bind(undefined, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Jn({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
        }
        if (n2) {
          const r3 = i2 === "exponential" ? { name: "exponential", base: t2.base !== undefined ? t2.base : 1 } : null;
          return { kind: "camera", interpolationType: r3, interpolationFactor: hr2.interpolationFactor.bind(undefined, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => o2(t2, e2, r4, l3, u2) };
        }
        return { kind: "source", evaluate(r3, n3) {
          const i3 = n3 && n3.properties ? n3.properties[t2.property] : undefined;
          return i3 === undefined ? Xn(t2.default, e2.default) : o2(t2, e2, i3, l3, u2);
        } };
      }
      function Xn(t2, e2, r2) {
        return t2 !== undefined ? t2 : e2 !== undefined ? e2 : r2 !== undefined ? r2 : undefined;
      }
      function Hn(t2, e2, r2, n2, i2) {
        return Xn(typeof r2 === i2 ? n2[r2] : undefined, t2.default, e2.default);
      }
      function Yn(t2, e2, r2) {
        if (qn(r2) !== "number")
          return Xn(t2.default, e2.default);
        const n2 = t2.stops.length;
        if (n2 === 1)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[n2 - 1][0])
          return t2.stops[n2 - 1][1];
        const i2 = ir2(t2.stops.map((t3) => t3[0]), r2);
        return t2.stops[i2][1];
      }
      function Jn(t2, e2, r2) {
        const n2 = t2.base !== undefined ? t2.base : 1;
        if (qn(r2) !== "number")
          return Xn(t2.default, e2.default);
        const i2 = t2.stops.length;
        if (i2 === 1)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[i2 - 1][0])
          return t2.stops[i2 - 1][1];
        const s2 = ir2(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
          const i3 = n3 - r3, s3 = t3 - r3;
          return i3 === 0 ? 0 : e3 === 1 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
        }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l3 = t2.stops[s2 + 1][1], u2 = fr2[e2.type] || Zn;
        return typeof o2.evaluate == "function" ? { evaluate(...e3) {
          const r3 = o2.evaluate.apply(undefined, e3), n3 = l3.evaluate.apply(undefined, e3);
          if (r3 !== undefined && n3 !== undefined)
            return u2(r3, n3, a2, t2.colorSpace);
        } } : u2(o2, l3, a2, t2.colorSpace);
      }
      function Wn(t2, e2, r2) {
        switch (e2.type) {
          case "color":
            r2 = ke2.parse(r2);
            break;
          case "formatted":
            r2 = Pe2.fromString(r2.toString());
            break;
          case "resolvedImage":
            r2 = $e2.fromString(r2.toString());
            break;
          case "padding":
            r2 = Ce2.parse(r2);
            break;
          case "colorArray":
            r2 = Ve2.parse(r2);
            break;
          case "numberArray":
            r2 = Be2.parse(r2);
            break;
          default:
            qn(r2) === e2.type || e2.type === "enum" && e2.values[r2] || (r2 = undefined);
        }
        return Xn(r2, t2.default, e2.default);
      }
      Cn.register(Pn, { error: [{ kind: "error" }, [Ft2], (t2, [e2]) => {
        throw new Ee2(e2.evaluate(t2));
      }], typeof: [Ft2, [jt2], (t2, [e2]) => Ht2(je2(e2.evaluate(t2)))], "to-rgba": [Xt2(Tt2, 4), [Lt2], (t2, [e2]) => {
        const [r2, n2, i2, s2] = e2.evaluate(t2).rgb;
        return [255 * r2, 255 * n2, 255 * i2, s2];
      }], rgb: [Lt2, [Tt2, Tt2, Tt2], Bn], rgba: [Lt2, [Tt2, Tt2, Tt2, Tt2], Bn], has: { type: $t2, overloads: [[[Ft2], (t2, [e2]) => Vn2(e2.evaluate(t2), t2.properties())], [[Ft2, Dt2], (t2, [e2, r2]) => Vn2(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: jt2, overloads: [[[Ft2], (t2, [e2]) => En(e2.evaluate(t2), t2.properties())], [[Ft2, Dt2], (t2, [e2, r2]) => En(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [jt2, [Ft2], (t2, [e2]) => En(e2.evaluate(t2), t2.featureState || {})], properties: [Dt2, [], (t2) => t2.properties()], "geometry-type": [Ft2, [], (t2) => t2.geometryType()], id: [jt2, [], (t2) => t2.id()], zoom: [Tt2, [], (t2) => t2.globals.zoom], "heatmap-density": [Tt2, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [Tt2, [], (t2) => t2.globals.lineProgress || 0], accumulated: [jt2, [], (t2) => t2.globals.accumulated === undefined ? null : t2.globals.accumulated], "+": [Tt2, Tn2(Tt2), (t2, e2) => {
        let r2 = 0;
        for (const n2 of e2)
          r2 += n2.evaluate(t2);
        return r2;
      }], "*": [Tt2, Tn2(Tt2), (t2, e2) => {
        let r2 = 1;
        for (const n2 of e2)
          r2 *= n2.evaluate(t2);
        return r2;
      }], "-": { type: Tt2, overloads: [[[Tt2, Tt2], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[Tt2], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [Tt2, [Tt2, Tt2], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [Tt2, [Tt2, Tt2], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [Tt2, [], () => Math.LN2], pi: [Tt2, [], () => Math.PI], e: [Tt2, [], () => Math.E], "^": [Tt2, [Tt2, Tt2], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [Tt2, [Tt2], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [Tt2, [Tt2], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [Tt2, [Tt2], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [Tt2, [Tt2], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [Tt2, [Tt2], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [Tt2, [Tt2], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [Tt2, [Tt2], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [Tt2, [Tt2], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [Tt2, [Tt2], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [Tt2, [Tt2], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [Tt2, Tn2(Tt2), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [Tt2, Tn2(Tt2), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [Tt2, [Tt2], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [Tt2, [Tt2], (t2, [e2]) => {
        const r2 = e2.evaluate(t2);
        return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
      }], floor: [Tt2, [Tt2], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [Tt2, [Tt2], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [$t2, [Ft2, jt2], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [$t2, [jt2], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [$t2, [Ft2], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [$t2, [Ft2, jt2], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 < i2;
      }], "filter-id-<": [$t2, [jt2], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 < n2;
      }], "filter->": [$t2, [Ft2, jt2], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 > i2;
      }], "filter-id->": [$t2, [jt2], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 > n2;
      }], "filter-<=": [$t2, [Ft2, jt2], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 <= i2;
      }], "filter-id-<=": [$t2, [jt2], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 <= n2;
      }], "filter->=": [$t2, [Ft2, jt2], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 >= i2;
      }], "filter-id->=": [$t2, [jt2], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 >= n2;
      }], "filter-has": [$t2, [jt2], (t2, [e2]) => (e2.value in t2.properties())], "filter-has-id": [$t2, [], (t2) => t2.id() !== null && t2.id() !== undefined], "filter-type-in": [$t2, [Xt2(Ft2)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [$t2, [Xt2(jt2)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [$t2, [Ft2, Xt2(jt2)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [$t2, [Ft2, Xt2(jt2)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
        for (;r3 <= n2; ) {
          const i2 = r3 + n2 >> 1;
          if (e3[i2] === t3)
            return true;
          e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
        }
        return false;
      }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: $t2, overloads: [[[$t2, $t2], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [Tn2($t2), (t2, e2) => {
        for (const r2 of e2)
          if (!r2.evaluate(t2))
            return false;
        return true;
      }]] }, any: { type: $t2, overloads: [[[$t2, $t2], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [Tn2($t2), (t2, e2) => {
        for (const r2 of e2)
          if (r2.evaluate(t2))
            return true;
        return false;
      }]] }, "!": [$t2, [$t2], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [$t2, [Ft2], (t2, [e2]) => {
        const r2 = t2.globals && t2.globals.isSupportedScript;
        return !r2 || r2(e2.evaluate(t2));
      }], upcase: [Ft2, [Ft2], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [Ft2, [Ft2], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [Ft2, Tn2(jt2), (t2, e2) => e2.map((e3) => Re2(e3.evaluate(t2))).join("")], "resolved-locale": [Ft2, [Rt2], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });

      class Qn {
        constructor(t2, e2) {
          this.expression = t2, this._warningHistory = {}, this._evaluator = new Xe2, this._defaultValue = e2 ? function(t3) {
            if (t3.type === "color" && Gn(t3.default))
              return new ke2(0, 0, 0, 0);
            switch (t3.type) {
              case "color":
                return ke2.parse(t3.default) || null;
              case "padding":
                return Ce2.parse(t3.default) || null;
              case "numberArray":
                return Be2.parse(t3.default) || null;
              case "colorArray":
                return Ve2.parse(t3.default) || null;
              case "variableAnchorOffsetCollection":
                return Fe2.parse(t3.default) || null;
              case "projectionDefinition":
                return Le2.parse(t3.default) || null;
              default:
                return t3.default === undefined ? null : t3.default;
            }
          }(e2) : null, this._enumValues = e2 && e2.type === "enum" ? e2.values : null;
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
          try {
            const t3 = this.expression.evaluate(this._evaluator);
            if (t3 == null || typeof t3 == "number" && t3 != t3)
              return this._defaultValue;
            if (this._enumValues && !(t3 in this._enumValues))
              throw new Ee2(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
            return t3;
          } catch (t3) {
            return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, typeof console != "undefined" && console.warn(t3.message)), this._defaultValue;
          }
        }
      }
      function ti2(t2) {
        return Array.isArray(t2) && t2.length > 0 && typeof t2[0] == "string" && t2[0] in Pn;
      }
      function ei2(t2, e2) {
        const r2 = new He2(Pn, Fn, [], e2 ? function(t3) {
          const e3 = { color: Lt2, string: Ft2, number: Tt2, enum: Ft2, boolean: $t2, formatted: Nt2, padding: Ut, numberArray: Gt2, colorArray: qt2, projectionDefinition: Ot2, resolvedImage: Zt2, variableAnchorOffsetCollection: Kt2 };
          return t3.type === "array" ? Xt2(e3[t3.value] || jt2, t3.length) : e3[t3.type];
        }(e2) : undefined), n2 = r2.parse(t2, undefined, undefined, undefined, e2 && e2.type === "string" ? { typeAnnotation: "coerce" } : undefined);
        return n2 ? Dn(new Qn(n2, e2)) : jn(r2.errors);
      }

      class ri2 {
        constructor(t2, e2) {
          this.kind = t2, this._styleExpression = e2, this.isStateDependent = t2 !== "constant" && !Ln(e2.expression);
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
        }
      }

      class ni2 {
        constructor(t2, e2, r2, n2) {
          this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = t2 !== "camera" && !Ln(e2.expression), this.interpolationType = n2;
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
        }
        interpolationFactor(t2, e2, r2) {
          return this.interpolationType ? hr2.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
        }
      }
      function ii2(t2, e2) {
        const r2 = ei2(t2, e2);
        if (r2.result === "error")
          return r2;
        const n2 = r2.value.expression, i2 = $n(n2);
        if (!i2 && !Rn(e2))
          return jn([new Bt2("", "data expressions not supported")]);
        const s2 = On(n2, ["zoom"]);
        if (!s2 && !Nn2(e2))
          return jn([new Bt2("", "zoom expressions not supported")]);
        const a2 = ai2(n2);
        return a2 || s2 ? a2 instanceof Bt2 ? jn([a2]) : a2 instanceof hr2 && !Un(e2) ? jn([new Bt2("", '"interpolate" expressions cannot be used with this property')]) : Dn(a2 ? new ni2(i2 ? "camera" : "composite", r2.value, a2.labels, a2 instanceof hr2 ? a2.interpolation : undefined) : new ri2(i2 ? "constant" : "source", r2.value)) : jn([new Bt2("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }

      class si2 {
        constructor(t2, e2) {
          this._parameters = t2, this._specification = e2, Ct(this, Kn(this._parameters, this._specification));
        }
        static deserialize(t2) {
          return new si2(t2._parameters, t2._specification);
        }
        static serialize(t2) {
          return { _parameters: t2._parameters, _specification: t2._specification };
        }
      }
      function ai2(t2) {
        let e2 = null;
        if (t2 instanceof Ye2)
          e2 = ai2(t2.result);
        else if (t2 instanceof dr2) {
          for (const r2 of t2.args)
            if (e2 = ai2(r2), e2)
              break;
        } else
          (t2 instanceof sr2 || t2 instanceof hr2) && t2.input instanceof Cn && t2.input.name === "zoom" && (e2 = t2);
        return e2 instanceof Bt2 || t2.eachChild((t3) => {
          const r2 = ai2(t3);
          r2 instanceof Bt2 ? e2 = r2 : !e2 && r2 ? e2 = new Bt2("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new Bt2("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e2;
      }
      function oi2(t2) {
        if (t2 === true || t2 === false)
          return true;
        if (!Array.isArray(t2) || t2.length === 0)
          return false;
        switch (t2[0]) {
          case "has":
            return t2.length >= 2 && t2[1] !== "$id" && t2[1] !== "$type";
          case "in":
            return t2.length >= 3 && (typeof t2[1] != "string" || Array.isArray(t2[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return t2.length !== 3 || Array.isArray(t2[1]) || Array.isArray(t2[2]);
          case "any":
          case "all":
            for (const e2 of t2.slice(1))
              if (!oi2(e2) && typeof e2 != "boolean")
                return false;
            return true;
          default:
            return true;
        }
      }
      const li2 = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
      function ui2(t2) {
        if (t2 == null)
          return { filter: () => true, needGeometry: false };
        oi2(t2) || (t2 = pi2(t2));
        const e2 = ei2(t2, li2);
        if (e2.result === "error")
          throw new Error(e2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
        return { filter: (t3, r2, n2) => e2.value.evaluate(t3, r2, {}, n2), needGeometry: hi2(t2) };
      }
      function ci2(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function hi2(t2) {
        if (!Array.isArray(t2))
          return false;
        if (t2[0] === "within" || t2[0] === "distance")
          return true;
        for (let e2 = 1;e2 < t2.length; e2++)
          if (hi2(t2[e2]))
            return true;
        return false;
      }
      function pi2(t2) {
        if (!t2)
          return true;
        const e2 = t2[0];
        return t2.length <= 1 ? e2 !== "any" : e2 === "==" ? fi2(t2[1], t2[2], "==") : e2 === "!=" ? mi2(fi2(t2[1], t2[2], "==")) : e2 === "<" || e2 === ">" || e2 === "<=" || e2 === ">=" ? fi2(t2[1], t2[2], e2) : e2 === "any" ? (r2 = t2.slice(1), ["any"].concat(r2.map(pi2))) : e2 === "all" ? ["all"].concat(t2.slice(1).map(pi2)) : e2 === "none" ? ["all"].concat(t2.slice(1).map(pi2).map(mi2)) : e2 === "in" ? di2(t2[1], t2.slice(2)) : e2 === "!in" ? mi2(di2(t2[1], t2.slice(2))) : e2 === "has" ? yi2(t2[1]) : e2 !== "!has" || mi2(yi2(t2[1]));
        var r2;
      }
      function fi2(t2, e2, r2) {
        switch (t2) {
          case "$type":
            return [`filter-type-${r2}`, e2];
          case "$id":
            return [`filter-id-${r2}`, e2];
          default:
            return [`filter-${r2}`, t2, e2];
        }
      }
      function di2(t2, e2) {
        if (e2.length === 0)
          return false;
        switch (t2) {
          case "$type":
            return ["filter-type-in", ["literal", e2]];
          case "$id":
            return ["filter-id-in", ["literal", e2]];
          default:
            return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(ci2)]] : ["filter-in-small", t2, ["literal", e2]];
        }
      }
      function yi2(t2) {
        switch (t2) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t2];
        }
      }
      function mi2(t2) {
        return ["!", t2];
      }
      function gi2(t2) {
        const e2 = typeof t2;
        if (e2 === "number" || e2 === "boolean" || e2 === "string" || t2 == null)
          return JSON.stringify(t2);
        if (Array.isArray(t2)) {
          let e3 = "[";
          for (const r3 of t2)
            e3 += `${gi2(r3)},`;
          return `${e3}]`;
        }
        const r2 = Object.keys(t2).sort();
        let n2 = "{";
        for (let e3 = 0;e3 < r2.length; e3++)
          n2 += `${JSON.stringify(r2[e3])}:${gi2(t2[r2[e3]])},`;
        return `${n2}}`;
      }
      function xi2(t2) {
        let e2 = "";
        for (const r2 of xt2)
          e2 += `/${gi2(t2[r2])}`;
        return e2;
      }
      function vi2(t2) {
        const e2 = t2.value;
        return e2 ? [new Pt2(t2.key, e2, "constants have been deprecated as of v8")] : [];
      }
      function bi2(t2) {
        return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
      }
      function wi2(t2) {
        if (Array.isArray(t2))
          return t2.map(wi2);
        if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
          const e2 = {};
          for (const r2 in t2)
            e2[r2] = wi2(t2[r2]);
          return e2;
        }
        return bi2(t2);
      }
      function _i2(t2) {
        const { key: e2, value: r2 } = t2, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec, o2 = t2.validateSpec;
        let l3 = [];
        const u2 = qn(r2);
        if (u2 !== "object")
          return [new Pt2(e2, r2, `object expected, ${u2} found`)];
        for (const t3 in r2) {
          const u3 = t3.split(".")[0], c2 = ge2(n2, u3) || n2["*"];
          let h2;
          if (ge2(i2, u3))
            h2 = i2[u3];
          else if (ge2(n2, u3))
            h2 = o2;
          else if (i2["*"])
            h2 = i2["*"];
          else {
            if (!n2["*"]) {
              l3.push(new Pt2(e2, r2[t3], `unknown property "${t3}"`));
              continue;
            }
            h2 = o2;
          }
          l3 = l3.concat(h2({ key: (e2 ? `${e2}.` : e2) + t3, value: r2[t3], valueSpec: c2, style: s2, styleSpec: a2, object: r2, objectKey: t3, validateSpec: o2 }, r2));
        }
        for (const t3 in n2)
          i2[t3] || n2[t3].required && n2[t3].default === undefined && r2[t3] === undefined && l3.push(new Pt2(e2, r2, `missing required property "${t3}"`));
        return l3;
      }
      function Ai2(t2) {
        const { value: e2, valueSpec: r2, style: n2, styleSpec: i2, key: s2 } = t2, a2 = t2.arrayElementValidator || t2.validateSpec;
        if (qn(e2) !== "array")
          return [new Pt2(s2, e2, `array expected, ${qn(e2)} found`)];
        if (r2.length && e2.length !== r2.length)
          return [new Pt2(s2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
        if (r2["min-length"] && e2.length < r2["min-length"])
          return [new Pt2(s2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
        let o2 = { type: r2.value, values: r2.values };
        i2.$version < 7 && (o2.function = r2.function), qn(r2.value) === "object" && (o2 = r2.value);
        let l3 = [];
        for (let r3 = 0;r3 < e2.length; r3++)
          l3 = l3.concat(a2({ array: e2, arrayIndex: r3, value: e2[r3], valueSpec: o2, validateSpec: t2.validateSpec, style: n2, styleSpec: i2, key: `${s2}[${r3}]` }));
        return l3;
      }
      function Si2(t2) {
        const { key: e2, value: r2, valueSpec: n2 } = t2;
        let i2 = qn(r2);
        return i2 === "number" && r2 != r2 && (i2 = "NaN"), i2 !== "number" ? [new Pt2(e2, r2, `number expected, ${i2} found`)] : ("minimum" in n2) && r2 < n2.minimum ? [new Pt2(e2, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : ("maximum" in n2) && r2 > n2.maximum ? [new Pt2(e2, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
      }
      function ki2(t2) {
        const e2 = t2.valueSpec, r2 = bi2(t2.value.type);
        let n2, i2, s2, a2 = {};
        const o2 = r2 !== "categorical" && t2.value.property === undefined, l3 = !o2, u2 = qn(t2.value.stops) === "array" && qn(t2.value.stops[0]) === "array" && qn(t2.value.stops[0][0]) === "object", c2 = _i2({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, validateSpec: t2.validateSpec, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
          if (r2 === "identity")
            return [new Pt2(t3.key, t3.value, 'identity function may not have a "stops" property')];
          let e3 = [];
          const n3 = t3.value;
          return e3 = e3.concat(Ai2({ key: t3.key, value: n3, valueSpec: t3.valueSpec, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), qn(n3) === "array" && n3.length === 0 && e3.push(new Pt2(t3.key, n3, "array must have at least one stop")), e3;
        }, default: function(t3) {
          return t3.validateSpec({ key: t3.key, value: t3.value, valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec });
        } } });
        return r2 === "identity" && o2 && c2.push(new Pt2(t2.key, t2.value, 'missing required property "property"')), r2 === "identity" || t2.value.stops || c2.push(new Pt2(t2.key, t2.value, 'missing required property "stops"')), r2 === "exponential" && t2.valueSpec.expression && !Un(t2.valueSpec) && c2.push(new Pt2(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l3 && !Rn(t2.valueSpec) ? c2.push(new Pt2(t2.key, t2.value, "property functions not supported")) : o2 && !Nn2(t2.valueSpec) && c2.push(new Pt2(t2.key, t2.value, "zoom functions not supported"))), r2 !== "categorical" && !u2 || t2.value.property !== undefined || c2.push(new Pt2(t2.key, t2.value, '"property" property is required')), c2;
        function h2(t3) {
          let r3 = [];
          const { value: n3, key: o3 } = t3;
          if (qn(n3) !== "array")
            return [new Pt2(o3, n3, `array expected, ${qn(n3)} found`)];
          if (n3.length !== 2)
            return [new Pt2(o3, n3, `array length 2 expected, length ${n3.length} found`)];
          if (u2) {
            if (qn(n3[0]) !== "object")
              return [new Pt2(o3, n3, `object expected, ${qn(n3[0])} found`)];
            if (n3[0].zoom === undefined)
              return [new Pt2(o3, n3, "object stop key must have zoom")];
            if (n3[0].value === undefined)
              return [new Pt2(o3, n3, "object stop key must have value")];
            if (s2 && s2 > bi2(n3[0].zoom))
              return [new Pt2(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
            bi2(n3[0].zoom) !== s2 && (s2 = bi2(n3[0].zoom), i2 = undefined, a2 = {}), r3 = r3.concat(_i2({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: Si2, value: p2 } }));
          } else
            r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }, n3));
          return ti2(wi2(n3[1])) ? r3.concat([new Pt2(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(t3.validateSpec({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }));
        }
        function p2(t3, s3) {
          const o3 = qn(t3.value), l4 = bi2(t3.value), u3 = t3.value !== null ? t3.value : s3;
          if (n2) {
            if (o3 !== n2)
              return [new Pt2(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
          } else
            n2 = o3;
          if (o3 !== "number" && o3 !== "string" && o3 !== "boolean")
            return [new Pt2(t3.key, u3, "stop domain value must be a number, string, or boolean")];
          if (o3 !== "number" && r2 !== "categorical") {
            let n3 = `number expected, ${o3} found`;
            return Rn(e2) && r2 === undefined && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Pt2(t3.key, u3, n3)];
          }
          return r2 !== "categorical" || o3 !== "number" || isFinite(l4) && Math.floor(l4) === l4 ? r2 !== "categorical" && o3 === "number" && i2 !== undefined && l4 < i2 ? [new Pt2(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l4, r2 === "categorical" && (l4 in a2) ? [new Pt2(t3.key, u3, "stop domain values must be unique")] : (a2[l4] = true, [])) : [new Pt2(t3.key, u3, `integer expected, found ${l4}`)];
        }
      }
      function Mi2(t2) {
        const e2 = (t2.expressionContext === "property" ? ii2 : ei2)(wi2(t2.value), t2.valueSpec);
        if (e2.result === "error")
          return e2.value.map((e3) => new Pt2(`${t2.key}${e3.key}`, t2.value, e3.message));
        const r2 = e2.value.expression || e2.value._styleExpression.expression;
        if (t2.expressionContext === "property" && t2.propertyKey === "text-font" && !r2.outputDefined())
          return [new Pt2(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (t2.expressionContext === "property" && t2.propertyType === "layout" && !Ln(r2))
          return [new Pt2(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (t2.expressionContext === "filter" && !Ln(r2))
          return [new Pt2(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
        if (t2.expressionContext && t2.expressionContext.indexOf("cluster") === 0) {
          if (!On(r2, ["zoom", "feature-state"]))
            return [new Pt2(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (t2.expressionContext === "cluster-initial" && !$n(r2))
            return [new Pt2(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Ii2(t2) {
        const { key: e2, value: r2 } = t2, n2 = qn(r2);
        return n2 !== "string" ? [new Pt2(e2, r2, `color expected, ${n2} found`)] : ke2.parse(String(r2)) ? [] : [new Pt2(e2, r2, `color expected, "${r2}" found`)];
      }
      function zi2(t2) {
        const { key: e2, value: r2, valueSpec: n2 } = t2, i2 = [];
        return Array.isArray(n2.values) ? n2.values.indexOf(bi2(r2)) === -1 && i2.push(new Pt2(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : Object.keys(n2.values).indexOf(bi2(r2)) === -1 && i2.push(new Pt2(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
      }
      function Pi2(t2) {
        return oi2(wi2(t2.value)) ? Mi2(Ct({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Ci2(t2);
      }
      function Ci2(t2) {
        const { value: e2, key: r2 } = t2;
        if (qn(e2) !== "array")
          return [new Pt2(r2, e2, `array expected, ${qn(e2)} found`)];
        const n2 = t2.styleSpec;
        let i2, s2 = [];
        if (e2.length < 1)
          return [new Pt2(r2, e2, "filter array must have at least 1 element")];
        switch (s2 = s2.concat(zi2({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), bi2(e2[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e2.length >= 2 && bi2(e2[1]) === "$type" && s2.push(new Pt2(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
          case "==":
          case "!=":
            e2.length !== 3 && s2.push(new Pt2(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e2.length >= 2 && (i2 = qn(e2[1]), i2 !== "string" && s2.push(new Pt2(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
            for (let a2 = 2;a2 < e2.length; a2++)
              i2 = qn(e2[a2]), bi2(e2[1]) === "$type" ? s2 = s2.concat(zi2({ key: `${r2}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : i2 !== "string" && i2 !== "number" && i2 !== "boolean" && s2.push(new Pt2(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let n3 = 1;n3 < e2.length; n3++)
              s2 = s2.concat(Ci2({ key: `${r2}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
            break;
          case "has":
          case "!has":
            i2 = qn(e2[1]), e2.length !== 2 ? s2.push(new Pt2(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "string" && s2.push(new Pt2(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
        }
        return s2;
      }
      function Bi2(t2, e2) {
        const { key: r2, validateSpec: n2, style: i2, styleSpec: s2, value: a2, objectKey: o2 } = t2, l3 = s2[`${e2}_${t2.layerType}`];
        if (!l3)
          return [];
        const u2 = o2.match(/^(.*)-transition$/);
        if (e2 === "paint" && u2 && l3[u2[1]] && l3[u2[1]].transition)
          return n2({ key: r2, value: a2, valueSpec: s2.transition, style: i2, styleSpec: s2 });
        const c2 = t2.valueSpec || l3[o2];
        if (!c2)
          return [new Pt2(r2, a2, `unknown property "${o2}"`)];
        let h2;
        if (qn(a2) === "string" && Rn(c2) && !c2.tokens && (h2 = /^{([^}]+)}$/.exec(a2)))
          return [new Pt2(r2, a2, `"${o2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h2[1])} }\`.`)];
        const p2 = [];
        return t2.layerType === "symbol" && (o2 === "text-field" && i2 && !i2.glyphs && p2.push(new Pt2(r2, a2, 'use of "text-field" requires a style "glyphs" property')), o2 === "text-font" && Gn(wi2(a2)) && bi2(a2.type) === "identity" && p2.push(new Pt2(r2, a2, '"text-font" does not support identity functions'))), p2.concat(n2({ key: t2.key, value: a2, valueSpec: c2, style: i2, styleSpec: s2, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
      }
      function Vi2(t2) {
        return Bi2(t2, "paint");
      }
      function Ei2(t2) {
        return Bi2(t2, "layout");
      }
      function Ti2(t2) {
        let e2 = [];
        const { value: r2, key: n2, style: i2, styleSpec: s2 } = t2;
        if (qn(r2) !== "object")
          return [new Pt2(n2, r2, `object expected, ${qn(r2)} found`)];
        r2.type || r2.ref || e2.push(new Pt2(n2, r2, 'either "type" or "ref" is required'));
        let a2 = bi2(r2.type);
        const o2 = bi2(r2.ref);
        if (r2.id) {
          const s3 = bi2(r2.id);
          for (let a3 = 0;a3 < t2.arrayIndex; a3++) {
            const t3 = i2.layers[a3];
            bi2(t3.id) === s3 && e2.push(new Pt2(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
          }
        }
        if ("ref" in r2) {
          let t3;
          ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
            t4 in r2 && e2.push(new Pt2(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
          }), i2.layers.forEach((e3) => {
            bi2(e3.id) === o2 && (t3 = e3);
          }), t3 ? t3.ref ? e2.push(new Pt2(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = bi2(t3.type) : e2.push(new Pt2(n2, r2.ref, `ref layer "${o2}" not found`));
        } else if (a2 !== "background")
          if (r2.source) {
            const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && bi2(t3.type);
            t3 ? s3 === "vector" && a2 === "raster" ? e2.push(new Pt2(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : s3 !== "raster-dem" && a2 === "hillshade" ? e2.push(new Pt2(n2, r2.source, `layer "${r2.id}" requires a raster-dem source`)) : s3 === "raster" && a2 !== "raster" ? e2.push(new Pt2(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : s3 !== "vector" || r2["source-layer"] ? s3 === "raster-dem" && a2 !== "hillshade" ? e2.push(new Pt2(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a2 !== "line" || !r2.paint || !r2.paint["line-gradient"] || s3 === "geojson" && t3.lineMetrics || e2.push(new Pt2(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new Pt2(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new Pt2(n2, r2.source, `source "${r2.source}" not found`));
          } else
            e2.push(new Pt2(n2, r2, 'missing required property "source"'));
        return e2 = e2.concat(_i2({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, objectElementValidators: { "*": () => [], type: () => t2.validateSpec({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, object: r2, objectKey: "type" }), filter: Pi2, layout: (t3) => _i2({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => Ei2(Ct({ layerType: a2 }, t4)) } }), paint: (t3) => _i2({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => Vi2(Ct({ layerType: a2 }, t4)) } }) } })), e2;
      }
      function Fi2(t2) {
        const { value: e2, key: r2 } = t2, n2 = qn(e2);
        return n2 !== "string" ? [new Pt2(r2, e2, `string expected, ${n2} found`)] : [];
      }
      const $i2 = { promoteId: function({ key: t2, value: e2 }) {
        if (qn(e2) === "string")
          return Fi2({ key: t2, value: e2 });
        {
          const r2 = [];
          for (const n2 in e2)
            r2.push(...Fi2({ key: `${t2}.${n2}`, value: e2[n2] }));
          return r2;
        }
      } };
      function Li2(t2) {
        const { value: e2, key: r2, styleSpec: n2, style: i2, validateSpec: s2 } = t2;
        if (!e2.type)
          return [new Pt2(r2, e2, '"type" is required')];
        const a2 = bi2(e2.type);
        let o2;
        switch (a2) {
          case "vector":
          case "raster":
            return o2 = _i2({ key: r2, value: e2, valueSpec: n2[`source_${a2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: $i2, validateSpec: s2 }), o2;
          case "raster-dem":
            return o2 = function(t3) {
              var e3;
              const r3 = (e3 = t3.sourceName) !== null && e3 !== undefined ? e3 : "", n3 = t3.value, i3 = t3.styleSpec, s3 = i3.source_raster_dem, a3 = t3.style;
              let o3 = [];
              const l3 = qn(n3);
              if (n3 === undefined)
                return o3;
              if (l3 !== "object")
                return o3.push(new Pt2("source_raster_dem", n3, `object expected, ${l3} found`)), o3;
              const u2 = bi2(n3.encoding) === "custom", c2 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h2 = t3.value.encoding ? `"${t3.value.encoding}"` : "Default";
              for (const e4 in n3)
                !u2 && c2.includes(e4) ? o3.push(new Pt2(e4, n3[e4], `In "${r3}": "${e4}" is only valid when "encoding" is set to "custom". ${h2} encoding found`)) : s3[e4] ? o3 = o3.concat(t3.validateSpec({ key: e4, value: n3[e4], valueSpec: s3[e4], validateSpec: t3.validateSpec, style: a3, styleSpec: i3 })) : o3.push(new Pt2(e4, n3[e4], `unknown property "${e4}"`));
              return o3;
            }({ sourceName: r2, value: e2, style: t2.style, styleSpec: n2, validateSpec: s2 }), o2;
          case "geojson":
            if (o2 = _i2({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, validateSpec: s2, objectElementValidators: $i2 }), e2.cluster)
              for (const t3 in e2.clusterProperties) {
                const [n3, i3] = e2.clusterProperties[t3], s3 = typeof n3 == "string" ? [n3, ["accumulated"], ["get", t3]] : n3;
                o2.push(...Mi2({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), o2.push(...Mi2({ key: `${r2}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
              }
            return o2;
          case "video":
            return _i2({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, validateSpec: s2, styleSpec: n2 });
          case "image":
            return _i2({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, validateSpec: s2, styleSpec: n2 });
          case "canvas":
            return [new Pt2(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return zi2({ key: `${r2}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
        }
      }
      function Oi2(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.light, i2 = t2.style;
        let s2 = [];
        const a2 = qn(e2);
        if (e2 === undefined)
          return s2;
        if (a2 !== "object")
          return s2 = s2.concat([new Pt2("light", e2, `object expected, ${a2} found`)]), s2;
        for (const a3 in e2) {
          const o2 = a3.match(/^(.*)-transition$/);
          s2 = s2.concat(o2 && n2[o2[1]] && n2[o2[1]].transition ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: r2.transition, validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new Pt2(a3, e2[a3], `unknown property "${a3}"`)]);
        }
        return s2;
      }
      function Di2(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.sky, i2 = t2.style, s2 = qn(e2);
        if (e2 === undefined)
          return [];
        if (s2 !== "object")
          return [new Pt2("sky", e2, `object expected, ${s2} found`)];
        let a2 = [];
        for (const s3 in e2)
          a2 = a2.concat(n2[s3] ? t2.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new Pt2(s3, e2[s3], `unknown property "${s3}"`)]);
        return a2;
      }
      function ji2(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.terrain, i2 = t2.style;
        let s2 = [];
        const a2 = qn(e2);
        if (e2 === undefined)
          return s2;
        if (a2 !== "object")
          return s2 = s2.concat([new Pt2("terrain", e2, `object expected, ${a2} found`)]), s2;
        for (const a3 in e2)
          s2 = s2.concat(n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new Pt2(a3, e2[a3], `unknown property "${a3}"`)]);
        return s2;
      }
      function Ri2(t2) {
        let e2 = [];
        const { value: r2, key: n2 } = t2;
        if (Array.isArray(r2)) {
          const i2 = [], s2 = [];
          for (const a2 in r2)
            r2[a2].id && i2.includes(r2[a2].id) && e2.push(new Pt2(n2, r2, `all the sprites' ids must be unique, but ${r2[a2].id} is duplicated`)), i2.push(r2[a2].id), r2[a2].url && s2.includes(r2[a2].url) && e2.push(new Pt2(n2, r2, `all the sprites' URLs must be unique, but ${r2[a2].url} is duplicated`)), s2.push(r2[a2].url), e2 = e2.concat(_i2({ key: `${n2}[${a2}]`, value: r2[a2], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t2.validateSpec }));
          return e2;
        }
        return Fi2({ key: n2, value: r2 });
      }
      function Ni2(t2) {
        return e2 = t2.value, Boolean(e2) && e2.constructor === Object ? [] : [new Pt2(t2.key, t2.value, `object expected, ${qn(t2.value)} found`)];
        var e2;
      }
      const Ui2 = { "*": () => [], array: Ai2, boolean: function(t2) {
        const { value: e2, key: r2 } = t2, n2 = qn(e2);
        return n2 !== "boolean" ? [new Pt2(r2, e2, `boolean expected, ${n2} found`)] : [];
      }, number: Si2, color: Ii2, constants: vi2, enum: zi2, filter: Pi2, function: ki2, layer: Ti2, object: _i2, source: Li2, light: Oi2, sky: Di2, terrain: ji2, projection: function(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.projection, i2 = t2.style, s2 = qn(e2);
        if (e2 === undefined)
          return [];
        if (s2 !== "object")
          return [new Pt2("projection", e2, `object expected, ${s2} found`)];
        let a2 = [];
        for (const s3 in e2)
          a2 = a2.concat(n2[s3] ? t2.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new Pt2(s3, e2[s3], `unknown property "${s3}"`)]);
        return a2;
      }, projectionDefinition: function(t2) {
        const e2 = t2.key;
        let r2 = t2.value;
        r2 = r2 instanceof String ? r2.valueOf() : r2;
        const n2 = qn(r2);
        return n2 !== "array" || function(t3) {
          return Array.isArray(t3) && t3.length === 3 && typeof t3[0] == "string" && typeof t3[1] == "string" && typeof t3[2] == "number";
        }(r2) || function(t3) {
          return !!["interpolate", "step", "literal"].includes(t3[0]);
        }(r2) ? ["array", "string"].includes(n2) ? [] : [new Pt2(e2, r2, `projection expected, invalid type "${n2}" found`)] : [new Pt2(e2, r2, `projection expected, invalid array ${JSON.stringify(r2)} found`)];
      }, string: Fi2, formatted: function(t2) {
        return Fi2(t2).length === 0 ? [] : Mi2(t2);
      }, resolvedImage: function(t2) {
        return Fi2(t2).length === 0 ? [] : Mi2(t2);
      }, padding: function(t2) {
        const { key: e2, value: r2 } = t2;
        if (qn(r2) === "array") {
          if (r2.length < 1 || r2.length > 4)
            return [new Pt2(e2, r2, `padding requires 1 to 4 values; ${r2.length} values found`)];
          const n2 = { type: "number" };
          let i2 = [];
          for (let s2 = 0;s2 < r2.length; s2++)
            i2 = i2.concat(t2.validateSpec({ key: `${e2}[${s2}]`, value: r2[s2], validateSpec: t2.validateSpec, valueSpec: n2 }));
          return i2;
        }
        return Si2({ key: e2, value: r2, valueSpec: {} });
      }, numberArray: function(t2) {
        const { key: e2, value: r2 } = t2;
        if (qn(r2) === "array") {
          const n2 = { type: "number" };
          if (r2.length < 1)
            return [new Pt2(e2, r2, "array length at least 1 expected, length 0 found")];
          let i2 = [];
          for (let s2 = 0;s2 < r2.length; s2++)
            i2 = i2.concat(t2.validateSpec({ key: `${e2}[${s2}]`, value: r2[s2], validateSpec: t2.validateSpec, valueSpec: n2 }));
          return i2;
        }
        return Si2({ key: e2, value: r2, valueSpec: {} });
      }, colorArray: function(t2) {
        const { key: e2, value: r2 } = t2;
        if (qn(r2) === "array") {
          if (r2.length < 1)
            return [new Pt2(e2, r2, "array length at least 1 expected, length 0 found")];
          let t3 = [];
          for (let n2 = 0;n2 < r2.length; n2++)
            t3 = t3.concat(Ii2({ key: `${e2}[${n2}]`, value: r2[n2] }));
          return t3;
        }
        return Ii2({ key: e2, value: r2 });
      }, variableAnchorOffsetCollection: function(t2) {
        const { key: e2, value: r2 } = t2, n2 = qn(r2), i2 = t2.styleSpec;
        if (n2 !== "array" || r2.length < 1 || r2.length % 2 != 0)
          return [new Pt2(e2, r2, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let s2 = [];
        for (let n3 = 0;n3 < r2.length; n3 += 2)
          s2 = s2.concat(zi2({ key: `${e2}[${n3}]`, value: r2[n3], valueSpec: i2.layout_symbol["text-anchor"] })), s2 = s2.concat(Ai2({ key: `${e2}[${n3 + 1}]`, value: r2[n3 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t2.validateSpec, style: t2.style, styleSpec: i2 }));
        return s2;
      }, sprite: Ri2, state: Ni2 };
      function qi2(t2) {
        const { value: e2, valueSpec: r2, styleSpec: n2 } = t2;
        return t2.validateSpec = qi2, r2.expression && Gn(bi2(e2)) ? ki2(t2) : r2.expression && ti2(wi2(e2)) ? Mi2(t2) : r2.type && Ui2[r2.type] ? Ui2[r2.type](t2) : _i2(Ct({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
      }
      function Gi2(t2) {
        const { value: e2, key: r2 } = t2, n2 = Fi2(t2);
        return n2.length || (e2.indexOf("{fontstack}") === -1 && n2.push(new Pt2(r2, e2, '"glyphs" url must include a "{fontstack}" token')), e2.indexOf("{range}") === -1 && n2.push(new Pt2(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
      }
      function Zi2(t2, e2 = gt2) {
        let r2 = [];
        return r2 = r2.concat(qi2({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, validateSpec: qi2, objectElementValidators: { glyphs: Gi2, "*": () => [] } })), t2.constants && (r2 = r2.concat(vi2({ key: "constants", value: t2.constants }))), Xi2(r2);
      }
      function Ki2(t2) {
        return function(e2) {
          return t2({ ...e2, validateSpec: qi2 });
        };
      }
      function Xi2(t2) {
        return [].concat(t2).sort((t3, e2) => t3.line - e2.line);
      }
      function Hi2(t2) {
        return function(...e2) {
          return Xi2(t2.apply(this, e2));
        };
      }
      Zi2.source = Hi2(Ki2(Li2)), Zi2.sprite = Hi2(Ki2(Ri2)), Zi2.glyphs = Hi2(Ki2(Gi2)), Zi2.light = Hi2(Ki2(Oi2)), Zi2.sky = Hi2(Ki2(Di2)), Zi2.terrain = Hi2(Ki2(ji2)), Zi2.state = Hi2(Ki2(Ni2)), Zi2.layer = Hi2(Ki2(Ti2)), Zi2.filter = Hi2(Ki2(Pi2)), Zi2.paintProperty = Hi2(Ki2(Vi2)), Zi2.layoutProperty = Hi2(Ki2(Ei2));
      const Yi2 = Zi2, Ji2 = Yi2.light, Wi2 = Yi2.sky, Qi2 = Yi2.paintProperty, ts = Yi2.layoutProperty;
      function es(t2, e2) {
        let r2 = false;
        if (e2 && e2.length)
          for (const n2 of e2)
            t2.fire(new yt2(new Error(n2.message))), r2 = true;
        return r2;
      }

      class rs {
        constructor(t2, e2, r2) {
          const n2 = this.cells = [];
          if (t2 instanceof ArrayBuffer) {
            this.arrayBuffer = t2;
            const i3 = new Int32Array(this.arrayBuffer);
            t2 = i3[0], this.d = (e2 = i3[1]) + 2 * (r2 = i3[2]);
            for (let t3 = 0;t3 < this.d * this.d; t3++) {
              const e3 = i3[3 + t3], r3 = i3[3 + t3 + 1];
              n2.push(e3 === r3 ? null : i3.subarray(e3, r3));
            }
            const s2 = i3[3 + n2.length + 1];
            this.keys = i3.subarray(i3[3 + n2.length], s2), this.bboxes = i3.subarray(s2), this.insert = this._insertReadonly;
          } else {
            this.d = e2 + 2 * r2;
            for (let t3 = 0;t3 < this.d * this.d; t3++)
              n2.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
          const i2 = r2 / e2 * t2;
          this.min = -i2, this.max = t2 + i2;
        }
        insert(t2, e2, r2, n2, i2) {
          this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++, undefined, undefined), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(t2, e2, r2, n2, i2, s2) {
          this.cells[i2].push(s2);
        }
        query(t2, e2, r2, n2, i2) {
          const s2 = this.min, a2 = this.max;
          if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
            return Array.prototype.slice.call(this.keys);
          {
            const s3 = [];
            return this._forEachCell(t2, e2, r2, n2, this._queryCell, s3, {}, i2), s3;
          }
        }
        _queryCell(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l3 = this.cells[i2];
          if (l3 !== null) {
            const i3 = this.keys, u2 = this.bboxes;
            for (let c2 = 0;c2 < l3.length; c2++) {
              const h2 = l3[c2];
              if (a2[h2] === undefined) {
                const l4 = 4 * h2;
                (o2 ? o2(u2[l4 + 0], u2[l4 + 1], u2[l4 + 2], u2[l4 + 3]) : t2 <= u2[l4 + 2] && e2 <= u2[l4 + 3] && r2 >= u2[l4 + 0] && n2 >= u2[l4 + 1]) ? (a2[h2] = true, s2.push(i3[h2])) : a2[h2] = false;
              }
            }
          }
        }
        _forEachCell(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l3 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
          for (let p2 = l3;p2 <= c2; p2++)
            for (let l4 = u2;l4 <= h2; l4++) {
              const u3 = this.d * l4 + p2;
              if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l4), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l4 + 1))) && i2.call(this, t2, e2, r2, n2, u3, s2, a2, o2))
                return;
            }
        }
        _convertFromCellCoord(t2) {
          return (t2 - this.padding) / this.scale;
        }
        _convertToCellCoord(t2) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          const t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
          let r2 = 0;
          for (let t3 = 0;t3 < this.cells.length; t3++)
            r2 += this.cells[t3].length;
          const n2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
          n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
          let i2 = e2;
          for (let e3 = 0;e3 < t2.length; e3++) {
            const r3 = t2[e3];
            n2[3 + e3] = i2, n2.set(r3, i2), i2 += r3.length;
          }
          return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
        }
        static serialize(t2, e2) {
          const r2 = t2.toArrayBuffer();
          return e2 && e2.push(r2), { buffer: r2 };
        }
        static deserialize(t2) {
          return new rs(t2.buffer);
        }
      }
      const ns = {};
      function is(t2, e2, r2 = {}) {
        if (ns[t2])
          throw new Error(`${t2} is already registered.`);
        Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), ns[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
      }
      is("Object", Object), is("TransferableGridIndex", rs), is("Color", ke2), is("Error", Error), is("AJAXError", lt2), is("ResolvedImage", $e2), is("StylePropertyFunction", si2), is("StyleExpression", Qn, { omit: ["_evaluator"] }), is("ZoomDependentExpression", ni2), is("ZoomConstantExpression", ri2), is("CompoundExpression", Cn, { omit: ["_evaluate"] });
      for (const t2 in Pn)
        Pn[t2]._classRegistryKey || is(`Expression_${t2}`, Pn[t2]);
      function ss(t2) {
        return t2 && typeof ArrayBuffer != "undefined" && (t2 instanceof ArrayBuffer || t2.constructor && t2.constructor.name === "ArrayBuffer");
      }
      function as(t2) {
        return t2.$name || t2.constructor._classRegistryKey;
      }
      function os(t2) {
        return !function(t3) {
          if (t3 === null || typeof t3 != "object")
            return false;
          const e2 = as(t3);
          return !(!e2 || e2 === "Object");
        }(t2) && (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || t2 instanceof Error || ss(t2) || K(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData);
      }
      function ls(t2, e2) {
        if (os(t2))
          return (ss(t2) || K(t2)) && e2 && e2.push(t2), ArrayBuffer.isView(t2) && e2 && e2.push(t2.buffer), t2 instanceof ImageData && e2 && e2.push(t2.data.buffer), t2;
        if (Array.isArray(t2)) {
          const r3 = [];
          for (const n3 of t2)
            r3.push(ls(n3, e2));
          return r3;
        }
        if (typeof t2 != "object")
          throw new Error("can't serialize object of type " + typeof t2);
        const r2 = as(t2);
        if (!r2)
          throw new Error(`can't serialize object of unregistered class ${t2.constructor.name}`);
        if (!ns[r2])
          throw new Error(`${r2} is not registered.`);
        const { klass: n2 } = ns[r2], i2 = n2.serialize ? n2.serialize(t2, e2) : {};
        if (n2.serialize) {
          if (e2 && i2 === e2[e2.length - 1])
            throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const n3 in t2) {
            if (!t2.hasOwnProperty(n3))
              continue;
            if (ns[r2].omit.indexOf(n3) >= 0)
              continue;
            const s2 = t2[n3];
            i2[n3] = ns[r2].shallow.indexOf(n3) >= 0 ? s2 : ls(s2, e2);
          }
          t2 instanceof Error && (i2.message = t2.message);
        }
        if (i2.$name)
          throw new Error("$name property is reserved for worker serialization logic.");
        return r2 !== "Object" && (i2.$name = r2), i2;
      }
      function us(t2) {
        if (os(t2))
          return t2;
        if (Array.isArray(t2))
          return t2.map(us);
        if (typeof t2 != "object")
          throw new Error("can't deserialize object of type " + typeof t2);
        const e2 = as(t2) || "Object";
        if (!ns[e2])
          throw new Error(`can't deserialize unregistered class ${e2}`);
        const { klass: r2 } = ns[e2];
        if (!r2)
          throw new Error(`can't deserialize unregistered class ${e2}`);
        if (r2.deserialize)
          return r2.deserialize(t2);
        const n2 = Object.create(r2.prototype);
        for (const r3 of Object.keys(t2)) {
          if (r3 === "$name")
            continue;
          const i2 = t2[r3];
          n2[r3] = ns[e2].shallow.indexOf(r3) >= 0 ? i2 : us(i2);
        }
        return n2;
      }

      class cs {
        constructor() {
          this.first = true;
        }
        update(t2, e2) {
          const r2 = Math.floor(t2);
          return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
        }
      }
      const hs = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519 };
      function ps(t2) {
        for (const e2 of t2)
          if (xs(e2.charCodeAt(0)))
            return true;
        return false;
      }
      function fs(t2) {
        for (const e2 of t2)
          if (!ms(e2.charCodeAt(0)))
            return false;
        return true;
      }
      function ds(t2) {
        const e2 = t2.map((t3) => {
          try {
            return new RegExp(`\\p{sc=${t3}}`, "u").source;
          } catch (t4) {
            return null;
          }
        }).filter((t3) => t3);
        return new RegExp(e2.join("|"), "u");
      }
      const ys = ds(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function ms(t2) {
        return !ys.test(String.fromCodePoint(t2));
      }
      const gs = ds(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
      function xs(t2) {
        return !(t2 !== 746 && t2 !== 747 && (t2 < 4352 || !(hs["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || hs["CJK Compatibility"](t2) || hs["CJK Strokes"](t2) || !(!hs["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || t2 === 12336) || hs["Enclosed CJK Letters and Months"](t2) || hs["Ideographic Description Characters"](t2) || hs.Kanbun(t2) || hs.Katakana(t2) && t2 !== 12540 || !(!hs["Halfwidth and Fullwidth Forms"](t2) || t2 === 65288 || t2 === 65289 || t2 === 65293 || t2 >= 65306 && t2 <= 65310 || t2 === 65339 || t2 === 65341 || t2 === 65343 || t2 >= 65371 && t2 <= 65503 || t2 === 65507 || t2 >= 65512 && t2 <= 65519) || !(!hs["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || hs["Vertical Forms"](t2) || hs["Yijing Hexagram Symbols"](t2) || /\p{sc=Cans}/u.test(String.fromCodePoint(t2)) || /\p{sc=Hang}/u.test(String.fromCodePoint(t2)) || gs.test(String.fromCodePoint(t2)))));
      }
      function vs(t2) {
        return !(xs(t2) || function(t3) {
          return !!(hs["Latin-1 Supplement"](t3) && (t3 === 167 || t3 === 169 || t3 === 174 || t3 === 177 || t3 === 188 || t3 === 189 || t3 === 190 || t3 === 215 || t3 === 247) || hs["General Punctuation"](t3) && (t3 === 8214 || t3 === 8224 || t3 === 8225 || t3 === 8240 || t3 === 8241 || t3 === 8251 || t3 === 8252 || t3 === 8258 || t3 === 8263 || t3 === 8264 || t3 === 8265 || t3 === 8273) || hs["Letterlike Symbols"](t3) || hs["Number Forms"](t3) || hs["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9000 || t3 === 9003 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || t3 === 9167 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || hs["Control Pictures"](t3) && t3 !== 9251 || hs["Optical Character Recognition"](t3) || hs["Enclosed Alphanumerics"](t3) || hs["Geometric Shapes"](t3) || hs["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || hs["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || hs["CJK Symbols and Punctuation"](t3) || hs.Katakana(t3) || hs["Private Use Area"](t3) || hs["CJK Compatibility Forms"](t3) || hs["Small Form Variants"](t3) || hs["Halfwidth and Fullwidth Forms"](t3) || t3 === 8734 || t3 === 8756 || t3 === 8757 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || t3 === 65532 || t3 === 65533);
        }(t2));
      }
      const bs = ds(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
      function ws(t2) {
        return bs.test(String.fromCodePoint(t2));
      }
      function _s(t2, e2) {
        return !(!e2 && ws(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || hs.Khmer(t2));
      }
      function As(t2) {
        for (const e2 of t2)
          if (ws(e2.charCodeAt(0)))
            return true;
        return false;
      }
      const Ss = new class {
        constructor() {
          this.TIMEOUT = 5000, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
          };
        }
        setState(t2) {
          this.pluginStatus = t2.pluginStatus, this.pluginURL = t2.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(t2) {
          if (Ss.isParsed())
            throw new Error("RTL text plugin already registered.");
          this.applyArabicShaping = t2.applyArabicShaping, this.processBidirectionalText = t2.processBidirectionalText, this.processStyledBidirectionalText = t2.processStyledBidirectionalText, this.loadScriptResolve();
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
        syncState(t2, r2) {
          return e(this, undefined, undefined, function* () {
            if (this.isParsed())
              return this.getState();
            if (t2.pluginStatus !== "loading")
              return this.setState(t2), t2;
            const e2 = t2.pluginURL, n2 = new Promise((t3) => {
              this.loadScriptResolve = t3;
            });
            r2(e2);
            const i2 = new Promise((t3) => setTimeout(() => t3(), this.TIMEOUT));
            if (yield Promise.race([n2, i2]), this.isParsed()) {
              const t3 = { pluginStatus: "loaded", pluginURL: e2 };
              return this.setState(t3), t3;
            }
            throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${e2}`);
          });
        }
      };

      class ks {
        constructor(t2, e2) {
          this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new cs, this.transition = {});
        }
        isSupportedScript(t2) {
          return function(t3, e2) {
            for (const r2 of t3)
              if (!_s(r2.charCodeAt(0), e2))
                return false;
            return true;
          }(t2, Ss.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
          return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
        }
      }

      class Ms {
        constructor(t2, e2) {
          this.property = t2, this.value = e2, this.expression = function(t3, e3) {
            if (Gn(t3))
              return new si2(t3, e3);
            if (ti2(t3)) {
              const r2 = ii2(t3, e3);
              if (r2.result === "error")
                throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              return r2.value;
            }
            {
              let r2 = t3;
              return e3.type === "color" && typeof t3 == "string" ? r2 = ke2.parse(t3) : e3.type !== "padding" || typeof t3 != "number" && !Array.isArray(t3) ? e3.type !== "numberArray" || typeof t3 != "number" && !Array.isArray(t3) ? e3.type !== "colorArray" || typeof t3 != "string" && !Array.isArray(t3) ? e3.type === "variableAnchorOffsetCollection" && Array.isArray(t3) ? r2 = Fe2.parse(t3) : e3.type === "projectionDefinition" && typeof t3 == "string" && (r2 = Le2.parse(t3)) : r2 = Ve2.parse(t3) : r2 = Be2.parse(t3) : r2 = Ce2.parse(t3), { kind: "constant", evaluate: () => r2 };
            }
          }(e2 === undefined ? t2.specification.default : e2, t2.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(t2, e2, r2) {
          return this.property.possiblyEvaluate(this, t2, e2, r2);
        }
      }

      class Is {
        constructor(t2) {
          this.property = t2, this.value = new Ms(t2, undefined);
        }
        transitioned(t2, e2) {
          return new Ps(this.property, this.value, e2, L({}, t2.transition, this.transition), t2.now);
        }
        untransitioned() {
          return new Ps(this.property, this.value, null, {}, 0);
        }
      }

      class zs {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
        }
        getValue(t2) {
          return R(this._values[t2].value.value);
        }
        setValue(t2, e2) {
          Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Is(this._values[t2].property)), this._values[t2].value = new Ms(this._values[t2].property, e2 === null ? undefined : R(e2));
        }
        getTransition(t2) {
          return R(this._values[t2].transition);
        }
        setTransition(t2, e2) {
          Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Is(this._values[t2].property)), this._values[t2].transition = R(e2) || undefined;
        }
        serialize() {
          const t2 = {};
          for (const e2 of Object.keys(this._values)) {
            const r2 = this.getValue(e2);
            r2 !== undefined && (t2[e2] = r2);
            const n2 = this.getTransition(e2);
            n2 !== undefined && (t2[`${e2}-transition`] = n2);
          }
          return t2;
        }
        transitioned(t2, e2) {
          const r2 = new Cs(this._properties);
          for (const n2 of Object.keys(this._values))
            r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
          return r2;
        }
        untransitioned() {
          const t2 = new Cs(this._properties);
          for (const e2 of Object.keys(this._values))
            t2._values[e2] = this._values[e2].untransitioned();
          return t2;
        }
      }

      class Ps {
        constructor(t2, e2, r2, n2, i2) {
          this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
          if (s2) {
            if (n2 > this.end)
              return this.prior = null, i2;
            if (this.value.isDataDriven())
              return this.prior = null, i2;
            if (n2 < this.begin)
              return s2.possiblyEvaluate(t2, e2, r2);
            {
              const a2 = (n2 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, V(a2));
            }
          }
          return i2;
        }
      }

      class Cs {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = new Es(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
          return n2;
        }
        hasTransition() {
          for (const t2 of Object.keys(this._values))
            if (this._values[t2].prior)
              return true;
          return false;
        }
      }

      class Bs {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
        }
        hasValue(t2) {
          return this._values[t2].value !== undefined;
        }
        getValue(t2) {
          return R(this._values[t2].value);
        }
        setValue(t2, e2) {
          this._values[t2] = new Ms(this._values[t2].property, e2 === null ? undefined : R(e2));
        }
        serialize() {
          const t2 = {};
          for (const e2 of Object.keys(this._values)) {
            const r2 = this.getValue(e2);
            r2 !== undefined && (t2[e2] = r2);
          }
          return t2;
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = new Es(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
          return n2;
        }
      }

      class Vs {
        constructor(t2, e2, r2) {
          this.property = t2, this.value = e2, this.parameters = r2;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(t2) {
          return this.value.kind === "constant" ? this.value.value : t2;
        }
        evaluate(t2, e2, r2, n2) {
          return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
        }
      }

      class Es {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
        }
        get(t2) {
          return this._values[t2];
        }
      }

      class Ts {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2) {
          if (t2.isDataDriven())
            throw new Error("Value should not be data driven");
          return t2.expression.evaluate(e2);
        }
        interpolate(t2, e2, r2) {
          const n2 = fr2[this.specification.type];
          return n2 ? n2(t2, e2, r2) : t2;
        }
      }

      class Fs {
        constructor(t2, e2) {
          this.specification = t2, this.overrides = e2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          return new Vs(this, t2.expression.kind === "constant" || t2.expression.kind === "camera" ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
        }
        interpolate(t2, e2, r2) {
          if (t2.value.kind !== "constant" || e2.value.kind !== "constant")
            return t2;
          if (t2.value.value === undefined || e2.value.value === undefined)
            return new Vs(this, { kind: "constant", value: undefined }, t2.parameters);
          const n2 = fr2[this.specification.type];
          if (n2) {
            const i2 = n2(t2.value.value, e2.value.value, r2);
            return new Vs(this, { kind: "constant", value: i2 }, t2.parameters);
          }
          return t2;
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return t2.kind === "constant" ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
        }
      }

      class $s extends Fs {
        possiblyEvaluate(t2, e2, r2, n2) {
          if (t2.value === undefined)
            return new Vs(this, { kind: "constant", value: undefined }, e2);
          if (t2.expression.kind === "constant") {
            const i2 = t2.expression.evaluate(e2, null, {}, r2, n2), s2 = t2.property.specification.type === "resolvedImage" && typeof i2 != "string" ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
            return new Vs(this, { kind: "constant", value: a2 }, e2);
          }
          if (t2.expression.kind === "camera") {
            const r3 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
            return new Vs(this, { kind: "constant", value: r3 }, e2);
          }
          return new Vs(this, t2.expression, e2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          if (t2.kind === "source") {
            const a2 = t2.evaluate(e2, r2, n2, i2, s2);
            return this._calculate(a2, a2, a2, e2);
          }
          return t2.kind === "composite" ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t2.value;
        }
        _calculate(t2, e2, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
        }
        interpolate(t2) {
          return t2;
        }
      }

      class Ls {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          if (t2.value !== undefined) {
            if (t2.expression.kind === "constant") {
              const i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
              return this._calculate(i2, i2, i2, e2);
            }
            return this._calculate(t2.expression.evaluate(new ks(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new ks(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new ks(Math.floor(e2.zoom + 1), e2)), e2);
          }
        }
        _calculate(t2, e2, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
        }
        interpolate(t2) {
          return t2;
        }
      }

      class Os {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          return !!t2.expression.evaluate(e2, null, {}, r2, n2);
        }
        interpolate() {
          return false;
        }
      }

      class Ds {
        constructor(t2) {
          this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const e2 in t2) {
            const r2 = t2[e2];
            r2.specification.overridable && this.overridableProperties.push(e2);
            const n2 = this.defaultPropertyValues[e2] = new Ms(r2, undefined), i2 = this.defaultTransitionablePropertyValues[e2] = new Is(r2);
            this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
          }
        }
      }
      is("DataDrivenProperty", Fs), is("DataConstantProperty", Ts), is("CrossFadedDataDrivenProperty", $s), is("CrossFadedProperty", Ls), is("ColorRampProperty", Os);
      const js = "-transition";

      class Rs extends mt2 {
        constructor(t2, e2) {
          if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, t2.type !== "custom" && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, t2.type !== "background" && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new Bs(e2.layout)), e2.paint)) {
            this._transitionablePaint = new zs(e2.paint);
            for (const e3 in t2.paint)
              this.setPaintProperty(e3, t2.paint[e3], { validate: false });
            for (const e3 in t2.layout)
              this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Es(e2.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t2) {
          return t2 === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t2);
        }
        setLayoutProperty(t2, e2, r2 = {}) {
          e2 != null && this._validate(ts, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || (t2 !== "visibility" ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
        }
        getPaintProperty(t2) {
          return t2.endsWith(js) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
        }
        setPaintProperty(t2, e2, r2 = {}) {
          if (e2 != null && this._validate(Qi2, `layers.${this.id}.paint.${t2}`, t2, e2, r2))
            return false;
          if (t2.endsWith(js))
            return this._transitionablePaint.setTransition(t2.slice(0, -11), e2 || undefined), false;
          {
            const r3 = this._transitionablePaint._values[t2], n2 = r3.property.specification["property-type"] === "cross-faded-data-driven", i2 = r3.value.isDataDriven(), s2 = r3.value;
            this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
            const a2 = this._transitionablePaint._values[t2].value;
            return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
          }
        }
        _handleSpecialPaintPropertyUpdate(t2) {
        }
        _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
          return false;
        }
        isHidden(t2) {
          return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(t2) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t2, e2) {
          t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, undefined, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, undefined, e2);
        }
        serialize() {
          const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), j2(t2, (t3, e2) => !(t3 === undefined || e2 === "layout" && !Object.keys(t3).length || e2 === "paint" && !Object.keys(t3).length));
        }
        _validate(t2, e2, r2, n2, i2 = {}) {
          return (!i2 || i2.validate !== false) && es(this, t2.call(Yi2, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: gt2, style: { glyphs: true, sprite: true } }));
        }
        is3D() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        resize() {
        }
        isStateDependent() {
          for (const t2 in this.paint._values) {
            const e2 = this.paint.get(t2);
            if (e2 instanceof Vs && Rn(e2.property.specification) && (e2.value.kind === "source" || e2.value.kind === "composite") && e2.value.isStateDependent)
              return true;
          }
          return false;
        }
      }
      const Ns = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };

      class Us {
        constructor(t2, e2) {
          this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }

      class qs {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(t2, e2) {
          return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
        }
        static deserialize(t2) {
          const e2 = Object.create(this.prototype);
          return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t2) {
          this.reserve(t2), this.length = t2;
        }
        reserve(t2) {
          if (t2 > this.capacity) {
            this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const e2 = this.uint8;
            this._refreshViews(), e2 && this.uint8.set(e2);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function Gs(t2, e2 = 1) {
        let r2 = 0, n2 = 0;
        return { members: t2.map((t3) => {
          const i2 = Ns[t3.type].BYTES_PER_ELEMENT, s2 = r2 = Zs(r2, Math.max(e2, i2)), a2 = t3.components || 1;
          return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
        }), size: Zs(r2, Math.max(n2, e2)), alignment: e2 };
      }
      function Zs(t2, e2) {
        return Math.ceil(t2 / e2) * e2;
      }

      class Ks extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
        }
      }
      Ks.prototype.bytesPerElement = 4, is("StructArrayLayout2i4", Ks);

      class Xs extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
        }
      }
      Xs.prototype.bytesPerElement = 6, is("StructArrayLayout3i6", Xs);

      class Hs extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
        }
      }
      Hs.prototype.bytesPerElement = 8, is("StructArrayLayout4i8", Hs);

      class Ys extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 6 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
        }
      }
      Ys.prototype.bytesPerElement = 12, is("StructArrayLayout2i4i12", Ys);

      class Js extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 4 * t2, l3 = 8 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.uint8[l3 + 4] = n2, this.uint8[l3 + 5] = i2, this.uint8[l3 + 6] = s2, this.uint8[l3 + 7] = a2, t2;
        }
      }
      Js.prototype.bytesPerElement = 8, is("StructArrayLayout2i4ub8", Js);

      class Ws extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
        }
      }
      Ws.prototype.bytesPerElement = 8, is("StructArrayLayout2f8", Ws);

      class Qs extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2) {
          const c2 = this.length;
          return this.resize(c2 + 1), this.emplace(c2, t2, e2, r2, n2, i2, s2, a2, o2, l3, u2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2) {
          const h2 = 10 * t2;
          return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = a2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l3, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
        }
      }
      Qs.prototype.bytesPerElement = 20, is("StructArrayLayout10ui20", Qs);

      class ta extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2) {
          const p2 = this.length;
          return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2) {
          const f2 = 12 * t2;
          return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l3, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
        }
      }
      ta.prototype.bytesPerElement = 24, is("StructArrayLayout4i4ui4i24", ta);

      class ea extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
        }
      }
      ea.prototype.bytesPerElement = 12, is("StructArrayLayout3f12", ea);

      class ra extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.uint32[1 * t2 + 0] = e2, t2;
        }
      }
      ra.prototype.bytesPerElement = 4, is("StructArrayLayout1ul4", ra);

      class na extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l3) {
          const u2 = this.length;
          return this.resize(u2 + 1), this.emplace(u2, t2, e2, r2, n2, i2, s2, a2, o2, l3);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2) {
          const c2 = 10 * t2, h2 = 5 * t2;
          return this.int16[c2 + 0] = e2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = s2, this.int16[c2 + 5] = a2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l3, this.uint16[c2 + 9] = u2, t2;
        }
      }
      na.prototype.bytesPerElement = 20, is("StructArrayLayout6i1ul2ui20", na);

      class ia extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 6 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
        }
      }
      ia.prototype.bytesPerElement = 12, is("StructArrayLayout2i2i2i12", ia);

      class sa extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
        }
        emplace(t2, e2, r2, n2, i2, s2) {
          const a2 = 4 * t2, o2 = 8 * t2;
          return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
        }
      }
      sa.prototype.bytesPerElement = 16, is("StructArrayLayout2f1f2i16", sa);

      class aa extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 16 * t2, l3 = 4 * t2, u2 = 8 * t2;
          return this.uint8[o2 + 0] = e2, this.uint8[o2 + 1] = r2, this.float32[l3 + 1] = n2, this.float32[l3 + 2] = i2, this.int16[u2 + 6] = s2, this.int16[u2 + 7] = a2, t2;
        }
      }
      aa.prototype.bytesPerElement = 16, is("StructArrayLayout2ub2f2i16", aa);

      class oa extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
        }
      }
      oa.prototype.bytesPerElement = 6, is("StructArrayLayout3ui6", oa);

      class la extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y2, m2) {
          const g2 = this.length;
          return this.resize(g2 + 1), this.emplace(g2, t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y2, m2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y2, m2, g2) {
          const x2 = 24 * t2, v2 = 12 * t2, b2 = 48 * t2;
          return this.int16[x2 + 0] = e2, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n2, this.uint16[x2 + 3] = i2, this.uint32[v2 + 2] = s2, this.uint32[v2 + 3] = a2, this.uint32[v2 + 4] = o2, this.uint16[x2 + 10] = l3, this.uint16[x2 + 11] = u2, this.uint16[x2 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y2, this.uint32[v2 + 10] = m2, this.int16[x2 + 22] = g2, t2;
        }
      }
      la.prototype.bytesPerElement = 48, is("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", la);

      class ua extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, M3, I2) {
          const z3 = this.length;
          return this.resize(z3 + 1), this.emplace(z3, t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, M3, I2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, M3, I2, z3) {
          const P2 = 32 * t2, C2 = 16 * t2;
          return this.int16[P2 + 0] = e2, this.int16[P2 + 1] = r2, this.int16[P2 + 2] = n2, this.int16[P2 + 3] = i2, this.int16[P2 + 4] = s2, this.int16[P2 + 5] = a2, this.int16[P2 + 6] = o2, this.int16[P2 + 7] = l3, this.uint16[P2 + 8] = u2, this.uint16[P2 + 9] = c2, this.uint16[P2 + 10] = h2, this.uint16[P2 + 11] = p2, this.uint16[P2 + 12] = f2, this.uint16[P2 + 13] = d2, this.uint16[P2 + 14] = y2, this.uint16[P2 + 15] = m2, this.uint16[P2 + 16] = g2, this.uint16[P2 + 17] = x2, this.uint16[P2 + 18] = v2, this.uint16[P2 + 19] = b2, this.uint16[P2 + 20] = w2, this.uint16[P2 + 21] = _2, this.uint16[P2 + 22] = A2, this.uint32[C2 + 12] = S2, this.float32[C2 + 13] = k2, this.float32[C2 + 14] = M3, this.uint16[P2 + 30] = I2, this.uint16[P2 + 31] = z3, t2;
        }
      }
      ua.prototype.bytesPerElement = 64, is("StructArrayLayout8i15ui1ul2f2ui64", ua);

      class ca extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.float32[1 * t2 + 0] = e2, t2;
        }
      }
      ca.prototype.bytesPerElement = 4, is("StructArrayLayout1f4", ca);

      class ha extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.uint16[6 * t2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
        }
      }
      ha.prototype.bytesPerElement = 12, is("StructArrayLayout1ui2f12", ha);

      class pa extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 4 * t2;
          return this.uint32[2 * t2 + 0] = e2, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
        }
      }
      pa.prototype.bytesPerElement = 8, is("StructArrayLayout1ul2ui8", pa);

      class fa extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
        }
      }
      fa.prototype.bytesPerElement = 4, is("StructArrayLayout2ui4", fa);

      class da extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.uint16[1 * t2 + 0] = e2, t2;
        }
      }
      da.prototype.bytesPerElement = 2, is("StructArrayLayout1ui2", da);

      class ya extends qs {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
        }
      }
      ya.prototype.bytesPerElement = 16, is("StructArrayLayout4f16", ya);

      class ma extends Us {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new l2(this.anchorPointX, this.anchorPointY);
        }
      }
      ma.prototype.size = 20;

      class ga extends na {
        get(t2) {
          return new ma(this, t2);
        }
      }
      is("CollisionBoxArray", ga);

      class xa extends Us {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(t2) {
          this._structArray.uint8[this._pos1 + 37] = t2;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(t2) {
          this._structArray.uint8[this._pos1 + 38] = t2;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 10] = t2;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      xa.prototype.size = 48;

      class va extends la {
        get(t2) {
          return new xa(this, t2);
        }
      }
      is("PlacedSymbolArray", va);

      class ba extends Us {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 12] = t2;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      ba.prototype.size = 64;

      class wa extends ua {
        get(t2) {
          return new ba(this, t2);
        }
      }
      is("SymbolInstanceArray", wa);

      class _a extends ca {
        getoffsetX(t2) {
          return this.float32[1 * t2 + 0];
        }
      }
      is("GlyphOffsetArray", _a);

      class Aa extends Xs {
        getx(t2) {
          return this.int16[3 * t2 + 0];
        }
        gety(t2) {
          return this.int16[3 * t2 + 1];
        }
        gettileUnitDistanceFromAnchor(t2) {
          return this.int16[3 * t2 + 2];
        }
      }
      is("SymbolLineVertexArray", Aa);

      class Sa extends Us {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      Sa.prototype.size = 12;

      class ka extends ha {
        get(t2) {
          return new Sa(this, t2);
        }
      }
      is("TextAnchorOffsetArray", ka);

      class Ma extends Us {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      Ma.prototype.size = 8;

      class Ia extends pa {
        get(t2) {
          return new Ma(this, t2);
        }
      }
      is("FeatureIndexArray", Ia);

      class za extends Ks {
      }

      class Pa extends Ks {
      }

      class Ca extends Ks {
      }

      class Ba extends Ys {
      }

      class Va extends Js {
      }

      class Ea extends Ws {
      }

      class Ta extends Qs {
      }

      class Fa extends ta {
      }

      class $a extends ea {
      }

      class La extends ra {
      }

      class Oa extends ia {
      }

      class Da extends aa {
      }

      class ja extends oa {
      }

      class Ra extends fa {
      }
      const Na = Gs([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ua } = Na;

      class qa {
        constructor(t2 = []) {
          this._forceNewSegmentOnNextPrepare = false, this.segments = t2;
        }
        prepareSegment(t2, e2, r2, n2) {
          const i2 = this.segments[this.segments.length - 1];
          return t2 > qa.MAX_VERTEX_ARRAY_LENGTH && U(`Max vertices per segment is ${qa.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${qa.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i2 || i2.vertexLength + t2 > qa.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2 ? this.createNewSegment(e2, r2, n2) : i2;
        }
        createNewSegment(t2, e2, r2) {
          const n2 = { vertexOffset: t2.length, primitiveOffset: e2.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
          return r2 !== undefined && (n2.sortKey = r2), this._forceNewSegmentOnNextPrepare = false, this.segments.push(n2), n2;
        }
        getOrCreateLatestSegment(t2, e2, r2) {
          return this.prepareSegment(0, t2, e2, r2);
        }
        forceNewSegmentOnNextPrepare() {
          this._forceNewSegmentOnNextPrepare = true;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t2 of this.segments)
            for (const e2 in t2.vaos)
              t2.vaos[e2].destroy();
        }
        static simpleSegment(t2, e2, r2, n2) {
          return new qa([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
        }
      }
      function Ga(t2, e2) {
        return 256 * (t2 = F2(Math.floor(t2), 0, 255)) + F2(Math.floor(e2), 0, 255);
      }
      qa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, is("SegmentVector", qa);
      const Za = Gs([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var Ka, Xa, Ha, Ya = { exports: {} }, Ja = { exports: {} }, Wa = { exports: {} }, Qa = function() {
        if (Ha)
          return Ya.exports;
        Ha = 1;
        var t2 = (Ka || (Ka = 1, Ja.exports = function(t3, e3) {
          var r2, n2, i2, s2, a2, o2, l3, u2;
          for (n2 = t3.length - (r2 = 3 & t3.length), i2 = e3, a2 = 3432918353, o2 = 461845907, u2 = 0;u2 < n2; )
            l3 = 255 & t3.charCodeAt(u2) | (255 & t3.charCodeAt(++u2)) << 8 | (255 & t3.charCodeAt(++u2)) << 16 | (255 & t3.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l3 = (65535 & (l3 = (l3 = (65535 & l3) * a2 + (((l3 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o2 + (((l3 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
          switch (l3 = 0, r2) {
            case 3:
              l3 ^= (255 & t3.charCodeAt(u2 + 2)) << 16;
            case 2:
              l3 ^= (255 & t3.charCodeAt(u2 + 1)) << 8;
            case 1:
              i2 ^= l3 = (65535 & (l3 = (l3 = (65535 & (l3 ^= 255 & t3.charCodeAt(u2))) * a2 + (((l3 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o2 + (((l3 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        }), Ja.exports), e2 = (Xa || (Xa = 1, Wa.exports = function(t3, e3) {
          for (var r2, n2 = t3.length, i2 = e3 ^ n2, s2 = 0;n2 >= 4; )
            r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
          switch (n2) {
            case 3:
              i2 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        }), Wa.exports);
        return Ya.exports = t2, Ya.exports.murmur3 = t2, Ya.exports.murmur2 = e2, Ya.exports;
      }(), to2 = r(Qa);

      class eo2 {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = false;
        }
        add(t2, e2, r2, n2) {
          this.ids.push(ro2(t2)), this.positions.push(e2, r2, n2);
        }
        getPositions(t2) {
          if (!this.indexed)
            throw new Error("Trying to get index, but feature positions are not indexed");
          const e2 = ro2(t2);
          let r2 = 0, n2 = this.ids.length - 1;
          for (;r2 < n2; ) {
            const t3 = r2 + n2 >> 1;
            this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
          }
          const i2 = [];
          for (;this.ids[r2] === e2; )
            i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
          return i2;
        }
        static serialize(t2, e2) {
          const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
          return no2(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
        }
        static deserialize(t2) {
          const e2 = new eo2;
          return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
        }
      }
      function ro2(t2) {
        const e2 = +t2;
        return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : to2(String(t2));
      }
      function no2(t2, e2, r2, n2) {
        for (;r2 < n2; ) {
          const i2 = t2[r2 + n2 >> 1];
          let s2 = r2 - 1, a2 = n2 + 1;
          for (;; ) {
            do {
              s2++;
            } while (t2[s2] < i2);
            do {
              a2--;
            } while (t2[a2] > i2);
            if (s2 >= a2)
              break;
            io2(t2, s2, a2), io2(e2, 3 * s2, 3 * a2), io2(e2, 3 * s2 + 1, 3 * a2 + 1), io2(e2, 3 * s2 + 2, 3 * a2 + 2);
          }
          a2 - r2 < n2 - a2 ? (no2(t2, e2, r2, a2), r2 = a2 + 1) : (no2(t2, e2, a2 + 1, n2), n2 = a2);
        }
      }
      function io2(t2, e2, r2) {
        const n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      is("FeaturePositionMap", eo2);

      class so2 {
        constructor(t2, e2) {
          this.gl = t2.gl, this.location = e2;
        }
      }

      class ao2 extends so2 {
        constructor(t2, e2) {
          super(t2, e2), this.current = 0;
        }
        set(t2) {
          this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
        }
      }

      class oo2 extends so2 {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0, 0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
        }
      }

      class lo2 extends so2 {
        constructor(t2, e2) {
          super(t2, e2), this.current = ke2.transparent;
        }
        set(t2) {
          t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
        }
      }
      const uo2 = new Float32Array(16);
      function co2(t2) {
        return [Ga(255 * t2.r, 255 * t2.g), Ga(255 * t2.b, 255 * t2.a)];
      }

      class ho2 {
        constructor(t2, e2, r2) {
          this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
        }
        setUniform(t2, e2, r2) {
          t2.set(r2.constantOr(this.value));
        }
        getBinding(t2, e2, r2) {
          return this.type === "color" ? new lo2(t2, e2) : new ao2(t2, e2);
        }
      }

      class po2 {
        constructor(t2, e2) {
          this.uniformNames = e2.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(t2, e2) {
          this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
        }
        setUniform(t2, e2, r2, n2) {
          const i2 = n2 === "u_pattern_to" ? this.patternTo : n2 === "u_pattern_from" ? this.patternFrom : n2 === "u_pixel_ratio_to" ? this.pixelRatioTo : n2 === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          i2 && t2.set(i2);
        }
        getBinding(t2, e2, r2) {
          return r2.substr(0, 9) === "u_pattern" ? new oo2(t2, e2) : new ao2(t2, e2);
        }
      }

      class fo2 {
        constructor(t2, e2, r2, n2) {
          this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r2 === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2;
        }
        populatePaintArray(t2, e2, r2, n2, i2) {
          const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new ks(0), e2, {}, n2, [], i2);
          this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2);
        }
        updatePaintArray(t2, e2, r2, n2) {
          const i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
          this._setPaintValue(t2, e2, i2);
        }
        _setPaintValue(t2, e2, r2) {
          if (this.type === "color") {
            const n2 = co2(r2);
            for (let r3 = t2;r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, n2[0], n2[1]);
          } else {
            for (let n2 = t2;n2 < e2; n2++)
              this.paintVertexArray.emplace(n2, r2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }

      class yo2 {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r2 === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2;
        }
        populatePaintArray(t2, e2, r2, n2, i2) {
          const s2 = this.expression.evaluate(new ks(this.zoom), e2, {}, n2, [], i2), a2 = this.expression.evaluate(new ks(this.zoom + 1), e2, {}, n2, [], i2), o2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, s2, a2);
        }
        updatePaintArray(t2, e2, r2, n2) {
          const i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
          this._setPaintValue(t2, e2, i2, s2);
        }
        _setPaintValue(t2, e2, r2, n2) {
          if (this.type === "color") {
            const i2 = co2(r2), s2 = co2(n2);
            for (let r3 = t2;r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
          } else {
            for (let i2 = t2;i2 < e2; i2++)
              this.paintVertexArray.emplace(i2, r2, n2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t2, e2) {
          const r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = F2(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
          t2.set(n2);
        }
        getBinding(t2, e2, r2) {
          return new ao2(t2, e2);
        }
      }

      class mo2 {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = s2, this.zoomInPaintVertexArray = new i2, this.zoomOutPaintVertexArray = new i2;
        }
        populatePaintArray(t2, e2, r2) {
          const n2 = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
        }
        updatePaintArray(t2, e2, r2, n2, i2) {
          this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
        }
        _setPaintValues(t2, e2, r2, n2) {
          if (!n2 || !r2)
            return;
          const { min: i2, mid: s2, max: a2 } = r2, o2 = n2[i2], l3 = n2[s2], u2 = n2[a2];
          if (o2 && l3 && u2)
            for (let r3 = t2;r3 < e2; r3++)
              this.zoomInPaintVertexArray.emplace(r3, l3.tl[0], l3.tl[1], l3.br[0], l3.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l3.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l3.tl[0], l3.tl[1], l3.br[0], l3.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l3.pixelRatio, u2.pixelRatio);
        }
        upload(t2) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, Za.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, Za.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }

      class go2 {
        constructor(t2, e2, r2) {
          this.binders = {}, this._buffers = [];
          const n2 = [];
          for (const i2 in t2.paint._values) {
            if (!r2(i2))
              continue;
            const s2 = t2.paint.get(i2);
            if (!(s2 instanceof Vs && Rn(s2.property.specification)))
              continue;
            const a2 = vo2(i2, t2.type), o2 = s2.value, l3 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = c2 === "cross-faded" || c2 === "cross-faded-data-driven";
            if (o2.kind === "constant")
              this.binders[i2] = h2 ? new po2(o2.value, a2) : new ho2(o2.value, a2, l3), n2.push(`/u_${i2}`);
            else if (o2.kind === "source" || h2) {
              const r3 = bo2(i2, l3, "source");
              this.binders[i2] = h2 ? new mo2(o2, l3, u2, e2, r3, t2.id) : new fo2(o2, a2, l3, r3), n2.push(`/a_${i2}`);
            } else {
              const t3 = bo2(i2, l3, "composite");
              this.binders[i2] = new yo2(o2, a2, l3, u2, e2, t3), n2.push(`/z_${i2}`);
            }
          }
          this.cacheKey = n2.sort().join("");
        }
        getMaxValue(t2) {
          const e2 = this.binders[t2];
          return e2 instanceof fo2 || e2 instanceof yo2 ? e2.maxValue : 0;
        }
        populatePaintArrays(t2, e2, r2, n2, i2) {
          for (const s2 in this.binders) {
            const a2 = this.binders[s2];
            (a2 instanceof fo2 || a2 instanceof yo2 || a2 instanceof mo2) && a2.populatePaintArray(t2, e2, r2, n2, i2);
          }
        }
        setConstantPatternPositions(t2, e2) {
          for (const r2 in this.binders) {
            const n2 = this.binders[r2];
            n2 instanceof po2 && n2.setConstantPatternPositions(t2, e2);
          }
        }
        updatePaintArrays(t2, e2, r2, n2, i2) {
          let s2 = false;
          for (const a2 in t2) {
            const o2 = e2.getPositions(a2);
            for (const e3 of o2) {
              const o3 = r2.feature(e3.index);
              for (const r3 in this.binders) {
                const l3 = this.binders[r3];
                if ((l3 instanceof fo2 || l3 instanceof yo2 || l3 instanceof mo2) && l3.expression.isStateDependent === true) {
                  const u2 = n2.paint.get(r3);
                  l3.expression = u2.value, l3.updatePaintArray(e3.start, e3.end, o3, t2[a2], i2), s2 = true;
                }
              }
            }
          }
          return s2;
        }
        defines() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            (r2 instanceof ho2 || r2 instanceof po2) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
          }
          return t2;
        }
        getBinderAttributes() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (r2 instanceof fo2 || r2 instanceof yo2)
              for (let e3 = 0;e3 < r2.paintVertexAttributes.length; e3++)
                t2.push(r2.paintVertexAttributes[e3].name);
            else if (r2 instanceof mo2)
              for (let e3 = 0;e3 < Za.members.length; e3++)
                t2.push(Za.members[e3].name);
          }
          return t2;
        }
        getBinderUniforms() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (r2 instanceof ho2 || r2 instanceof po2 || r2 instanceof yo2)
              for (const e3 of r2.uniformNames)
                t2.push(e3);
          }
          return t2;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t2, e2) {
          const r2 = [];
          for (const n2 in this.binders) {
            const i2 = this.binders[n2];
            if (i2 instanceof ho2 || i2 instanceof po2 || i2 instanceof yo2) {
              for (const s2 of i2.uniformNames)
                if (e2[s2]) {
                  const a2 = i2.getBinding(t2, e2[s2], s2);
                  r2.push({ name: s2, property: n2, binding: a2 });
                }
            }
          }
          return r2;
        }
        setUniforms(t2, e2, r2, n2) {
          for (const { name: t3, property: i2, binding: s2 } of e2)
            this.binders[i2].setUniform(s2, n2, r2.get(i2), t3);
        }
        updatePaintBuffers(t2) {
          this._buffers = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (t2 && r2 instanceof mo2) {
              const e3 = t2.fromScale === 2 ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
              e3 && this._buffers.push(e3);
            } else
              (r2 instanceof fo2 || r2 instanceof yo2) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
          }
        }
        upload(t2) {
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            (r2 instanceof fo2 || r2 instanceof yo2 || r2 instanceof mo2) && r2.upload(t2);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t2 in this.binders) {
            const e2 = this.binders[t2];
            (e2 instanceof fo2 || e2 instanceof yo2 || e2 instanceof mo2) && e2.destroy();
          }
        }
      }

      class xo2 {
        constructor(t2, e2, r2 = () => true) {
          this.programConfigurations = {};
          for (const n2 of t2)
            this.programConfigurations[n2.id] = new go2(n2, e2, r2);
          this.needsUpload = false, this._featureMap = new eo2, this._bufferOffset = 0;
        }
        populatePaintArrays(t2, e2, r2, n2, i2, s2) {
          for (const r3 in this.programConfigurations)
            this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2);
          e2.id !== undefined && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
        }
        updatePaintArrays(t2, e2, r2, n2) {
          for (const i2 of r2)
            this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
        }
        get(t2) {
          return this.programConfigurations[t2];
        }
        upload(t2) {
          if (this.needsUpload) {
            for (const e2 in this.programConfigurations)
              this.programConfigurations[e2].upload(t2);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const t2 in this.programConfigurations)
            this.programConfigurations[t2].destroy();
        }
      }
      function vo2(t2, e2) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
      }
      function bo2(t2, e2, r2) {
        const n2 = { color: { source: Ws, composite: ya }, number: { source: ca, composite: Ws } }, i2 = function(t3) {
          return { "line-pattern": { source: Ta, composite: Ta }, "fill-pattern": { source: Ta, composite: Ta }, "fill-extrusion-pattern": { source: Ta, composite: Ta } }[t3];
        }(t2);
        return i2 && i2[r2] || n2[e2][r2];
      }
      is("ConstantBinder", ho2), is("CrossFadedConstantBinder", po2), is("SourceExpressionBinder", fo2), is("CrossFadedCompositeBinder", mo2), is("CompositeExpressionBinder", yo2), is("ProgramConfiguration", go2, { omit: ["_buffers"] }), is("ProgramConfigurationSet", xo2);
      const wo2 = Math.pow(2, 14) - 1, _o2 = -wo2 - 1;
      function Ao2(t2) {
        const e2 = z2 / t2.extent, r2 = t2.loadGeometry();
        for (let t3 = 0;t3 < r2.length; t3++) {
          const n2 = r2[t3];
          for (let t4 = 0;t4 < n2.length; t4++) {
            const r3 = n2[t4], i2 = Math.round(r3.x * e2), s2 = Math.round(r3.y * e2);
            r3.x = F2(i2, _o2, wo2), r3.y = F2(s2, _o2, wo2), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && U("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return r2;
      }
      function So2(t2, e2) {
        return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Ao2(t2) : [] };
      }
      const ko2 = -32768;
      function Mo2(t2, e2, r2, n2, i2) {
        t2.emplaceBack(ko2 + 8 * e2 + n2, ko2 + 8 * r2 + i2);
      }

      class Io2 {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Pa, this.indexArray = new ja, this.segments = new qa, this.programConfigurations = new xo2(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          const n2 = this.layers[0], i2 = [];
          let s2 = null, a2 = false, o2 = n2.type === "heatmap";
          if (n2.type === "circle") {
            const t3 = n2;
            s2 = t3.layout.get("circle-sort-key"), a2 = !s2.isConstant(), o2 = o2 || t3.paint.get("circle-pitch-alignment") === "map";
          }
          const l3 = o2 ? e2.subdivisionGranularity.circle : 1;
          for (const { feature: e3, id: n3, index: o3, sourceLayerIndex: l4 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u2 = So2(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new ks(this.zoom), u2, r2))
              continue;
            const c2 = a2 ? s2.evaluate(u2, {}, r2) : undefined, h2 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: l4, index: o3, geometry: t3 ? u2.geometry : Ao2(e3), patterns: {}, sortKey: c2 };
            i2.push(h2);
          }
          a2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of i2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, o3 = t2[s3].feature;
            this.addFeature(n3, i3, s3, r2, l3), e2.featureIndex.insert(o3, i3, s3, a3, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ua), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t2, e2, r2, n2, i2 = 1) {
          let s2;
          switch (i2) {
            case 1:
              s2 = [0, 7];
              break;
            case 3:
              s2 = [0, 2, 5, 7];
              break;
            case 5:
              s2 = [0, 1, 3, 4, 6, 7];
              break;
            case 7:
              s2 = [0, 1, 2, 3, 4, 5, 6, 7];
              break;
            default:
              throw new Error(`Invalid circle bucket granularity: ${i2}; valid values are 1, 3, 5, 7.`);
          }
          const a2 = s2.length;
          for (const r3 of e2)
            for (const e3 of r3) {
              const { x: r4, y: n3 } = e3;
              if (r4 < 0 || r4 >= z2 || n3 < 0 || n3 >= z2)
                continue;
              const i3 = this.segments.prepareSegment(a2 * a2, this.layoutVertexArray, this.indexArray, t2.sortKey), o2 = i3.vertexLength;
              for (let t3 = 0;t3 < a2; t3++)
                for (let e4 = 0;e4 < a2; e4++)
                  Mo2(this.layoutVertexArray, r4, n3, s2[e4], s2[t3]);
              for (let t3 = 0;t3 < a2 - 1; t3++)
                for (let e4 = 0;e4 < a2 - 1; e4++) {
                  const r5 = o2 + t3 * a2 + e4, n4 = o2 + (t3 + 1) * a2 + e4;
                  this.indexArray.emplaceBack(r5, n4 + 1, r5 + 1), this.indexArray.emplaceBack(r5, n4, n4 + 1);
                }
              i3.vertexLength += a2 * a2, i3.primitiveLength += (a2 - 1) * (a2 - 1) * 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
        }
      }
      function zo2(t2, e2) {
        for (let r2 = 0;r2 < t2.length; r2++)
          if (Lo2(e2, t2[r2]))
            return true;
        for (let r2 = 0;r2 < e2.length; r2++)
          if (Lo2(t2, e2[r2]))
            return true;
        return !!Vo2(t2, e2);
      }
      function Po2(t2, e2, r2) {
        return !!Lo2(t2, e2) || !!To2(e2, t2, r2);
      }
      function Co2(t2, e2) {
        if (t2.length === 1)
          return $o2(e2, t2[0]);
        for (let r2 = 0;r2 < e2.length; r2++) {
          const n2 = e2[r2];
          for (let e3 = 0;e3 < n2.length; e3++)
            if (Lo2(t2, n2[e3]))
              return true;
        }
        for (let r2 = 0;r2 < t2.length; r2++)
          if ($o2(e2, t2[r2]))
            return true;
        for (let r2 = 0;r2 < e2.length; r2++)
          if (Vo2(t2, e2[r2]))
            return true;
        return false;
      }
      function Bo2(t2, e2, r2) {
        if (t2.length > 1) {
          if (Vo2(t2, e2))
            return true;
          for (let n2 = 0;n2 < e2.length; n2++)
            if (To2(e2[n2], t2, r2))
              return true;
        }
        for (let n2 = 0;n2 < t2.length; n2++)
          if (To2(t2[n2], e2, r2))
            return true;
        return false;
      }
      function Vo2(t2, e2) {
        if (t2.length === 0 || e2.length === 0)
          return false;
        for (let r2 = 0;r2 < t2.length - 1; r2++) {
          const n2 = t2[r2], i2 = t2[r2 + 1];
          for (let t3 = 0;t3 < e2.length - 1; t3++)
            if (Eo2(n2, i2, e2[t3], e2[t3 + 1]))
              return true;
        }
        return false;
      }
      function Eo2(t2, e2, r2, n2) {
        return q(t2, r2, n2) !== q(e2, r2, n2) && q(t2, e2, r2) !== q(t2, e2, n2);
      }
      function To2(t2, e2, r2) {
        const n2 = r2 * r2;
        if (e2.length === 1)
          return t2.distSqr(e2[0]) < n2;
        for (let r3 = 1;r3 < e2.length; r3++)
          if (Fo2(t2, e2[r3 - 1], e2[r3]) < n2)
            return true;
        return false;
      }
      function Fo2(t2, e2, r2) {
        const n2 = e2.distSqr(r2);
        if (n2 === 0)
          return t2.distSqr(e2);
        const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
        return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
      }
      function $o2(t2, e2) {
        for (let r2 = 0;r2 < t2.length; r2++)
          if (Lo2(t2[r2], e2))
            return true;
        return false;
      }
      function Lo2(t2, e2) {
        let r2 = false;
        for (let n2 = 0, i2 = t2.length - 1;n2 < t2.length; i2 = n2++) {
          const s2 = t2[n2], a2 = t2[i2];
          s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
        }
        return r2;
      }
      function Oo2(t2, e2, r2) {
        const n2 = r2[0], i2 = r2[2];
        if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
          return false;
        const s2 = q(t2, e2, r2[0]);
        return s2 !== q(t2, e2, r2[1]) || s2 !== q(t2, e2, r2[2]) || s2 !== q(t2, e2, r2[3]);
      }
      function Do2(t2, e2, r2) {
        const n2 = e2.paint.get(t2).value;
        return n2.kind === "constant" ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
      }
      function jo2(t2) {
        return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
      }
      function Ro(t2, e2, r2, n2, i2) {
        if (!e2[0] && !e2[1])
          return t2;
        const s2 = l2.convert(e2)._mult(i2);
        r2 === "viewport" && s2._rotate(-n2);
        const a2 = [];
        for (let e3 = 0;e3 < t2.length; e3++)
          a2.push(t2[e3].sub(s2));
        return a2;
      }
      let No2, Uo2;
      is("CircleBucket", Io2, { omit: ["layers"] });
      var qo2 = { get paint() {
        return Uo2 = Uo2 || new Ds({ "circle-radius": new Fs(gt2.paint_circle["circle-radius"]), "circle-color": new Fs(gt2.paint_circle["circle-color"]), "circle-blur": new Fs(gt2.paint_circle["circle-blur"]), "circle-opacity": new Fs(gt2.paint_circle["circle-opacity"]), "circle-translate": new Ts(gt2.paint_circle["circle-translate"]), "circle-translate-anchor": new Ts(gt2.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ts(gt2.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ts(gt2.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Fs(gt2.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Fs(gt2.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Fs(gt2.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return No2 = No2 || new Ds({ "circle-sort-key": new Fs(gt2.layout_circle["circle-sort-key"]) });
      } };

      class Go2 extends Rs {
        constructor(t2) {
          super(t2, qo2);
        }
        createBucket(t2) {
          return new Io2(t2);
        }
        queryRadius(t2) {
          const e2 = t2;
          return Do2("circle-radius", this, e2) + Do2("circle-stroke-width", this, e2) + jo2(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature({ queryGeometry: t2, feature: e2, featureState: r2, geometry: n2, transform: i2, pixelsToTileUnits: s2, unwrappedTileID: a2, getElevation: o2 }) {
          const l3 = Ro(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i2.bearingInRadians, s2), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2), c2 = this.paint.get("circle-pitch-alignment") === "map", h2 = c2 ? l3 : function(t3, e3, r3, n3) {
            return t3.map((t4) => Zo2(t4, e3, r3, n3));
          }(l3, i2, a2, o2), p2 = c2 ? u2 * s2 : u2;
          for (const t3 of n2)
            for (const e3 of t3) {
              const t4 = c2 ? e3 : Zo2(e3, i2, a2, o2);
              let r3 = p2;
              const n3 = i2.projectTileCoordinates(e3.x, e3.y, a2, o2).signedDistanceFromCamera;
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? r3 *= n3 / i2.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (r3 *= i2.cameraToCenterDistance / n3), Po2(h2, t4, r3))
                return true;
            }
          return false;
        }
      }
      function Zo2(t2, e2, r2, n2) {
        const i2 = e2.projectTileCoordinates(t2.x, t2.y, r2, n2).point;
        return new l2((0.5 * i2.x + 0.5) * e2.width, (0.5 * -i2.y + 0.5) * e2.height);
      }

      class Ko2 extends Io2 {
      }
      let Xo2;
      is("HeatmapBucket", Ko2, { omit: ["layers"] });
      var Ho = { get paint() {
        return Xo2 = Xo2 || new Ds({ "heatmap-radius": new Fs(gt2.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Fs(gt2.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ts(gt2.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Os(gt2.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ts(gt2.paint_heatmap["heatmap-opacity"]) });
      } };
      function Yo2(t2, { width: e2, height: r2 }, n2, i2) {
        if (i2) {
          if (i2 instanceof Uint8ClampedArray)
            i2 = new Uint8Array(i2.buffer);
          else if (i2.length !== e2 * r2 * n2)
            throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${e2 * r2 * n2}`);
        } else
          i2 = new Uint8Array(e2 * r2 * n2);
        return t2.width = e2, t2.height = r2, t2.data = i2, t2;
      }
      function Jo2(t2, { width: e2, height: r2 }, n2) {
        if (e2 === t2.width && r2 === t2.height)
          return;
        const i2 = Yo2({}, { width: e2, height: r2 }, n2);
        Wo(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r2) }, n2), t2.width = e2, t2.height = r2, t2.data = i2.data;
      }
      function Wo(t2, e2, r2, n2, i2, s2) {
        if (i2.width === 0 || i2.height === 0)
          return e2;
        if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const a2 = t2.data, o2 = e2.data;
        if (a2 === o2)
          throw new Error("srcData equals dstData, so image is already copied");
        for (let l3 = 0;l3 < i2.height; l3++) {
          const u2 = ((r2.y + l3) * t2.width + r2.x) * s2, c2 = ((n2.y + l3) * e2.width + n2.x) * s2;
          for (let t3 = 0;t3 < i2.width * s2; t3++)
            o2[c2 + t3] = a2[u2 + t3];
        }
        return e2;
      }

      class Qo2 {
        constructor(t2, e2) {
          Yo2(this, t2, 1, e2);
        }
        resize(t2) {
          Jo2(this, t2, 1);
        }
        clone() {
          return new Qo2({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e2, r2, n2, i2) {
          Wo(t2, e2, r2, n2, i2, 1);
        }
      }

      class tl {
        constructor(t2, e2) {
          Yo2(this, t2, 4, e2);
        }
        resize(t2) {
          Jo2(this, t2, 4);
        }
        replace(t2, e2) {
          e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
        }
        clone() {
          return new tl({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e2, r2, n2, i2) {
          Wo(t2, e2, r2, n2, i2, 4);
        }
      }
      function el(t2) {
        const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new tl({ width: r2, height: n2 });
        if (Math.log(r2) / Math.LN2 % 1 != 0)
          throw new Error(`width is not a power of 2 - ${r2}`);
        const s2 = (r3, n3, s3) => {
          e2[t2.evaluationKey] = s3;
          const a2 = t2.expression.evaluate(e2);
          i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
        };
        if (t2.clips)
          for (let e3 = 0, i3 = 0;e3 < n2; ++e3, i3 += 4 * r2)
            for (let n3 = 0, a2 = 0;n3 < r2; n3++, a2 += 4) {
              const o2 = n3 / (r2 - 1), { start: l3, end: u2 } = t2.clips[e3];
              s2(i3, a2, l3 * (1 - o2) + u2 * o2);
            }
        else
          for (let t3 = 0, e3 = 0;t3 < r2; t3++, e3 += 4)
            s2(0, e3, t3 / (r2 - 1));
        return i2;
      }
      is("AlphaImage", Qo2), is("RGBAImage", tl);
      const rl = "big-fb";

      class nl extends Rs {
        createBucket(t2) {
          return new Ko2(t2);
        }
        constructor(t2) {
          super(t2, Ho), this.heatmapFbos = new Map, this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          t2 === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = el({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(rl) && this.heatmapFbos.delete(rl);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let il;
      var sl = { get paint() {
        return il = il || new Ds({ "hillshade-illumination-direction": new Ts(gt2.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Ts(gt2.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Ts(gt2.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ts(gt2.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ts(gt2.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ts(gt2.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ts(gt2.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Ts(gt2.paint_hillshade["hillshade-method"]) });
      } };

      class al extends Rs {
        constructor(t2) {
          super(t2, sl), this.recalculate({ zoom: 0, zoomHistory: {} }, undefined);
        }
        getIlluminationProperties() {
          let t2 = this.paint.get("hillshade-illumination-direction").values, e2 = this.paint.get("hillshade-illumination-altitude").values, r2 = this.paint.get("hillshade-highlight-color").values, n2 = this.paint.get("hillshade-shadow-color").values;
          const i2 = Math.max(t2.length, e2.length, r2.length, n2.length);
          t2 = t2.concat(Array(i2 - t2.length).fill(t2.at(-1))), e2 = e2.concat(Array(i2 - e2.length).fill(e2.at(-1))), r2 = r2.concat(Array(i2 - r2.length).fill(r2.at(-1))), n2 = n2.concat(Array(i2 - n2.length).fill(n2.at(-1)));
          const s2 = e2.map(Q2);
          return { directionRadians: t2.map(Q2), altitudeRadians: s2, shadowColor: n2, highlightColor: r2 };
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const ol = Gs([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ll } = ol;
      function ul(t2, e2, r2) {
        const n2 = r2.patternDependencies;
        let i2 = false;
        for (const r3 of e2) {
          const e3 = r3.paint.get(`${t2}-pattern`);
          e3.isConstant() || (i2 = true);
          const s2 = e3.constantOr(null);
          s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
        }
        return i2;
      }
      function cl(t2, e2, r2, n2, i2) {
        const s2 = i2.patternDependencies;
        for (const a2 of e2) {
          const e3 = a2.paint.get(`${t2}-pattern`).value;
          if (e3.kind !== "constant") {
            let t3 = e3.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l3 = e3.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
            t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l3 = l3 && l3.name ? l3.name : l3, s2[t3] = true, s2[o2] = true, s2[l3] = true, r2.patterns[a2.id] = { min: t3, mid: o2, max: l3 };
          }
        }
        return r2;
      }
      function hl(t2, e2, r2, n2, i2) {
        let s2;
        if (i2 === function(t3, e3, r3, n3) {
          let i3 = 0;
          for (let s3 = e3, a2 = r3 - n3;s3 < r3; s3 += n3)
            i3 += (t3[a2] - t3[s3]) * (t3[s3 + 1] + t3[a2 + 1]), a2 = s3;
          return i3;
        }(t2, e2, r2, n2) > 0)
          for (let i3 = e2;i3 < r2; i3 += n2)
            s2 = El(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
        else
          for (let i3 = r2 - n2;i3 >= e2; i3 -= n2)
            s2 = El(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
        return s2 && Il(s2, s2.next) && (Tl(s2), s2 = s2.next), s2;
      }
      function pl(t2, e2) {
        if (!t2)
          return t2;
        e2 || (e2 = t2);
        let r2, n2 = t2;
        do {
          if (r2 = false, n2.steiner || !Il(n2, n2.next) && Ml(n2.prev, n2, n2.next) !== 0)
            n2 = n2.next;
          else {
            if (Tl(n2), n2 = e2 = n2.prev, n2 === n2.next)
              break;
            r2 = true;
          }
        } while (r2 || n2 !== e2);
        return e2;
      }
      function fl(t2, e2, r2, n2, i2, s2, a2) {
        if (!t2)
          return;
        !a2 && s2 && function(t3, e3, r3, n3) {
          let i3 = t3;
          do {
            i3.z === 0 && (i3.z = wl(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
          } while (i3 !== t3);
          i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
            let e4, r4 = 1;
            do {
              let n4, i4 = t4;
              t4 = null;
              let s3 = null;
              for (e4 = 0;i4; ) {
                e4++;
                let a3 = i4, o3 = 0;
                for (let t5 = 0;t5 < r4 && (o3++, a3 = a3.nextZ, a3); t5++)
                  ;
                let l3 = r4;
                for (;o3 > 0 || l3 > 0 && a3; )
                  o3 !== 0 && (l3 === 0 || !a3 || i4.z <= a3.z) ? (n4 = i4, i4 = i4.nextZ, o3--) : (n4 = a3, a3 = a3.nextZ, l3--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                i4 = a3;
              }
              s3.nextZ = null, r4 *= 2;
            } while (e4 > 1);
          }(i3);
        }(t2, n2, i2, s2);
        let o2 = t2;
        for (;t2.prev !== t2.next; ) {
          const { prev: l3, next: u2 } = t2;
          if (s2 ? yl(t2, n2, i2, s2) : dl(t2))
            e2.push(l3.i, t2.i, u2.i), Tl(t2), t2 = u2.next, o2 = u2.next;
          else if ((t2 = u2) === o2) {
            a2 ? a2 === 1 ? fl(t2 = ml(pl(t2), e2), e2, r2, n2, i2, s2, 2) : a2 === 2 && gl(t2, e2, r2, n2, i2, s2) : fl(pl(t2), e2, r2, n2, i2, s2, 1);
            break;
          }
        }
      }
      function dl(t2) {
        const e2 = t2.prev, r2 = t2, n2 = t2.next;
        if (Ml(e2, r2, n2) >= 0)
          return false;
        const i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l3 = r2.y, u2 = n2.y, c2 = Math.min(i2, s2, a2), h2 = Math.min(o2, l3, u2), p2 = Math.max(i2, s2, a2), f2 = Math.max(o2, l3, u2);
        let d2 = n2.next;
        for (;d2 !== e2; ) {
          if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && Sl(i2, o2, s2, l3, a2, u2, d2.x, d2.y) && Ml(d2.prev, d2, d2.next) >= 0)
            return false;
          d2 = d2.next;
        }
        return true;
      }
      function yl(t2, e2, r2, n2) {
        const i2 = t2.prev, s2 = t2, a2 = t2.next;
        if (Ml(i2, s2, a2) >= 0)
          return false;
        const o2 = i2.x, l3 = s2.x, u2 = a2.x, c2 = i2.y, h2 = s2.y, p2 = a2.y, f2 = Math.min(o2, l3, u2), d2 = Math.min(c2, h2, p2), y2 = Math.max(o2, l3, u2), m2 = Math.max(c2, h2, p2), g2 = wl(f2, d2, e2, r2, n2), x2 = wl(y2, m2, e2, r2, n2);
        let { prevZ: v2, nextZ: b2 } = t2;
        for (;v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
          if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && Sl(o2, c2, l3, h2, u2, p2, v2.x, v2.y) && Ml(v2.prev, v2, v2.next) >= 0)
            return false;
          if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Sl(o2, c2, l3, h2, u2, p2, b2.x, b2.y) && Ml(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        for (;v2 && v2.z >= g2; ) {
          if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && Sl(o2, c2, l3, h2, u2, p2, v2.x, v2.y) && Ml(v2.prev, v2, v2.next) >= 0)
            return false;
          v2 = v2.prevZ;
        }
        for (;b2 && b2.z <= x2; ) {
          if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Sl(o2, c2, l3, h2, u2, p2, b2.x, b2.y) && Ml(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        return true;
      }
      function ml(t2, e2) {
        let r2 = t2;
        do {
          const n2 = r2.prev, i2 = r2.next.next;
          !Il(n2, i2) && zl(n2, r2, r2.next, i2) && Bl(n2, i2) && Bl(i2, n2) && (e2.push(n2.i, r2.i, i2.i), Tl(r2), Tl(r2.next), r2 = t2 = i2), r2 = r2.next;
        } while (r2 !== t2);
        return pl(r2);
      }
      function gl(t2, e2, r2, n2, i2, s2) {
        let a2 = t2;
        do {
          let t3 = a2.next.next;
          for (;t3 !== a2.prev; ) {
            if (a2.i !== t3.i && kl(a2, t3)) {
              let o2 = Vl(a2, t3);
              return a2 = pl(a2, a2.next), o2 = pl(o2, o2.next), fl(a2, e2, r2, n2, i2, s2, 0), void fl(o2, e2, r2, n2, i2, s2, 0);
            }
            t3 = t3.next;
          }
          a2 = a2.next;
        } while (a2 !== t2);
      }
      function xl(t2, e2) {
        let r2 = t2.x - e2.x;
        return r2 === 0 && (r2 = t2.y - e2.y, r2 === 0) && (r2 = (t2.next.y - t2.y) / (t2.next.x - t2.x) - (e2.next.y - e2.y) / (e2.next.x - e2.x)), r2;
      }
      function vl(t2, e2) {
        const r2 = function(t3, e3) {
          let r3 = e3;
          const { x: n3, y: i2 } = t3;
          let s2, a2 = -1 / 0;
          if (Il(t3, r3))
            return r3;
          do {
            if (Il(t3, r3.next))
              return r3.next;
            if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
              const t4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
              if (t4 <= n3 && t4 > a2 && (a2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3))
                return s2;
            }
            r3 = r3.next;
          } while (r3 !== e3);
          if (!s2)
            return null;
          const o2 = s2, l3 = s2.x, u2 = s2.y;
          let c2 = 1 / 0;
          r3 = s2;
          do {
            if (n3 >= r3.x && r3.x >= l3 && n3 !== r3.x && Al(i2 < u2 ? n3 : a2, i2, l3, u2, i2 < u2 ? a2 : n3, i2, r3.x, r3.y)) {
              const e4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
              Bl(r3, t3) && (e4 < c2 || e4 === c2 && (r3.x > s2.x || r3.x === s2.x && bl(s2, r3))) && (s2 = r3, c2 = e4);
            }
            r3 = r3.next;
          } while (r3 !== o2);
          return s2;
        }(t2, e2);
        if (!r2)
          return e2;
        const n2 = Vl(r2, t2);
        return pl(n2, n2.next), pl(r2, r2.next);
      }
      function bl(t2, e2) {
        return Ml(t2.prev, t2, e2.prev) < 0 && Ml(e2.next, t2, t2.next) < 0;
      }
      function wl(t2, e2, r2, n2, i2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function _l(t2) {
        let e2 = t2, r2 = t2;
        do {
          (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return r2;
      }
      function Al(t2, e2, r2, n2, i2, s2, a2, o2) {
        return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
      }
      function Sl(t2, e2, r2, n2, i2, s2, a2, o2) {
        return !(t2 === a2 && e2 === o2) && Al(t2, e2, r2, n2, i2, s2, a2, o2);
      }
      function kl(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          let r2 = t3;
          do {
            if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && zl(r2, r2.next, t3, e3))
              return true;
            r2 = r2.next;
          } while (r2 !== t3);
          return false;
        }(t2, e2) && (Bl(t2, e2) && Bl(e2, t2) && function(t3, e3) {
          let r2 = t3, n2 = false;
          const i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
          do {
            r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
          } while (r2 !== t3);
          return n2;
        }(t2, e2) && (Ml(t2.prev, t2, e2.prev) || Ml(t2, e2.prev, e2)) || Il(t2, e2) && Ml(t2.prev, t2, t2.next) > 0 && Ml(e2.prev, e2, e2.next) > 0);
      }
      function Ml(t2, e2, r2) {
        return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
      }
      function Il(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function zl(t2, e2, r2, n2) {
        const i2 = Cl(Ml(t2, e2, r2)), s2 = Cl(Ml(t2, e2, n2)), a2 = Cl(Ml(r2, n2, t2)), o2 = Cl(Ml(r2, n2, e2));
        return i2 !== s2 && a2 !== o2 || !(i2 !== 0 || !Pl(t2, r2, e2)) || !(s2 !== 0 || !Pl(t2, n2, e2)) || !(a2 !== 0 || !Pl(r2, t2, n2)) || !(o2 !== 0 || !Pl(r2, e2, n2));
      }
      function Pl(t2, e2, r2) {
        return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
      }
      function Cl(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function Bl(t2, e2) {
        return Ml(t2.prev, t2, t2.next) < 0 ? Ml(t2, e2, t2.next) >= 0 && Ml(t2, t2.prev, e2) >= 0 : Ml(t2, e2, t2.prev) < 0 || Ml(t2, t2.next, e2) < 0;
      }
      function Vl(t2, e2) {
        const r2 = Fl(t2.i, t2.x, t2.y), n2 = Fl(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
        return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
      }
      function El(t2, e2, r2, n2) {
        const i2 = Fl(t2, e2, r2);
        return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
      }
      function Tl(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function Fl(t2, e2, r2) {
        return { i: t2, x: e2, y: r2, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
      }

      class $l {
        constructor(t2, e2) {
          if (e2 > t2)
            throw new Error("Min granularity must not be greater than base granularity.");
          this._baseZoomGranularity = t2, this._minGranularity = e2;
        }
        getGranularityForZoomLevel(t2) {
          return Math.max(Math.floor(this._baseZoomGranularity / (1 << t2)), this._minGranularity, 1);
        }
      }

      class Ll {
        constructor(t2) {
          this.fill = t2.fill, this.line = t2.line, this.tile = t2.tile, this.stencil = t2.stencil, this.circle = t2.circle;
        }
      }
      Ll.noSubdivision = new Ll({ fill: new $l(0, 0), line: new $l(0, 0), tile: new $l(0, 0), stencil: new $l(0, 0), circle: 1 }), is("SubdivisionGranularityExpression", $l), is("SubdivisionGranularitySetting", Ll);
      const Ol = -32768, Dl = 32767;

      class jl {
        constructor(t2, e2) {
          this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = false, this._granularity = t2, this._granularityCellSize = z2 / t2, this._canonical = e2;
        }
        _getKey(t2, e2) {
          return (t2 += 32768) << 16 | (e2 += 32768) << 0;
        }
        _vertexToIndex(t2, e2) {
          if (t2 < -32768 || e2 < -32768 || t2 > 32767 || e2 > 32767)
            throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
          const r2 = 0 | Math.round(t2), n2 = 0 | Math.round(e2), i2 = this._getKey(r2, n2);
          if (this._vertexDictionary.has(i2))
            return this._vertexDictionary.get(i2);
          const s2 = this._vertexBuffer.length / 2;
          return this._vertexDictionary.set(i2, s2), this._vertexBuffer.push(r2, n2), s2;
        }
        _subdivideTrianglesScanline(t2) {
          if (this._granularity < 2)
            return function(t3, e3) {
              const r3 = [];
              for (let n2 = 0;n2 < e3.length; n2 += 3) {
                const i2 = e3[n2], s2 = e3[n2 + 1], a2 = e3[n2 + 2], o2 = t3[2 * i2], l3 = t3[2 * i2 + 1];
                (t3[2 * s2] - o2) * (t3[2 * a2 + 1] - l3) - (t3[2 * s2 + 1] - l3) * (t3[2 * a2] - o2) > 0 ? (r3.push(i2), r3.push(a2), r3.push(s2)) : (r3.push(i2), r3.push(s2), r3.push(a2));
              }
              return r3;
            }(this._vertexBuffer, t2);
          const e2 = [], r2 = t2.length;
          for (let n2 = 0;n2 < r2; n2 += 3) {
            const r3 = [t2[n2 + 0], t2[n2 + 1], t2[n2 + 2]], i2 = [this._vertexBuffer[2 * t2[n2 + 0] + 0], this._vertexBuffer[2 * t2[n2 + 0] + 1], this._vertexBuffer[2 * t2[n2 + 1] + 0], this._vertexBuffer[2 * t2[n2 + 1] + 1], this._vertexBuffer[2 * t2[n2 + 2] + 0], this._vertexBuffer[2 * t2[n2 + 2] + 1]];
            let s2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, l3 = -1 / 0;
            for (let t3 = 0;t3 < 3; t3++) {
              const e3 = i2[2 * t3], r4 = i2[2 * t3 + 1];
              s2 = Math.min(s2, e3), o2 = Math.max(o2, e3), a2 = Math.min(a2, r4), l3 = Math.max(l3, r4);
            }
            if (s2 === o2 || a2 === l3)
              continue;
            const u2 = Math.floor(s2 / this._granularityCellSize), c2 = Math.ceil(o2 / this._granularityCellSize), h2 = Math.floor(a2 / this._granularityCellSize), p2 = Math.ceil(l3 / this._granularityCellSize);
            if (u2 !== c2 || h2 !== p2)
              for (let t3 = h2;t3 < p2; t3++) {
                const n3 = this._scanlineGenerateVertexRingForCellRow(t3, i2, r3);
                Ul(this._vertexBuffer, n3, e2);
              }
            else
              e2.push(...r3);
          }
          return e2;
        }
        _scanlineGenerateVertexRingForCellRow(t2, e2, r2) {
          const n2 = t2 * this._granularityCellSize, i2 = n2 + this._granularityCellSize, s2 = [];
          for (let t3 = 0;t3 < 3; t3++) {
            const a2 = e2[2 * t3], o2 = e2[2 * t3 + 1], l3 = e2[2 * (t3 + 1) % 6], u2 = e2[(2 * (t3 + 1) + 1) % 6], c2 = e2[2 * (t3 + 2) % 6], h2 = e2[(2 * (t3 + 2) + 1) % 6], p2 = l3 - a2, f2 = u2 - o2, d2 = p2 === 0, y2 = f2 === 0, m2 = (n2 - o2) / f2, g2 = (i2 - o2) / f2, x2 = Math.min(m2, g2), v2 = Math.max(m2, g2);
            if (!y2 && (x2 >= 1 || v2 <= 0) || y2 && (o2 < n2 || o2 > i2)) {
              u2 >= n2 && u2 <= i2 && s2.push(r2[(t3 + 1) % 3]);
              continue;
            }
            !y2 && x2 > 0 && s2.push(this._vertexToIndex(a2 + p2 * x2, o2 + f2 * x2));
            const b2 = a2 + p2 * Math.max(x2, 0), w2 = a2 + p2 * Math.min(v2, 1);
            d2 || this._generateIntraEdgeVertices(s2, a2, o2, l3, u2, b2, w2), !y2 && v2 < 1 && s2.push(this._vertexToIndex(a2 + p2 * v2, o2 + f2 * v2)), (y2 || u2 >= n2 && u2 <= i2) && s2.push(r2[(t3 + 1) % 3]), !y2 && (u2 <= n2 || u2 >= i2) && this._generateInterEdgeVertices(s2, a2, o2, l3, u2, c2, h2, w2, n2, i2);
          }
          return s2;
        }
        _generateIntraEdgeVertices(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = n2 - e2, l3 = i2 - r2, u2 = l3 === 0, c2 = u2 ? Math.min(e2, n2) : Math.min(s2, a2), h2 = u2 ? Math.max(e2, n2) : Math.max(s2, a2), p2 = Math.floor(c2 / this._granularityCellSize) + 1, f2 = Math.ceil(h2 / this._granularityCellSize) - 1;
          if (u2 ? e2 < n2 : s2 < a2)
            for (let n3 = p2;n3 <= f2; n3++) {
              const i3 = n3 * this._granularityCellSize;
              t2.push(this._vertexToIndex(i3, r2 + l3 * (i3 - e2) / o2));
            }
          else
            for (let n3 = f2;n3 >= p2; n3--) {
              const i3 = n3 * this._granularityCellSize;
              t2.push(this._vertexToIndex(i3, r2 + l3 * (i3 - e2) / o2));
            }
        }
        _generateInterEdgeVertices(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2) {
          const c2 = i2 - r2, h2 = s2 - n2, p2 = a2 - i2, f2 = (l3 - i2) / p2, d2 = (u2 - i2) / p2, y2 = Math.min(f2, d2), m2 = Math.max(f2, d2), g2 = n2 + h2 * y2;
          let x2 = Math.floor(Math.min(g2, o2) / this._granularityCellSize) + 1, v2 = Math.ceil(Math.max(g2, o2) / this._granularityCellSize) - 1, b2 = o2 < g2;
          const w2 = p2 === 0;
          if (w2 && (a2 === l3 || a2 === u2))
            return;
          if (w2 || y2 >= 1 || m2 <= 0) {
            const t3 = r2 - a2, n3 = s2 + (e2 - s2) * Math.min((l3 - a2) / t3, (u2 - a2) / t3);
            x2 = Math.floor(Math.min(n3, o2) / this._granularityCellSize) + 1, v2 = Math.ceil(Math.max(n3, o2) / this._granularityCellSize) - 1, b2 = o2 < n3;
          }
          const _2 = c2 > 0 ? u2 : l3;
          if (b2)
            for (let e3 = x2;e3 <= v2; e3++)
              t2.push(this._vertexToIndex(e3 * this._granularityCellSize, _2));
          else
            for (let e3 = v2;e3 >= x2; e3--)
              t2.push(this._vertexToIndex(e3 * this._granularityCellSize, _2));
        }
        _generateOutline(t2) {
          const e2 = [];
          for (const r2 of t2) {
            const t3 = Nl(r2, this._granularity, true), n2 = this._pointArrayToIndices(t3), i2 = [];
            for (let t4 = 1;t4 < n2.length; t4++)
              i2.push(n2[t4 - 1]), i2.push(n2[t4]);
            e2.push(i2);
          }
          return e2;
        }
        _handlePoles(t2) {
          let e2 = false, r2 = false;
          this._canonical && (this._canonical.y === 0 && (e2 = true), this._canonical.y === (1 << this._canonical.z) - 1 && (r2 = true)), (e2 || r2) && this._fillPoles(t2, e2, r2);
        }
        _ensureNoPoleVertices() {
          const t2 = this._vertexBuffer;
          for (let e2 = 0;e2 < t2.length; e2 += 2) {
            const r2 = t2[e2 + 1];
            r2 === Ol && (t2[e2 + 1] = -32767), r2 === Dl && (t2[e2 + 1] = 32766);
          }
        }
        _generatePoleQuad(t2, e2, r2, n2, i2, s2) {
          n2 > i2 != (s2 === Ol) ? (t2.push(e2), t2.push(r2), t2.push(this._vertexToIndex(n2, s2)), t2.push(r2), t2.push(this._vertexToIndex(i2, s2)), t2.push(this._vertexToIndex(n2, s2))) : (t2.push(r2), t2.push(e2), t2.push(this._vertexToIndex(n2, s2)), t2.push(this._vertexToIndex(i2, s2)), t2.push(r2), t2.push(this._vertexToIndex(n2, s2)));
        }
        _fillPoles(t2, e2, r2) {
          const n2 = this._vertexBuffer, i2 = z2, s2 = t2.length;
          for (let a2 = 2;a2 < s2; a2 += 3) {
            const s3 = t2[a2 - 2], o2 = t2[a2 - 1], l3 = t2[a2], u2 = n2[2 * s3], c2 = n2[2 * s3 + 1], h2 = n2[2 * o2], p2 = n2[2 * o2 + 1], f2 = n2[2 * l3], d2 = n2[2 * l3 + 1];
            e2 && (c2 === 0 && p2 === 0 && this._generatePoleQuad(t2, s3, o2, u2, h2, Ol), p2 === 0 && d2 === 0 && this._generatePoleQuad(t2, o2, l3, h2, f2, Ol), d2 === 0 && c2 === 0 && this._generatePoleQuad(t2, l3, s3, f2, u2, Ol)), r2 && (c2 === i2 && p2 === i2 && this._generatePoleQuad(t2, s3, o2, u2, h2, Dl), p2 === i2 && d2 === i2 && this._generatePoleQuad(t2, o2, l3, h2, f2, Dl), d2 === i2 && c2 === i2 && this._generatePoleQuad(t2, l3, s3, f2, u2, Dl));
          }
        }
        _initializeVertices(t2) {
          for (let e2 = 0;e2 < t2.length; e2 += 2)
            this._vertexToIndex(t2[e2], t2[e2 + 1]);
        }
        subdividePolygonInternal(t2, e2) {
          if (this._used)
            throw new Error("Subdivision: multiple use not allowed.");
          this._used = true;
          const { flattened: r2, holeIndices: n2 } = function(t3) {
            const e3 = [], r3 = [];
            for (const n3 of t3)
              if (n3.length !== 0) {
                n3 !== t3[0] && e3.push(r3.length / 2);
                for (let t4 = 0;t4 < n3.length; t4++)
                  r3.push(n3[t4].x), r3.push(n3[t4].y);
              }
            return { flattened: r3, holeIndices: e3 };
          }(t2);
          let i2;
          this._initializeVertices(r2);
          try {
            const t3 = function(t4, e4, r3 = 2) {
              const n3 = e4 && e4.length, i3 = n3 ? e4[0] * r3 : t4.length;
              let s3 = hl(t4, 0, i3, r3, true);
              const a2 = [];
              if (!s3 || s3.next === s3.prev)
                return a2;
              let o2, l3, u2;
              if (n3 && (s3 = function(t5, e5, r4, n4) {
                const i4 = [];
                for (let r5 = 0, s4 = e5.length;r5 < s4; r5++) {
                  const a3 = hl(t5, e5[r5] * n4, r5 < s4 - 1 ? e5[r5 + 1] * n4 : t5.length, n4, false);
                  a3 === a3.next && (a3.steiner = true), i4.push(_l(a3));
                }
                i4.sort(xl);
                for (let t6 = 0;t6 < i4.length; t6++)
                  r4 = vl(i4[t6], r4);
                return r4;
              }(t4, e4, s3, r3)), t4.length > 80 * r3) {
                o2 = 1 / 0, l3 = 1 / 0;
                let e5 = -1 / 0, n4 = -1 / 0;
                for (let s4 = r3;s4 < i3; s4 += r3) {
                  const r4 = t4[s4], i4 = t4[s4 + 1];
                  r4 < o2 && (o2 = r4), i4 < l3 && (l3 = i4), r4 > e5 && (e5 = r4), i4 > n4 && (n4 = i4);
                }
                u2 = Math.max(e5 - o2, n4 - l3), u2 = u2 !== 0 ? 32767 / u2 : 0;
              }
              return fl(s3, a2, r3, o2, l3, u2, 0), a2;
            }(r2, n2), e3 = this._convertIndices(r2, t3);
            i2 = this._subdivideTrianglesScanline(e3);
          } catch (t3) {
            console.error(t3);
          }
          let s2 = [];
          return e2 && (s2 = this._generateOutline(t2)), this._ensureNoPoleVertices(), this._handlePoles(i2), { verticesFlattened: this._vertexBuffer, indicesTriangles: i2, indicesLineList: s2 };
        }
        _convertIndices(t2, e2) {
          const r2 = [];
          for (let n2 = 0;n2 < e2.length; n2++)
            r2.push(this._vertexToIndex(t2[2 * e2[n2]], t2[2 * e2[n2] + 1]));
          return r2;
        }
        _pointArrayToIndices(t2) {
          const e2 = [];
          for (let r2 = 0;r2 < t2.length; r2++) {
            const n2 = t2[r2];
            e2.push(this._vertexToIndex(n2.x, n2.y));
          }
          return e2;
        }
      }
      function Rl(t2, e2, r2, n2 = true) {
        return new jl(r2, e2).subdividePolygonInternal(t2, n2);
      }
      function Nl(t2, e2, r2 = false) {
        if (!t2 || t2.length < 1)
          return [];
        if (t2.length < 2)
          return [];
        const n2 = t2[0], i2 = t2[t2.length - 1], s2 = r2 && (n2.x !== i2.x || n2.y !== i2.y);
        if (e2 < 2)
          return s2 ? [...t2, t2[0]] : [...t2];
        const a2 = Math.floor(z2 / e2), o2 = [];
        o2.push(new l2(t2[0].x, t2[0].y));
        const u2 = t2.length, c2 = s2 ? u2 : u2 - 1;
        for (let e3 = 0;e3 < c2; e3++) {
          const r3 = t2[e3], n3 = e3 < u2 - 1 ? t2[e3 + 1] : t2[0], i3 = r3.x, s3 = r3.y, c3 = n3.x, h2 = n3.y, p2 = i3 !== c3, f2 = s3 !== h2;
          if (!p2 && !f2)
            continue;
          const d2 = c3 - i3, y2 = h2 - s3, m2 = Math.abs(d2), g2 = Math.abs(y2);
          let x2 = i3, v2 = s3;
          for (;; ) {
            const t3 = d2 > 0 ? (Math.floor(x2 / a2) + 1) * a2 : (Math.ceil(x2 / a2) - 1) * a2, e4 = y2 > 0 ? (Math.floor(v2 / a2) + 1) * a2 : (Math.ceil(v2 / a2) - 1) * a2, r4 = Math.abs(x2 - t3), n4 = Math.abs(v2 - e4), i4 = Math.abs(x2 - c3), s4 = Math.abs(v2 - h2), u3 = p2 ? r4 / m2 : Number.POSITIVE_INFINITY, b3 = f2 ? n4 / g2 : Number.POSITIVE_INFINITY;
            if ((i4 <= r4 || !p2) && (s4 <= n4 || !f2))
              break;
            if (u3 < b3 && p2 || !f2) {
              x2 = t3, v2 += y2 * u3;
              const e5 = new l2(x2, Math.round(v2));
              o2[o2.length - 1].x === e5.x && o2[o2.length - 1].y === e5.y || o2.push(e5);
            } else {
              x2 += d2 * b3, v2 = e4;
              const t4 = new l2(Math.round(x2), v2);
              o2[o2.length - 1].x === t4.x && o2[o2.length - 1].y === t4.y || o2.push(t4);
            }
          }
          const b2 = new l2(c3, h2);
          o2[o2.length - 1].x === b2.x && o2[o2.length - 1].y === b2.y || o2.push(b2);
        }
        return o2;
      }
      function Ul(t2, e2, r2) {
        if (e2.length === 0)
          throw new Error("Subdivision vertex ring is empty.");
        let n2 = 0, i2 = t2[2 * e2[0]];
        for (let r3 = 1;r3 < e2.length; r3++) {
          const s3 = t2[2 * e2[r3]];
          s3 < i2 && (i2 = s3, n2 = r3);
        }
        const s2 = e2.length;
        let a2 = n2, o2 = (a2 + 1) % s2;
        for (;; ) {
          const n3 = a2 - 1 >= 0 ? a2 - 1 : s2 - 1, i3 = (o2 + 1) % s2, l3 = t2[2 * e2[n3]], u2 = t2[2 * e2[i3]], c2 = t2[2 * e2[a2]], h2 = t2[2 * e2[a2] + 1], p2 = t2[2 * e2[o2] + 1];
          let f2 = false;
          if (l3 < u2)
            f2 = true;
          else if (l3 > u2)
            f2 = false;
          else {
            const r3 = p2 - h2, s3 = -(t2[2 * e2[o2]] - c2), a3 = h2 < p2 ? 1 : -1;
            ((l3 - c2) * r3 + (t2[2 * e2[n3] + 1] - h2) * s3) * a3 > ((u2 - c2) * r3 + (t2[2 * e2[i3] + 1] - h2) * s3) * a3 && (f2 = true);
          }
          if (f2) {
            const t3 = e2[n3], i4 = e2[a2], l4 = e2[o2];
            t3 !== i4 && t3 !== l4 && i4 !== l4 && r2.push(l4, i4, t3), a2--, a2 < 0 && (a2 = s2 - 1);
          } else {
            const t3 = e2[i3], n4 = e2[a2], l4 = e2[o2];
            t3 !== n4 && t3 !== l4 && n4 !== l4 && r2.push(l4, n4, t3), o2++, o2 >= s2 && (o2 = 0);
          }
          if (n3 === i3)
            break;
        }
      }
      function ql(t2, e2, r2, n2, i2, s2, a2, o2, l3) {
        const u2 = i2.length / 2, c2 = a2 && o2 && l3;
        if (u2 < qa.MAX_VERTEX_ARRAY_LENGTH) {
          const h2 = e2.prepareSegment(u2, r2, n2), p2 = h2.vertexLength;
          for (let t3 = 0;t3 < s2.length; t3 += 3)
            n2.emplaceBack(p2 + s2[t3], p2 + s2[t3 + 1], p2 + s2[t3 + 2]);
          let f2, d2;
          h2.vertexLength += u2, h2.primitiveLength += s2.length / 3, c2 && (d2 = a2.prepareSegment(u2, r2, o2), f2 = d2.vertexLength, d2.vertexLength += u2);
          for (let e3 = 0;e3 < i2.length; e3 += 2)
            t2(i2[e3], i2[e3 + 1]);
          if (c2)
            for (let t3 = 0;t3 < l3.length; t3++) {
              const e3 = l3[t3];
              for (let t4 = 1;t4 < e3.length; t4 += 2)
                o2.emplaceBack(f2 + e3[t4 - 1], f2 + e3[t4]);
              d2.primitiveLength += e3.length / 2;
            }
        } else
          (function(t3, e3, r3, n3, i3, s3) {
            const a3 = [];
            for (let t4 = 0;t4 < n3.length / 2; t4++)
              a3.push(-1);
            const o3 = { count: 0 };
            let l4 = 0, u3 = t3.getOrCreateLatestSegment(e3, r3), c3 = u3.vertexLength;
            for (let h2 = 2;h2 < i3.length; h2 += 3) {
              const p2 = i3[h2 - 2], f2 = i3[h2 - 1], d2 = i3[h2];
              let y2 = a3[p2] < l4, m2 = a3[f2] < l4, g2 = a3[d2] < l4;
              u3.vertexLength + ((y2 ? 1 : 0) + (m2 ? 1 : 0) + (g2 ? 1 : 0)) > qa.MAX_VERTEX_ARRAY_LENGTH && (u3 = t3.createNewSegment(e3, r3), l4 = o3.count, y2 = true, m2 = true, g2 = true, c3 = 0);
              const x2 = Gl(a3, n3, s3, o3, p2, y2, u3), v2 = Gl(a3, n3, s3, o3, f2, m2, u3), b2 = Gl(a3, n3, s3, o3, d2, g2, u3);
              r3.emplaceBack(c3 + x2 - l4, c3 + v2 - l4, c3 + b2 - l4), u3.primitiveLength++;
            }
          })(e2, r2, n2, i2, s2, t2), c2 && function(t3, e3, r3, n3, i3, s3) {
            const a3 = [];
            for (let t4 = 0;t4 < n3.length / 2; t4++)
              a3.push(-1);
            const o3 = { count: 0 };
            let l4 = 0, u3 = t3.getOrCreateLatestSegment(e3, r3), c3 = u3.vertexLength;
            for (let h2 = 0;h2 < i3.length; h2++) {
              const p2 = i3[h2];
              for (let f2 = 1;f2 < i3[h2].length; f2 += 2) {
                const i4 = p2[f2 - 1], h3 = p2[f2];
                let d2 = a3[i4] < l4, y2 = a3[h3] < l4;
                u3.vertexLength + ((d2 ? 1 : 0) + (y2 ? 1 : 0)) > qa.MAX_VERTEX_ARRAY_LENGTH && (u3 = t3.createNewSegment(e3, r3), l4 = o3.count, d2 = true, y2 = true, c3 = 0);
                const m2 = Gl(a3, n3, s3, o3, i4, d2, u3), g2 = Gl(a3, n3, s3, o3, h3, y2, u3);
                r3.emplaceBack(c3 + m2 - l4, c3 + g2 - l4), u3.primitiveLength++;
              }
            }
          }(a2, r2, o2, i2, l3, t2), e2.forceNewSegmentOnNextPrepare(), a2 == null || a2.forceNewSegmentOnNextPrepare();
      }
      function Gl(t2, e2, r2, n2, i2, s2, a2) {
        if (s2) {
          const s3 = n2.count;
          return r2(e2[2 * i2], e2[2 * i2 + 1]), t2[i2] = n2.count, n2.count++, a2.vertexLength++, s3;
        }
        return t2[i2];
      }

      class Zl {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Ca, this.indexArray = new ja, this.indexArray2 = new Ra, this.programConfigurations = new xo2(t2.layers, t2.zoom), this.segments = new qa, this.segments2 = new qa, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.hasPattern = ul("fill", this.layers, e2);
          const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), s2 = [];
          for (const { feature: a2, id: o2, index: l3, sourceLayerIndex: u2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, c2 = So2(a2, t3);
            if (!this.layers[0]._featureFilter.filter(new ks(this.zoom), c2, r2))
              continue;
            const h2 = i2 ? n2.evaluate(c2, {}, r2, e2.availableImages) : undefined, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l3, geometry: t3 ? c2.geometry : Ao2(a2), patterns: {}, sortKey: h2 };
            s2.push(p2);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
            if (this.hasPattern) {
              const t3 = cl("fill", this.layers, n3, this.zoom, e2);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r2, {}, e2.subdivisionGranularity);
            e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        addFeatures(t2, e2, r2) {
          for (const n2 of this.patternFeatures)
            this.addFeature(n2, n2.geometry, n2.index, e2, r2, t2.subdivisionGranularity);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ll), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t2, e2, r2, n2, i2, s2) {
          for (const t3 of Wr2(e2, 500)) {
            const e3 = Rl(t3, n2, s2.fill.getGranularityForZoomLevel(n2.z)), r3 = this.layoutVertexArray;
            ql((t4, e4) => {
              r3.emplaceBack(t4, e4);
            }, this.segments, this.layoutVertexArray, this.indexArray, e3.verticesFlattened, e3.indicesTriangles, this.segments2, this.indexArray2, e3.indicesLineList);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
      }
      let Kl, Xl;
      is("FillBucket", Zl, { omit: ["layers", "patternFeatures"] });
      var Hl = { get paint() {
        return Xl = Xl || new Ds({ "fill-antialias": new Ts(gt2.paint_fill["fill-antialias"]), "fill-opacity": new Fs(gt2.paint_fill["fill-opacity"]), "fill-color": new Fs(gt2.paint_fill["fill-color"]), "fill-outline-color": new Fs(gt2.paint_fill["fill-outline-color"]), "fill-translate": new Ts(gt2.paint_fill["fill-translate"]), "fill-translate-anchor": new Ts(gt2.paint_fill["fill-translate-anchor"]), "fill-pattern": new $s(gt2.paint_fill["fill-pattern"]) });
      }, get layout() {
        return Kl = Kl || new Ds({ "fill-sort-key": new Fs(gt2.layout_fill["fill-sort-key"]) });
      } };

      class Yl extends Rs {
        constructor(t2) {
          super(t2, Hl);
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2);
          const r2 = this.paint._values["fill-outline-color"];
          r2.value.kind === "constant" && r2.value.value === undefined && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t2) {
          return new Zl(t2);
        }
        queryRadius() {
          return jo2(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature({ queryGeometry: t2, geometry: e2, transform: r2, pixelsToTileUnits: n2 }) {
          return Co2(Ro(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r2.bearingInRadians, n2), e2);
        }
        isTileClipped() {
          return true;
        }
      }
      const Jl = Gs([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Wl = Gs([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Ql } = Jl;
      var tu, eu, ru, nu, iu2, su, au, ou = {};
      function lu() {
        if (eu)
          return tu;
        eu = 1;
        var t2 = s();
        function e2(t3, e3, n3, i2, s2) {
          this.properties = {}, this.extent = n3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = i2, this._values = s2, t3.readFields(r2, this, e3);
        }
        function r2(t3, e3, r3) {
          t3 == 1 ? e3.id = r3.readVarint() : t3 == 2 ? function(t4, e4) {
            for (var r4 = t4.readVarint() + t4.pos;t4.pos < r4; ) {
              var n3 = e4._keys[t4.readVarint()], i2 = e4._values[t4.readVarint()];
              e4.properties[n3] = i2;
            }
          }(r3, e3) : t3 == 3 ? e3.type = r3.readVarint() : t3 == 4 && (e3._geometry = r3.pos);
        }
        function n2(t3) {
          for (var e3, r3, n3 = 0, i2 = 0, s2 = t3.length, a2 = s2 - 1;i2 < s2; a2 = i2++)
            n3 += ((r3 = t3[a2]).x - (e3 = t3[i2]).x) * (e3.y + r3.y);
          return n3;
        }
        return tu = e2, e2.types = ["Unknown", "Point", "LineString", "Polygon"], e2.prototype.loadGeometry = function() {
          var e3 = this._pbf;
          e3.pos = this._geometry;
          for (var r3, n3 = e3.readVarint() + e3.pos, i2 = 1, s2 = 0, a2 = 0, o2 = 0, l3 = [];e3.pos < n3; ) {
            if (s2 <= 0) {
              var u2 = e3.readVarint();
              i2 = 7 & u2, s2 = u2 >> 3;
            }
            if (s2--, i2 === 1 || i2 === 2)
              a2 += e3.readSVarint(), o2 += e3.readSVarint(), i2 === 1 && (r3 && l3.push(r3), r3 = []), r3.push(new t2(a2, o2));
            else {
              if (i2 !== 7)
                throw new Error("unknown command " + i2);
              r3 && r3.push(r3[0].clone());
            }
          }
          return r3 && l3.push(r3), l3;
        }, e2.prototype.bbox = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e3 = t3.readVarint() + t3.pos, r3 = 1, n3 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l3 = 1 / 0, u2 = -1 / 0;t3.pos < e3; ) {
            if (n3 <= 0) {
              var c2 = t3.readVarint();
              r3 = 7 & c2, n3 = c2 >> 3;
            }
            if (n3--, r3 === 1 || r3 === 2)
              (i2 += t3.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t3.readSVarint()) < l3 && (l3 = s2), s2 > u2 && (u2 = s2);
            else if (r3 !== 7)
              throw new Error("unknown command " + r3);
          }
          return [a2, l3, o2, u2];
        }, e2.prototype.toGeoJSON = function(t3, r3, i2) {
          var s2, a2, o2 = this.extent * Math.pow(2, i2), l3 = this.extent * t3, u2 = this.extent * r3, c2 = this.loadGeometry(), h2 = e2.types[this.type];
          function p2(t4) {
            for (var e3 = 0;e3 < t4.length; e3++) {
              var r4 = t4[e3];
              t4[e3] = [360 * (r4.x + l3) / o2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + u2) / o2) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var f2 = [];
              for (s2 = 0;s2 < c2.length; s2++)
                f2[s2] = c2[s2][0];
              p2(c2 = f2);
              break;
            case 2:
              for (s2 = 0;s2 < c2.length; s2++)
                p2(c2[s2]);
              break;
            case 3:
              for (c2 = function(t4) {
                var e3 = t4.length;
                if (e3 <= 1)
                  return [t4];
                for (var r4, i3, s3 = [], a3 = 0;a3 < e3; a3++) {
                  var o3 = n2(t4[a3]);
                  o3 !== 0 && (i3 === undefined && (i3 = o3 < 0), i3 === o3 < 0 ? (r4 && s3.push(r4), r4 = [t4[a3]]) : r4.push(t4[a3]));
                }
                return r4 && s3.push(r4), s3;
              }(c2), s2 = 0;s2 < c2.length; s2++)
                for (a2 = 0;a2 < c2[s2].length; a2++)
                  p2(c2[s2][a2]);
          }
          c2.length === 1 ? c2 = c2[0] : h2 = "Multi" + h2;
          var d2 = { type: "Feature", geometry: { type: h2, coordinates: c2 }, properties: this.properties };
          return "id" in this && (d2.id = this.id), d2;
        }, tu;
      }
      function uu() {
        if (nu)
          return ru;
        nu = 1;
        var t2 = lu();
        function e2(t3, e3) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(r2, this, e3), this.length = this._features.length;
        }
        function r2(t3, e3, r3) {
          t3 === 15 ? e3.version = r3.readVarint() : t3 === 1 ? e3.name = r3.readString() : t3 === 5 ? e3.extent = r3.readVarint() : t3 === 2 ? e3._features.push(r3.pos) : t3 === 3 ? e3._keys.push(r3.readString()) : t3 === 4 && e3._values.push(function(t4) {
            for (var e4 = null, r4 = t4.readVarint() + t4.pos;t4.pos < r4; ) {
              var n2 = t4.readVarint() >> 3;
              e4 = n2 === 1 ? t4.readString() : n2 === 2 ? t4.readFloat() : n2 === 3 ? t4.readDouble() : n2 === 4 ? t4.readVarint64() : n2 === 5 ? t4.readVarint() : n2 === 6 ? t4.readSVarint() : n2 === 7 ? t4.readBoolean() : null;
            }
            return e4;
          }(r3));
        }
        return ru = e2, e2.prototype.feature = function(e3) {
          if (e3 < 0 || e3 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[e3];
          var r3 = this._pbf.readVarint() + this._pbf.pos;
          return new t2(this._pbf, r3, this.extent, this._keys, this._values);
        }, ru;
      }
      function cu() {
        return au || (au = 1, ou.VectorTile = function() {
          if (su)
            return iu2;
          su = 1;
          var t2 = uu();
          function e2(e3, r2, n2) {
            if (e3 === 3) {
              var i2 = new t2(n2, n2.readVarint() + n2.pos);
              i2.length && (r2[i2.name] = i2);
            }
          }
          return iu2 = function(t3, r2) {
            this.layers = t3.readFields(e2, {}, r2);
          }, iu2;
        }(), ou.VectorTileFeature = lu(), ou.VectorTileLayer = uu()), ou;
      }
      var hu = r(cu());
      const pu = hu.VectorTileFeature.types, fu = Math.pow(2, 13);
      function du(t2, e2, r2, n2, i2, s2, a2, o2) {
        t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * fu) + a2, i2 * fu * 2, s2 * fu * 2, Math.round(o2));
      }

      class yu {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Ba, this.centroidVertexArray = new za, this.indexArray = new ja, this.programConfigurations = new xo2(t2.layers, t2.zoom), this.segments = new qa, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.features = [], this.hasPattern = ul("fill-extrusion", this.layers, e2);
          for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, o2 = So2(n2, t3);
            if (!this.layers[0]._featureFilter.filter(new ks(this.zoom), o2, r2))
              continue;
            const l3 = { id: i2, sourceLayerIndex: a2, index: s2, geometry: t3 ? o2.geometry : Ao2(n2), properties: n2.properties, type: n2.type, patterns: {} };
            this.hasPattern ? this.features.push(cl("fill-extrusion", this.layers, l3, this.zoom, e2)) : this.addFeature(l3, l3.geometry, s2, r2, {}, e2.subdivisionGranularity), e2.featureIndex.insert(n2, l3.geometry, s2, a2, this.index, true);
          }
        }
        addFeatures(t2, e2, r2) {
          for (const n2 of this.features) {
            const { geometry: i2 } = n2;
            this.addFeature(n2, i2, n2.index, e2, r2, t2.subdivisionGranularity);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ql), this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Wl.members, true), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(t2, e2, r2, n2, i2, s2) {
          for (const r3 of Wr2(e2, 500)) {
            const e3 = { x: 0, y: 0, sampleCount: 0 }, i3 = this.layoutVertexArray.length;
            this.processPolygon(e3, n2, t2, r3, s2);
            const a2 = this.layoutVertexArray.length - i3, o2 = Math.floor(e3.x / e3.sampleCount), l3 = Math.floor(e3.y / e3.sampleCount);
            for (let t3 = 0;t3 < a2; t3++)
              this.centroidVertexArray.emplaceBack(o2, l3);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
        processPolygon(t2, e2, r2, n2, i2) {
          if (n2.length < 1)
            return;
          if (xu(n2[0]))
            return;
          for (const e3 of n2)
            e3.length !== 0 && mu(t2, e3);
          const s2 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, a2 = i2.fill.getGranularityForZoomLevel(e2.z), o2 = pu[r2.type] === "Polygon";
          for (const t3 of n2) {
            if (t3.length === 0)
              continue;
            if (xu(t3))
              continue;
            const e3 = Nl(t3, a2, o2);
            this._generateSideFaces(e3, s2);
          }
          if (!o2)
            return;
          const l3 = Rl(n2, e2, a2, false), u2 = this.layoutVertexArray;
          ql((t3, e3) => {
            du(u2, t3, e3, 0, 0, 1, 1, 0);
          }, this.segments, this.layoutVertexArray, this.indexArray, l3.verticesFlattened, l3.indicesTriangles);
        }
        _generateSideFaces(t2, e2) {
          let r2 = 0;
          for (let n2 = 1;n2 < t2.length; n2++) {
            const i2 = t2[n2], s2 = t2[n2 - 1];
            if (gu(i2, s2))
              continue;
            e2.segment.vertexLength + 4 > qa.MAX_VERTEX_ARRAY_LENGTH && (e2.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
            const a2 = i2.sub(s2)._perp()._unit(), o2 = s2.dist(i2);
            r2 + o2 > 32768 && (r2 = 0), du(this.layoutVertexArray, i2.x, i2.y, a2.x, a2.y, 0, 0, r2), du(this.layoutVertexArray, i2.x, i2.y, a2.x, a2.y, 0, 1, r2), r2 += o2, du(this.layoutVertexArray, s2.x, s2.y, a2.x, a2.y, 0, 0, r2), du(this.layoutVertexArray, s2.x, s2.y, a2.x, a2.y, 0, 1, r2);
            const l3 = e2.segment.vertexLength;
            this.indexArray.emplaceBack(l3, l3 + 2, l3 + 1), this.indexArray.emplaceBack(l3 + 1, l3 + 2, l3 + 3), e2.segment.vertexLength += 4, e2.segment.primitiveLength += 2;
          }
        }
      }
      function mu(t2, e2) {
        for (let r2 = 0;r2 < e2.length; r2++) {
          const n2 = e2[r2];
          r2 === e2.length - 1 && e2[0].x === n2.x && e2[0].y === n2.y || (t2.x += n2.x, t2.y += n2.y, t2.sampleCount++);
        }
      }
      function gu(t2, e2) {
        return t2.x === e2.x && (t2.x < 0 || t2.x > z2) || t2.y === e2.y && (t2.y < 0 || t2.y > z2);
      }
      function xu(t2) {
        return t2.every((t3) => t3.x < 0) || t2.every((t3) => t3.x > z2) || t2.every((t3) => t3.y < 0) || t2.every((t3) => t3.y > z2);
      }
      let vu;
      is("FillExtrusionBucket", yu, { omit: ["layers", "features"] });
      var bu = { get paint() {
        return vu = vu || new Ds({ "fill-extrusion-opacity": new Ts(gt2["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Fs(gt2["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ts(gt2["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ts(gt2["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new $s(gt2["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Fs(gt2["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Fs(gt2["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ts(gt2["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };

      class wu extends Rs {
        constructor(t2) {
          super(t2, bu);
        }
        createBucket(t2) {
          return new yu(t2);
        }
        queryRadius() {
          return jo2(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        queryIntersectsFeature({ queryGeometry: t2, feature: e2, featureState: r2, geometry: n2, transform: i2, pixelsToTileUnits: s2, pixelPosMatrix: a2 }) {
          const o2 = Ro(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -i2.bearingInRadians, s2), u2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), c2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), h2 = function(t3, e3, r3) {
            const n3 = [];
            for (const r4 of t3) {
              const t4 = [r4.x, r4.y, 0, 1];
              S(t4, t4, e3), n3.push(new l2(t4[0] / t4[3], t4[1] / t4[3]));
            }
            return n3;
          }(o2, a2), p2 = function(t3, e3, r3, n3) {
            const i3 = [], s3 = [], a3 = n3[8] * e3, o3 = n3[9] * e3, u3 = n3[10] * e3, c3 = n3[11] * e3, h3 = n3[8] * r3, p3 = n3[9] * r3, f2 = n3[10] * r3, d2 = n3[11] * r3;
            for (const e4 of t3) {
              const t4 = [], r4 = [];
              for (const i4 of e4) {
                const { x: e5, y: s4 } = i4, y2 = n3[0] * e5 + n3[4] * s4 + n3[12], m2 = n3[1] * e5 + n3[5] * s4 + n3[13], g2 = n3[2] * e5 + n3[6] * s4 + n3[14], x2 = n3[3] * e5 + n3[7] * s4 + n3[15], v2 = g2 + u3, b2 = x2 + c3, w2 = y2 + h3, _2 = m2 + p3, A2 = g2 + f2, S2 = x2 + d2, k2 = new l2((y2 + a3) / b2, (m2 + o3) / b2);
                k2.z = v2 / b2, t4.push(k2);
                const M3 = new l2(w2 / S2, _2 / S2);
                M3.z = A2 / S2, r4.push(M3);
              }
              i3.push(t4), s3.push(r4);
            }
            return [i3, s3];
          }(n2, c2, u2, a2);
          return function(t3, e3, r3) {
            let n3 = 1 / 0;
            Co2(r3, e3) && (n3 = Au(r3, e3[0]));
            for (let i3 = 0;i3 < e3.length; i3++) {
              const s3 = e3[i3], a3 = t3[i3];
              for (let t4 = 0;t4 < s3.length - 1; t4++) {
                const e4 = s3[t4], i4 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                zo2(r3, i4) && (n3 = Math.min(n3, Au(r3, i4)));
              }
            }
            return n3 !== 1 / 0 && n3;
          }(p2[0], p2[1], h2);
        }
      }
      function _u(t2, e2) {
        return t2.x * e2.x + t2.y * e2.y;
      }
      function Au(t2, e2) {
        if (t2.length === 1) {
          let r2 = 0;
          const n2 = e2[r2++];
          let i2;
          for (;!i2 || n2.equals(i2); )
            if (i2 = e2[r2++], !i2)
              return 1 / 0;
          for (;r2 < e2.length; r2++) {
            const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l3 = s2.sub(n2), u2 = a2.sub(n2), c2 = _u(o2, o2), h2 = _u(o2, l3), p2 = _u(l3, l3), f2 = _u(u2, o2), d2 = _u(u2, l3), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
            if (isFinite(x2))
              return x2;
          }
          return 1 / 0;
        }
        {
          let t3 = 1 / 0;
          for (const r2 of e2)
            t3 = Math.min(t3, r2.z);
          return t3;
        }
      }
      const Su = Gs([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: ku } = Su, Mu = Gs([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Iu } = Mu, zu = hu.VectorTileFeature.types, Pu = Math.cos(Math.PI / 180 * 37.5), Cu = Math.pow(2, 14) / 0.5;

      class Bu {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
            this.gradients[t3.id] = {};
          }), this.layoutVertexArray = new Va, this.layoutVertexArray2 = new Ea, this.indexArray = new ja, this.programConfigurations = new xo2(t2.layers, t2.zoom), this.segments = new qa, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.hasPattern = ul("line", this.layers, e2);
          const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), s2 = [];
          for (const { feature: e3, id: a2, index: o2, sourceLayerIndex: l3 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u2 = So2(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new ks(this.zoom), u2, r2))
              continue;
            const c2 = i2 ? n2.evaluate(u2, {}, r2) : undefined, h2 = { id: a2, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o2, geometry: t3 ? u2.geometry : Ao2(e3), patterns: {}, sortKey: c2 };
            s2.push(h2);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
            if (this.hasPattern) {
              const t3 = cl("line", this.layers, n3, this.zoom, e2);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r2, {}, e2.subdivisionGranularity);
            e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        addFeatures(t2, e2, r2) {
          for (const n2 of this.patternFeatures)
            this.addFeature(n2, n2.geometry, n2.index, e2, r2, t2.subdivisionGranularity);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Iu)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ku), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t2) {
          if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end"))
            return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
        }
        addFeature(t2, e2, r2, n2, i2, s2) {
          const a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t2, {}), l3 = a2.get("line-cap"), u2 = a2.get("line-miter-limit"), c2 = a2.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t2);
          for (const r3 of e2)
            this.addLine(r3, t2, o2, l3, u2, c2, n2, s2);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
        addLine(t2, e2, r2, n2, i2, s2, a2, o2) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t2 = Nl(t2, a2 ? o2.line.getGranularityForZoomLevel(a2.z) : 1), this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let e3 = 0;e3 < t2.length - 1; e3++)
              this.totalDistance += t2[e3].dist(t2[e3 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const l3 = zu[e2.type] === "Polygon";
          let u2 = t2.length;
          for (;u2 >= 2 && t2[u2 - 1].equals(t2[u2 - 2]); )
            u2--;
          let c2 = 0;
          for (;c2 < u2 - 1 && t2[c2].equals(t2[c2 + 1]); )
            c2++;
          if (u2 < (l3 ? 3 : 2))
            return;
          r2 === "bevel" && (i2 = 1.05);
          const h2 = this.overscaling <= 16 ? 15 * z2 / (512 * this.overscaling) : 0, p2 = this.segments.prepareSegment(10 * u2, this.layoutVertexArray, this.indexArray);
          let f2, d2, y2, m2, g2;
          this.e1 = this.e2 = -1, l3 && (f2 = t2[u2 - 2], g2 = t2[c2].sub(f2)._unit()._perp());
          for (let e3 = c2;e3 < u2; e3++) {
            if (y2 = e3 === u2 - 1 ? l3 ? t2[c2 + 1] : undefined : t2[e3 + 1], y2 && t2[e3].equals(y2))
              continue;
            g2 && (m2 = g2), f2 && (d2 = f2), f2 = t2[e3], g2 = y2 ? y2.sub(f2)._unit()._perp() : m2, m2 = m2 || g2;
            let a3 = m2.add(g2);
            a3.x === 0 && a3.y === 0 || a3._unit();
            const o3 = m2.x * g2.x + m2.y * g2.y, x2 = a3.x * g2.x + a3.y * g2.y, v2 = x2 !== 0 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < Pu && d2 && y2, _2 = m2.x * g2.y - m2.y * g2.x > 0;
            if (w2 && e3 > c2) {
              const t3 = f2.dist(d2);
              if (t3 > 2 * h2) {
                const e4 = f2.sub(f2.sub(d2)._mult(h2 / t3)._round());
                this.updateDistance(d2, e4), this.addCurrentVertex(e4, m2, 0, 0, p2), d2 = e4;
              }
            }
            const A2 = d2 && y2;
            let S2 = A2 ? r2 : l3 ? "butt" : n2;
            if (A2 && S2 === "round" && (v2 < s2 ? S2 = "miter" : v2 <= 2 && (S2 = "fakeround")), S2 === "miter" && v2 > i2 && (S2 = "bevel"), S2 === "bevel" && (v2 > 2 && (S2 = "flipbevel"), v2 < i2 && (S2 = "miter")), d2 && this.updateDistance(d2, f2), S2 === "miter")
              a3._mult(v2), this.addCurrentVertex(f2, a3, 0, 0, p2);
            else if (S2 === "flipbevel") {
              if (v2 > 100)
                a3 = g2.mult(-1);
              else {
                const t3 = v2 * m2.add(g2).mag() / m2.sub(g2).mag();
                a3._perp()._mult(t3 * (_2 ? -1 : 1));
              }
              this.addCurrentVertex(f2, a3, 0, 0, p2), this.addCurrentVertex(f2, a3.mult(-1), 0, 0, p2);
            } else if (S2 === "bevel" || S2 === "fakeround") {
              const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
              if (d2 && this.addCurrentVertex(f2, m2, e4, r3, p2), S2 === "fakeround") {
                const t4 = Math.round(180 * b2 / Math.PI / 20);
                for (let e5 = 1;e5 < t4; e5++) {
                  let r4 = e5 / t4;
                  if (r4 !== 0.5) {
                    const t5 = r4 - 0.5;
                    r4 += r4 * t5 * (r4 - 1) * ((1.0904 + o3 * (o3 * (3.55645 - 1.43519 * o3) - 3.2452)) * t5 * t5 + (0.848013 + o3 * (0.215638 * o3 - 1.06021)));
                  }
                  const n3 = g2.sub(m2)._mult(r4)._add(m2)._unit()._mult(_2 ? -1 : 1);
                  this.addHalfVertex(f2, n3.x, n3.y, false, _2, 0, p2);
                }
              }
              y2 && this.addCurrentVertex(f2, g2, -e4, -r3, p2);
            } else if (S2 === "butt")
              this.addCurrentVertex(f2, a3, 0, 0, p2);
            else if (S2 === "square") {
              const t3 = d2 ? 1 : -1;
              this.addCurrentVertex(f2, a3, t3, t3, p2);
            } else
              S2 === "round" && (d2 && (this.addCurrentVertex(f2, m2, 0, 0, p2), this.addCurrentVertex(f2, m2, 1, 1, p2, true)), y2 && (this.addCurrentVertex(f2, g2, -1, -1, p2, true), this.addCurrentVertex(f2, g2, 0, 0, p2)));
            if (w2 && e3 < u2 - 1) {
              const t3 = f2.dist(y2);
              if (t3 > 2 * h2) {
                const e4 = f2.add(y2.sub(f2)._mult(h2 / t3)._round());
                this.updateDistance(f2, e4), this.addCurrentVertex(e4, g2, 0, 0, p2), f2 = e4;
              }
            }
          }
        }
        addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
          const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
          this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2), this.distance > Cu / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t2, e2, r2, n2, i2, s2));
        }
        addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
          const l3 = 0.5 * (this.lineClips ? this.scaledDistance * (Cu - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (a2 === 0 ? 0 : a2 < 0 ? -1 : 1) | (63 & l3) << 2, l3 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const u2 = o2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u2, this.e2), o2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(t2, e2) {
          this.distance += t2.dist(e2), this.updateScaledDistance();
        }
      }
      let Vu, Eu;
      is("LineBucket", Bu, { omit: ["layers", "patternFeatures"] });
      var Tu = { get paint() {
        return Eu = Eu || new Ds({ "line-opacity": new Fs(gt2.paint_line["line-opacity"]), "line-color": new Fs(gt2.paint_line["line-color"]), "line-translate": new Ts(gt2.paint_line["line-translate"]), "line-translate-anchor": new Ts(gt2.paint_line["line-translate-anchor"]), "line-width": new Fs(gt2.paint_line["line-width"]), "line-gap-width": new Fs(gt2.paint_line["line-gap-width"]), "line-offset": new Fs(gt2.paint_line["line-offset"]), "line-blur": new Fs(gt2.paint_line["line-blur"]), "line-dasharray": new Ls(gt2.paint_line["line-dasharray"]), "line-pattern": new $s(gt2.paint_line["line-pattern"]), "line-gradient": new Os(gt2.paint_line["line-gradient"]) });
      }, get layout() {
        return Vu = Vu || new Ds({ "line-cap": new Ts(gt2.layout_line["line-cap"]), "line-join": new Fs(gt2.layout_line["line-join"]), "line-miter-limit": new Ts(gt2.layout_line["line-miter-limit"]), "line-round-limit": new Ts(gt2.layout_line["line-round-limit"]), "line-sort-key": new Fs(gt2.layout_line["line-sort-key"]) });
      } };

      class Fu extends Fs {
        possiblyEvaluate(t2, e2) {
          return e2 = new ks(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
        }
        evaluate(t2, e2, r2, n2) {
          return e2 = L({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
        }
      }
      let $u;

      class Lu extends Rs {
        constructor(t2) {
          super(t2, Tu), this.gradientVersion = 0, $u || ($u = new Fu(Tu.paint.properties["line-width"].specification), $u.useIntegerZoom = true);
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          if (t2 === "line-gradient") {
            const t3 = this.gradientExpression();
            this.stepInterpolant = !!function(t4) {
              return t4._styleExpression !== undefined;
            }(t3) && t3._styleExpression.expression instanceof sr2, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = $u.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
        }
        createBucket(t2) {
          return new Bu(t2);
        }
        queryRadius(t2) {
          const e2 = t2, r2 = Ou(Do2("line-width", this, e2), Do2("line-gap-width", this, e2)), n2 = Do2("line-offset", this, e2);
          return r2 / 2 + Math.abs(n2) + jo2(this.paint.get("line-translate"));
        }
        queryIntersectsFeature({ queryGeometry: t2, feature: e2, featureState: r2, geometry: n2, transform: i2, pixelsToTileUnits: s2 }) {
          const a2 = Ro(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -i2.bearingInRadians, s2), o2 = s2 / 2 * Ou(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), u2 = this.paint.get("line-offset").evaluate(e2, r2);
          return u2 && (n2 = function(t3, e3) {
            const r3 = [];
            for (let n3 = 0;n3 < t3.length; n3++) {
              const i3 = t3[n3], s3 = [];
              for (let t4 = 0;t4 < i3.length; t4++) {
                const r4 = i3[t4 - 1], n4 = i3[t4], a3 = i3[t4 + 1], o3 = t4 === 0 ? new l2(0, 0) : n4.sub(r4)._unit()._perp(), u3 = t4 === i3.length - 1 ? new l2(0, 0) : a3.sub(n4)._unit()._perp(), c2 = o3._add(u3)._unit(), h2 = c2.x * u3.x + c2.y * u3.y;
                h2 !== 0 && c2._mult(1 / h2), s3.push(c2._mult(e3)._add(n4));
              }
              r3.push(s3);
            }
            return r3;
          }(n2, u2 * s2)), function(t3, e3, r3) {
            for (let n3 = 0;n3 < e3.length; n3++) {
              const i3 = e3[n3];
              if (t3.length >= 3) {
                for (let e4 = 0;e4 < i3.length; e4++)
                  if (Lo2(t3, i3[e4]))
                    return true;
              }
              if (Bo2(t3, i3, r3))
                return true;
            }
            return false;
          }(a2, n2, o2);
        }
        isTileClipped() {
          return true;
        }
      }
      function Ou(t2, e2) {
        return e2 > 0 ? e2 + 2 * t2 : t2;
      }
      const Du = Gs([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), ju = Gs([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      Gs([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const Ru = Gs([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      Gs([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Nu = Gs([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Uu = Gs([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function qu(t2, e2, r2) {
        return t2.sections.forEach((t3) => {
          t3.text = function(t4, e3, r3) {
            const n2 = e3.layout.get("text-transform").evaluate(r3, {});
            return n2 === "uppercase" ? t4 = t4.toLocaleUpperCase() : n2 === "lowercase" && (t4 = t4.toLocaleLowerCase()), Ss.applyArabicShaping && (t4 = Ss.applyArabicShaping(t4)), t4;
          }(t3.text, e2, r2);
        }), t2;
      }
      Gs([{ name: "triangle", components: 3, type: "Uint16" }]), Gs([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Gs([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Gs([{ type: "Float32", name: "offsetX" }]), Gs([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Gs([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const Gu = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
      var Zu, Ku, Xu, Hu = 24, Yu = {};
      function Ju() {
        return Zu || (Zu = 1, Yu.read = function(t2, e2, r2, n2, i2) {
          var s2, a2, o2 = 8 * i2 - n2 - 1, l3 = (1 << o2) - 1, u2 = l3 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h2];
          for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2;c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8)
            ;
          for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2;c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8)
            ;
          if (s2 === 0)
            s2 = 1 - u2;
          else {
            if (s2 === l3)
              return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            a2 += Math.pow(2, n2), s2 -= u2;
          }
          return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
        }, Yu.write = function(t2, e2, r2, n2, i2, s2) {
          var a2, o2, l3, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l3 = Math.pow(2, -a2)) < 1 && (a2--, l3 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l3 : p2 * Math.pow(2, 1 - h2)) * l3 >= 2 && (a2++, l3 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l3 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0));i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
            ;
          for (a2 = a2 << i2 | o2, u2 += i2;u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8)
            ;
          t2[r2 + f2 - d2] |= 128 * y2;
        }), Yu;
      }
      function Wu() {
        if (Xu)
          return Ku;
        Xu = 1, Ku = e2;
        var t2 = Ju();
        function e2(t3) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        e2.Varint = 0, e2.Fixed64 = 1, e2.Bytes = 2, e2.Fixed32 = 5;
        var r2 = 4294967296, n2 = 1 / r2, i2 = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf-8");
        function s2(t3) {
          return t3.type === e2.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
        }
        function a2(t3, e3, r3) {
          return r3 ? 4294967296 * e3 + (t3 >>> 0) : 4294967296 * (e3 >>> 0) + (t3 >>> 0);
        }
        function o2(t3, e3, r3) {
          var n3 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
          r3.realloc(n3);
          for (var i3 = r3.pos - 1;i3 >= t3; i3--)
            r3.buf[i3 + n3] = r3.buf[i3];
        }
        function l3(t3, e3) {
          for (var r3 = 0;r3 < t3.length; r3++)
            e3.writeVarint(t3[r3]);
        }
        function u2(t3, e3) {
          for (var r3 = 0;r3 < t3.length; r3++)
            e3.writeSVarint(t3[r3]);
        }
        function c2(t3, e3) {
          for (var r3 = 0;r3 < t3.length; r3++)
            e3.writeFloat(t3[r3]);
        }
        function h2(t3, e3) {
          for (var r3 = 0;r3 < t3.length; r3++)
            e3.writeDouble(t3[r3]);
        }
        function p2(t3, e3) {
          for (var r3 = 0;r3 < t3.length; r3++)
            e3.writeBoolean(t3[r3]);
        }
        function f2(t3, e3) {
          for (var r3 = 0;r3 < t3.length; r3++)
            e3.writeFixed32(t3[r3]);
        }
        function d2(t3, e3) {
          for (var r3 = 0;r3 < t3.length; r3++)
            e3.writeSFixed32(t3[r3]);
        }
        function y2(t3, e3) {
          for (var r3 = 0;r3 < t3.length; r3++)
            e3.writeFixed64(t3[r3]);
        }
        function m2(t3, e3) {
          for (var r3 = 0;r3 < t3.length; r3++)
            e3.writeSFixed64(t3[r3]);
        }
        function g2(t3, e3) {
          return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + 16777216 * t3[e3 + 3];
        }
        function x2(t3, e3, r3) {
          t3[r3] = e3, t3[r3 + 1] = e3 >>> 8, t3[r3 + 2] = e3 >>> 16, t3[r3 + 3] = e3 >>> 24;
        }
        function v2(t3, e3) {
          return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + (t3[e3 + 3] << 24);
        }
        return e2.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t3, e3, r3) {
          for (r3 = r3 || this.length;this.pos < r3; ) {
            var n3 = this.readVarint(), i3 = n3 >> 3, s3 = this.pos;
            this.type = 7 & n3, t3(i3, e3, this), this.pos === s3 && this.skip(n3);
          }
          return e3;
        }, readMessage: function(t3, e3) {
          return this.readFields(t3, e3, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t3 = g2(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readSFixed32: function() {
          var t3 = v2(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readFixed64: function() {
          var t3 = g2(this.buf, this.pos) + g2(this.buf, this.pos + 4) * r2;
          return this.pos += 8, t3;
        }, readSFixed64: function() {
          var t3 = g2(this.buf, this.pos) + v2(this.buf, this.pos + 4) * r2;
          return this.pos += 8, t3;
        }, readFloat: function() {
          var e3 = t2.read(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, e3;
        }, readDouble: function() {
          var e3 = t2.read(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, e3;
        }, readVarint: function(t3) {
          var e3, r3, n3 = this.buf;
          return e3 = 127 & (r3 = n3[this.pos++]), r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 7, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 14, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 21, r3 < 128 ? e3 : function(t4, e4, r4) {
            var n4, i3, s3 = r4.buf;
            if (n4 = (112 & (i3 = s3[r4.pos++])) >> 4, i3 < 128)
              return a2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 3, i3 < 128)
              return a2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 10, i3 < 128)
              return a2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 17, i3 < 128)
              return a2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 24, i3 < 128)
              return a2(t4, n4, e4);
            if (n4 |= (1 & (i3 = s3[r4.pos++])) << 31, i3 < 128)
              return a2(t4, n4, e4);
            throw new Error("Expected varint not more than 10 bytes");
          }(e3 |= (15 & (r3 = n3[this.pos])) << 28, t3, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t3 = this.readVarint();
          return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t3 = this.readVarint() + this.pos, e3 = this.pos;
          return this.pos = t3, t3 - e3 >= 12 && i2 ? function(t4, e4, r3) {
            return i2.decode(t4.subarray(e4, r3));
          }(this.buf, e3, t3) : function(t4, e4, r3) {
            for (var n3 = "", i3 = e4;i3 < r3; ) {
              var s3, a3, o3, l4 = t4[i3], u3 = null, c3 = l4 > 239 ? 4 : l4 > 223 ? 3 : l4 > 191 ? 2 : 1;
              if (i3 + c3 > r3)
                break;
              c3 === 1 ? l4 < 128 && (u3 = l4) : c3 === 2 ? (192 & (s3 = t4[i3 + 1])) == 128 && (u3 = (31 & l4) << 6 | 63 & s3) <= 127 && (u3 = null) : c3 === 3 ? (a3 = t4[i3 + 2], (192 & (s3 = t4[i3 + 1])) == 128 && (192 & a3) == 128 && ((u3 = (15 & l4) << 12 | (63 & s3) << 6 | 63 & a3) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : c3 === 4 && (a3 = t4[i3 + 2], o3 = t4[i3 + 3], (192 & (s3 = t4[i3 + 1])) == 128 && (192 & a3) == 128 && (192 & o3) == 128 && ((u3 = (15 & l4) << 18 | (63 & s3) << 12 | (63 & a3) << 6 | 63 & o3) <= 65535 || u3 >= 1114112) && (u3 = null)), u3 === null ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i3 += c3;
            }
            return n3;
          }(this.buf, e3, t3);
        }, readBytes: function() {
          var t3 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t3);
          return this.pos = t3, e3;
        }, readPackedVarint: function(t3, r3) {
          if (this.type !== e2.Bytes)
            return t3.push(this.readVarint(r3));
          var n3 = s2(this);
          for (t3 = t3 || [];this.pos < n3; )
            t3.push(this.readVarint(r3));
          return t3;
        }, readPackedSVarint: function(t3) {
          if (this.type !== e2.Bytes)
            return t3.push(this.readSVarint());
          var r3 = s2(this);
          for (t3 = t3 || [];this.pos < r3; )
            t3.push(this.readSVarint());
          return t3;
        }, readPackedBoolean: function(t3) {
          if (this.type !== e2.Bytes)
            return t3.push(this.readBoolean());
          var r3 = s2(this);
          for (t3 = t3 || [];this.pos < r3; )
            t3.push(this.readBoolean());
          return t3;
        }, readPackedFloat: function(t3) {
          if (this.type !== e2.Bytes)
            return t3.push(this.readFloat());
          var r3 = s2(this);
          for (t3 = t3 || [];this.pos < r3; )
            t3.push(this.readFloat());
          return t3;
        }, readPackedDouble: function(t3) {
          if (this.type !== e2.Bytes)
            return t3.push(this.readDouble());
          var r3 = s2(this);
          for (t3 = t3 || [];this.pos < r3; )
            t3.push(this.readDouble());
          return t3;
        }, readPackedFixed32: function(t3) {
          if (this.type !== e2.Bytes)
            return t3.push(this.readFixed32());
          var r3 = s2(this);
          for (t3 = t3 || [];this.pos < r3; )
            t3.push(this.readFixed32());
          return t3;
        }, readPackedSFixed32: function(t3) {
          if (this.type !== e2.Bytes)
            return t3.push(this.readSFixed32());
          var r3 = s2(this);
          for (t3 = t3 || [];this.pos < r3; )
            t3.push(this.readSFixed32());
          return t3;
        }, readPackedFixed64: function(t3) {
          if (this.type !== e2.Bytes)
            return t3.push(this.readFixed64());
          var r3 = s2(this);
          for (t3 = t3 || [];this.pos < r3; )
            t3.push(this.readFixed64());
          return t3;
        }, readPackedSFixed64: function(t3) {
          if (this.type !== e2.Bytes)
            return t3.push(this.readSFixed64());
          var r3 = s2(this);
          for (t3 = t3 || [];this.pos < r3; )
            t3.push(this.readSFixed64());
          return t3;
        }, skip: function(t3) {
          var r3 = 7 & t3;
          if (r3 === e2.Varint)
            for (;this.buf[this.pos++] > 127; )
              ;
          else if (r3 === e2.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (r3 === e2.Fixed32)
            this.pos += 4;
          else {
            if (r3 !== e2.Fixed64)
              throw new Error("Unimplemented type: " + r3);
            this.pos += 8;
          }
        }, writeTag: function(t3, e3) {
          this.writeVarint(t3 << 3 | e3);
        }, realloc: function(t3) {
          for (var e3 = this.length || 16;e3 < this.pos + t3; )
            e3 *= 2;
          if (e3 !== this.length) {
            var r3 = new Uint8Array(e3);
            r3.set(this.buf), this.buf = r3, this.length = e3;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t3) {
          this.realloc(4), x2(this.buf, t3, this.pos), this.pos += 4;
        }, writeSFixed32: function(t3) {
          this.realloc(4), x2(this.buf, t3, this.pos), this.pos += 4;
        }, writeFixed64: function(t3) {
          this.realloc(8), x2(this.buf, -1 & t3, this.pos), x2(this.buf, Math.floor(t3 * n2), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t3) {
          this.realloc(8), x2(this.buf, -1 & t3, this.pos), x2(this.buf, Math.floor(t3 * n2), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t3) {
          (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e3) {
            var r3, n3;
            if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552000 || t4 < -18446744073709552000)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e3.realloc(10), function(t5, e4, r4) {
              r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
            }(r3, 0, e3), function(t5, e4) {
              var r4 = (7 & t5) << 4;
              e4.buf[e4.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5)))));
            }(n3, e3);
          }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
        }, writeSVarint: function(t3) {
          this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
        }, writeBoolean: function(t3) {
          this.writeVarint(Boolean(t3));
        }, writeString: function(t3) {
          t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
          var e3 = this.pos;
          this.pos = function(t4, e4, r4) {
            for (var n3, i3, s3 = 0;s3 < e4.length; s3++) {
              if ((n3 = e4.charCodeAt(s3)) > 55295 && n3 < 57344) {
                if (!i3) {
                  n3 > 56319 || s3 + 1 === e4.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i3 = n3;
                  continue;
                }
                if (n3 < 56320) {
                  t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = n3;
                  continue;
                }
                n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
              } else
                i3 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = null);
              n3 < 128 ? t4[r4++] = n3 : (n3 < 2048 ? t4[r4++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r4++] = n3 >> 12 | 224 : (t4[r4++] = n3 >> 18 | 240, t4[r4++] = n3 >> 12 & 63 | 128), t4[r4++] = n3 >> 6 & 63 | 128), t4[r4++] = 63 & n3 | 128);
            }
            return r4;
          }(this.buf, t3, this.pos);
          var r3 = this.pos - e3;
          r3 >= 128 && o2(e3, r3, this), this.pos = e3 - 1, this.writeVarint(r3), this.pos += r3;
        }, writeFloat: function(e3) {
          this.realloc(4), t2.write(this.buf, e3, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(e3) {
          this.realloc(8), t2.write(this.buf, e3, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t3) {
          var e3 = t3.length;
          this.writeVarint(e3), this.realloc(e3);
          for (var r3 = 0;r3 < e3; r3++)
            this.buf[this.pos++] = t3[r3];
        }, writeRawMessage: function(t3, e3) {
          this.pos++;
          var r3 = this.pos;
          t3(e3, this);
          var n3 = this.pos - r3;
          n3 >= 128 && o2(r3, n3, this), this.pos = r3 - 1, this.writeVarint(n3), this.pos += n3;
        }, writeMessage: function(t3, r3, n3) {
          this.writeTag(t3, e2.Bytes), this.writeRawMessage(r3, n3);
        }, writePackedVarint: function(t3, e3) {
          e3.length && this.writeMessage(t3, l3, e3);
        }, writePackedSVarint: function(t3, e3) {
          e3.length && this.writeMessage(t3, u2, e3);
        }, writePackedBoolean: function(t3, e3) {
          e3.length && this.writeMessage(t3, p2, e3);
        }, writePackedFloat: function(t3, e3) {
          e3.length && this.writeMessage(t3, c2, e3);
        }, writePackedDouble: function(t3, e3) {
          e3.length && this.writeMessage(t3, h2, e3);
        }, writePackedFixed32: function(t3, e3) {
          e3.length && this.writeMessage(t3, f2, e3);
        }, writePackedSFixed32: function(t3, e3) {
          e3.length && this.writeMessage(t3, d2, e3);
        }, writePackedFixed64: function(t3, e3) {
          e3.length && this.writeMessage(t3, y2, e3);
        }, writePackedSFixed64: function(t3, e3) {
          e3.length && this.writeMessage(t3, m2, e3);
        }, writeBytesField: function(t3, r3) {
          this.writeTag(t3, e2.Bytes), this.writeBytes(r3);
        }, writeFixed32Field: function(t3, r3) {
          this.writeTag(t3, e2.Fixed32), this.writeFixed32(r3);
        }, writeSFixed32Field: function(t3, r3) {
          this.writeTag(t3, e2.Fixed32), this.writeSFixed32(r3);
        }, writeFixed64Field: function(t3, r3) {
          this.writeTag(t3, e2.Fixed64), this.writeFixed64(r3);
        }, writeSFixed64Field: function(t3, r3) {
          this.writeTag(t3, e2.Fixed64), this.writeSFixed64(r3);
        }, writeVarintField: function(t3, r3) {
          this.writeTag(t3, e2.Varint), this.writeVarint(r3);
        }, writeSVarintField: function(t3, r3) {
          this.writeTag(t3, e2.Varint), this.writeSVarint(r3);
        }, writeStringField: function(t3, r3) {
          this.writeTag(t3, e2.Bytes), this.writeString(r3);
        }, writeFloatField: function(t3, r3) {
          this.writeTag(t3, e2.Fixed32), this.writeFloat(r3);
        }, writeDoubleField: function(t3, r3) {
          this.writeTag(t3, e2.Fixed64), this.writeDouble(r3);
        }, writeBooleanField: function(t3, e3) {
          this.writeVarintField(t3, Boolean(e3));
        } }, Ku;
      }
      var Qu = r(Wu());
      const tc = 3;
      function ec(t2, e2, r2) {
        t2 === 1 && r2.readMessage(rc, e2);
      }
      function rc(t2, e2, r2) {
        if (t2 === 3) {
          const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l3 } = r2.readMessage(nc, {});
          e2.push({ id: t3, bitmap: new Qo2({ width: i2 + 2 * tc, height: s2 + 2 * tc }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l3 } });
        }
      }
      function nc(t2, e2, r2) {
        t2 === 1 ? e2.id = r2.readVarint() : t2 === 2 ? e2.bitmap = r2.readBytes() : t2 === 3 ? e2.width = r2.readVarint() : t2 === 4 ? e2.height = r2.readVarint() : t2 === 5 ? e2.left = r2.readSVarint() : t2 === 6 ? e2.top = r2.readSVarint() : t2 === 7 && (e2.advance = r2.readVarint());
      }
      const ic = tc;
      function sc(t2) {
        let e2 = 0, r2 = 0;
        for (const n3 of t2)
          e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
        t2.sort((t3, e3) => e3.h - t3.h);
        const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
        let i2 = 0, s2 = 0;
        for (const e3 of t2)
          for (let t3 = n2.length - 1;t3 >= 0; t3--) {
            const r3 = n2[t3];
            if (!(e3.w > r3.w || e3.h > r3.h)) {
              if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                const e4 = n2.pop();
                t3 < n2.length && (n2[t3] = e4);
              } else
                e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
              break;
            }
          }
        return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
      }
      const ac = 1;

      class oc {
        constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2, textFitWidth: a2, textFitHeight: o2 }) {
          this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2, this.textFitWidth = a2, this.textFitHeight = o2;
        }
        get tl() {
          return [this.paddedRect.x + ac, this.paddedRect.y + ac];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - ac, this.paddedRect.y + this.paddedRect.h - ac];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * ac) / this.pixelRatio, (this.paddedRect.h - 2 * ac) / this.pixelRatio];
        }
      }

      class lc {
        constructor(t2, e2) {
          const r2 = {}, n2 = {};
          this.haveRenderCallbacks = [];
          const i2 = [];
          this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
          const { w: s2, h: a2 } = sc(i2), o2 = new tl({ width: s2 || 1, height: a2 || 1 });
          for (const e3 in t2) {
            const n3 = t2[e3], i3 = r2[e3].paddedRect;
            tl.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + ac, y: i3.y + ac }, n3.data);
          }
          for (const t3 in e2) {
            const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + ac, a3 = i3.y + ac, l3 = r3.data.width, u2 = r3.data.height;
            tl.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), tl.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l3, height: 1 }), tl.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l3, height: 1 }), tl.copy(r3.data, o2, { x: l3 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), tl.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l3, y: a3 }, { width: 1, height: u2 });
          }
          this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
        }
        addImages(t2, e2, r2) {
          for (const n2 in t2) {
            const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2 * ac, h: i2.data.height + 2 * ac };
            r2.push(s2), e2[n2] = new oc(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
          }
        }
        patchUpdatedImages(t2, e2) {
          t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const r2 in t2.updatedImages)
            this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
        }
        patchUpdatedImage(t2, e2, r2) {
          if (!t2 || !e2)
            return;
          if (t2.version === e2.version)
            return;
          t2.version = e2.version;
          const [n2, i2] = t2.tl;
          r2.update(e2.data, undefined, { x: n2, y: i2 });
        }
      }
      var uc;
      is("ImagePosition", oc), is("ImageAtlas", lc), t.al = undefined, (uc = t.al || (t.al = {}))[uc.none = 0] = "none", uc[uc.horizontal = 1] = "horizontal", uc[uc.vertical = 2] = "vertical", uc[uc.horizontalOnly = 3] = "horizontalOnly";
      const cc = -17;

      class hc {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
        }
        static forText(t2, e2, r2) {
          const n2 = new hc;
          return n2.scale = t2 || 1, n2.fontStack = e2, n2.verticalAlign = r2 || "bottom", n2;
        }
        static forImage(t2, e2) {
          const r2 = new hc;
          return r2.imageName = t2, r2.verticalAlign = e2 || "bottom", r2;
        }
      }

      class pc {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t2, e2) {
          const r2 = new pc;
          for (let n2 = 0;n2 < t2.sections.length; n2++) {
            const i2 = t2.sections[n2];
            i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
          }
          return r2;
        }
        length() {
          return this.text.length;
        }
        getSection(t2) {
          return this.sections[this.sectionIndex[t2]];
        }
        getSectionIndex(t2) {
          return this.sectionIndex[t2];
        }
        getCharCode(t2) {
          return this.text.charCodeAt(t2);
        }
        verticalizePunctuation() {
          this.text = function(t2) {
            let e2 = "";
            for (let r2 = 0;r2 < t2.length; r2++) {
              const n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
              e2 += n2 && vs(n2) && !Gu[t2[r2 + 1]] || i2 && vs(i2) && !Gu[t2[r2 - 1]] || !Gu[t2[r2]] ? t2[r2] : Gu[t2[r2]];
            }
            return e2;
          }(this.text);
        }
        trim() {
          let t2 = 0;
          for (let e3 = 0;e3 < this.text.length && dc[this.text.charCodeAt(e3)]; e3++)
            t2++;
          let e2 = this.text.length;
          for (let r2 = this.text.length - 1;r2 >= 0 && r2 >= t2 && dc[this.text.charCodeAt(r2)]; r2--)
            e2--;
          this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
        }
        substring(t2, e2) {
          const r2 = new pc;
          return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
        }
        getMaxImageSize(t2) {
          let e2 = 0, r2 = 0;
          for (let n2 = 0;n2 < this.length(); n2++) {
            const i2 = this.getSection(n2);
            if (i2.imageName) {
              const n3 = t2[i2.imageName];
              if (!n3)
                continue;
              const s2 = n3.displaySize;
              e2 = Math.max(e2, s2[0]), r2 = Math.max(r2, s2[1]);
            }
          }
          return { maxImageWidth: e2, maxImageHeight: r2 };
        }
        addTextSection(t2, e2) {
          this.text += t2.text, this.sections.push(hc.forText(t2.scale, t2.fontStack || e2, t2.verticalAlign));
          const r2 = this.sections.length - 1;
          for (let e3 = 0;e3 < t2.text.length; ++e3)
            this.sectionIndex.push(r2);
        }
        addImageSection(t2) {
          const e2 = t2.image ? t2.image.name : "";
          if (e2.length === 0)
            return void U("Can't add FormattedSection with an empty image.");
          const r2 = this.getNextImageSectionCharCode();
          r2 ? (this.text += String.fromCharCode(r2), this.sections.push(hc.forImage(e2, t2.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : U("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function fc(e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y2) {
        const m2 = pc.fromFeature(e2, s2);
        let g2;
        p2 === t.al.vertical && m2.verticalizePunctuation();
        const { processBidirectionalText: x2, processStyledBidirectionalText: v2 } = Ss;
        if (x2 && m2.sections.length === 1) {
          g2 = [];
          const t2 = x2(m2.toString(), _c(m2, c2, a2, r2, i2, d2));
          for (const e3 of t2) {
            const t3 = new pc;
            t3.text = e3, t3.sections = m2.sections;
            for (let r3 = 0;r3 < e3.length; r3++)
              t3.sectionIndex.push(0);
            g2.push(t3);
          }
        } else if (v2) {
          g2 = [];
          const t2 = v2(m2.text, m2.sectionIndex, _c(m2, c2, a2, r2, i2, d2));
          for (const e3 of t2) {
            const t3 = new pc;
            t3.text = e3[0], t3.sectionIndex = e3[1], t3.sections = m2.sections, g2.push(t3);
          }
        } else
          g2 = function(t2, e3) {
            const r3 = [], n3 = t2.text;
            let i3 = 0;
            for (const n4 of e3)
              r3.push(t2.substring(i3, n4)), i3 = n4;
            return i3 < n3.length && r3.push(t2.substring(i3, n3.length)), r3;
          }(m2, _c(m2, c2, a2, r2, i2, d2));
        const b2 = [], w2 = { positionedLines: b2, text: m2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: false, verticalizable: false };
        return function(t2, e3, r3, n3, i3, s3, a3, o3, l4, u3, c3, h3) {
          let p3 = 0, f3 = 0, d3 = 0, y3 = 0;
          const m3 = o3 === "right" ? 1 : o3 === "left" ? 0 : 0.5, g3 = Hu / h3;
          let x3 = 0;
          for (const a4 of i3) {
            a4.trim();
            const i4 = a4.getMaxScale(), o4 = { positionedGlyphs: [], lineOffset: 0 };
            t2.positionedLines[x3] = o4;
            const h4 = o4.positionedGlyphs;
            let v4 = 0;
            if (!a4.length()) {
              f3 += s3, ++x3;
              continue;
            }
            const b4 = Sc(n3, a4, g3);
            for (let s4 = 0;s4 < a4.length(); s4++) {
              const o5 = a4.getSection(s4), d4 = a4.getSectionIndex(s4), y4 = a4.getCharCode(s4), m4 = Mc(l4, c3, y4);
              let x4;
              if (o5.imageName) {
                if (t2.iconsInText = true, o5.scale = o5.scale * g3, x4 = zc(o5, m4, i4, b4, n3), !x4)
                  continue;
                v4 = Math.max(v4, x4.imageOffset);
              } else if (x4 = Ic(o5, y4, m4, b4, e3, r3), !x4)
                continue;
              const { rect: w4, metrics: _2, baselineOffset: A2 } = x4;
              h4.push({ glyph: y4, imageName: o5.imageName, x: p3, y: f3 + A2 + cc, vertical: m4, scale: o5.scale, fontStack: o5.fontStack, sectionIndex: d4, metrics: _2, rect: w4 }), m4 ? (t2.verticalizable = true, p3 += (o5.imageName ? _2.advance : Hu) * o5.scale + u3) : p3 += _2.advance * o5.scale + u3;
            }
            h4.length !== 0 && (d3 = Math.max(p3 - u3, d3), Pc(h4, 0, h4.length - 1, m3)), p3 = 0, o4.lineOffset = Math.max(v4, (i4 - 1) * Hu);
            const w3 = s3 * i4 + v4;
            f3 += w3, y3 = Math.max(w3, y3), ++x3;
          }
          const { horizontalAlign: v3, verticalAlign: b3 } = Ac(a3);
          (function(t3, e4, r4, n4, i4, s4, a4, o4, l5) {
            const u4 = (e4 - r4) * i4;
            let c4 = 0;
            c4 = s4 !== a4 ? -o4 * n4 - cc : -n4 * l5 * a4 + 0.5 * a4;
            for (const e5 of t3)
              for (const t4 of e5.positionedGlyphs)
                t4.x += u4, t4.y += c4;
          })(t2.positionedLines, m3, v3, b3, d3, y3, s3, f3, i3.length), t2.top += -b3 * f3, t2.bottom = t2.top + f3, t2.left += -v3 * d3, t2.right = t2.left + d3;
        }(w2, r2, n2, i2, g2, o2, l3, u2, p2, c2, f2, y2), !function(t2) {
          for (const e3 of t2)
            if (e3.positionedGlyphs.length !== 0)
              return false;
          return true;
        }(b2) && w2;
      }
      const dc = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, yc = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, mc = { 40: true };
      function gc(t2, e2, r2, n2, i2, s2) {
        if (e2.imageName) {
          const t3 = n2[e2.imageName];
          return t3 ? t3.displaySize[0] * e2.scale * Hu / s2 + i2 : 0;
        }
        {
          const n3 = r2[e2.fontStack], s3 = n3 && n3[t2];
          return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
        }
      }
      function xc(t2, e2, r2, n2) {
        const i2 = Math.pow(t2 - e2, 2);
        return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
      }
      function vc(t2, e2, r2) {
        let n2 = 0;
        return t2 === 10 && (n2 -= 1e4), r2 && (n2 += 150), t2 !== 40 && t2 !== 65288 || (n2 += 50), e2 !== 41 && e2 !== 65289 || (n2 += 50), n2;
      }
      function bc(t2, e2, r2, n2, i2, s2) {
        let a2 = null, o2 = xc(e2, r2, i2, s2);
        for (const t3 of n2) {
          const n3 = xc(e2 - t3.x, r2, i2, s2) + t3.badness;
          n3 <= o2 && (a2 = t3, o2 = n3);
        }
        return { index: t2, x: e2, priorBreak: a2, badness: o2 };
      }
      function wc(t2) {
        return t2 ? wc(t2.priorBreak).concat(t2.index) : [];
      }
      function _c(t2, e2, r2, n2, i2, s2) {
        if (!t2)
          return [];
        const a2 = [], o2 = function(t3, e3, r3, n3, i3, s3) {
          let a3 = 0;
          for (let r4 = 0;r4 < t3.length(); r4++) {
            const o3 = t3.getSection(r4);
            a3 += gc(t3.getCharCode(r4), o3, n3, i3, e3, s3);
          }
          return a3 / Math.max(1, Math.ceil(a3 / r3));
        }(t2, e2, r2, n2, i2, s2), l3 = t2.text.indexOf("​") >= 0;
        let u2 = 0;
        for (let r3 = 0;r3 < t2.length(); r3++) {
          const h2 = t2.getSection(r3), p2 = t2.getCharCode(r3);
          if (dc[p2] || (u2 += gc(p2, h2, n2, i2, e2, s2)), r3 < t2.length() - 1) {
            const e3 = !((c2 = p2) < 11904) && (!!hs["CJK Compatibility Forms"](c2) || !!hs["CJK Compatibility"](c2) || !!hs["CJK Strokes"](c2) || !!hs["CJK Symbols and Punctuation"](c2) || !!hs["Enclosed CJK Letters and Months"](c2) || !!hs["Halfwidth and Fullwidth Forms"](c2) || !!hs["Ideographic Description Characters"](c2) || !!hs["Vertical Forms"](c2) || gs.test(String.fromCodePoint(c2)));
            (yc[p2] || e3 || h2.imageName || r3 !== t2.length() - 2 && mc[t2.getCharCode(r3 + 1)]) && a2.push(bc(r3 + 1, u2, o2, a2, vc(p2, t2.getCharCode(r3 + 1), e3 && l3), false));
          }
        }
        var c2;
        return wc(bc(t2.length(), u2, o2, a2, 0, true));
      }
      function Ac(t2) {
        let e2 = 0.5, r2 = 0.5;
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            e2 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e2 = 0;
        }
        switch (t2) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r2 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r2 = 0;
        }
        return { horizontalAlign: e2, verticalAlign: r2 };
      }
      function Sc(t2, e2, r2) {
        const n2 = e2.getMaxScale() * Hu, { maxImageWidth: i2, maxImageHeight: s2 } = e2.getMaxImageSize(t2), a2 = Math.max(n2, s2 * r2);
        return { verticalLineContentWidth: Math.max(n2, i2 * r2), horizontalLineContentHeight: a2 };
      }
      function kc(t2) {
        switch (t2) {
          case "top":
            return 0;
          case "center":
            return 0.5;
          default:
            return 1;
        }
      }
      function Mc(e2, r2, n2) {
        return !(e2 === t.al.horizontal || !r2 && !xs(n2) || r2 && (dc[n2] || (i2 = n2, /\p{sc=Arab}/u.test(String.fromCodePoint(i2)))));
        var i2;
      }
      function Ic(t2, e2, r2, n2, i2, s2) {
        const a2 = s2[t2.fontStack], o2 = function(t3, e3, r3, n3) {
          if (t3 && t3.rect)
            return t3;
          const i3 = e3[r3.fontStack], s3 = i3 && i3[n3];
          return s3 ? { rect: null, metrics: s3.metrics } : null;
        }(a2 && a2[e2], i2, t2, e2);
        if (o2 === null)
          return null;
        let l3;
        if (r2)
          l3 = n2.verticalLineContentWidth - t2.scale * Hu;
        else {
          const e3 = kc(t2.verticalAlign);
          l3 = (n2.horizontalLineContentHeight - t2.scale * Hu) * e3;
        }
        return { rect: o2.rect, metrics: o2.metrics, baselineOffset: l3 };
      }
      function zc(t2, e2, r2, n2, i2) {
        const s2 = i2[t2.imageName];
        if (!s2)
          return null;
        const { paddedRect: a2, displaySize: o2 } = s2, l3 = { width: o2[0], height: o2[1], left: ac, top: -3, advance: e2 ? o2[1] : o2[0] };
        let u2;
        if (e2)
          u2 = n2.verticalLineContentWidth - o2[1] * t2.scale;
        else {
          const e3 = kc(t2.verticalAlign);
          u2 = (n2.horizontalLineContentHeight - o2[1] * t2.scale) * e3;
        }
        return { rect: a2, metrics: l3, baselineOffset: u2, imageOffset: (e2 ? o2[0] : o2[1]) * t2.scale - Hu * r2 };
      }
      function Pc(t2, e2, r2, n2) {
        if (n2 === 0)
          return;
        const i2 = t2[r2], s2 = (t2[r2].x + i2.metrics.advance * i2.scale) * n2;
        for (let n3 = e2;n3 <= r2; n3++)
          t2[n3].x -= s2;
      }
      function Cc(t2, e2, r2) {
        const { horizontalAlign: n2, verticalAlign: i2 } = Ac(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
        return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
      }
      function Bc(t2) {
        var e2, r2;
        let { left: n2, top: i2 } = t2, s2 = t2.right - n2, a2 = t2.bottom - i2;
        const o2 = (e2 = t2.image.textFitWidth) !== null && e2 !== undefined ? e2 : "stretchOrShrink", l3 = (r2 = t2.image.textFitHeight) !== null && r2 !== undefined ? r2 : "stretchOrShrink", u2 = (t2.image.content[2] - t2.image.content[0]) / (t2.image.content[3] - t2.image.content[1]);
        if (l3 === "proportional") {
          if (o2 === "stretchOnly" && s2 / a2 < u2 || o2 === "proportional") {
            const t3 = Math.ceil(a2 * u2);
            n2 *= t3 / s2, s2 = t3;
          }
        } else if (o2 === "proportional" && l3 === "stretchOnly" && u2 !== 0 && s2 / a2 > u2) {
          const t3 = Math.ceil(s2 / u2);
          i2 *= t3 / a2, a2 = t3;
        }
        return { x1: n2, y1: i2, x2: n2 + s2, y2: i2 + a2 };
      }
      function Vc(t2, e2, r2, n2, i2, s2) {
        const a2 = t2.image;
        let o2;
        if (a2.content) {
          const t3 = a2.content, e3 = a2.pixelRatio || 1;
          o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
        }
        const l3 = e2.left * s2, u2 = e2.right * s2;
        let c2, h2, p2, f2;
        r2 === "width" || r2 === "both" ? (f2 = i2[0] + l3 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l3 + u2 - a2.displaySize[0]) / 2, h2 = f2 + a2.displaySize[0]);
        const d2 = e2.top * s2, y2 = e2.bottom * s2;
        return r2 === "height" || r2 === "both" ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
      }
      const Ec = 255, Tc = 128, Fc = Ec * Tc;
      function $c(t2, e2) {
        const { expression: r2 } = e2;
        if (r2.kind === "constant")
          return { kind: "constant", layoutSize: r2.evaluate(new ks(t2 + 1)) };
        if (r2.kind === "source")
          return { kind: "source" };
        {
          const { zoomStops: e3, interpolationType: n2 } = r2;
          let i2 = 0;
          for (;i2 < e3.length && e3[i2] <= t2; )
            i2++;
          i2 = Math.max(0, i2 - 1);
          let s2 = i2;
          for (;s2 < e3.length && e3[s2] < t2 + 1; )
            s2++;
          s2 = Math.min(e3.length - 1, s2);
          const a2 = e3[i2], o2 = e3[s2];
          return r2.kind === "composite" ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new ks(a2)), maxSize: r2.evaluate(new ks(o2)), interpolationType: n2 };
        }
      }
      function Lc(t2, e2, r2) {
        let n2 = "never";
        const i2 = t2.get(e2);
        return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
      }
      const Oc = hu.VectorTileFeature.types, Dc = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function jc(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2) {
        const f2 = o2 ? Math.min(Fc, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(Fc, Math.round(o2[1])) : 0;
        t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l3 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
      }
      function Rc(t2, e2, r2) {
        t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
      }
      function Nc(t2) {
        for (const e2 of t2.sections)
          if (As(e2.text))
            return true;
        return false;
      }

      class Uc {
        constructor(t2) {
          this.layoutVertexArray = new Fa, this.indexArray = new ja, this.programConfigurations = t2, this.segments = new qa, this.dynamicLayoutVertexArray = new $a, this.opacityVertexArray = new La, this.hasVisibleVertices = false, this.placedSymbolArray = new va;
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(t2, e2, r2, n2) {
          this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Du.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, ju.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Dc, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      is("SymbolBuffers", Uc);

      class qc {
        constructor(t2, e2, r2) {
          this.layoutVertexArray = new t2, this.layoutAttributes = e2, this.indexArray = new r2, this.segments = new qa, this.collisionVertexArray = new Da;
        }
        upload(t2) {
          this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Ru.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      is("CollisionBuffers", qc);

      class Gc {
        constructor(e2) {
          this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t2) => t2.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
          const r2 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = $c(this.zoom, r2["text-size"]), this.iconSizeData = $c(this.zoom, r2["icon-size"]);
          const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
          this.canOverlap = Lc(n2, "text-overlap", "text-allow-overlap") !== "never" || Lc(n2, "icon-overlap", "icon-allow-overlap") !== "never" || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = s2 !== "viewport-y" && !i2.isConstant(), this.sortFeaturesByY = (s2 === "viewport-y" || s2 === "auto" && !this.sortFeaturesByKey) && this.canOverlap, n2.get("symbol-placement") === "point" && (this.writingModes = n2.get("text-writing-mode").map((e3) => t.al[e3])), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e2.sourceID;
        }
        createArrays() {
          this.text = new Uc(new xo2(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new Uc(new xo2(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new _a, this.lineVertexArray = new Aa, this.symbolInstances = new wa, this.textAnchorOffsets = new ka;
        }
        calculateGlyphDependencies(t2, e2, r2, n2, i2) {
          for (let s2 = 0;s2 < t2.length; s2++)
            if (e2[t2.charCodeAt(s2)] = true, (r2 || n2) && i2) {
              const r3 = Gu[t2.charAt(s2)];
              r3 && (e2[r3.charCodeAt(0)] = true);
            }
        }
        populate(e2, r2, n2) {
          const i2 = this.layers[0], s2 = i2.layout, a2 = s2.get("text-font"), o2 = s2.get("text-field"), l3 = s2.get("icon-image"), u2 = (o2.value.kind !== "constant" || o2.value.value instanceof Pe2 && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && (a2.value.kind !== "constant" || a2.value.value.length > 0), c2 = l3.value.kind !== "constant" || !!l3.value.value || Object.keys(l3.parameters).length > 0, h2 = s2.get("symbol-sort-key");
          if (this.features = [], !u2 && !c2)
            return;
          const { iconDependencies: p2, glyphDependencies: f2, availableImages: d2 } = r2, y2 = new ks(this.zoom);
          for (const { feature: r3, id: o3, index: l4, sourceLayerIndex: m2 } of e2) {
            const e3 = i2._featureFilter.needGeometry, g2 = So2(r3, e3);
            if (!i2._featureFilter.filter(y2, g2, n2))
              continue;
            let x2, v2;
            if (e3 || (g2.geometry = Ao2(r3)), u2) {
              const t2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), e4 = Pe2.factory(t2), r4 = this.hasRTLText = this.hasRTLText || Nc(e4);
              (!r4 || Ss.getRTLTextPluginStatus() === "unavailable" || r4 && Ss.isParsed()) && (x2 = qu(e4, i2, g2));
            }
            if (c2) {
              const t2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
              v2 = t2 instanceof $e2 ? t2 : $e2.fromString(t2);
            }
            if (!x2 && !v2)
              continue;
            const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : undefined;
            if (this.features.push({ id: o3, text: x2, icon: v2, index: l4, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: Oc[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x2) {
              const e4 = a2.evaluate(g2, {}, n2).join(","), r4 = s2.get("text-rotation-alignment") !== "viewport" && s2.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.al.vertical) >= 0;
              for (const t2 of x2.sections)
                if (t2.image)
                  p2[t2.image.name] = true;
                else {
                  const n3 = ps(x2.toString()), i3 = t2.fontStack || e4, s3 = f2[i3] = f2[i3] || {};
                  this.calculateGlyphDependencies(t2.text, s3, r4, this.allowVerticalPlacement, n3);
                }
            }
          }
          s2.get("symbol-placement") === "line" && (this.features = function(t2) {
            const e3 = {}, r3 = {}, n3 = [];
            let i3 = 0;
            function s3(e4) {
              n3.push(t2[e4]), i3++;
            }
            function a3(t3, e4, i4) {
              const s4 = r3[t3];
              return delete r3[t3], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
            }
            function o3(t3, r4, i4) {
              const s4 = e3[r4];
              return delete e3[r4], e3[t3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
            }
            function l4(t3, e4, r4) {
              const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
              return `${t3}:${n4.x}:${n4.y}`;
            }
            for (let u3 = 0;u3 < t2.length; u3++) {
              const c3 = t2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
              if (!p3) {
                s3(u3);
                continue;
              }
              const f3 = l4(p3, h3), d3 = l4(p3, h3, true);
              if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                const t3 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t3].geometry);
                delete e3[f3], delete r3[d3], r3[l4(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
              } else
                f3 in r3 ? a3(f3, d3, h3) : (d3 in e3) ? o3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
            }
            return n3.filter((t3) => t3.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e3) => t2.sortKey - e3.sortKey);
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t2) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t2, e2) {
          const r2 = this.lineVertexArray.length;
          if (t2.segment !== undefined) {
            let r3 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]);
            const i2 = {};
            for (let n3 = t2.segment + 1;n3 < e2.length; n3++)
              i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
            for (let r4 = t2.segment || 0;r4 >= 0; r4--)
              i2[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
            for (let t3 = 0;t3 < e2.length; t3++) {
              const e3 = i2[t3];
              this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
        }
        addSymbols(e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2) {
          const { indexArray: f2, layoutVertexArray: d2 } = e2, y2 = e2.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? a2.sortKey : undefined), m2 = this.glyphOffsetArray.length, g2 = y2.vertexLength, x2 = this.allowVerticalPlacement && o2 === t.al.vertical ? Math.PI / 2 : 0, v2 = a2.text && a2.text.sections;
          for (let t2 = 0;t2 < r2.length; t2++) {
            const { tl: i3, tr: s3, bl: o3, br: u3, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w2, isSDF: _2, sectionIndex: A2 } = r2[t2], S2 = y2.vertexLength, k2 = w2[1];
            jc(d2, l3.x, l3.y, i3.x, k2 + i3.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), jc(d2, l3.x, l3.y, s3.x, k2 + s3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), jc(d2, l3.x, l3.y, o3.x, k2 + o3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), jc(d2, l3.x, l3.y, u3.x, k2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), Rc(e2.dynamicLayoutVertexArray, l3, x2), f2.emplaceBack(S2, S2 + 2, S2 + 1), f2.emplaceBack(S2 + 1, S2 + 2, S2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t2 !== r2.length - 1 && A2 === r2[t2 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d2.length, a2, a2.index, {}, p2, v2 && v2[A2]);
          }
          e2.placedSymbolArray.emplaceBack(l3.x, l3.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l3.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, false, 0, h2);
        }
        _addCollisionDebugVertex(t2, e2, r2, n2, i2, s2) {
          return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(s2.x), Math.round(s2.y));
        }
        addCollisionDebugVertices(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), u2 = o2.vertexLength, c2 = i2.layoutVertexArray, h2 = i2.collisionVertexArray, p2 = a2.anchorX, f2 = a2.anchorY;
          this._addCollisionDebugVertex(c2, h2, s2, p2, f2, new l2(t2, e2)), this._addCollisionDebugVertex(c2, h2, s2, p2, f2, new l2(r2, e2)), this._addCollisionDebugVertex(c2, h2, s2, p2, f2, new l2(r2, n2)), this._addCollisionDebugVertex(c2, h2, s2, p2, f2, new l2(t2, n2)), o2.vertexLength += 4;
          const d2 = i2.indexArray;
          d2.emplaceBack(u2, u2 + 1), d2.emplaceBack(u2 + 1, u2 + 2), d2.emplaceBack(u2 + 2, u2 + 3), d2.emplaceBack(u2 + 3, u2), o2.primitiveLength += 4;
        }
        addDebugCollisionBoxes(t2, e2, r2, n2) {
          for (let i2 = t2;i2 < e2; i2++) {
            const t3 = this.collisionBoxArray.get(i2);
            this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new qc(Oa, Nu.members, Ra), this.iconCollisionBox = new qc(Oa, Nu.members, Ra);
          for (let t2 = 0;t2 < this.symbolInstances.length; t2++) {
            const e2 = this.symbolInstances.get(t2);
            this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
          }
        }
        _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l3) {
          const u2 = {};
          for (let n3 = e2;n3 < r2; n3++) {
            const e3 = t2.get(n3);
            u2.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u2.textFeatureIndex = e3.featureIndex;
            break;
          }
          for (let e3 = n2;e3 < i2; e3++) {
            const r3 = t2.get(e3);
            u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
            break;
          }
          for (let e3 = s2;e3 < a2; e3++) {
            const r3 = t2.get(e3);
            u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
            break;
          }
          for (let e3 = o2;e3 < l3; e3++) {
            const r3 = t2.get(e3);
            u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
            break;
          }
          return u2;
        }
        deserializeCollisionBoxes(t2) {
          this.collisionArrays = [];
          for (let e2 = 0;e2 < this.symbolInstances.length; e2++) {
            const r2 = this.symbolInstances.get(e2);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(t2, e2) {
          const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
          for (let e3 = r2.vertexStartIndex;e3 < n2; e3 += 4)
            t2.indexArray.emplaceBack(e3, e3 + 2, e3 + 1), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
        }
        getSortedSymbolIndexes(t2) {
          if (this.sortedAngle === t2 && this.symbolInstanceIndexes !== undefined)
            return this.symbolInstanceIndexes;
          const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
          for (let t3 = 0;t3 < this.symbolInstances.length; ++t3) {
            s2.push(t3);
            const a2 = this.symbolInstances.get(t3);
            n2.push(0 | Math.round(e2 * a2.anchorX + r2 * a2.anchorY)), i2.push(a2.featureIndex);
          }
          return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
        }
        addToSortKeyRanges(t2, e2) {
          const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
        }
        sortFeatures(t2) {
          if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const t3 of this.symbolInstanceIndexes) {
              const e2 = this.symbolInstances.get(t3);
              this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t4, e3, r2) => {
                t4 >= 0 && r2.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
              }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let Zc, Kc;
      is("SymbolBucket", Gc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Gc.MAX_GLYPHS = 65535, Gc.addDynamicAttributes = Rc;
      var Xc = { get paint() {
        return Kc = Kc || new Ds({ "icon-opacity": new Fs(gt2.paint_symbol["icon-opacity"]), "icon-color": new Fs(gt2.paint_symbol["icon-color"]), "icon-halo-color": new Fs(gt2.paint_symbol["icon-halo-color"]), "icon-halo-width": new Fs(gt2.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Fs(gt2.paint_symbol["icon-halo-blur"]), "icon-translate": new Ts(gt2.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ts(gt2.paint_symbol["icon-translate-anchor"]), "text-opacity": new Fs(gt2.paint_symbol["text-opacity"]), "text-color": new Fs(gt2.paint_symbol["text-color"], { runtimeType: Lt2, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new Fs(gt2.paint_symbol["text-halo-color"]), "text-halo-width": new Fs(gt2.paint_symbol["text-halo-width"]), "text-halo-blur": new Fs(gt2.paint_symbol["text-halo-blur"]), "text-translate": new Ts(gt2.paint_symbol["text-translate"]), "text-translate-anchor": new Ts(gt2.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return Zc = Zc || new Ds({ "symbol-placement": new Ts(gt2.layout_symbol["symbol-placement"]), "symbol-spacing": new Ts(gt2.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ts(gt2.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Fs(gt2.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ts(gt2.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Ts(gt2.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Ts(gt2.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Ts(gt2.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ts(gt2.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ts(gt2.layout_symbol["icon-rotation-alignment"]), "icon-size": new Fs(gt2.layout_symbol["icon-size"]), "icon-text-fit": new Ts(gt2.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ts(gt2.layout_symbol["icon-text-fit-padding"]), "icon-image": new Fs(gt2.layout_symbol["icon-image"]), "icon-rotate": new Fs(gt2.layout_symbol["icon-rotate"]), "icon-padding": new Fs(gt2.layout_symbol["icon-padding"]), "icon-keep-upright": new Ts(gt2.layout_symbol["icon-keep-upright"]), "icon-offset": new Fs(gt2.layout_symbol["icon-offset"]), "icon-anchor": new Fs(gt2.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ts(gt2.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ts(gt2.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ts(gt2.layout_symbol["text-rotation-alignment"]), "text-field": new Fs(gt2.layout_symbol["text-field"]), "text-font": new Fs(gt2.layout_symbol["text-font"]), "text-size": new Fs(gt2.layout_symbol["text-size"]), "text-max-width": new Fs(gt2.layout_symbol["text-max-width"]), "text-line-height": new Ts(gt2.layout_symbol["text-line-height"]), "text-letter-spacing": new Fs(gt2.layout_symbol["text-letter-spacing"]), "text-justify": new Fs(gt2.layout_symbol["text-justify"]), "text-radial-offset": new Fs(gt2.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ts(gt2.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Fs(gt2.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Fs(gt2.layout_symbol["text-anchor"]), "text-max-angle": new Ts(gt2.layout_symbol["text-max-angle"]), "text-writing-mode": new Ts(gt2.layout_symbol["text-writing-mode"]), "text-rotate": new Fs(gt2.layout_symbol["text-rotate"]), "text-padding": new Ts(gt2.layout_symbol["text-padding"]), "text-keep-upright": new Ts(gt2.layout_symbol["text-keep-upright"]), "text-transform": new Fs(gt2.layout_symbol["text-transform"]), "text-offset": new Fs(gt2.layout_symbol["text-offset"]), "text-allow-overlap": new Ts(gt2.layout_symbol["text-allow-overlap"]), "text-overlap": new Ts(gt2.layout_symbol["text-overlap"]), "text-ignore-placement": new Ts(gt2.layout_symbol["text-ignore-placement"]), "text-optional": new Ts(gt2.layout_symbol["text-optional"]) });
      } };

      class Hc {
        constructor(t2) {
          if (t2.property.overrides === undefined)
            throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = t2.property.overrides ? t2.property.overrides.runtimeType : Et2, this.defaultValue = t2;
        }
        evaluate(t2) {
          if (t2.formattedSection) {
            const e2 = this.defaultValue.property.overrides;
            if (e2 && e2.hasOverride(t2.formattedSection))
              return e2.getOverride(t2.formattedSection);
          }
          return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t2) {
          this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      is("FormatSectionOverride", Hc, { omit: ["defaultValue"] });

      class Yc extends Rs {
        constructor(t2) {
          super(t2, Xc);
        }
        recalculate(t2, e2) {
          if (super.recalculate(t2, e2), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const t3 = this.layout.get("text-writing-mode");
            if (t3) {
              const e3 = [];
              for (const r2 of t3)
                e3.indexOf(r2) < 0 && e3.push(r2);
              this.layout._values["text-writing-mode"] = e3;
            } else
              this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t2, e2, r2, n2) {
          const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
          return s2.isDataDriven() || ti2(s2.value) || !i2 ? i2 : function(t3, e3) {
            return e3.replace(/{([^{}]+)}/g, (e4, r3) => t3 && (r3 in t3) ? String(t3[r3]) : "");
          }(e2.properties, i2);
        }
        createBucket(t2) {
          return new Gc(t2);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const t2 of Xc.paint.overridableProperties) {
            if (!Yc.hasPaintOverride(this.layout, t2))
              continue;
            const e2 = this.paint.get(t2), r2 = new Hc(e2), n2 = new Qn(r2, e2.property.specification);
            let i2 = null;
            i2 = e2.value.kind === "constant" || e2.value.kind === "source" ? new ri2("source", n2) : new ni2("composite", n2, e2.value.zoomStops), this.paint._values[t2] = new Vs(e2.property, i2, e2.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
          return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && Yc.hasPaintOverride(this.layout, t2);
        }
        static hasPaintOverride(t2, e2) {
          const r2 = t2.get("text-field"), n2 = Xc.paint.properties[e2];
          let i2 = false;
          const s2 = (t3) => {
            for (const e3 of t3)
              if (n2.overrides && n2.overrides.hasOverride(e3))
                return void (i2 = true);
          };
          if (r2.value.kind === "constant" && r2.value.value instanceof Pe2)
            s2(r2.value.value.sections);
          else if (r2.value.kind === "source") {
            const t3 = (e4) => {
              i2 || (e4 instanceof Ne2 && je2(e4.value) === Nt2 ? s2(e4.value.sections) : e4 instanceof Mr2 ? s2(e4.sections) : e4.eachChild(t3));
            }, e3 = r2.value;
            e3._styleExpression && t3(e3._styleExpression.expression);
          }
          return i2;
        }
      }
      let Jc;
      var Wc = { get paint() {
        return Jc = Jc || new Ds({ "background-color": new Ts(gt2.paint_background["background-color"]), "background-pattern": new Ls(gt2.paint_background["background-pattern"]), "background-opacity": new Ts(gt2.paint_background["background-opacity"]) });
      } };

      class Qc extends Rs {
        constructor(t2) {
          super(t2, Wc);
        }
      }
      let th;
      var eh = { get paint() {
        return th = th || new Ds({ "raster-opacity": new Ts(gt2.paint_raster["raster-opacity"]), "raster-hue-rotate": new Ts(gt2.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ts(gt2.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ts(gt2.paint_raster["raster-brightness-max"]), "raster-saturation": new Ts(gt2.paint_raster["raster-saturation"]), "raster-contrast": new Ts(gt2.paint_raster["raster-contrast"]), "raster-resampling": new Ts(gt2.paint_raster["raster-resampling"]), "raster-fade-duration": new Ts(gt2.paint_raster["raster-fade-duration"]) });
      } };

      class rh extends Rs {
        constructor(t2) {
          super(t2, eh);
        }
      }

      class nh extends Rs {
        constructor(t2) {
          super(t2, {}), this.onAdd = (t3) => {
            this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
          }, this.onRemove = (t3) => {
            this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
          }, this.implementation = t2;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== undefined;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }

      class ih {
        constructor(t2) {
          this._methodToThrottle = t2, this._triggered = false, typeof MessageChannel != "undefined" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
            this._triggered = false, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const sh = { once: true }, ah = 6371008.8;

      class oh {
        constructor(t2, e2) {
          if (isNaN(t2) || isNaN(e2))
            throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
          if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new oh($2(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t2) {
          const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
          return ah * Math.acos(Math.min(i2, 1));
        }
        static convert(t2) {
          if (t2 instanceof oh)
            return t2;
          if (Array.isArray(t2) && (t2.length === 2 || t2.length === 3))
            return new oh(Number(t2[0]), Number(t2[1]));
          if (!Array.isArray(t2) && typeof t2 == "object" && t2 !== null)
            return new oh(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const lh = 2 * Math.PI * ah;
      function uh(t2) {
        return lh * Math.cos(t2 * Math.PI / 180);
      }
      function ch(t2) {
        return (180 + t2) / 360;
      }
      function hh(t2) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
      }
      function ph(t2, e2) {
        return t2 / uh(e2);
      }
      function fh(t2) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
      }
      function dh(t2, e2) {
        return t2 * uh(fh(e2));
      }

      class yh {
        constructor(t2, e2, r2 = 0) {
          this.x = +t2, this.y = +e2, this.z = +r2;
        }
        static fromLngLat(t2, e2 = 0) {
          const r2 = oh.convert(t2);
          return new yh(ch(r2.lng), hh(r2.lat), ph(e2, r2.lat));
        }
        toLngLat() {
          return new oh(360 * this.x - 180, fh(this.y));
        }
        toAltitude() {
          return dh(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / lh * (t2 = fh(this.y), 1 / Math.cos(t2 * Math.PI / 180));
          var t2;
        }
      }
      function mh(t2, e2, r2) {
        var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
        return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
      }

      class gh {
        constructor(t2, e2, r2) {
          if (!function(t3, e3, r3) {
            return !(t3 < 0 || t3 > 25 || r3 < 0 || r3 >= Math.pow(2, t3) || e3 < 0 || e3 >= Math.pow(2, t3));
          }(t2, e2, r2))
            throw new Error(`x=${e2}, y=${r2}, z=${t2} outside of bounds. 0<=x<${Math.pow(2, t2)}, 0<=y<${Math.pow(2, t2)} 0<=z<=25 `);
          this.z = t2, this.x = e2, this.y = r2, this.key = bh(0, t2, t2, e2, r2);
        }
        equals(t2) {
          return this.z === t2.z && this.x === t2.x && this.y === t2.y;
        }
        url(t2, e2, r2) {
          const n2 = (s2 = this.y, a2 = this.z, o2 = mh(256 * (i2 = this.x), 256 * (s2 = Math.pow(2, a2) - s2 - 1), a2), l3 = mh(256 * (i2 + 1), 256 * (s2 + 1), a2), o2[0] + "," + o2[1] + "," + l3[0] + "," + l3[1]);
          var i2, s2, a2, o2, l3;
          const u2 = function(t3, e3, r3) {
            let n3, i3 = "";
            for (let s3 = t3;s3 > 0; s3--)
              n3 = 1 << s3 - 1, i3 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
            return i3;
          }(this.z, this.x, this.y);
          return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(r2 === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
        }
        isChildOf(t2) {
          const e2 = this.z - t2.z;
          return e2 > 0 && t2.x === this.x >> e2 && t2.y === this.y >> e2;
        }
        getTilePoint(t2) {
          const e2 = Math.pow(2, this.z);
          return new l2((t2.x * e2 - this.x) * z2, (t2.y * e2 - this.y) * z2);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }

      class xh {
        constructor(t2, e2) {
          this.wrap = t2, this.canonical = e2, this.key = bh(t2, e2.z, e2.z, e2.x, e2.y);
        }
      }

      class vh {
        constructor(t2, e2, r2, n2, i2) {
          if (this.terrainRttPosMatrix32f = null, t2 < r2)
            throw new Error(`overscaledZ should be >= z; overscaledZ = ${t2}; z = ${r2}`);
          this.overscaledZ = t2, this.wrap = e2, this.canonical = new gh(r2, +n2, +i2), this.key = bh(e2, t2, r2, n2, i2);
        }
        clone() {
          return new vh(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(t2) {
          return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
        }
        scaledTo(t2) {
          if (t2 > this.overscaledZ)
            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
          const e2 = this.canonical.z - t2;
          return t2 > this.canonical.z ? new vh(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new vh(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
        }
        calculateScaledKey(t2, e2) {
          if (t2 > this.overscaledZ)
            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
          const r2 = this.canonical.z - t2;
          return t2 > this.canonical.z ? bh(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : bh(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
        }
        isChildOf(t2) {
          if (t2.wrap !== this.wrap)
            return false;
          const e2 = this.canonical.z - t2.canonical.z;
          return t2.overscaledZ === 0 || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
        }
        children(t2) {
          if (this.overscaledZ >= t2)
            return [new vh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
          return [new vh(e2, this.wrap, e2, r2, n2), new vh(e2, this.wrap, e2, r2 + 1, n2), new vh(e2, this.wrap, e2, r2, n2 + 1), new vh(e2, this.wrap, e2, r2 + 1, n2 + 1)];
        }
        isLessThan(t2) {
          return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
        }
        wrapped() {
          return new vh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t2) {
          return new vh(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new xh(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(t2) {
          return this.canonical.getTilePoint(new yh(t2.x - this.wrap, t2.y));
        }
      }
      function bh(t2, e2, r2, n2, i2) {
        (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
        const s2 = 1 << r2;
        return (s2 * s2 * t2 + s2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
      }
      is("CanonicalTileID", gh), is("OverscaledTileID", vh, { omit: ["terrainRttPosMatrix32f"] });

      class wh {
        constructor(t2, e2, r2, n2 = 1, i2 = 1, s2 = 1, a2 = 0) {
          if (this.uid = t2, e2.height !== e2.width)
            throw new RangeError("DEM tiles must be square");
          if (r2 && !["mapbox", "terrarium", "custom"].includes(r2))
            return void U(`"${r2}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = e2.height;
          const o2 = this.dim = e2.height - 2;
          switch (this.data = new Uint32Array(e2.data.buffer), r2) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = n2, this.greenFactor = i2, this.blueFactor = s2, this.baseShift = a2;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let t3 = 0;t3 < o2; t3++)
            this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(o2, t3)] = this.data[this._idx(o2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, o2)] = this.data[this._idx(t3, o2 - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o2, -1)] = this.data[this._idx(o2 - 1, 0)], this.data[this._idx(-1, o2)] = this.data[this._idx(0, o2 - 1)], this.data[this._idx(o2, o2)] = this.data[this._idx(o2 - 1, o2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let t3 = 0;t3 < o2; t3++)
            for (let e3 = 0;e3 < o2; e3++) {
              const r3 = this.get(t3, e3);
              r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
            }
        }
        get(t2, e2) {
          const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
          return this.unpack(r2[n2], r2[n2 + 1], r2[n2 + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(t2, e2) {
          if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (e2 + 1) * this.stride + (t2 + 1);
        }
        unpack(t2, e2, r2) {
          return t2 * this.redFactor + e2 * this.greenFactor + r2 * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new tl({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(t2, e2, r2) {
          if (this.dim !== t2.dim)
            throw new Error("dem dimension mismatch");
          let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
          switch (e2) {
            case -1:
              n2 = i2 - 1;
              break;
            case 1:
              i2 = n2 + 1;
          }
          switch (r2) {
            case -1:
              s2 = a2 - 1;
              break;
            case 1:
              a2 = s2 + 1;
          }
          const o2 = -e2 * this.dim, l3 = -r2 * this.dim;
          for (let e3 = s2;e3 < a2; e3++)
            for (let r3 = n2;r3 < i2; r3++)
              this.data[this._idx(r3, e3)] = t2.data[this._idx(r3 + o2, e3 + l3)];
        }
      }
      is("DEMData", wh);

      class _h {
        constructor(t2) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let e2 = 0;e2 < t2.length; e2++) {
            const r2 = t2[e2];
            this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
          }
        }
        encode(t2) {
          return this._stringToNumber[t2];
        }
        decode(t2) {
          if (t2 >= this._numberToString.length)
            throw new Error(`Out of bounds. Index requested n=${t2} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[t2];
        }
      }

      class Ah {
        constructor(t2, e2, r2, n2, i2) {
          this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
        }
        get geometry() {
          return this._geometry === undefined && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(t2) {
          this._geometry = t2;
        }
        toJSON() {
          const t2 = { geometry: this.geometry };
          for (const e2 in this)
            e2 !== "_geometry" && e2 !== "_vectorTileFeature" && (t2[e2] = this[e2]);
          return t2;
        }
      }

      class Sh {
        constructor(t2, e2) {
          this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new rs(z2, 16, 0), this.grid3D = new rs(z2, 16, 0), this.featureIndexArray = new Ia, this.promoteId = e2;
        }
        insert(t2, e2, r2, n2, i2, s2) {
          const a2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r2, n2, i2);
          const o2 = s2 ? this.grid3D : this.grid;
          for (let t3 = 0;t3 < e2.length; t3++) {
            const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let t4 = 0;t4 < r3.length; t4++) {
              const e3 = r3[t4];
              n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
            }
            n3[0] < z2 && n3[1] < z2 && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new hu.VectorTile(new Qu(this.rawTileData)).layers, this.sourceLayerCoder = new _h(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(t2, e2, r2, n2) {
          this.loadVTLayers();
          const i2 = t2.params, s2 = z2 / t2.tileSize / t2.scale, a2 = ui2(i2.filter), o2 = t2.queryGeometry, u2 = t2.queryPadding * s2, c2 = Mh(o2), h2 = this.grid.query(c2.minX - u2, c2.minY - u2, c2.maxX + u2, c2.maxY + u2), p2 = Mh(t2.cameraQueryGeometry), f2 = this.grid3D.query(p2.minX - u2, p2.minY - u2, p2.maxX + u2, p2.maxY + u2, (e3, r3, n3, i3) => function(t3, e4, r4, n4, i4) {
            for (const s4 of t3)
              if (e4 <= s4.x && r4 <= s4.y && n4 >= s4.x && i4 >= s4.y)
                return true;
            const s3 = [new l2(e4, r4), new l2(e4, i4), new l2(n4, i4), new l2(n4, r4)];
            if (t3.length > 2) {
              for (const e5 of s3)
                if (Lo2(t3, e5))
                  return true;
            }
            for (let e5 = 0;e5 < t3.length - 1; e5++)
              if (Oo2(t3[e5], t3[e5 + 1], s3))
                return true;
            return false;
          }(t2.cameraQueryGeometry, e3 - u2, r3 - u2, n3 + u2, i3 + u2));
          for (const t3 of f2)
            h2.push(t3);
          h2.sort(Ih);
          const d2 = {};
          let y2;
          for (let l3 = 0;l3 < h2.length; l3++) {
            const u3 = h2[l3];
            if (u3 === y2)
              continue;
            y2 = u3;
            const c3 = this.featureIndexArray.get(u3);
            let p3 = null;
            this.loadMatchingFeature(d2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, a2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3) => (p3 || (p3 = Ao2(e3)), r3.queryIntersectsFeature({ queryGeometry: o2, feature: e3, featureState: n3, geometry: p3, zoom: this.z, transform: t2.transform, pixelsToTileUnits: s2, pixelPosMatrix: t2.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t2.getElevation })));
          }
          return d2;
        }
        loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2) {
          const h2 = this.bucketLayerIDs[e2];
          if (s2 && !h2.some((t3) => s2.has(t3)))
            return;
          const p2 = this.sourceLayerCoder.decode(r2), f2 = this.vtLayers[p2].feature(n2);
          if (i2.needGeometry) {
            const t3 = So2(f2, true);
            if (!i2.filter(new ks(this.tileID.overscaledZ), t3, this.tileID.canonical))
              return;
          } else if (!i2.filter(new ks(this.tileID.overscaledZ), f2))
            return;
          const d2 = this.getId(f2, p2);
          for (let e3 = 0;e3 < h2.length; e3++) {
            const r3 = h2[e3];
            if (s2 && !s2.has(r3))
              continue;
            const i3 = o2[r3];
            if (!i3)
              continue;
            let p3 = {};
            d2 && u2 && (p3 = u2.getState(i3.sourceLayer || "_geojsonTileLayer", d2));
            const y2 = L({}, l3[r3]);
            y2.paint = kh(y2.paint, i3.paint, f2, p3, a2), y2.layout = kh(y2.layout, i3.layout, f2, p3, a2);
            const m2 = !c2 || c2(f2, i3, p3);
            if (!m2)
              continue;
            const g2 = new Ah(f2, this.z, this.x, this.y, d2);
            g2.layer = y2;
            let x2 = t2[r3];
            x2 === undefined && (x2 = t2[r3] = []), x2.push({ featureIndex: n2, feature: g2, intersectionZ: m2 });
          }
        }
        lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l3 = {};
          this.loadVTLayers();
          const u2 = ui2(i2);
          for (const i3 of t2)
            this.loadMatchingFeature(l3, r2, n2, i3, u2, s2, a2, o2, e2);
          return l3;
        }
        hasLayer(t2) {
          for (const e2 of this.bucketLayerIDs)
            for (const r2 of e2)
              if (t2 === r2)
                return true;
          return false;
        }
        getId(t2, e2) {
          var r2;
          let n2 = t2.id;
          return this.promoteId && (n2 = t2.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[e2]], typeof n2 == "boolean" && (n2 = Number(n2)), n2 === undefined && ((r2 = t2.properties) === null || r2 === undefined ? undefined : r2.cluster) && this.promoteId && (n2 = Number(t2.properties.cluster_id))), n2;
        }
      }
      function kh(t2, e2, r2, n2, i2) {
        return D2(t2, (t3, s2) => {
          const a2 = e2 instanceof Es ? e2.get(s2) : null;
          return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
        });
      }
      function Mh(t2) {
        let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
        for (const s2 of t2)
          e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
        return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
      }
      function Ih(t2, e2) {
        return e2 - t2;
      }
      function zh(t2, e2, r2, n2, i2) {
        const s2 = [];
        for (let a2 = 0;a2 < t2.length; a2++) {
          const o2 = t2[a2];
          let u2;
          for (let t3 = 0;t3 < o2.length - 1; t3++) {
            let a3 = o2[t3], c2 = o2[t3 + 1];
            a3.x < e2 && c2.x < e2 || (a3.x < e2 ? a3 = new l2(e2, a3.y + (e2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round() : c2.x < e2 && (c2 = new l2(e2, a3.y + (e2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round()), a3.y < r2 && c2.y < r2 || (a3.y < r2 ? a3 = new l2(a3.x + (r2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), r2)._round() : c2.y < r2 && (c2 = new l2(a3.x + (r2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), r2)._round()), a3.x >= n2 && c2.x >= n2 || (a3.x >= n2 ? a3 = new l2(n2, a3.y + (n2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round() : c2.x >= n2 && (c2 = new l2(n2, a3.y + (n2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round()), a3.y >= i2 && c2.y >= i2 || (a3.y >= i2 ? a3 = new l2(a3.x + (i2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), i2)._round() : c2.y >= i2 && (c2 = new l2(a3.x + (i2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), i2)._round()), u2 && a3.equals(u2[u2.length - 1]) || (u2 = [a3], s2.push(u2)), u2.push(c2)))));
          }
        }
        return s2;
      }
      is("FeatureIndex", Sh, { omit: ["rawTileData", "sourceLayerCoder"] });

      class Ph extends l2 {
        constructor(t2, e2, r2, n2) {
          super(t2, e2), this.angle = r2, n2 !== undefined && (this.segment = n2);
        }
        clone() {
          return new Ph(this.x, this.y, this.angle, this.segment);
        }
      }
      function Ch(t2, e2, r2, n2, i2) {
        if (e2.segment === undefined || r2 === 0)
          return true;
        let s2 = e2, a2 = e2.segment + 1, o2 = 0;
        for (;o2 > -r2 / 2; ) {
          if (a2--, a2 < 0)
            return false;
          o2 -= t2[a2].dist(s2), s2 = t2[a2];
        }
        o2 += t2[a2].dist(t2[a2 + 1]), a2++;
        const l3 = [];
        let u2 = 0;
        for (;o2 < r2 / 2; ) {
          const e3 = t2[a2], r3 = t2[a2 + 1];
          if (!r3)
            return false;
          let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
          for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l3.push({ distance: o2, angleDelta: s3 }), u2 += s3;o2 - l3[0].distance > n2; )
            u2 -= l3.shift().angleDelta;
          if (u2 > i2)
            return false;
          a2++, o2 += e3.dist(r3);
        }
        return true;
      }
      function Bh(t2) {
        let e2 = 0;
        for (let r2 = 0;r2 < t2.length - 1; r2++)
          e2 += t2[r2].dist(t2[r2 + 1]);
        return e2;
      }
      function Vh(t2, e2, r2) {
        return t2 ? 0.6 * e2 * r2 : 0;
      }
      function Eh(t2, e2) {
        return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
      }
      function Th(t2, e2, r2, n2, i2, s2) {
        const a2 = Vh(r2, i2, s2), o2 = Eh(r2, n2) * s2;
        let l3 = 0;
        const u2 = Bh(t2) / 2;
        for (let r3 = 0;r3 < t2.length - 1; r3++) {
          const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
          if (l3 + s3 > u2) {
            const c2 = (u2 - l3) / s3, h2 = fr2.number(n3.x, i3.x, c2), p2 = fr2.number(n3.y, i3.y, c2), f2 = new Ph(h2, p2, i3.angleTo(n3), r3);
            return f2._round(), !a2 || Ch(t2, f2, o2, a2, e2) ? f2 : undefined;
          }
          l3 += s3;
        }
      }
      function Fh(t2, e2, r2, n2, i2, s2, a2, o2, l3) {
        const u2 = Vh(n2, s2, a2), c2 = Eh(n2, i2), h2 = c2 * a2, p2 = t2[0].x === 0 || t2[0].x === l3 || t2[0].y === 0 || t2[0].y === l3;
        return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), $h(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h2, p2, false, l3);
      }
      function $h(t2, e2, r2, n2, i2, s2, a2, o2, l3) {
        const u2 = s2 / 2, c2 = Bh(t2);
        let h2 = 0, p2 = e2 - r2, f2 = [];
        for (let e3 = 0;e3 < t2.length - 1; e3++) {
          const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y2 = o3.angleTo(a3);
          for (;p2 + r2 < h2 + d2; ) {
            p2 += r2;
            const m2 = (p2 - h2) / d2, g2 = fr2.number(a3.x, o3.x, m2), x2 = fr2.number(a3.y, o3.y, m2);
            if (g2 >= 0 && g2 < l3 && x2 >= 0 && x2 < l3 && p2 - u2 >= 0 && p2 + u2 <= c2) {
              const r3 = new Ph(g2, x2, y2, e3);
              r3._round(), n2 && !Ch(t2, r3, s2, n2, i2) || f2.push(r3);
            }
          }
          h2 += d2;
        }
        return o2 || f2.length || a2 || (f2 = $h(t2, h2 / 2, r2, n2, i2, s2, a2, true, l3)), f2;
      }
      is("Anchor", Ph);
      const Lh = ac;
      function Oh(t2, e2, r2, n2) {
        const i2 = [], s2 = t2.image, a2 = s2.pixelRatio, o2 = s2.paddedRect.w - 2 * Lh, u2 = s2.paddedRect.h - 2 * Lh;
        let c2 = { x1: t2.left, y1: t2.top, x2: t2.right, y2: t2.bottom };
        const h2 = s2.stretchX || [[0, o2]], p2 = s2.stretchY || [[0, u2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], d2 = h2.reduce(f2, 0), y2 = p2.reduce(f2, 0), m2 = o2 - d2, g2 = u2 - y2;
        let x2 = 0, v2 = d2, b2 = 0, w2 = y2, _2 = 0, A2 = m2, S2 = 0, k2 = g2;
        if (s2.content && n2) {
          const e3 = s2.content, r3 = e3[2] - e3[0], n3 = e3[3] - e3[1];
          (s2.textFitWidth || s2.textFitHeight) && (c2 = Bc(t2)), x2 = Dh(h2, 0, e3[0]), b2 = Dh(p2, 0, e3[1]), v2 = Dh(h2, e3[0], e3[2]), w2 = Dh(p2, e3[1], e3[3]), _2 = e3[0] - x2, S2 = e3[1] - b2, A2 = r3 - v2, k2 = n3 - w2;
        }
        const { x1: M3, y1: I2 } = c2, z3 = c2.x2 - M3, P2 = c2.y2 - I2, C2 = (t3, n3, i3, o3) => {
          const u3 = Rh(t3.stretch - x2, v2, z3, M3), c3 = Nh(t3.fixed - _2, A2, t3.stretch, d2), h3 = Rh(n3.stretch - b2, w2, P2, I2), p3 = Nh(n3.fixed - S2, k2, n3.stretch, y2), f3 = Rh(i3.stretch - x2, v2, z3, M3), m3 = Nh(i3.fixed - _2, A2, i3.stretch, d2), g3 = Rh(o3.stretch - b2, w2, P2, I2), C3 = Nh(o3.fixed - S2, k2, o3.stretch, y2), B3 = new l2(u3, h3), V2 = new l2(f3, h3), E3 = new l2(f3, g3), T2 = new l2(u3, g3), F3 = new l2(c3 / a2, p3 / a2), $3 = new l2(m3 / a2, C3 / a2), L2 = e2 * Math.PI / 180;
          if (L2) {
            const t4 = Math.sin(L2), e3 = Math.cos(L2), r3 = [e3, -t4, t4, e3];
            B3._matMult(r3), V2._matMult(r3), T2._matMult(r3), E3._matMult(r3);
          }
          const O2 = t3.stretch + t3.fixed, D3 = n3.stretch + n3.fixed;
          return { tl: B3, tr: V2, bl: T2, br: E3, tex: { x: s2.paddedRect.x + Lh + O2, y: s2.paddedRect.y + Lh + D3, w: i3.stretch + i3.fixed - O2, h: o3.stretch + o3.fixed - D3 }, writingMode: undefined, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F3, pixelOffsetBR: $3, minFontScaleX: A2 / a2 / z3, minFontScaleY: k2 / a2 / P2, isSDF: r2 };
        };
        if (n2 && (s2.stretchX || s2.stretchY)) {
          const t3 = jh(h2, m2, d2), e3 = jh(p2, g2, y2);
          for (let r3 = 0;r3 < t3.length - 1; r3++) {
            const n3 = t3[r3], s3 = t3[r3 + 1];
            for (let t4 = 0;t4 < e3.length - 1; t4++)
              i2.push(C2(n3, e3[t4], s3, e3[t4 + 1]));
          }
        } else
          i2.push(C2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
        return i2;
      }
      function Dh(t2, e2, r2) {
        let n2 = 0;
        for (const i2 of t2)
          n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
        return n2;
      }
      function jh(t2, e2, r2) {
        const n2 = [{ fixed: -1, stretch: 0 }];
        for (const [e3, r3] of t2) {
          const t3 = n2[n2.length - 1];
          n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
        }
        return n2.push({ fixed: e2 + Lh, stretch: r2 }), n2;
      }
      function Rh(t2, e2, r2, n2) {
        return t2 / e2 * r2 + n2;
      }
      function Nh(t2, e2, r2, n2) {
        return t2 - e2 * r2 / n2;
      }

      class Uh {
        constructor(t2, e2, r2, n2, i2, s2, a2, o2, u2, c2) {
          var h2;
          if (this.boxStartIndex = t2.length, u2) {
            let { top: t3, bottom: e3 } = s2;
            const r3 = s2.collisionPadding;
            r3 && (t3 -= r3[1], e3 += r3[3]);
            let n3 = e3 - t3;
            n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
          } else {
            const u3 = ((h2 = s2.image) === null || h2 === undefined ? undefined : h2.content) && (s2.image.textFitWidth || s2.image.textFitHeight) ? Bc(s2) : { x1: s2.left, y1: s2.top, x2: s2.right, y2: s2.bottom };
            u3.y1 = u3.y1 * a2 - o2[0], u3.y2 = u3.y2 * a2 + o2[2], u3.x1 = u3.x1 * a2 - o2[3], u3.x2 = u3.x2 * a2 + o2[1];
            const p2 = s2.collisionPadding;
            if (p2 && (u3.x1 -= p2[0] * a2, u3.y1 -= p2[1] * a2, u3.x2 += p2[2] * a2, u3.y2 += p2[3] * a2), c2) {
              const t3 = new l2(u3.x1, u3.y1), e3 = new l2(u3.x2, u3.y1), r3 = new l2(u3.x1, u3.y2), n3 = new l2(u3.x2, u3.y2), i3 = c2 * Math.PI / 180;
              t3._rotate(i3), e3._rotate(i3), r3._rotate(i3), n3._rotate(i3), u3.x1 = Math.min(t3.x, e3.x, r3.x, n3.x), u3.x2 = Math.max(t3.x, e3.x, r3.x, n3.x), u3.y1 = Math.min(t3.y, e3.y, r3.y, n3.y), u3.y2 = Math.max(t3.y, e3.y, r3.y, n3.y);
            }
            t2.emplaceBack(e2.x, e2.y, u3.x1, u3.y1, u3.x2, u3.y2, r2, n2, i2);
          }
          this.boxEndIndex = t2.length;
        }
      }

      class qh {
        constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
          if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (let t3 = (this.length >> 1) - 1;t3 >= 0; t3--)
              this._down(t3);
        }
        push(t2) {
          this.data.push(t2), this._up(this.length++);
        }
        pop() {
          if (this.length === 0)
            return;
          const t2 = this.data[0], e2 = this.data.pop();
          return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
        }
        peek() {
          return this.data[0];
        }
        _up(t2) {
          const { data: e2, compare: r2 } = this, n2 = e2[t2];
          for (;t2 > 0; ) {
            const i2 = t2 - 1 >> 1, s2 = e2[i2];
            if (r2(n2, s2) >= 0)
              break;
            e2[t2] = s2, t2 = i2;
          }
          e2[t2] = n2;
        }
        _down(t2) {
          const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
          for (;t2 < n2; ) {
            let n3 = 1 + (t2 << 1);
            const s2 = n3 + 1;
            if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0)
              break;
            e2[t2] = e2[n3], t2 = n3;
          }
          e2[t2] = i2;
        }
      }
      function Gh(t2, e2 = 1, r2 = false) {
        let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
        const o2 = t2[0];
        for (let t3 = 0;t3 < o2.length; t3++) {
          const e3 = o2[t3];
          (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
        }
        const u2 = Math.min(s2 - n2, a2 - i2);
        let c2 = u2 / 2;
        const h2 = new qh([], Zh);
        if (u2 === 0)
          return new l2(n2, i2);
        for (let e3 = n2;e3 < s2; e3 += u2)
          for (let r3 = i2;r3 < a2; r3 += u2)
            h2.push(new Kh(e3 + c2, r3 + c2, c2, t2));
        let p2 = function(t3) {
          let e3 = 0, r3 = 0, n3 = 0;
          const i3 = t3[0];
          for (let t4 = 0, s3 = i3.length, a3 = s3 - 1;t4 < s3; a3 = t4++) {
            const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
            r3 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
          }
          return new Kh(r3 / e3, n3 / e3, 0, t3);
        }(t2), f2 = h2.length;
        for (;h2.length; ) {
          const n3 = h2.pop();
          (n3.d > p2.d || !p2.d) && (p2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, f2)), n3.max - p2.d <= e2 || (c2 = n3.h / 2, h2.push(new Kh(n3.p.x - c2, n3.p.y - c2, c2, t2)), h2.push(new Kh(n3.p.x + c2, n3.p.y - c2, c2, t2)), h2.push(new Kh(n3.p.x - c2, n3.p.y + c2, c2, t2)), h2.push(new Kh(n3.p.x + c2, n3.p.y + c2, c2, t2)), f2 += 4);
        }
        return r2 && (console.log(`num probes: ${f2}`), console.log(`best distance: ${p2.d}`)), p2.p;
      }
      function Zh(t2, e2) {
        return e2.max - t2.max;
      }
      function Kh(t2, e2, r2, n2) {
        this.p = new l2(t2, e2), this.h = r2, this.d = function(t3, e3) {
          let r3 = false, n3 = 1 / 0;
          for (let i2 = 0;i2 < e3.length; i2++) {
            const s2 = e3[i2];
            for (let e4 = 0, i3 = s2.length, a2 = i3 - 1;e4 < i3; a2 = e4++) {
              const i4 = s2[e4], o2 = s2[a2];
              i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Fo2(t3, i4, o2));
            }
          }
          return (r3 ? 1 : -1) * Math.sqrt(n3);
        }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
      }
      var Xh;
      t.aB = undefined, (Xh = t.aB || (t.aB = {}))[Xh.center = 1] = "center", Xh[Xh.left = 2] = "left", Xh[Xh.right = 3] = "right", Xh[Xh.top = 4] = "top", Xh[Xh.bottom = 5] = "bottom", Xh[Xh["top-left"] = 6] = "top-left", Xh[Xh["top-right"] = 7] = "top-right", Xh[Xh["bottom-left"] = 8] = "bottom-left", Xh[Xh["bottom-right"] = 9] = "bottom-right";
      const Hh = 7, Yh = Number.POSITIVE_INFINITY;
      function Jh(t2, e2) {
        return e2[1] !== Yh ? function(t3, e3, r2) {
          let n2 = 0, i2 = 0;
          switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
            case "top-right":
            case "top-left":
            case "top":
              i2 = r2 - Hh;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i2 = -r2 + Hh;
          }
          switch (t3) {
            case "top-right":
            case "bottom-right":
            case "right":
              n2 = -e3;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n2 = e3;
          }
          return [n2, i2];
        }(t2, e2[0], e2[1]) : function(t3, e3) {
          let r2 = 0, n2 = 0;
          e3 < 0 && (e3 = 0);
          const i2 = e3 / Math.SQRT2;
          switch (t3) {
            case "top-right":
            case "top-left":
              n2 = i2 - Hh;
              break;
            case "bottom-right":
            case "bottom-left":
              n2 = -i2 + Hh;
              break;
            case "bottom":
              n2 = -e3 + Hh;
              break;
            case "top":
              n2 = e3 - Hh;
          }
          switch (t3) {
            case "top-right":
            case "bottom-right":
              r2 = -i2;
              break;
            case "top-left":
            case "bottom-left":
              r2 = i2;
              break;
            case "left":
              r2 = e3;
              break;
            case "right":
              r2 = -e3;
          }
          return [r2, n2];
        }(t2, e2[0]);
      }
      function Wh(t2, e2, r2) {
        var n2;
        const i2 = t2.layout, s2 = (n2 = i2.get("text-variable-anchor-offset")) === null || n2 === undefined ? undefined : n2.evaluate(e2, {}, r2);
        if (s2) {
          const t3 = s2.values, e3 = [];
          for (let r3 = 0;r3 < t3.length; r3 += 2) {
            const n3 = e3[r3] = t3[r3], i3 = t3[r3 + 1].map((t4) => t4 * Hu);
            n3.startsWith("top") ? i3[1] -= Hh : n3.startsWith("bottom") && (i3[1] += Hh), e3[r3 + 1] = i3;
          }
          return new Fe2(e3);
        }
        const a2 = i2.get("text-variable-anchor");
        if (a2) {
          let n3;
          n3 = t2._unevaluatedLayout.getValue("text-radial-offset") !== undefined ? [i2.get("text-radial-offset").evaluate(e2, {}, r2) * Hu, Yh] : i2.get("text-offset").evaluate(e2, {}, r2).map((t3) => t3 * Hu);
          const s3 = [];
          for (const t3 of a2)
            s3.push(t3, Jh(t3, n3));
          return new Fe2(s3);
        }
        return null;
      }
      function Qh(t2) {
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function tp(e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2) {
        let f2 = a2.textMaxSize.evaluate(r2, {});
        f2 === undefined && (f2 = o2);
        const d2 = e2.layers[0].layout, y2 = d2.get("icon-offset").evaluate(r2, {}, h2), m2 = rp(n2.horizontal), g2 = o2 / 24, x2 = e2.tilePixelRatio * g2, v2 = e2.tilePixelRatio * f2 / 24, b2 = e2.tilePixelRatio * l3, w2 = e2.tilePixelRatio * d2.get("symbol-spacing"), _2 = d2.get("text-padding") * e2.tilePixelRatio, A2 = function(t2, e3, r3, n3 = 1) {
          const i3 = t2.get("icon-padding").evaluate(e3, {}, r3), s3 = i3 && i3.values;
          return [s3[0] * n3, s3[1] * n3, s3[2] * n3, s3[3] * n3];
        }(d2, r2, h2, e2.tilePixelRatio), S2 = d2.get("text-max-angle") / 180 * Math.PI, k2 = d2.get("text-rotation-alignment") !== "viewport" && d2.get("symbol-placement") !== "point", M3 = d2.get("icon-rotation-alignment") === "map" && d2.get("symbol-placement") !== "point", I2 = d2.get("symbol-placement"), P2 = w2 / 2, C2 = d2.get("icon-text-fit");
        let B3;
        i2 && C2 !== "none" && (e2.allowVerticalPlacement && n2.vertical && (B3 = Vc(i2, n2.vertical, C2, d2.get("icon-text-fit-padding"), y2, g2)), m2 && (i2 = Vc(i2, m2, C2, d2.get("icon-text-fit-padding"), y2, g2)));
        const V2 = h2 ? p2.line.getGranularityForZoomLevel(h2.z) : 1, E3 = (l4, p3) => {
          p3.x < 0 || p3.x >= z2 || p3.y < 0 || p3.y >= z2 || function(e3, r3, n3, i3, s3, a3, o3, l5, u3, c3, h3, p4, f3, d3, y3, m3, g3, x3, v3, b3, w3, _3, A3, S3, k3) {
            const M4 = e3.addToLineVertexArray(r3, n3);
            let I3, z3, P3, C3, B4 = 0, V3 = 0, E4 = 0, T2 = 0, F3 = -1, $3 = -1;
            const L2 = {};
            let O2 = to2("");
            if (e3.allowVerticalPlacement && i3.vertical) {
              const t2 = l5.layout.get("text-rotate").evaluate(w3, {}, S3) + 90;
              P3 = new Uh(u3, r3, c3, h3, p4, i3.vertical, f3, d3, y3, t2), o3 && (C3 = new Uh(u3, r3, c3, h3, p4, o3, g3, x3, y3, t2));
            }
            if (s3) {
              const n4 = l5.layout.get("icon-rotate").evaluate(w3, {}), i4 = l5.layout.get("icon-text-fit") !== "none", a4 = Oh(s3, n4, A3, i4), f4 = o3 ? Oh(o3, n4, A3, i4) : undefined;
              z3 = new Uh(u3, r3, c3, h3, p4, s3, g3, x3, false, n4), B4 = 4 * a4.length;
              const d4 = e3.iconSizeData;
              let y4 = null;
              d4.kind === "source" ? (y4 = [Tc * l5.layout.get("icon-size").evaluate(w3, {})], y4[0] > Fc && U(`${e3.layerIds[0]}: Value for "icon-size" is >= ${Ec}. Reduce your "icon-size".`)) : d4.kind === "composite" && (y4 = [Tc * _3.compositeIconSizes[0].evaluate(w3, {}, S3), Tc * _3.compositeIconSizes[1].evaluate(w3, {}, S3)], (y4[0] > Fc || y4[1] > Fc) && U(`${e3.layerIds[0]}: Value for "icon-size" is >= ${Ec}. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, a4, y4, b3, v3, w3, t.al.none, r3, M4.lineStartIndex, M4.lineLength, -1, S3), F3 = e3.icon.placedSymbolArray.length - 1, f4 && (V3 = 4 * f4.length, e3.addSymbols(e3.icon, f4, y4, b3, v3, w3, t.al.vertical, r3, M4.lineStartIndex, M4.lineLength, -1, S3), $3 = e3.icon.placedSymbolArray.length - 1);
            }
            const D3 = Object.keys(i3.horizontal);
            for (const n4 of D3) {
              const s4 = i3.horizontal[n4];
              if (!I3) {
                O2 = to2(s4.text);
                const t2 = l5.layout.get("text-rotate").evaluate(w3, {}, S3);
                I3 = new Uh(u3, r3, c3, h3, p4, s4, f3, d3, y3, t2);
              }
              const o4 = s4.positionedLines.length === 1;
              if (E4 += ep(e3, r3, s4, a3, l5, y3, w3, m3, M4, i3.vertical ? t.al.horizontal : t.al.horizontalOnly, o4 ? D3 : [n4], L2, F3, _3, S3), o4)
                break;
            }
            i3.vertical && (T2 += ep(e3, r3, i3.vertical, a3, l5, y3, w3, m3, M4, t.al.vertical, ["vertical"], L2, $3, _3, S3));
            const j3 = I3 ? I3.boxStartIndex : e3.collisionBoxArray.length, R2 = I3 ? I3.boxEndIndex : e3.collisionBoxArray.length, N2 = P3 ? P3.boxStartIndex : e3.collisionBoxArray.length, q2 = P3 ? P3.boxEndIndex : e3.collisionBoxArray.length, G3 = z3 ? z3.boxStartIndex : e3.collisionBoxArray.length, Z3 = z3 ? z3.boxEndIndex : e3.collisionBoxArray.length, K2 = C3 ? C3.boxStartIndex : e3.collisionBoxArray.length, X2 = C3 ? C3.boxEndIndex : e3.collisionBoxArray.length;
            let H2 = -1;
            const Y3 = (t2, e4) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e4) : e4;
            H2 = Y3(I3, H2), H2 = Y3(P3, H2), H2 = Y3(z3, H2), H2 = Y3(C3, H2);
            const J3 = H2 > -1 ? 1 : 0;
            J3 && (H2 *= k3 / Hu), e3.glyphOffsetArray.length >= Gc.MAX_GLYPHS && U("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), w3.sortKey !== undefined && e3.addToSortKeyRanges(e3.symbolInstances.length, w3.sortKey);
            const W3 = Wh(l5, w3, S3), [Q3, tt3] = function(e4, r4) {
              const n4 = e4.length, i4 = r4 == null ? undefined : r4.values;
              if ((i4 == null ? undefined : i4.length) > 0)
                for (let r5 = 0;r5 < i4.length; r5 += 2) {
                  const n5 = i4[r5 + 1];
                  e4.emplaceBack(t.aB[i4[r5]], n5[0], n5[1]);
                }
              return [n4, e4.length];
            }(e3.textAnchorOffsets, W3);
            e3.symbolInstances.emplaceBack(r3.x, r3.y, L2.right >= 0 ? L2.right : -1, L2.center >= 0 ? L2.center : -1, L2.left >= 0 ? L2.left : -1, L2.vertical || -1, F3, $3, O2, j3, R2, N2, q2, G3, Z3, K2, X2, c3, E4, T2, B4, V3, J3, 0, f3, H2, Q3, tt3);
          }(e2, p3, l4, n2, i2, s2, B3, e2.layers[0], e2.collisionBoxArray, r2.index, r2.sourceLayerIndex, e2.index, x2, [_2, _2, _2, _2], k2, u2, b2, A2, M3, y2, r2, a2, c2, h2, o2);
        };
        if (I2 === "line")
          for (const t2 of zh(r2.geometry, 0, 0, z2, z2)) {
            const r3 = Nl(t2, V2), s3 = Fh(r3, w2, S2, n2.vertical || m2, i2, 24, v2, e2.overscaling, z2);
            for (const t3 of s3)
              m2 && np(e2, m2.text, P2, t3) || E3(r3, t3);
          }
        else if (I2 === "line-center") {
          for (const t2 of r2.geometry)
            if (t2.length > 1) {
              const e3 = Nl(t2, V2), r3 = Th(e3, S2, n2.vertical || m2, i2, 24, v2);
              r3 && E3(e3, r3);
            }
        } else if (r2.type === "Polygon")
          for (const t2 of Wr2(r2.geometry, 0)) {
            const e3 = Gh(t2, 16);
            E3(Nl(t2[0], V2, true), new Ph(e3.x, e3.y, 0));
          }
        else if (r2.type === "LineString")
          for (const t2 of r2.geometry) {
            const e3 = Nl(t2, V2);
            E3(e3, new Ph(e3[0].x, e3[0].y, 0));
          }
        else if (r2.type === "Point")
          for (const t2 of r2.geometry)
            for (const e3 of t2)
              E3([e3], new Ph(e3.x, e3.y, 0));
      }
      function ep(t2, e2, r2, n2, i2, s2, a2, o2, u2, c2, h2, p2, f2, d2, y2) {
        const m2 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
          const u3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = [];
          for (const t4 of e3.positionedLines)
            for (const n4 of t4.positionedGlyphs) {
              if (!n4.rect)
                continue;
              const s4 = n4.rect || {};
              let h3 = ic + 1, p3 = true, f3 = 1, d3 = 0;
              const y3 = (i3 || o3) && n4.vertical, m3 = n4.metrics.advance * n4.scale / 2;
              if (o3 && e3.verticalizable && (d3 = t4.lineOffset / 2 - (n4.imageName ? -(Hu - n4.metrics.width * n4.scale) / 2 : (n4.scale - 1) * Hu)), n4.imageName) {
                const t5 = a3[n4.imageName];
                p3 = t5.sdf, f3 = t5.pixelRatio, h3 = ac / f3;
              }
              const g3 = i3 ? [n4.x + m3, n4.y] : [0, 0];
              let x3 = i3 ? [0, 0] : [n4.x + m3 + r3[0], n4.y + r3[1] - d3], v2 = [0, 0];
              y3 && (v2 = x3, x3 = [0, 0]);
              const b2 = n4.metrics.isDoubleResolution ? 2 : 1, w2 = (n4.metrics.left - h3) * n4.scale - m3 + x3[0], _2 = (-n4.metrics.top - h3) * n4.scale + x3[1], A2 = w2 + s4.w / b2 * n4.scale / f3, S2 = _2 + s4.h / b2 * n4.scale / f3, k2 = new l2(w2, _2), M3 = new l2(A2, _2), I2 = new l2(w2, S2), z3 = new l2(A2, S2);
              if (y3) {
                const t5 = new l2(-m3, m3 - cc), e4 = -Math.PI / 2, r4 = Hu / 2 - m3, i4 = new l2(5 - cc - r4, -(n4.imageName ? r4 : 0)), s5 = new l2(...v2);
                k2._rotateAround(e4, t5)._add(i4)._add(s5), M3._rotateAround(e4, t5)._add(i4)._add(s5), I2._rotateAround(e4, t5)._add(i4)._add(s5), z3._rotateAround(e4, t5)._add(i4)._add(s5);
              }
              if (u3) {
                const t5 = Math.sin(u3), e4 = Math.cos(u3), r4 = [e4, -t5, t5, e4];
                k2._matMult(r4), M3._matMult(r4), I2._matMult(r4), z3._matMult(r4);
              }
              const P2 = new l2(0, 0), C2 = new l2(0, 0);
              c3.push({ tl: k2, tr: M3, bl: I2, br: z3, tex: s4, writingMode: e3.writingMode, glyphOffset: g3, sectionIndex: n4.sectionIndex, isSDF: p3, pixelOffsetTL: P2, pixelOffsetBR: C2, minFontScaleX: 0, minFontScaleY: 0 });
            }
          return c3;
        }(0, r2, o2, i2, s2, a2, n2, t2.allowVerticalPlacement), g2 = t2.textSizeData;
        let x2 = null;
        g2.kind === "source" ? (x2 = [Tc * i2.layout.get("text-size").evaluate(a2, {})], x2[0] > Fc && U(`${t2.layerIds[0]}: Value for "text-size" is >= ${Ec}. Reduce your "text-size".`)) : g2.kind === "composite" && (x2 = [Tc * d2.compositeTextSizes[0].evaluate(a2, {}, y2), Tc * d2.compositeTextSizes[1].evaluate(a2, {}, y2)], (x2[0] > Fc || x2[1] > Fc) && U(`${t2.layerIds[0]}: Value for "text-size" is >= ${Ec}. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x2, o2, s2, a2, c2, e2, u2.lineStartIndex, u2.lineLength, f2, y2);
        for (const e3 of h2)
          p2[e3] = t2.text.placedSymbolArray.length - 1;
        return 4 * m2.length;
      }
      function rp(t2) {
        for (const e2 in t2)
          return t2[e2];
        return null;
      }
      function np(t2, e2, r2, n2) {
        const i2 = t2.compareText;
        if (e2 in i2) {
          const t3 = i2[e2];
          for (let e3 = t3.length - 1;e3 >= 0; e3--)
            if (n2.dist(t3[e3]) < r2)
              return true;
        } else
          i2[e2] = [];
        return i2[e2].push(n2), false;
      }
      const ip = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];

      class sp {
        static from(t2) {
          if (!(t2 instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [e2, r2] = new Uint8Array(t2, 0, 2);
          if (e2 !== 219)
            throw new Error("Data does not appear to be in a KDBush format.");
          const n2 = r2 >> 4;
          if (n2 !== 1)
            throw new Error(`Got v${n2} data when expected v1.`);
          const i2 = ip[15 & r2];
          if (!i2)
            throw new Error("Unrecognized array type.");
          const [s2] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
          return new sp(a2, s2, i2, t2);
        }
        constructor(t2, e2 = 64, r2 = Float64Array, n2) {
          if (isNaN(t2) || t2 < 0)
            throw new Error(`Unpexpected numItems value: ${t2}.`);
          this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
          const i2 = ip.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
          if (i2 < 0)
            throw new Error(`Unexpected typed array class: ${r2}.`);
          n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
        }
        add(t2, e2) {
          const r2 = this._pos >> 1;
          return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
        }
        finish() {
          const t2 = this._pos >> 1;
          if (t2 !== this.numItems)
            throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
          return ap(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(t2, e2, r2, n2) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l3 = [];
          for (;o2.length; ) {
            const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
            if (c2 - h2 <= a2) {
              for (let a3 = h2;a3 <= c2; a3++) {
                const o3 = s2[2 * a3], u3 = s2[2 * a3 + 1];
                o3 >= t2 && o3 <= r2 && u3 >= e2 && u3 <= n2 && l3.push(i2[a3]);
              }
              continue;
            }
            const p2 = h2 + c2 >> 1, f2 = s2[2 * p2], d2 = s2[2 * p2 + 1];
            f2 >= t2 && f2 <= r2 && d2 >= e2 && d2 <= n2 && l3.push(i2[p2]), (u2 === 0 ? t2 <= f2 : e2 <= d2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u2)), (u2 === 0 ? r2 >= f2 : n2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
          }
          return l3;
        }
        within(t2, e2, r2) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: n2, coords: i2, nodeSize: s2 } = this, a2 = [0, n2.length - 1, 0], o2 = [], l3 = r2 * r2;
          for (;a2.length; ) {
            const u2 = a2.pop() || 0, c2 = a2.pop() || 0, h2 = a2.pop() || 0;
            if (c2 - h2 <= s2) {
              for (let r3 = h2;r3 <= c2; r3++)
                cp(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l3 && o2.push(n2[r3]);
              continue;
            }
            const p2 = h2 + c2 >> 1, f2 = i2[2 * p2], d2 = i2[2 * p2 + 1];
            cp(f2, d2, t2, e2) <= l3 && o2.push(n2[p2]), (u2 === 0 ? t2 - r2 <= f2 : e2 - r2 <= d2) && (a2.push(h2), a2.push(p2 - 1), a2.push(1 - u2)), (u2 === 0 ? t2 + r2 >= f2 : e2 + r2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u2));
          }
          return o2;
        }
      }
      function ap(t2, e2, r2, n2, i2, s2) {
        if (i2 - n2 <= r2)
          return;
        const a2 = n2 + i2 >> 1;
        op(t2, e2, a2, n2, i2, s2), ap(t2, e2, r2, n2, a2 - 1, 1 - s2), ap(t2, e2, r2, a2 + 1, i2, 1 - s2);
      }
      function op(t2, e2, r2, n2, i2, s2) {
        for (;i2 > n2; ) {
          if (i2 - n2 > 600) {
            const a3 = i2 - n2 + 1, o3 = r2 - n2 + 1, l4 = Math.log(a3), u2 = 0.5 * Math.exp(2 * l4 / 3), c2 = 0.5 * Math.sqrt(l4 * u2 * (a3 - u2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
            op(t2, e2, r2, Math.max(n2, Math.floor(r2 - o3 * u2 / a3 + c2)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u2 / a3 + c2)), s2);
          }
          const a2 = e2[2 * r2 + s2];
          let o2 = n2, l3 = i2;
          for (lp(t2, e2, n2, r2), e2[2 * i2 + s2] > a2 && lp(t2, e2, n2, i2);o2 < l3; ) {
            for (lp(t2, e2, o2, l3), o2++, l3--;e2[2 * o2 + s2] < a2; )
              o2++;
            for (;e2[2 * l3 + s2] > a2; )
              l3--;
          }
          e2[2 * n2 + s2] === a2 ? lp(t2, e2, n2, l3) : (l3++, lp(t2, e2, l3, i2)), l3 <= r2 && (n2 = l3 + 1), r2 <= l3 && (i2 = l3 - 1);
        }
      }
      function lp(t2, e2, r2, n2) {
        up(t2, r2, n2), up(e2, 2 * r2, 2 * n2), up(e2, 2 * r2 + 1, 2 * n2 + 1);
      }
      function up(t2, e2, r2) {
        const n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      function cp(t2, e2, r2, n2) {
        const i2 = t2 - r2, s2 = e2 - n2;
        return i2 * i2 + s2 * s2;
      }
      var hp;
      t.co = undefined, (hp = t.co || (t.co = {})).create = "create", hp.load = "load", hp.fullLoad = "fullLoad";
      let pp = null, fp = [];
      const dp = 1000 / 60, yp = "loadTime", mp = "fullLoadTime", gp = { mark(t2) {
        performance.mark(t2);
      }, frame(t2) {
        const e2 = t2;
        pp != null && fp.push(e2 - pp), pp = e2;
      }, clearMetrics() {
        pp = null, fp = [], performance.clearMeasures(yp), performance.clearMeasures(mp);
        for (const e2 in t.co)
          performance.clearMarks(t.co[e2]);
      }, getPerformanceMetrics() {
        performance.measure(yp, t.co.create, t.co.load), performance.measure(mp, t.co.create, t.co.fullLoad);
        const e2 = performance.getEntriesByName(yp)[0].duration, r2 = performance.getEntriesByName(mp)[0].duration, n2 = fp.length, i2 = 1 / (fp.reduce((t2, e3) => t2 + e3, 0) / n2 / 1000), s2 = fp.filter((t2) => t2 > dp).reduce((t2, e3) => t2 + (e3 - dp) / dp, 0);
        return { loadTime: e2, fullLoadTime: r2, fps: i2, percentDroppedFrames: s2 / (n2 + s2) * 100, totalFrames: n2 };
      } };
      t.$ = yh, t.A = m, t.B = fr2, t.C = ks, t.D = Ts, t.E = mt2, t.F = Wi2, t.G = function(t2) {
        if (Z2 == null) {
          const e2 = t2.navigator ? t2.navigator.userAgent : null;
          Z2 = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
        }
        return Z2;
      }, t.H = class {
        constructor(t2, e2) {
          this.target = t2, this.mapId = e2, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new ih(() => this.process()), this.subscription = W2(this.target, "message", (t3) => this.receive(t3), false), this.globalScope = G2(self) ? t2 : window;
        }
        registerMessageHandler(t2, e2) {
          this.messageHandlers[t2] = e2;
        }
        sendAsync(t2, e2) {
          return new Promise((r2, n2) => {
            const i2 = Math.round(1000000000000000000 * Math.random()).toString(36).substring(0, 10), s2 = e2 ? W2(e2.signal, "abort", () => {
              s2 == null || s2.unsubscribe(), delete this.resolveRejects[i2];
              const e3 = { id: i2, type: "<cancel>", origin: location.origin, targetMapId: t2.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(e3);
            }, sh) : null;
            this.resolveRejects[i2] = { resolve: (t3) => {
              s2 == null || s2.unsubscribe(), r2(t3);
            }, reject: (t3) => {
              s2 == null || s2.unsubscribe(), n2(t3);
            } };
            const a2 = [], o2 = Object.assign(Object.assign({}, t2), { id: i2, sourceMapId: this.mapId, origin: location.origin, data: ls(t2.data, a2) });
            this.target.postMessage(o2, { transfer: a2 });
          });
        }
        receive(t2) {
          const e2 = t2.data, r2 = e2.id;
          if (!(e2.origin !== "file://" && location.origin !== "file://" && e2.origin !== "resource://android" && location.origin !== "resource://android" && e2.origin !== location.origin || e2.targetMapId && this.mapId !== e2.targetMapId)) {
            if (e2.type === "<cancel>") {
              delete this.tasks[r2];
              const t3 = this.abortControllers[r2];
              return delete this.abortControllers[r2], void (t3 && t3.abort());
            }
            if (G2(self) || e2.mustQueue)
              return this.tasks[r2] = e2, this.taskQueue.push(r2), void this.invoker.trigger();
            this.processTask(r2, e2);
          }
        }
        process() {
          if (this.taskQueue.length === 0)
            return;
          const t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
          delete this.tasks[t2], this.taskQueue.length > 0 && this.invoker.trigger(), e2 && this.processTask(t2, e2);
        }
        processTask(t2, r2) {
          return e(this, undefined, undefined, function* () {
            if (r2.type === "<response>") {
              const e3 = this.resolveRejects[t2];
              if (delete this.resolveRejects[t2], !e3)
                return;
              return void (r2.error ? e3.reject(us(r2.error)) : e3.resolve(us(r2.data)));
            }
            if (!this.messageHandlers[r2.type])
              return void this.completeTask(t2, new Error(`Could not find a registered handler for ${r2.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const e2 = us(r2.data), n2 = new AbortController;
            this.abortControllers[t2] = n2;
            try {
              const i2 = yield this.messageHandlers[r2.type](r2.sourceMapId, e2, n2);
              this.completeTask(t2, null, i2);
            } catch (e3) {
              this.completeTask(t2, e3);
            }
          });
        }
        completeTask(t2, e2, r2) {
          const n2 = [];
          delete this.abortControllers[t2];
          const i2 = { id: t2, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e2 ? ls(e2) : null, data: ls(r2, n2) };
          this.target.postMessage(i2, { transfer: n2 });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, t.I = oc, t.J = ot2, t.K = function() {
        var t2 = new m(16);
        return m != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
      }, t.L = function(t2, e2, r2) {
        var n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
        return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l3 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l3, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y2 + l3 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y2 + u2 * m2 + f2 * g2 + e2[14], t2[15] = a2 * y2 + c2 * m2 + d2 * g2 + e2[15]), t2;
      }, t.M = function(t2, e2, r2) {
        var n2 = r2[0], i2 = r2[1], s2 = r2[2];
        return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
      }, t.N = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l3 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
        return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t2[1] = v2 * i2 + b2 * l3 + w2 * p2 + _2 * m2, t2[2] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t2[5] = v2 * i2 + b2 * l3 + w2 * p2 + _2 * m2, t2[6] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t2[9] = v2 * i2 + b2 * l3 + w2 * p2 + _2 * m2, t2[10] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t2[13] = v2 * i2 + b2 * l3 + w2 * p2 + _2 * m2, t2[14] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
      }, t.O = function(t2, e2) {
        const r2 = {};
        for (let n2 = 0;n2 < e2.length; n2++) {
          const i2 = e2[n2];
          i2 in t2 && (r2[i2] = t2[i2]);
        }
        return r2;
      }, t.P = l2, t.Q = oh, t.R = tl, t.S = hh, t.T = zs, t.U = ch, t.V = f, t.W = d, t.X = H, t.Y = vh, t.Z = z2, t._ = e, t.a = st2, t.a$ = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l3 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
        return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l3 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l3 * n2, t2;
      }, t.a0 = 25, t.a1 = gh, t.a2 = (t2) => {
        const e2 = window.document.createElement("video");
        return e2.muted = true, new Promise((r2) => {
          e2.onloadstart = () => {
            r2(e2);
          };
          for (const r3 of t2) {
            const t3 = window.document.createElement("source");
            ht2(r3) || (e2.crossOrigin = "Anonymous"), t3.src = r3, e2.appendChild(t3);
          }
        });
      }, t.a3 = Pt2, t.a4 = function() {
        return O++;
      }, t.a5 = ga, t.a6 = Gc, t.a7 = ui2, t.a8 = So2, t.a9 = Ah, t.aA = function(t2, e2, r2, n2, i2 = false) {
        if (!r2[0] && !r2[1])
          return [0, 0];
        const s2 = i2 ? n2 === "map" ? -t2.bearingInRadians : 0 : n2 === "viewport" ? t2.bearingInRadians : 0;
        if (s2) {
          const t3 = Math.sin(s2), e3 = Math.cos(s2);
          r2 = [r2[0] * e3 - r2[1] * t3, r2[0] * t3 + r2[1] * e3];
        }
        return [i2 ? r2[0] : P(e2, r2[0], t2.zoom), i2 ? r2[1] : P(e2, r2[1], t2.zoom)];
      }, t.aC = Lc, t.aD = Qh, t.aE = Ac, t.aF = sp, t.aG = Gs, t.aH = Ll, t.aI = za, t.aJ = qa, t.aK = ja, t.aL = $2, t.aM = tt2, t.aN = dh, t.aO = function(t2, e2, r2) {
        return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
      }, t.aP = function(t2, e2, r2) {
        return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
      }, t.aQ = function(t2) {
        var e2 = new m(3);
        return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
      }, t.aR = function(t2, e2, r2) {
        return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2[3] = e2[3] * r2[3], t2;
      }, t.aS = function(t2, e2, r2) {
        return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
      }, t.aT = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = r2 * r2 + n2 * n2 + i2 * i2;
        return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e2[0] * s2, t2[1] = e2[1] * s2, t2[2] = e2[2] * s2, t2;
      }, t.aU = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[0], o2 = r2[1], l3 = r2[2];
        return t2[0] = i2 * l3 - s2 * o2, t2[1] = s2 * a2 - n2 * l3, t2[2] = n2 * o2 - i2 * a2, t2;
      }, t.aV = function(t2, e2) {
        return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
      }, t.aW = xh, t.aX = bh, t.aY = function(t2, e2, r2, n2, i2) {
        var s2, a2 = 1 / Math.tan(e2 / 2);
        return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, i2 != null && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
      }, t.aZ = function(t2) {
        var e2 = new m(16);
        return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
      }, t.a_ = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l3 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
        return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l3 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l3 * n2, t2;
      }, t.aa = function(t2) {
        const e2 = {};
        if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
          const s2 = n2 || i2;
          return e2[r2] = !s2 || s2.toLowerCase(), "";
        }), e2["max-age"]) {
          const t3 = parseInt(e2["max-age"], 10);
          isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
        }
        return e2;
      }, t.ab = Q2, t.ac = function(t2) {
        return Math.pow(2, t2);
      }, t.ad = x, t.ae = F2, t.af = 85.051129, t.ag = ph, t.ah = function(t2) {
        return Math.log(t2) / Math.LN2;
      }, t.ai = function(t2) {
        var e2 = t2[0], r2 = t2[1];
        return e2 * e2 + r2 * r2;
      }, t.aj = function(t2, e2) {
        const r2 = [];
        for (const n2 in t2)
          n2 in e2 || r2.push(n2);
        return r2;
      }, t.ak = function(t2, e2) {
        let r2 = 0, n2 = 0;
        if (t2.kind === "constant")
          n2 = t2.layoutSize;
        else if (t2.kind !== "source") {
          const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? F2(hr2.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
          t2.kind === "camera" ? n2 = fr2.number(t2.minSize, t2.maxSize, o2) : r2 = o2;
        }
        return { uSizeT: r2, uSize: n2 };
      }, t.am = function(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
        return t2.kind === "source" ? n2 / Tc : t2.kind === "composite" ? fr2.number(n2 / Tc, i2 / Tc, r2) : e2;
      }, t.an = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l3 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l3 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l3 - i2 * o2, _2 = n2 * u2 - s2 * o2, A2 = i2 * u2 - s2 * l3, S2 = c2 * y2 - h2 * d2, k2 = c2 * m2 - p2 * d2, M3 = c2 * g2 - f2 * d2, I2 = h2 * m2 - p2 * y2, z3 = h2 * g2 - f2 * y2, P2 = p2 * g2 - f2 * m2, C2 = x2 * P2 - v2 * z3 + b2 * I2 + w2 * M3 - _2 * k2 + A2 * S2;
        return C2 ? (t2[0] = (o2 * P2 - l3 * z3 + u2 * I2) * (C2 = 1 / C2), t2[1] = (i2 * z3 - n2 * P2 - s2 * I2) * C2, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * C2, t2[3] = (p2 * _2 - h2 * A2 - f2 * w2) * C2, t2[4] = (l3 * M3 - a2 * P2 - u2 * k2) * C2, t2[5] = (r2 * P2 - i2 * M3 + s2 * k2) * C2, t2[6] = (m2 * b2 - d2 * A2 - g2 * v2) * C2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v2) * C2, t2[8] = (a2 * z3 - o2 * M3 + u2 * S2) * C2, t2[9] = (n2 * M3 - r2 * z3 - s2 * S2) * C2, t2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * C2, t2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * C2, t2[12] = (o2 * k2 - a2 * I2 - l3 * S2) * C2, t2[13] = (r2 * I2 - n2 * k2 + i2 * S2) * C2, t2[14] = (y2 * v2 - d2 * w2 - m2 * x2) * C2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * C2, t2) : null;
      }, t.ao = M2, t.ap = function(t2) {
        return Math.hypot(t2[0], t2[1]);
      }, t.aq = function(t2) {
        return t2[0] = 0, t2[1] = 0, t2;
      }, t.ar = function(t2, e2, r2) {
        return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2;
      }, t.as = Rc, t.at = S, t.au = function(t2, e2, r2, n2) {
        const i2 = e2.y - t2.y, s2 = e2.x - t2.x, a2 = n2.y - r2.y, o2 = n2.x - r2.x, u2 = a2 * s2 - o2 * i2;
        if (u2 === 0)
          return null;
        const c2 = (o2 * (t2.y - r2.y) - a2 * (t2.x - r2.x)) / u2;
        return new l2(t2.x + c2 * s2, t2.y + c2 * i2);
      }, t.av = zh, t.aw = zo2, t.ax = function(t2) {
        let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
        for (const s2 of t2)
          e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
        return [e2, r2, n2, i2];
      }, t.ay = Hu, t.az = P, t.b = K, t.b$ = class extends da {
      }, t.b0 = function() {
        const t2 = new Float32Array(16);
        return x(t2), t2;
      }, t.b1 = function() {
        const t2 = new Float64Array(16);
        return x(t2), t2;
      }, t.b2 = function() {
        return new Float64Array(16);
      }, t.b3 = function(t2, e2, r2) {
        const n2 = new Float64Array(4);
        return function(t3, e3, r3, n3) {
          var i2 = 0.5 * Math.PI / 180;
          e3 *= i2, r3 *= i2, n3 *= i2;
          var s2 = Math.sin(e3), a2 = Math.cos(e3), o2 = Math.sin(r3), l3 = Math.cos(r3), u2 = Math.sin(n3), c2 = Math.cos(n3);
          t3[0] = s2 * l3 * c2 - a2 * o2 * u2, t3[1] = a2 * o2 * c2 + s2 * l3 * u2, t3[2] = a2 * l3 * u2 - s2 * o2 * c2, t3[3] = a2 * l3 * c2 + s2 * o2 * u2;
        }(n2, t2, e2 - 90, r2), n2;
      }, t.b4 = function(t2, e2, r2, n2) {
        var i2, s2, a2, o2, l3, u2 = e2[0], c2 = e2[1], h2 = e2[2], p2 = e2[3], f2 = r2[0], d2 = r2[1], m2 = r2[2], g2 = r2[3];
        return (s2 = u2 * f2 + c2 * d2 + h2 * m2 + p2 * g2) < 0 && (s2 = -s2, f2 = -f2, d2 = -d2, m2 = -m2, g2 = -g2), 1 - s2 > y ? (i2 = Math.acos(s2), a2 = Math.sin(i2), o2 = Math.sin((1 - n2) * i2) / a2, l3 = Math.sin(n2 * i2) / a2) : (o2 = 1 - n2, l3 = n2), t2[0] = o2 * u2 + l3 * f2, t2[1] = o2 * c2 + l3 * d2, t2[2] = o2 * h2 + l3 * m2, t2[3] = o2 * p2 + l3 * g2, t2;
      }, t.b5 = function(t2) {
        const e2 = new Float64Array(9);
        var r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2;
        h2 = (i2 = (n2 = t2)[0]) * (l3 = i2 + i2), p2 = (s2 = n2[1]) * l3, d2 = (a2 = n2[2]) * l3, y2 = a2 * (u2 = s2 + s2), g2 = (o2 = n2[3]) * l3, x2 = o2 * u2, v2 = o2 * (c2 = a2 + a2), (r2 = e2)[0] = 1 - (f2 = s2 * u2) - (m2 = a2 * c2), r2[3] = p2 - v2, r2[6] = d2 + x2, r2[1] = p2 + v2, r2[4] = 1 - h2 - m2, r2[7] = y2 - g2, r2[2] = d2 - x2, r2[5] = y2 + g2, r2[8] = 1 - h2 - f2;
        const b2 = tt2(-Math.asin(F2(e2[2], -1, 1)));
        let w2, _2;
        return Math.hypot(e2[5], e2[8]) < 0.001 ? (w2 = 0, _2 = -tt2(Math.atan2(e2[3], e2[4]))) : (w2 = tt2(e2[5] === 0 && e2[8] === 0 ? 0 : Math.atan2(e2[5], e2[8])), _2 = tt2(e2[1] === 0 && e2[0] === 0 ? 0 : Math.atan2(e2[1], e2[0]))), { roll: w2, pitch: b2 + 90, bearing: _2 };
      }, t.b6 = function(t2, e2) {
        return t2.roll == e2.roll && t2.pitch == e2.pitch && t2.bearing == e2.bearing;
      }, t.b7 = ke2, t.b8 = ao2, t.b9 = Ol, t.bA = function(t2) {
        if (t2.type === "custom")
          return new nh(t2);
        switch (t2.type) {
          case "background":
            return new Qc(t2);
          case "circle":
            return new Go2(t2);
          case "fill":
            return new Yl(t2);
          case "fill-extrusion":
            return new wu(t2);
          case "heatmap":
            return new nl(t2);
          case "hillshade":
            return new al(t2);
          case "line":
            return new Lu(t2);
          case "raster":
            return new rh(t2);
          case "symbol":
            return new Yc(t2);
        }
      }, t.bB = R, t.bC = function(t2, e2) {
        if (!t2)
          return [{ command: "setStyle", args: [e2] }];
        let r2 = [];
        try {
          if (!bt2(t2.version, e2.version))
            return [{ command: "setStyle", args: [e2] }];
          bt2(t2.center, e2.center) || r2.push({ command: "setCenter", args: [e2.center] }), bt2(t2.state, e2.state) || r2.push({ command: "setGlobalState", args: [e2.state] }), bt2(t2.centerAltitude, e2.centerAltitude) || r2.push({ command: "setCenterAltitude", args: [e2.centerAltitude] }), bt2(t2.zoom, e2.zoom) || r2.push({ command: "setZoom", args: [e2.zoom] }), bt2(t2.bearing, e2.bearing) || r2.push({ command: "setBearing", args: [e2.bearing] }), bt2(t2.pitch, e2.pitch) || r2.push({ command: "setPitch", args: [e2.pitch] }), bt2(t2.roll, e2.roll) || r2.push({ command: "setRoll", args: [e2.roll] }), bt2(t2.sprite, e2.sprite) || r2.push({ command: "setSprite", args: [e2.sprite] }), bt2(t2.glyphs, e2.glyphs) || r2.push({ command: "setGlyphs", args: [e2.glyphs] }), bt2(t2.transition, e2.transition) || r2.push({ command: "setTransition", args: [e2.transition] }), bt2(t2.light, e2.light) || r2.push({ command: "setLight", args: [e2.light] }), bt2(t2.terrain, e2.terrain) || r2.push({ command: "setTerrain", args: [e2.terrain] }), bt2(t2.sky, e2.sky) || r2.push({ command: "setSky", args: [e2.sky] }), bt2(t2.projection, e2.projection) || r2.push({ command: "setProjection", args: [e2.projection] });
          const n2 = {}, i2 = [];
          (function(t3, e3, r3, n3) {
            let i3;
            for (i3 in e3 = e3 || {}, t3 = t3 || {})
              Object.prototype.hasOwnProperty.call(t3, i3) && (Object.prototype.hasOwnProperty.call(e3, i3) || At2(i3, r3, n3));
            for (i3 in e3)
              Object.prototype.hasOwnProperty.call(e3, i3) && (Object.prototype.hasOwnProperty.call(t3, i3) ? bt2(t3[i3], e3[i3]) || (t3[i3].type === "geojson" && e3[i3].type === "geojson" && kt2(t3, e3, i3) ? wt(r3, { command: "setGeoJSONSourceData", args: [i3, e3[i3].data] }) : St2(i3, e3, r3, n3)) : _t2(i3, e3, r3));
          })(t2.sources, e2.sources, i2, n2);
          const s2 = [];
          t2.layers && t2.layers.forEach((t3) => {
            "source" in t3 && n2[t3.source] ? r2.push({ command: "removeLayer", args: [t3.id] }) : s2.push(t3);
          }), r2 = r2.concat(i2), function(t3, e3, r3) {
            e3 = e3 || [];
            const n3 = (t3 = t3 || []).map(It2), i3 = e3.map(It2), s3 = t3.reduce(zt2, {}), a2 = e3.reduce(zt2, {}), o2 = n3.slice(), l3 = Object.create(null);
            let u2, c2, h2, p2, f2;
            for (let t4 = 0, e4 = 0;t4 < n3.length; t4++)
              u2 = n3[t4], Object.prototype.hasOwnProperty.call(a2, u2) ? e4++ : (wt(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.indexOf(u2, e4), 1));
            for (let t4 = 0, e4 = 0;t4 < i3.length; t4++)
              u2 = i3[i3.length - 1 - t4], o2[o2.length - 1 - t4] !== u2 && (Object.prototype.hasOwnProperty.call(s3, u2) ? (wt(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.lastIndexOf(u2, o2.length - e4), 1)) : e4++, p2 = o2[o2.length - t4], wt(r3, { command: "addLayer", args: [a2[u2], p2] }), o2.splice(o2.length - t4, 0, u2), l3[u2] = true);
            for (let t4 = 0;t4 < i3.length; t4++)
              if (u2 = i3[t4], c2 = s3[u2], h2 = a2[u2], !l3[u2] && !bt2(c2, h2))
                if (bt2(c2.source, h2.source) && bt2(c2["source-layer"], h2["source-layer"]) && bt2(c2.type, h2.type)) {
                  for (f2 in Mt2(c2.layout, h2.layout, r3, u2, null, "setLayoutProperty"), Mt2(c2.paint, h2.paint, r3, u2, null, "setPaintProperty"), bt2(c2.filter, h2.filter) || wt(r3, { command: "setFilter", args: [u2, h2.filter] }), bt2(c2.minzoom, h2.minzoom) && bt2(c2.maxzoom, h2.maxzoom) || wt(r3, { command: "setLayerZoomRange", args: [u2, h2.minzoom, h2.maxzoom] }), c2)
                    Object.prototype.hasOwnProperty.call(c2, f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? Mt2(c2[f2], h2[f2], r3, u2, f2.slice(6), "setPaintProperty") : bt2(c2[f2], h2[f2]) || wt(r3, { command: "setLayerProperty", args: [u2, f2, h2[f2]] }));
                  for (f2 in h2)
                    Object.prototype.hasOwnProperty.call(h2, f2) && !Object.prototype.hasOwnProperty.call(c2, f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? Mt2(c2[f2], h2[f2], r3, u2, f2.slice(6), "setPaintProperty") : bt2(c2[f2], h2[f2]) || wt(r3, { command: "setLayerProperty", args: [u2, f2, h2[f2]] }));
                } else
                  wt(r3, { command: "removeLayer", args: [u2] }), p2 = o2[o2.lastIndexOf(u2) + 1], wt(r3, { command: "addLayer", args: [h2, p2] });
          }(s2, e2.layers, r2);
        } catch (t3) {
          console.warn("Unable to compute style diff:", t3), r2 = [{ command: "setStyle", args: [e2] }];
        }
        return r2;
      }, t.bD = function(t2) {
        const e2 = [], r2 = t2.id;
        return r2 === undefined && e2.push({ message: `layers.${r2}: missing required property "id"` }), t2.render === undefined && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && t2.renderingMode !== "2d" && t2.renderingMode !== "3d" && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
      }, t.bE = function t(e2, r2) {
        if (Array.isArray(e2)) {
          if (!Array.isArray(r2) || e2.length !== r2.length)
            return false;
          for (let n2 = 0;n2 < e2.length; n2++)
            if (!t(e2[n2], r2[n2]))
              return false;
          return true;
        }
        if (typeof e2 == "object" && e2 !== null && r2 !== null) {
          if (typeof r2 != "object")
            return false;
          if (Object.keys(e2).length !== Object.keys(r2).length)
            return false;
          for (const n2 in e2)
            if (!t(e2[n2], r2[n2]))
              return false;
          return true;
        }
        return e2 === r2;
      }, t.bF = D2, t.bG = j2, t.bH = class extends so2 {
        constructor(t2, e2) {
          super(t2, e2), this.current = 0;
        }
        set(t2) {
          this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
        }
      }, t.bI = lo2, t.bJ = class extends so2 {
        constructor(t2, e2) {
          super(t2, e2), this.current = uo2;
        }
        set(t2) {
          if (t2[12] !== this.current[12] || t2[0] !== this.current[0])
            return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
          for (let e2 = 1;e2 < 16; e2++)
            if (t2[e2] !== this.current[e2]) {
              this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
              break;
            }
        }
      }, t.bK = oo2, t.bL = class extends so2 {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
        }
      }, t.bM = class extends so2 {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
        }
      }, t.bN = g, t.bO = function(t2, e2) {
        var r2 = Math.sin(e2), n2 = Math.cos(e2);
        return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
      }, t.bP = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2];
        return t2[0] = n2 * r2[0] + i2 * r2[3] + s2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + s2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + s2 * r2[8], t2;
      }, t.bQ = function(t2, e2, r2, n2, i2, s2, a2) {
        var o2 = 1 / (e2 - r2), l3 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
        return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l3, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l3, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
      }, t.bR = class extends so2 {
        constructor(t2, e2) {
          super(t2, e2), this.current = new Array;
        }
        set(t2) {
          if (t2 != this.current) {
            this.current = t2;
            const e2 = new Float32Array(4 * t2.length);
            for (let r2 = 0;r2 < t2.length; r2++)
              e2[4 * r2] = t2[r2].r, e2[4 * r2 + 1] = t2[r2].g, e2[4 * r2 + 2] = t2[r2].b, e2[4 * r2 + 3] = t2[r2].a;
            this.gl.uniform4fv(this.location, e2);
          }
        }
      }, t.bS = class extends so2 {
        constructor(t2, e2) {
          super(t2, e2), this.current = new Array;
        }
        set(t2) {
          if (t2 != this.current) {
            this.current = t2;
            const e2 = new Float32Array(t2);
            this.gl.uniform1fv(this.location, e2);
          }
        }
      }, t.bT = class extends sa {
      }, t.bU = Uu, t.bV = class extends oa {
      }, t.bW = rl, t.bX = function(t2) {
        return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
      }, t.bY = el, t.bZ = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
        return t2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / (a2 = a2 || 1), t2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / a2, t2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / a2, t2;
      }, t.b_ = class extends Hs {
      }, t.ba = Dl, t.bb = $l, t.bc = B2, t.bd = V, t.be = Le2, t.bf = function(t2, e2, r2, n2, i2) {
        return B2(n2, i2, F2((t2 - e2) / (r2 - e2), 0, 1));
      }, t.bg = C, t.bh = function() {
        return new Float64Array(3);
      }, t.bi = function(t2, e2, r2, n2) {
        return t2[0] = e2[0] + r2[0] * n2, t2[1] = e2[1] + r2[1] * n2, t2[2] = e2[2] + r2[2] * n2, t2;
      }, t.bj = A, t.bk = function() {
        return new Float64Array(4);
      }, t.bl = function(t2, e2, r2, n2) {
        var i2 = [], s2 = [];
        return i2[0] = e2[0] - r2[0], i2[1] = e2[1] - r2[1], i2[2] = e2[2] - r2[2], s2[0] = i2[0] * Math.cos(n2) - i2[1] * Math.sin(n2), s2[1] = i2[0] * Math.sin(n2) + i2[1] * Math.cos(n2), s2[2] = i2[2], t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
      }, t.bm = function(t2, e2, r2, n2) {
        var i2 = [], s2 = [];
        return i2[0] = e2[0] - r2[0], i2[1] = e2[1] - r2[1], i2[2] = e2[2] - r2[2], s2[0] = i2[0], s2[1] = i2[1] * Math.cos(n2) - i2[2] * Math.sin(n2), s2[2] = i2[1] * Math.sin(n2) + i2[2] * Math.cos(n2), t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
      }, t.bn = function(t2, e2, r2, n2) {
        var i2 = [], s2 = [];
        return i2[0] = e2[0] - r2[0], i2[1] = e2[1] - r2[1], i2[2] = e2[2] - r2[2], s2[0] = i2[2] * Math.sin(n2) + i2[0] * Math.cos(n2), s2[1] = i2[1], s2[2] = i2[2] * Math.cos(n2) - i2[0] * Math.sin(n2), t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
      }, t.bo = b, t.bp = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l3 = e2[3], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
        return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 - u2 * n2, t2[1] = a2 * i2 - c2 * n2, t2[2] = o2 * i2 - h2 * n2, t2[3] = l3 * i2 - p2 * n2, t2[8] = s2 * n2 + u2 * i2, t2[9] = a2 * n2 + c2 * i2, t2[10] = o2 * n2 + h2 * i2, t2[11] = l3 * n2 + p2 * i2, t2;
      }, t.bq = function(t2, e2) {
        const r2 = C(t2, 360), n2 = C(e2, 360), i2 = n2 - r2, s2 = n2 > r2 ? i2 - 360 : i2 + 360;
        return Math.abs(i2) < Math.abs(s2) ? i2 : s2;
      }, t.br = function(t2) {
        return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2;
      }, t.bs = function(t2, e2, r2, n2) {
        const i2 = Math.sqrt(t2 * t2 + e2 * e2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
        t2 /= i2, e2 /= i2, r2 /= s2, n2 /= s2;
        const a2 = Math.acos(t2 * r2 + e2 * n2);
        return -e2 * r2 + t2 * n2 > 0 ? a2 : -a2;
      }, t.bt = function(t2, e2) {
        return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3];
      }, t.bu = ah, t.bv = function(t2, e2) {
        const r2 = C(t2, 2 * Math.PI), n2 = C(e2, 2 * Math.PI);
        return Math.min(Math.abs(r2 - n2), Math.abs(r2 - n2 + 2 * Math.PI), Math.abs(r2 - n2 - 2 * Math.PI));
      }, t.bw = function() {
        const t2 = {}, e2 = gt2.$version;
        for (const r2 in gt2.$root) {
          const n2 = gt2.$root[r2];
          if (n2.required) {
            let i2 = null;
            i2 = r2 === "version" ? e2 : n2.type === "array" ? [] : {}, i2 != null && (t2[r2] = i2);
          }
        }
        return t2;
      }, t.bx = cs, t.by = ut2, t.bz = function(t2) {
        t2 = t2.slice();
        const e2 = Object.create(null);
        for (let r2 = 0;r2 < t2.length; r2++)
          e2[t2[r2].id] = t2[r2];
        for (let r2 = 0;r2 < t2.length; r2++)
          "ref" in t2[r2] && (t2[r2] = vt2(t2[r2], e2[t2[r2].ref]));
        return t2;
      }, t.c = it2, t.c0 = function(t2, e2) {
        return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3] && t2[4] === e2[4] && t2[5] === e2[5] && t2[6] === e2[6] && t2[7] === e2[7] && t2[8] === e2[8] && t2[9] === e2[9] && t2[10] === e2[10] && t2[11] === e2[11] && t2[12] === e2[12] && t2[13] === e2[13] && t2[14] === e2[14] && t2[15] === e2[15];
      }, t.c1 = function(t2, e2) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l3 = t2[6], u2 = t2[7], c2 = t2[8], h2 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], m2 = t2[13], g2 = t2[14], x2 = t2[15], v2 = e2[0], b2 = e2[1], w2 = e2[2], _2 = e2[3], A2 = e2[4], S2 = e2[5], k2 = e2[6], M3 = e2[7], I2 = e2[8], z3 = e2[9], P2 = e2[10], C2 = e2[11], B3 = e2[12], V2 = e2[13], E3 = e2[14], T2 = e2[15];
        return Math.abs(r2 - v2) <= y * Math.max(1, Math.abs(r2), Math.abs(v2)) && Math.abs(n2 - b2) <= y * Math.max(1, Math.abs(n2), Math.abs(b2)) && Math.abs(i2 - w2) <= y * Math.max(1, Math.abs(i2), Math.abs(w2)) && Math.abs(s2 - _2) <= y * Math.max(1, Math.abs(s2), Math.abs(_2)) && Math.abs(a2 - A2) <= y * Math.max(1, Math.abs(a2), Math.abs(A2)) && Math.abs(o2 - S2) <= y * Math.max(1, Math.abs(o2), Math.abs(S2)) && Math.abs(l3 - k2) <= y * Math.max(1, Math.abs(l3), Math.abs(k2)) && Math.abs(u2 - M3) <= y * Math.max(1, Math.abs(u2), Math.abs(M3)) && Math.abs(c2 - I2) <= y * Math.max(1, Math.abs(c2), Math.abs(I2)) && Math.abs(h2 - z3) <= y * Math.max(1, Math.abs(h2), Math.abs(z3)) && Math.abs(p2 - P2) <= y * Math.max(1, Math.abs(p2), Math.abs(P2)) && Math.abs(f2 - C2) <= y * Math.max(1, Math.abs(f2), Math.abs(C2)) && Math.abs(d2 - B3) <= y * Math.max(1, Math.abs(d2), Math.abs(B3)) && Math.abs(m2 - V2) <= y * Math.max(1, Math.abs(m2), Math.abs(V2)) && Math.abs(g2 - E3) <= y * Math.max(1, Math.abs(g2), Math.abs(E3)) && Math.abs(x2 - T2) <= y * Math.max(1, Math.abs(x2), Math.abs(T2));
      }, t.c2 = function(t2, e2) {
        return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
      }, t.c3 = (t2) => t2.type === "symbol", t.c4 = (t2) => t2.type === "circle", t.c5 = (t2) => t2.type === "heatmap", t.c6 = (t2) => t2.type === "line", t.c7 = (t2) => t2.type === "fill", t.c8 = (t2) => t2.type === "fill-extrusion", t.c9 = (t2) => t2.type === "hillshade", t.cA = Zl, t.cB = yu, t.cC = hu, t.cD = Qu, t.cE = class {
        constructor(t2) {
          this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let t2 = performance.getEntriesByName(this._marks.measure);
          return t2.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
        }
      }, t.cF = function(t2, r2, n2, i2, s2) {
        return e(this, undefined, undefined, function* () {
          if (d())
            try {
              return yield H(t2, r2, n2, i2, s2);
            } catch (t3) {
            }
          return function(t3, e2, r3, n3, i3) {
            const { width: s3, height: a2 } = t3;
            Y2 && J2 || (Y2 = new OffscreenCanvas(s3, a2), J2 = Y2.getContext("2d", { willReadFrequently: true })), Y2.width = s3, Y2.height = a2, J2.drawImage(t3, 0, 0, s3, a2);
            const o2 = J2.getImageData(e2, r3, n3, i3);
            return J2.clearRect(0, 0, s3, a2), o2.data;
          }(t2, r2, n2, i2, s2);
        });
      }, t.cG = wh, t.cH = r, t.cI = s, t.cJ = cu, t.cK = Wu, t.cL = ei2, t.cM = Ss, t.ca = (t2) => t2.type === "raster", t.cb = (t2) => t2.type === "background", t.cc = (t2) => t2.type === "custom", t.cd = E2, t.ce = function(t2, e2, r2) {
        const n2 = I(e2.x - r2.x, e2.y - r2.y), i2 = I(t2.x - r2.x, t2.y - r2.y);
        var s2, a2;
        return tt2(Math.atan2(n2[0] * i2[1] - n2[1] * i2[0], (s2 = n2)[0] * (a2 = i2)[0] + s2[1] * a2[1]));
      }, t.cf = T, t.cg = function(t2, e2) {
        return rt2[e2] && (t2 instanceof MouseEvent || t2 instanceof WheelEvent);
      }, t.ch = function(t2, e2) {
        return et[e2] && "touches" in t2;
      }, t.ci = function(t2) {
        return et[t2] || rt2[t2];
      }, t.cj = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1];
        return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[12], t2[1] = r2[1] * n2 + r2[5] * i2 + r2[13], t2;
      }, t.ck = function(t2, e2) {
        const { x: r2, y: n2 } = yh.fromLngLat(e2);
        return !(t2 < 0 || t2 > 25 || n2 < 0 || n2 >= 1 || r2 < 0 || r2 >= 1);
      }, t.cl = function(t2, e2) {
        return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, t.cm = class extends Xs {
      }, t.cn = gp, t.cp = function(t2) {
        return t2.message === nt2;
      }, t.cq = lt2, t.cr = function(t2, e2) {
        st2.REGISTERED_PROTOCOLS[t2] = e2;
      }, t.cs = function(t2) {
        delete st2.REGISTERED_PROTOCOLS[t2];
      }, t.ct = function(t2, e2) {
        const r2 = {};
        for (let n3 = 0;n3 < t2.length; n3++) {
          const i2 = e2 && e2[t2[n3].id] || xi2(t2[n3]);
          e2 && (e2[t2[n3].id] = i2);
          let s2 = r2[i2];
          s2 || (s2 = r2[i2] = []), s2.push(t2[n3]);
        }
        const n2 = [];
        for (const t3 in r2)
          n2.push(r2[t3]);
        return n2;
      }, t.cu = is, t.cv = _h, t.cw = Sh, t.cx = lc, t.cy = function(e2) {
        e2.bucket.createArrays(), e2.bucket.tilePixelRatio = z2 / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = false;
        const r2 = e2.bucket.layers[0], n2 = r2.layout, i2 = r2._unevaluatedLayout._values, s2 = { layoutIconSize: i2["icon-size"].possiblyEvaluate(new ks(e2.bucket.zoom + 1), e2.canonical), layoutTextSize: i2["text-size"].possiblyEvaluate(new ks(e2.bucket.zoom + 1), e2.canonical), textMaxSize: i2["text-size"].possiblyEvaluate(new ks(18)) };
        if (e2.bucket.textSizeData.kind === "composite") {
          const { minZoom: t2, maxZoom: r3 } = e2.bucket.textSizeData;
          s2.compositeTextSizes = [i2["text-size"].possiblyEvaluate(new ks(t2), e2.canonical), i2["text-size"].possiblyEvaluate(new ks(r3), e2.canonical)];
        }
        if (e2.bucket.iconSizeData.kind === "composite") {
          const { minZoom: t2, maxZoom: r3 } = e2.bucket.iconSizeData;
          s2.compositeIconSizes = [i2["icon-size"].possiblyEvaluate(new ks(t2), e2.canonical), i2["icon-size"].possiblyEvaluate(new ks(r3), e2.canonical)];
        }
        const a2 = n2.get("text-line-height") * Hu, o2 = n2.get("text-rotation-alignment") !== "viewport" && n2.get("symbol-placement") !== "point", l3 = n2.get("text-keep-upright"), u2 = n2.get("text-size");
        for (const i3 of e2.bucket.features) {
          const c2 = n2.get("text-font").evaluate(i3, {}, e2.canonical).join(","), h2 = u2.evaluate(i3, {}, e2.canonical), p2 = s2.layoutTextSize.evaluate(i3, {}, e2.canonical), f2 = s2.layoutIconSize.evaluate(i3, {}, e2.canonical), d2 = { horizontal: {}, vertical: undefined }, y2 = i3.text;
          let m2, g2 = [0, 0];
          if (y2) {
            const s3 = y2.toString(), u3 = n2.get("text-letter-spacing").evaluate(i3, {}, e2.canonical) * Hu, f3 = fs(s3) ? u3 : 0, m3 = n2.get("text-anchor").evaluate(i3, {}, e2.canonical), x3 = Wh(r2, i3, e2.canonical);
            if (!x3) {
              const t2 = n2.get("text-radial-offset").evaluate(i3, {}, e2.canonical);
              g2 = t2 ? Jh(m3, [t2 * Hu, Yh]) : n2.get("text-offset").evaluate(i3, {}, e2.canonical).map((t3) => t3 * Hu);
            }
            let v3 = o2 ? "center" : n2.get("text-justify").evaluate(i3, {}, e2.canonical);
            const b2 = n2.get("symbol-placement") === "point" ? n2.get("text-max-width").evaluate(i3, {}, e2.canonical) * Hu : 1 / 0, w2 = () => {
              e2.bucket.allowVerticalPlacement && ps(s3) && (d2.vertical = fc(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, "left", f3, g2, t.al.vertical, true, p2, h2));
            };
            if (!o2 && x3) {
              const r3 = new Set;
              if (v3 === "auto")
                for (let t2 = 0;t2 < x3.values.length; t2 += 2)
                  r3.add(Qh(x3.values[t2]));
              else
                r3.add(v3);
              let n3 = false;
              for (const i4 of r3)
                if (!d2.horizontal[i4])
                  if (n3)
                    d2.horizontal[i4] = d2.horizontal[0];
                  else {
                    const r4 = fc(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, "center", i4, f3, g2, t.al.horizontal, false, p2, h2);
                    r4 && (d2.horizontal[i4] = r4, n3 = r4.positionedLines.length === 1);
                  }
              w2();
            } else {
              v3 === "auto" && (v3 = Qh(m3));
              const r3 = fc(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v3, f3, g2, t.al.horizontal, false, p2, h2);
              r3 && (d2.horizontal[v3] = r3), w2(), ps(s3) && o2 && l3 && (d2.vertical = fc(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v3, f3, g2, t.al.vertical, false, p2, h2));
            }
          }
          let x2 = false;
          if (i3.icon && i3.icon.name) {
            const t2 = e2.imageMap[i3.icon.name];
            t2 && (m2 = Cc(e2.imagePositions[i3.icon.name], n2.get("icon-offset").evaluate(i3, {}, e2.canonical), n2.get("icon-anchor").evaluate(i3, {}, e2.canonical)), x2 = !!t2.sdf, e2.bucket.sdfIcons === undefined ? e2.bucket.sdfIcons = x2 : e2.bucket.sdfIcons !== x2 && U("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e2.bucket.pixelRatio || n2.get("icon-rotate").constantOr(1) !== 0) && (e2.bucket.iconsNeedLinear = true));
          }
          const v2 = rp(d2.horizontal) || d2.vertical;
          e2.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || m2) && tp(e2.bucket, i3, d2, m2, e2.imageMap, s2, p2, f2, g2, x2, e2.canonical, e2.subdivisionGranularity);
        }
        e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
      }, t.cz = Bu, t.d = ht2, t.e = L, t.f = (t2) => e(undefined, undefined, undefined, function* () {
        if (t2.byteLength === 0)
          return createImageBitmap(new ImageData(1, 1));
        const e2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
        try {
          return createImageBitmap(e2);
        } catch (t3) {
          throw new Error(`Could not load image because of ${t3.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), t.g = at2, t.h = (t2) => new Promise((e2, r2) => {
        const n2 = new Image;
        n2.onload = () => {
          e2(n2), URL.revokeObjectURL(n2.src), n2.onload = null, window.requestAnimationFrame(() => {
            n2.src = X;
          });
        }, n2.onerror = () => r2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const i2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
        n2.src = t2.byteLength ? URL.createObjectURL(i2) : X;
      }), t.i = G2, t.j = (t2, e2) => ct2(L(t2, { type: "json" }), e2), t.k = yt2, t.l = dt2, t.m = ct2, t.n = (t2, e2) => ct2(L(t2, { type: "arrayBuffer" }), e2), t.o = function(t2) {
        return new Qu(t2).readFields(ec, []);
      }, t.p = sc, t.q = Qo2, t.r = Ds, t.s = W2, t.t = Ji2, t.u = hs, t.v = gt2, t.w = U, t.x = es, t.y = Yi2, t.z = function([t2, e2, r2]) {
        return e2 += 90, e2 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t2 * Math.cos(e2) * Math.sin(r2), y: t2 * Math.sin(e2) * Math.sin(r2), z: t2 * Math.cos(r2) };
      };
    });
    define2("worker", ["./shared"], function(e) {

      class t {
        constructor(e2) {
          this.keyCache = {}, e2 && this.replace(e2);
        }
        replace(e2) {
          this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
        }
        update(t2, o2) {
          for (const o3 of t2) {
            this._layerConfigs[o3.id] = o3;
            const t3 = this._layers[o3.id] = e.bA(o3);
            t3._featureFilter = e.a7(t3.filter), this.keyCache[o3.id] && delete this.keyCache[o3.id];
          }
          for (const e2 of o2)
            delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
          this.familiesBySource = {};
          const i2 = e.ct(Object.values(this._layerConfigs), this.keyCache);
          for (const e2 of i2) {
            const t3 = e2.map((e3) => this._layers[e3.id]), o3 = t3[0];
            if (o3.visibility === "none")
              continue;
            const i3 = o3.source || "";
            let r2 = this.familiesBySource[i3];
            r2 || (r2 = this.familiesBySource[i3] = {});
            const s2 = o3.sourceLayer || "_geojsonTileLayer";
            let n2 = r2[s2];
            n2 || (n2 = r2[s2] = []), n2.push(t3);
          }
        }
      }

      class o {
        constructor(t2) {
          const o2 = {}, i2 = [];
          for (const e2 in t2) {
            const r3 = t2[e2], s3 = o2[e2] = {};
            for (const e3 in r3) {
              const t3 = r3[+e3];
              if (!t3 || t3.bitmap.width === 0 || t3.bitmap.height === 0)
                continue;
              const o3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
              i2.push(o3), s3[e3] = { rect: o3, metrics: t3.metrics };
            }
          }
          const { w: r2, h: s2 } = e.p(i2), n2 = new e.q({ width: r2 || 1, height: s2 || 1 });
          for (const i3 in t2) {
            const r3 = t2[i3];
            for (const t3 in r3) {
              const s3 = r3[+t3];
              if (!s3 || s3.bitmap.width === 0 || s3.bitmap.height === 0)
                continue;
              const a2 = o2[i3][t3].rect;
              e.q.copy(s3.bitmap, n2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, s3.bitmap);
            }
          }
          this.image = n2, this.positions = o2;
        }
      }
      e.cu("GlyphAtlas", o);

      class i {
        constructor(t2) {
          this.tileID = new e.Y(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.inFlightDependencies = [];
        }
        parse(t2, i2, s2, n2, a2) {
          return e._(this, undefined, undefined, function* () {
            this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.a5;
            const l3 = new e.cv(Object.keys(t2.layers).sort()), c2 = new e.cw(this.tileID, this.promoteId);
            c2.bucketLayerIDs = [];
            const u2 = {}, h2 = { featureIndex: c2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s2, subdivisionGranularity: a2 }, d2 = i2.familiesBySource[this.source];
            for (const o2 in d2) {
              const i3 = t2.layers[o2];
              if (!i3)
                continue;
              i3.version === 1 && e.w(`Vector tile source "${this.source}" layer "${o2}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const n3 = l3.encode(o2), a3 = [];
              for (let e2 = 0;e2 < i3.length; e2++) {
                const t3 = i3.feature(e2), r2 = c2.getId(t3, o2);
                a3.push({ feature: t3, id: r2, index: e2, sourceLayerIndex: n3 });
              }
              for (const t3 of d2[o2]) {
                const o3 = t3[0];
                o3.source !== this.source && e.w(`layer.source = ${o3.source} does not equal this.source = ${this.source}`), o3.minzoom && this.zoom < Math.floor(o3.minzoom) || o3.maxzoom && this.zoom >= o3.maxzoom || o3.visibility !== "none" && (r(t3, this.zoom, s2), (u2[o3.id] = o3.createBucket({ index: c2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n3, sourceID: this.source })).populate(a3, h2, this.tileID.canonical), c2.bucketLayerIDs.push(t3.map((e2) => e2.id)));
              }
            }
            const f2 = e.bF(h2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
            this.inFlightDependencies.forEach((e2) => e2 == null ? undefined : e2.abort()), this.inFlightDependencies = [];
            let g2 = Promise.resolve({});
            if (Object.keys(f2).length) {
              const e2 = new AbortController;
              this.inFlightDependencies.push(e2), g2 = n2.sendAsync({ type: "GG", data: { stacks: f2, source: this.source, tileID: this.tileID, type: "glyphs" } }, e2);
            }
            const p2 = Object.keys(h2.iconDependencies);
            let m2 = Promise.resolve({});
            if (p2.length) {
              const e2 = new AbortController;
              this.inFlightDependencies.push(e2), m2 = n2.sendAsync({ type: "GI", data: { icons: p2, source: this.source, tileID: this.tileID, type: "icons" } }, e2);
            }
            const y2 = Object.keys(h2.patternDependencies);
            let v2 = Promise.resolve({});
            if (y2.length) {
              const e2 = new AbortController;
              this.inFlightDependencies.push(e2), v2 = n2.sendAsync({ type: "GI", data: { icons: y2, source: this.source, tileID: this.tileID, type: "patterns" } }, e2);
            }
            const [w2, x2, _2] = yield Promise.all([g2, m2, v2]), b2 = new o(w2), M3 = new e.cx(x2, _2);
            for (const t3 in u2) {
              const o2 = u2[t3];
              o2 instanceof e.a6 ? (r(o2.layers, this.zoom, s2), e.cy({ bucket: o2, glyphMap: w2, glyphPositions: b2.positions, imageMap: x2, imagePositions: M3.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: h2.subdivisionGranularity })) : o2.hasPattern && (o2 instanceof e.cz || o2 instanceof e.cA || o2 instanceof e.cB) && (r(o2.layers, this.zoom, s2), o2.addFeatures(h2, this.tileID.canonical, M3.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(u2).filter((e2) => !e2.isEmpty()), featureIndex: c2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: b2.image, imageAtlas: M3, glyphMap: this.returnDependencies ? w2 : null, iconMap: this.returnDependencies ? x2 : null, glyphPositions: this.returnDependencies ? b2.positions : null };
          });
        }
      }
      function r(t2, o2, i2) {
        const r2 = new e.C(o2);
        for (const e2 of t2)
          e2.recalculate(r2, i2);
      }

      class s {
        constructor(e2, t2, o2) {
          this.actor = e2, this.layerIndex = t2, this.availableImages = o2, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            const i2 = yield e.n(t2.request, o2);
            try {
              return { vectorTile: new e.cC.VectorTile(new e.cD(i2.data)), rawData: i2.data, cacheControl: i2.cacheControl, expires: i2.expires };
            } catch (e2) {
              const o3 = new Uint8Array(i2.data);
              let r2 = `Unable to parse the tile at ${t2.request.url}, `;
              throw r2 += o3[0] === 31 && o3[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e2.message}`, new Error(r2);
            }
          });
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const o2 = t2.uid, r2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.cE(t2.request), s2 = new i(t2);
            this.loading[o2] = s2;
            const n2 = new AbortController;
            s2.abort = n2;
            try {
              const i2 = yield this.loadVectorTile(t2, n2);
              if (delete this.loading[o2], !i2)
                return null;
              const a2 = i2.rawData, l3 = {};
              i2.expires && (l3.expires = i2.expires), i2.cacheControl && (l3.cacheControl = i2.cacheControl);
              const c2 = {};
              if (r2) {
                const e2 = r2.finish();
                e2 && (c2.resourceTiming = JSON.parse(JSON.stringify(e2)));
              }
              s2.vectorTile = i2.vectorTile;
              const u2 = s2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
              this.loaded[o2] = s2, this.fetching[o2] = { rawTileData: a2, cacheControl: l3, resourceTiming: c2 };
              try {
                const t3 = yield u2;
                return e.e({ rawTileData: a2.slice(0) }, t3, l3, c2);
              } finally {
                delete this.fetching[o2];
              }
            } catch (e2) {
              throw delete this.loading[o2], s2.status = "done", this.loaded[o2] = s2, e2;
            }
          });
        }
        reloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const o2 = t2.uid;
            if (!this.loaded || !this.loaded[o2])
              throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const i2 = this.loaded[o2];
            if (i2.showCollisionBoxes = t2.showCollisionBoxes, i2.status === "parsing") {
              const r2 = yield i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
              let s2;
              if (this.fetching[o2]) {
                const { rawTileData: t3, cacheControl: i3, resourceTiming: n2 } = this.fetching[o2];
                delete this.fetching[o2], s2 = e.e({ rawTileData: t3.slice(0) }, r2, i3, n2);
              } else
                s2 = r2;
              return s2;
            }
            if (i2.status === "done" && i2.vectorTile)
              return i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
          });
        }
        abortTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = this.loading, o2 = t2.uid;
            e2 && e2[o2] && e2[o2].abort && (e2[o2].abort.abort(), delete e2[o2]);
          });
        }
        removeTile(t2) {
          return e._(this, undefined, undefined, function* () {
            this.loaded && this.loaded[t2.uid] && delete this.loaded[t2.uid];
          });
        }
      }

      class n {
        constructor() {
          this.loaded = {};
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const { uid: o2, encoding: i2, rawImageData: r2, redFactor: s2, greenFactor: n2, blueFactor: a2, baseShift: l3 } = t2, c2 = r2.width + 2, u2 = r2.height + 2, h2 = e.b(r2) ? new e.R({ width: c2, height: u2 }, yield e.cF(r2, -1, -1, c2, u2)) : r2, d2 = new e.cG(o2, h2, i2, s2, n2, a2, l3);
            return this.loaded = this.loaded || {}, this.loaded[o2] = d2, d2;
          });
        }
        removeTile(e2) {
          const t2 = this.loaded, o2 = e2.uid;
          t2 && t2[o2] && delete t2[o2];
        }
      }
      var a, l2, c = function() {
        if (l2)
          return a;
        function e2(e3, o2) {
          if (e3.length !== 0) {
            t2(e3[0], o2);
            for (var i2 = 1;i2 < e3.length; i2++)
              t2(e3[i2], !o2);
          }
        }
        function t2(e3, t3) {
          for (var o2 = 0, i2 = 0, r2 = 0, s2 = e3.length, n2 = s2 - 1;r2 < s2; n2 = r2++) {
            var a2 = (e3[r2][0] - e3[n2][0]) * (e3[n2][1] + e3[r2][1]), l3 = o2 + a2;
            i2 += Math.abs(o2) >= Math.abs(a2) ? o2 - l3 + a2 : a2 - l3 + o2, o2 = l3;
          }
          o2 + i2 >= 0 != !!t3 && e3.reverse();
        }
        return l2 = 1, a = function t(o2, i2) {
          var r2, s2 = o2 && o2.type;
          if (s2 === "FeatureCollection")
            for (r2 = 0;r2 < o2.features.length; r2++)
              t(o2.features[r2], i2);
          else if (s2 === "GeometryCollection")
            for (r2 = 0;r2 < o2.geometries.length; r2++)
              t(o2.geometries[r2], i2);
          else if (s2 === "Feature")
            t(o2.geometry, i2);
          else if (s2 === "Polygon")
            e2(o2.coordinates, i2);
          else if (s2 === "MultiPolygon")
            for (r2 = 0;r2 < o2.coordinates.length; r2++)
              e2(o2.coordinates[r2], i2);
          return o2;
        };
      }(), u = e.cH(c);
      const h = e.cC.VectorTileFeature.prototype.toGeoJSON;

      class d {
        constructor(t2) {
          this._feature = t2, this.extent = e.Z, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
        }
        loadGeometry() {
          if (this._feature.type === 1) {
            const t2 = [];
            for (const o2 of this._feature.geometry)
              t2.push([new e.P(o2[0], o2[1])]);
            return t2;
          }
          {
            const t2 = [];
            for (const o2 of this._feature.geometry) {
              const i2 = [];
              for (const t3 of o2)
                i2.push(new e.P(t3[0], t3[1]));
              t2.push(i2);
            }
            return t2;
          }
        }
        toGeoJSON(e2, t2, o2) {
          return h.call(this, e2, t2, o2);
        }
      }

      class f {
        constructor(t2) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.Z, this.length = t2.length, this._features = t2;
        }
        feature(e2) {
          return new d(this._features[e2]);
        }
      }
      var g, p, m, y = { exports: {} }, v = function() {
        if (m)
          return y.exports;
        m = 1;
        var t2 = e.cK(), o2 = function() {
          if (p)
            return g;
          p = 1;
          var t3 = e.cI(), o3 = e.cJ().VectorTileFeature;
          function i3(e2, t4) {
            this.options = t4 || {}, this.features = e2, this.length = e2.length;
          }
          function r3(e2, t4) {
            this.id = typeof e2.id == "number" ? e2.id : undefined, this.type = e2.type, this.rawGeometry = e2.type === 1 ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t4 || 4096;
          }
          return g = i3, i3.prototype.feature = function(e2) {
            return new r3(this.features[e2], this.options.extent);
          }, r3.prototype.loadGeometry = function() {
            var e2 = this.rawGeometry;
            this.geometry = [];
            for (var o4 = 0;o4 < e2.length; o4++) {
              for (var i4 = e2[o4], r4 = [], s3 = 0;s3 < i4.length; s3++)
                r4.push(new t3(i4[s3][0], i4[s3][1]));
              this.geometry.push(r4);
            }
            return this.geometry;
          }, r3.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e2 = this.geometry, t4 = 1 / 0, o4 = -1 / 0, i4 = 1 / 0, r4 = -1 / 0, s3 = 0;s3 < e2.length; s3++)
              for (var n3 = e2[s3], a3 = 0;a3 < n3.length; a3++) {
                var l4 = n3[a3];
                t4 = Math.min(t4, l4.x), o4 = Math.max(o4, l4.x), i4 = Math.min(i4, l4.y), r4 = Math.max(r4, l4.y);
              }
            return [t4, i4, o4, r4];
          }, r3.prototype.toGeoJSON = o3.prototype.toGeoJSON, g;
        }();
        function i2(e2) {
          var o3 = new t2;
          return function(e3, t3) {
            for (var o4 in e3.layers)
              t3.writeMessage(3, r2, e3.layers[o4]);
          }(e2, o3), o3.finish();
        }
        function r2(e2, t3) {
          var o3;
          t3.writeVarintField(15, e2.version || 1), t3.writeStringField(1, e2.name || ""), t3.writeVarintField(5, e2.extent || 4096);
          var i3 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (o3 = 0;o3 < e2.length; o3++)
            i3.feature = e2.feature(o3), t3.writeMessage(2, s2, i3);
          var r3 = i3.keys;
          for (o3 = 0;o3 < r3.length; o3++)
            t3.writeStringField(3, r3[o3]);
          var n3 = i3.values;
          for (o3 = 0;o3 < n3.length; o3++)
            t3.writeMessage(4, u2, n3[o3]);
        }
        function s2(e2, t3) {
          var o3 = e2.feature;
          o3.id !== undefined && t3.writeVarintField(1, o3.id), t3.writeMessage(2, n2, e2), t3.writeVarintField(3, o3.type), t3.writeMessage(4, c2, o3);
        }
        function n2(e2, t3) {
          var { feature: o3, keys: i3, values: r3, keycache: s3, valuecache: n3 } = e2;
          for (var a3 in o3.properties) {
            var l4 = o3.properties[a3], c3 = s3[a3];
            if (l4 !== null) {
              c3 === undefined && (i3.push(a3), s3[a3] = c3 = i3.length - 1), t3.writeVarint(c3);
              var u3 = typeof l4;
              u3 !== "string" && u3 !== "boolean" && u3 !== "number" && (l4 = JSON.stringify(l4));
              var h2 = u3 + ":" + l4, d2 = n3[h2];
              d2 === undefined && (r3.push(l4), n3[h2] = d2 = r3.length - 1), t3.writeVarint(d2);
            }
          }
        }
        function a2(e2, t3) {
          return (t3 << 3) + (7 & e2);
        }
        function l3(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function c2(e2, t3) {
          for (var o3 = e2.loadGeometry(), i3 = e2.type, r3 = 0, s3 = 0, n3 = o3.length, c3 = 0;c3 < n3; c3++) {
            var u3 = o3[c3], h2 = 1;
            i3 === 1 && (h2 = u3.length), t3.writeVarint(a2(1, h2));
            for (var d2 = i3 === 3 ? u3.length - 1 : u3.length, f2 = 0;f2 < d2; f2++) {
              f2 === 1 && i3 !== 1 && t3.writeVarint(a2(2, d2 - 1));
              var g2 = u3[f2].x - r3, p2 = u3[f2].y - s3;
              t3.writeVarint(l3(g2)), t3.writeVarint(l3(p2)), r3 += g2, s3 += p2;
            }
            i3 === 3 && t3.writeVarint(a2(7, 1));
          }
        }
        function u2(e2, t3) {
          var o3 = typeof e2;
          o3 === "string" ? t3.writeStringField(1, e2) : o3 === "boolean" ? t3.writeBooleanField(7, e2) : o3 === "number" && (e2 % 1 != 0 ? t3.writeDoubleField(3, e2) : e2 < 0 ? t3.writeSVarintField(6, e2) : t3.writeVarintField(5, e2));
        }
        return y.exports = i2, y.exports.fromVectorTileJs = i2, y.exports.fromGeojsonVt = function(e2, t3) {
          t3 = t3 || {};
          var r3 = {};
          for (var s3 in e2)
            r3[s3] = new o2(e2[s3].features, t3), r3[s3].name = s3, r3[s3].version = t3.version, r3[s3].extent = t3.extent;
          return i2({ layers: r3 });
        }, y.exports.GeoJSONWrapper = o2, y.exports;
      }(), w = e.cH(v);
      const x = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, _ = Math.fround || (b = new Float32Array(1), (e2) => (b[0] = +e2, b[0]));
      var b;
      const M2 = 3, S = 5, I = 6;

      class P {
        constructor(e2) {
          this.options = Object.assign(Object.create(x), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(e2) {
          const { log: t2, minZoom: o2, maxZoom: i2 } = this.options;
          t2 && console.time("total time");
          const r2 = `prepare ${e2.length} points`;
          t2 && console.time(r2), this.points = e2;
          const s2 = [];
          for (let t3 = 0;t3 < e2.length; t3++) {
            const o3 = e2[t3];
            if (!o3.geometry)
              continue;
            const [i3, r3] = o3.geometry.coordinates, n3 = _(D2(i3)), a2 = _(C(r3));
            s2.push(n3, a2, 1 / 0, t3, -1, 1), this.options.reduce && s2.push(0);
          }
          let n2 = this.trees[i2 + 1] = this._createTree(s2);
          t2 && console.timeEnd(r2);
          for (let e3 = i2;e3 >= o2; e3--) {
            const o3 = +Date.now();
            n2 = this.trees[e3] = this._createTree(this._cluster(n2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, n2.numItems, +Date.now() - o3);
          }
          return t2 && console.timeEnd("total time"), this;
        }
        getClusters(e2, t2) {
          let o2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
          const i2 = Math.max(-90, Math.min(90, e2[1]));
          let r2 = e2[2] === 180 ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
          const s2 = Math.max(-90, Math.min(90, e2[3]));
          if (e2[2] - e2[0] >= 360)
            o2 = -180, r2 = 180;
          else if (o2 > r2) {
            const e3 = this.getClusters([o2, i2, 180, s2], t2), n3 = this.getClusters([-180, i2, r2, s2], t2);
            return e3.concat(n3);
          }
          const n2 = this.trees[this._limitZoom(t2)], a2 = n2.range(D2(o2), C(s2), D2(r2), C(i2)), l3 = n2.data, c2 = [];
          for (const e3 of a2) {
            const t3 = this.stride * e3;
            c2.push(l3[t3 + S] > 1 ? k(l3, t3, this.clusterProps) : this.points[l3[t3 + M2]]);
          }
          return c2;
        }
        getChildren(e2) {
          const t2 = this._getOriginId(e2), o2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", r2 = this.trees[o2];
          if (!r2)
            throw new Error(i2);
          const s2 = r2.data;
          if (t2 * this.stride >= s2.length)
            throw new Error(i2);
          const n2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = r2.within(s2[t2 * this.stride], s2[t2 * this.stride + 1], n2), l3 = [];
          for (const t3 of a2) {
            const o3 = t3 * this.stride;
            s2[o3 + 4] === e2 && l3.push(s2[o3 + S] > 1 ? k(s2, o3, this.clusterProps) : this.points[s2[o3 + M2]]);
          }
          if (l3.length === 0)
            throw new Error(i2);
          return l3;
        }
        getLeaves(e2, t2, o2) {
          const i2 = [];
          return this._appendLeaves(i2, e2, t2 = t2 || 10, o2 = o2 || 0, 0), i2;
        }
        getTile(e2, t2, o2) {
          const i2 = this.trees[this._limitZoom(e2)], r2 = Math.pow(2, e2), { extent: s2, radius: n2 } = this.options, a2 = n2 / s2, l3 = (o2 - a2) / r2, c2 = (o2 + 1 + a2) / r2, u2 = { features: [] };
          return this._addTileFeatures(i2.range((t2 - a2) / r2, l3, (t2 + 1 + a2) / r2, c2), i2.data, t2, o2, r2, u2), t2 === 0 && this._addTileFeatures(i2.range(1 - a2 / r2, l3, 1, c2), i2.data, r2, o2, r2, u2), t2 === r2 - 1 && this._addTileFeatures(i2.range(0, l3, a2 / r2, c2), i2.data, -1, o2, r2, u2), u2.features.length ? u2 : null;
        }
        getClusterExpansionZoom(e2) {
          let t2 = this._getOriginZoom(e2) - 1;
          for (;t2 <= this.options.maxZoom; ) {
            const o2 = this.getChildren(e2);
            if (t2++, o2.length !== 1)
              break;
            e2 = o2[0].properties.cluster_id;
          }
          return t2;
        }
        _appendLeaves(e2, t2, o2, i2, r2) {
          const s2 = this.getChildren(t2);
          for (const t3 of s2) {
            const s3 = t3.properties;
            if (s3 && s3.cluster ? r2 + s3.point_count <= i2 ? r2 += s3.point_count : r2 = this._appendLeaves(e2, s3.cluster_id, o2, i2, r2) : r2 < i2 ? r2++ : e2.push(t3), e2.length === o2)
              break;
          }
          return r2;
        }
        _createTree(t2) {
          const o2 = new e.aF(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let e2 = 0;e2 < t2.length; e2 += this.stride)
            o2.add(t2[e2], t2[e2 + 1]);
          return o2.finish(), o2.data = t2, o2;
        }
        _addTileFeatures(e2, t2, o2, i2, r2, s2) {
          for (const n2 of e2) {
            const e3 = n2 * this.stride, a2 = t2[e3 + S] > 1;
            let l3, c2, u2;
            if (a2)
              l3 = T(t2, e3, this.clusterProps), c2 = t2[e3], u2 = t2[e3 + 1];
            else {
              const o3 = this.points[t2[e3 + M2]];
              l3 = o3.properties;
              const [i3, r3] = o3.geometry.coordinates;
              c2 = D2(i3), u2 = C(r3);
            }
            const h2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * r2 - o2)), Math.round(this.options.extent * (u2 * r2 - i2))]], tags: l3 };
            let d2;
            d2 = a2 || this.options.generateId ? t2[e3 + M2] : this.points[t2[e3 + M2]].id, d2 !== undefined && (h2.id = d2), s2.features.push(h2);
          }
        }
        _limitZoom(e2) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
        }
        _cluster(e2, t2) {
          const { radius: o2, extent: i2, reduce: r2, minPoints: s2 } = this.options, n2 = o2 / (i2 * Math.pow(2, t2)), a2 = e2.data, l3 = [], c2 = this.stride;
          for (let o3 = 0;o3 < a2.length; o3 += c2) {
            if (a2[o3 + 2] <= t2)
              continue;
            a2[o3 + 2] = t2;
            const i3 = a2[o3], u2 = a2[o3 + 1], h2 = e2.within(a2[o3], a2[o3 + 1], n2), d2 = a2[o3 + S];
            let f2 = d2;
            for (const e3 of h2) {
              const o4 = e3 * c2;
              a2[o4 + 2] > t2 && (f2 += a2[o4 + S]);
            }
            if (f2 > d2 && f2 >= s2) {
              let e3, s3 = i3 * d2, n3 = u2 * d2, g2 = -1;
              const p2 = ((o3 / c2 | 0) << 5) + (t2 + 1) + this.points.length;
              for (const i4 of h2) {
                const l4 = i4 * c2;
                if (a2[l4 + 2] <= t2)
                  continue;
                a2[l4 + 2] = t2;
                const u3 = a2[l4 + S];
                s3 += a2[l4] * u3, n3 += a2[l4 + 1] * u3, a2[l4 + 4] = p2, r2 && (e3 || (e3 = this._map(a2, o3, true), g2 = this.clusterProps.length, this.clusterProps.push(e3)), r2(e3, this._map(a2, l4)));
              }
              a2[o3 + 4] = p2, l3.push(s3 / f2, n3 / f2, 1 / 0, p2, -1, f2), r2 && l3.push(g2);
            } else {
              for (let e3 = 0;e3 < c2; e3++)
                l3.push(a2[o3 + e3]);
              if (f2 > 1)
                for (const e3 of h2) {
                  const o4 = e3 * c2;
                  if (!(a2[o4 + 2] <= t2)) {
                    a2[o4 + 2] = t2;
                    for (let e4 = 0;e4 < c2; e4++)
                      l3.push(a2[o4 + e4]);
                  }
                }
            }
          }
          return l3;
        }
        _getOriginId(e2) {
          return e2 - this.points.length >> 5;
        }
        _getOriginZoom(e2) {
          return (e2 - this.points.length) % 32;
        }
        _map(e2, t2, o2) {
          if (e2[t2 + S] > 1) {
            const i3 = this.clusterProps[e2[t2 + I]];
            return o2 ? Object.assign({}, i3) : i3;
          }
          const i2 = this.points[e2[t2 + M2]].properties, r2 = this.options.map(i2);
          return o2 && r2 === i2 ? Object.assign({}, r2) : r2;
        }
      }
      function k(e2, t2, o2) {
        return { type: "Feature", id: e2[t2 + M2], properties: T(e2, t2, o2), geometry: { type: "Point", coordinates: [(i2 = e2[t2], 360 * (i2 - 0.5)), O(e2[t2 + 1])] } };
        var i2;
      }
      function T(e2, t2, o2) {
        const i2 = e2[t2 + S], r2 = i2 >= 1e4 ? `${Math.round(i2 / 1000)}k` : i2 >= 1000 ? Math.round(i2 / 100) / 10 + "k" : i2, s2 = e2[t2 + I], n2 = s2 === -1 ? {} : Object.assign({}, o2[s2]);
        return Object.assign(n2, { cluster: true, cluster_id: e2[t2 + M2], point_count: i2, point_count_abbreviated: r2 });
      }
      function D2(e2) {
        return e2 / 360 + 0.5;
      }
      function C(e2) {
        const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
      }
      function O(e2) {
        const t2 = (180 - 360 * e2) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
      }
      function L(e2, t2, o2, i2) {
        let r2 = i2;
        const s2 = t2 + (o2 - t2 >> 1);
        let n2, a2 = o2 - t2;
        const l3 = e2[t2], c2 = e2[t2 + 1], u2 = e2[o2], h2 = e2[o2 + 1];
        for (let i3 = t2 + 3;i3 < o2; i3 += 3) {
          const t3 = F2(e2[i3], e2[i3 + 1], l3, c2, u2, h2);
          if (t3 > r2)
            n2 = i3, r2 = t3;
          else if (t3 === r2) {
            const e3 = Math.abs(i3 - s2);
            e3 < a2 && (n2 = i3, a2 = e3);
          }
        }
        r2 > i2 && (n2 - t2 > 3 && L(e2, t2, n2, i2), e2[n2 + 2] = r2, o2 - n2 > 3 && L(e2, n2, o2, i2));
      }
      function F2(e2, t2, o2, i2, r2, s2) {
        let n2 = r2 - o2, a2 = s2 - i2;
        if (n2 !== 0 || a2 !== 0) {
          const l3 = ((e2 - o2) * n2 + (t2 - i2) * a2) / (n2 * n2 + a2 * a2);
          l3 > 1 ? (o2 = r2, i2 = s2) : l3 > 0 && (o2 += n2 * l3, i2 += a2 * l3);
        }
        return n2 = e2 - o2, a2 = t2 - i2, n2 * n2 + a2 * a2;
      }
      function G2(e2, t2, o2, i2) {
        const r2 = { id: e2 == null ? null : e2, type: t2, geometry: o2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (t2 === "Point" || t2 === "MultiPoint" || t2 === "LineString")
          z2(r2, o2);
        else if (t2 === "Polygon")
          z2(r2, o2[0]);
        else if (t2 === "MultiLineString")
          for (const e3 of o2)
            z2(r2, e3);
        else if (t2 === "MultiPolygon")
          for (const e3 of o2)
            z2(r2, e3[0]);
        return r2;
      }
      function z2(e2, t2) {
        for (let o2 = 0;o2 < t2.length; o2 += 3)
          e2.minX = Math.min(e2.minX, t2[o2]), e2.minY = Math.min(e2.minY, t2[o2 + 1]), e2.maxX = Math.max(e2.maxX, t2[o2]), e2.maxY = Math.max(e2.maxY, t2[o2 + 1]);
      }
      function A(e2, t2, o2, i2) {
        if (!t2.geometry)
          return;
        const r2 = t2.geometry.coordinates;
        if (r2 && r2.length === 0)
          return;
        const s2 = t2.geometry.type, n2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2);
        let a2 = [], l3 = t2.id;
        if (o2.promoteId ? l3 = t2.properties[o2.promoteId] : o2.generateId && (l3 = i2 || 0), s2 === "Point")
          E2(r2, a2);
        else if (s2 === "MultiPoint")
          for (const e3 of r2)
            E2(e3, a2);
        else if (s2 === "LineString")
          j2(r2, a2, n2, false);
        else if (s2 === "MultiLineString") {
          if (o2.lineMetrics) {
            for (const o3 of r2)
              a2 = [], j2(o3, a2, n2, false), e2.push(G2(l3, "LineString", a2, t2.properties));
            return;
          }
          Z2(r2, a2, n2, false);
        } else if (s2 === "Polygon")
          Z2(r2, a2, n2, true);
        else {
          if (s2 !== "MultiPolygon") {
            if (s2 === "GeometryCollection") {
              for (const r3 of t2.geometry.geometries)
                A(e2, { id: l3, geometry: r3, properties: t2.properties }, o2, i2);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const e3 of r2) {
            const t3 = [];
            Z2(e3, t3, n2, true), a2.push(t3);
          }
        }
        e2.push(G2(l3, s2, a2, t2.properties));
      }
      function E2(e2, t2) {
        t2.push(N(e2[0]), J2(e2[1]), 0);
      }
      function j2(e2, t2, o2, i2) {
        let r2, s2, n2 = 0;
        for (let o3 = 0;o3 < e2.length; o3++) {
          const a3 = N(e2[o3][0]), l3 = J2(e2[o3][1]);
          t2.push(a3, l3, 0), o3 > 0 && (n2 += i2 ? (r2 * l3 - a3 * s2) / 2 : Math.sqrt(Math.pow(a3 - r2, 2) + Math.pow(l3 - s2, 2))), r2 = a3, s2 = l3;
        }
        const a2 = t2.length - 3;
        t2[2] = 1, L(t2, 0, a2, o2), t2[a2 + 2] = 1, t2.size = Math.abs(n2), t2.start = 0, t2.end = t2.size;
      }
      function Z2(e2, t2, o2, i2) {
        for (let r2 = 0;r2 < e2.length; r2++) {
          const s2 = [];
          j2(e2[r2], s2, o2, i2), t2.push(s2);
        }
      }
      function N(e2) {
        return e2 / 360 + 0.5;
      }
      function J2(e2) {
        const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
      }
      function W2(e2, t2, o2, i2, r2, s2, n2, a2) {
        if (i2 /= t2, s2 >= (o2 /= t2) && n2 < i2)
          return e2;
        if (n2 < o2 || s2 >= i2)
          return null;
        const l3 = [];
        for (const t3 of e2) {
          const e3 = t3.geometry;
          let s3 = t3.type;
          const n3 = r2 === 0 ? t3.minX : t3.minY, c2 = r2 === 0 ? t3.maxX : t3.maxY;
          if (n3 >= o2 && c2 < i2) {
            l3.push(t3);
            continue;
          }
          if (c2 < o2 || n3 >= i2)
            continue;
          let u2 = [];
          if (s3 === "Point" || s3 === "MultiPoint")
            R(e3, u2, o2, i2, r2);
          else if (s3 === "LineString")
            Y2(e3, u2, o2, i2, r2, false, a2.lineMetrics);
          else if (s3 === "MultiLineString")
            q(e3, u2, o2, i2, r2, false);
          else if (s3 === "Polygon")
            q(e3, u2, o2, i2, r2, true);
          else if (s3 === "MultiPolygon")
            for (const t4 of e3) {
              const e4 = [];
              q(t4, e4, o2, i2, r2, true), e4.length && u2.push(e4);
            }
          if (u2.length) {
            if (a2.lineMetrics && s3 === "LineString") {
              for (const e4 of u2)
                l3.push(G2(t3.id, s3, e4, t3.tags));
              continue;
            }
            s3 !== "LineString" && s3 !== "MultiLineString" || (u2.length === 1 ? (s3 = "LineString", u2 = u2[0]) : s3 = "MultiLineString"), s3 !== "Point" && s3 !== "MultiPoint" || (s3 = u2.length === 3 ? "Point" : "MultiPoint"), l3.push(G2(t3.id, s3, u2, t3.tags));
          }
        }
        return l3.length ? l3 : null;
      }
      function R(e2, t2, o2, i2, r2) {
        for (let s2 = 0;s2 < e2.length; s2 += 3) {
          const n2 = e2[s2 + r2];
          n2 >= o2 && n2 <= i2 && H(t2, e2[s2], e2[s2 + 1], e2[s2 + 2]);
        }
      }
      function Y2(e2, t2, o2, i2, r2, s2, n2) {
        let a2 = V(e2);
        const l3 = r2 === 0 ? X : B2;
        let c2, u2, h2 = e2.start;
        for (let d3 = 0;d3 < e2.length - 3; d3 += 3) {
          const f3 = e2[d3], g3 = e2[d3 + 1], p3 = e2[d3 + 2], m2 = e2[d3 + 3], y2 = e2[d3 + 4], v2 = r2 === 0 ? f3 : g3, w2 = r2 === 0 ? m2 : y2;
          let x2 = false;
          n2 && (c2 = Math.sqrt(Math.pow(f3 - m2, 2) + Math.pow(g3 - y2, 2))), v2 < o2 ? w2 > o2 && (u2 = l3(a2, f3, g3, m2, y2, o2), n2 && (a2.start = h2 + c2 * u2)) : v2 > i2 ? w2 < i2 && (u2 = l3(a2, f3, g3, m2, y2, i2), n2 && (a2.start = h2 + c2 * u2)) : H(a2, f3, g3, p3), w2 < o2 && v2 >= o2 && (u2 = l3(a2, f3, g3, m2, y2, o2), x2 = true), w2 > i2 && v2 <= i2 && (u2 = l3(a2, f3, g3, m2, y2, i2), x2 = true), !s2 && x2 && (n2 && (a2.end = h2 + c2 * u2), t2.push(a2), a2 = V(e2)), n2 && (h2 += c2);
        }
        let d2 = e2.length - 3;
        const f2 = e2[d2], g2 = e2[d2 + 1], p2 = r2 === 0 ? f2 : g2;
        p2 >= o2 && p2 <= i2 && H(a2, f2, g2, e2[d2 + 2]), d2 = a2.length - 3, s2 && d2 >= 3 && (a2[d2] !== a2[0] || a2[d2 + 1] !== a2[1]) && H(a2, a2[0], a2[1], a2[2]), a2.length && t2.push(a2);
      }
      function V(e2) {
        const t2 = [];
        return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
      }
      function q(e2, t2, o2, i2, r2, s2) {
        for (const n2 of e2)
          Y2(n2, t2, o2, i2, r2, s2, false);
      }
      function H(e2, t2, o2, i2) {
        e2.push(t2, o2, i2);
      }
      function X(e2, t2, o2, i2, r2, s2) {
        const n2 = (s2 - t2) / (i2 - t2);
        return H(e2, s2, o2 + (r2 - o2) * n2, 1), n2;
      }
      function B2(e2, t2, o2, i2, r2, s2) {
        const n2 = (s2 - o2) / (r2 - o2);
        return H(e2, t2 + (i2 - t2) * n2, s2, 1), n2;
      }
      function $2(e2, t2) {
        const o2 = [];
        for (let i2 = 0;i2 < e2.length; i2++) {
          const r2 = e2[i2], s2 = r2.type;
          let n2;
          if (s2 === "Point" || s2 === "MultiPoint" || s2 === "LineString")
            n2 = U(r2.geometry, t2);
          else if (s2 === "MultiLineString" || s2 === "Polygon") {
            n2 = [];
            for (const e3 of r2.geometry)
              n2.push(U(e3, t2));
          } else if (s2 === "MultiPolygon") {
            n2 = [];
            for (const e3 of r2.geometry) {
              const o3 = [];
              for (const i3 of e3)
                o3.push(U(i3, t2));
              n2.push(o3);
            }
          }
          o2.push(G2(r2.id, s2, n2, r2.tags));
        }
        return o2;
      }
      function U(e2, t2) {
        const o2 = [];
        o2.size = e2.size, e2.start !== undefined && (o2.start = e2.start, o2.end = e2.end);
        for (let i2 = 0;i2 < e2.length; i2 += 3)
          o2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
        return o2;
      }
      function K(e2, t2) {
        if (e2.transformed)
          return e2;
        const o2 = 1 << e2.z, i2 = e2.x, r2 = e2.y;
        for (const s2 of e2.features) {
          const { geometry: e3, type: n2 } = s2;
          if (s2.geometry = [], n2 === 1)
            for (let n3 = 0;n3 < e3.length; n3 += 2)
              s2.geometry.push(Q2(e3[n3], e3[n3 + 1], t2, o2, i2, r2));
          else
            for (let n3 = 0;n3 < e3.length; n3++) {
              const a2 = [];
              for (let s3 = 0;s3 < e3[n3].length; s3 += 2)
                a2.push(Q2(e3[n3][s3], e3[n3][s3 + 1], t2, o2, i2, r2));
              s2.geometry.push(a2);
            }
        }
        return e2.transformed = true, e2;
      }
      function Q2(e2, t2, o2, i2, r2, s2) {
        return [Math.round(o2 * (e2 * i2 - r2)), Math.round(o2 * (t2 * i2 - s2))];
      }
      function ee2(e2, t2, o2, i2, r2) {
        const s2 = t2 === r2.maxZoom ? 0 : r2.tolerance / ((1 << t2) * r2.extent), n2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e2.length, source: null, x: o2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const t3 of e2)
          te2(n2, t3, s2, r2);
        return n2;
      }
      function te2(e2, t2, o2, i2) {
        const { geometry: r2, type: s2 } = t2, n2 = [];
        if (e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), s2 === "Point" || s2 === "MultiPoint")
          for (let t3 = 0;t3 < r2.length; t3 += 3)
            n2.push(r2[t3], r2[t3 + 1]), e2.numPoints++, e2.numSimplified++;
        else if (s2 === "LineString")
          oe(n2, r2, e2, o2, false, false);
        else if (s2 === "MultiLineString" || s2 === "Polygon")
          for (let t3 = 0;t3 < r2.length; t3++)
            oe(n2, r2[t3], e2, o2, s2 === "Polygon", t3 === 0);
        else if (s2 === "MultiPolygon")
          for (let t3 = 0;t3 < r2.length; t3++) {
            const i3 = r2[t3];
            for (let t4 = 0;t4 < i3.length; t4++)
              oe(n2, i3[t4], e2, o2, true, t4 === 0);
          }
        if (n2.length) {
          let o3 = t2.tags || null;
          if (s2 === "LineString" && i2.lineMetrics) {
            o3 = {};
            for (const e3 in t2.tags)
              o3[e3] = t2.tags[e3];
            o3.mapbox_clip_start = r2.start / r2.size, o3.mapbox_clip_end = r2.end / r2.size;
          }
          const a2 = { geometry: n2, type: s2 === "Polygon" || s2 === "MultiPolygon" ? 3 : s2 === "LineString" || s2 === "MultiLineString" ? 2 : 1, tags: o3 };
          t2.id !== null && (a2.id = t2.id), e2.features.push(a2);
        }
      }
      function oe(e2, t2, o2, i2, r2, s2) {
        const n2 = i2 * i2;
        if (i2 > 0 && t2.size < (r2 ? n2 : i2))
          return void (o2.numPoints += t2.length / 3);
        const a2 = [];
        for (let e3 = 0;e3 < t2.length; e3 += 3)
          (i2 === 0 || t2[e3 + 2] > n2) && (o2.numSimplified++, a2.push(t2[e3], t2[e3 + 1])), o2.numPoints++;
        r2 && function(e3, t3) {
          let o3 = 0;
          for (let t4 = 0, i3 = e3.length, r3 = i3 - 2;t4 < i3; r3 = t4, t4 += 2)
            o3 += (e3[t4] - e3[r3]) * (e3[t4 + 1] + e3[r3 + 1]);
          if (o3 > 0 === t3)
            for (let t4 = 0, o4 = e3.length;t4 < o4 / 2; t4 += 2) {
              const i3 = e3[t4], r3 = e3[t4 + 1];
              e3[t4] = e3[o4 - 2 - t4], e3[t4 + 1] = e3[o4 - 1 - t4], e3[o4 - 2 - t4] = i3, e3[o4 - 1 - t4] = r3;
            }
        }(a2, s2), e2.push(a2);
      }
      const ie2 = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };

      class re2 {
        constructor(e2, t2) {
          const o2 = (t2 = this.options = function(e3, t3) {
            for (const o3 in t3)
              e3[o3] = t3[o3];
            return e3;
          }(Object.create(ie2), t2)).debug;
          if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t2.promoteId && t2.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          let i2 = function(e3, t3) {
            const o3 = [];
            if (e3.type === "FeatureCollection")
              for (let i3 = 0;i3 < e3.features.length; i3++)
                A(o3, e3.features[i3], t3, i3);
            else
              A(o3, e3.type === "Feature" ? e3 : { geometry: e3 }, t3);
            return o3;
          }(e2, t2);
          this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e3, t3) {
            const o3 = t3.buffer / t3.extent;
            let i3 = e3;
            const r2 = W2(e3, 1, -1 - o3, o3, 0, -1, 2, t3), s2 = W2(e3, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
            return (r2 || s2) && (i3 = W2(e3, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], r2 && (i3 = $2(r2, 1).concat(i3)), s2 && (i3 = i3.concat($2(s2, -1)))), i3;
          }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), o2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(e2, t2, o2, i2, r2, s2, n2) {
          const a2 = [e2, t2, o2, i2], l3 = this.options, c2 = l3.debug;
          for (;a2.length; ) {
            i2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
            const u2 = 1 << t2, h2 = se2(t2, o2, i2);
            let d2 = this.tiles[h2];
            if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[h2] = ee2(e2, t2, o2, i2, l3), this.tileCoords.push({ z: t2, x: o2, y: i2 }), c2)) {
              c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, i2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
              const e3 = `z${t2}`;
              this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
            }
            if (d2.source = e2, r2 == null) {
              if (t2 === l3.indexMaxZoom || d2.numPoints <= l3.indexMaxPoints)
                continue;
            } else {
              if (t2 === l3.maxZoom || t2 === r2)
                continue;
              if (r2 != null) {
                const e3 = r2 - t2;
                if (o2 !== s2 >> e3 || i2 !== n2 >> e3)
                  continue;
              }
            }
            if (d2.source = null, e2.length === 0)
              continue;
            c2 > 1 && console.time("clipping");
            const f2 = 0.5 * l3.buffer / l3.extent, g2 = 0.5 - f2, p2 = 0.5 + f2, m2 = 1 + f2;
            let y2 = null, v2 = null, w2 = null, x2 = null, _2 = W2(e2, u2, o2 - f2, o2 + p2, 0, d2.minX, d2.maxX, l3), b2 = W2(e2, u2, o2 + g2, o2 + m2, 0, d2.minX, d2.maxX, l3);
            e2 = null, _2 && (y2 = W2(_2, u2, i2 - f2, i2 + p2, 1, d2.minY, d2.maxY, l3), v2 = W2(_2, u2, i2 + g2, i2 + m2, 1, d2.minY, d2.maxY, l3), _2 = null), b2 && (w2 = W2(b2, u2, i2 - f2, i2 + p2, 1, d2.minY, d2.maxY, l3), x2 = W2(b2, u2, i2 + g2, i2 + m2, 1, d2.minY, d2.maxY, l3), b2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(y2 || [], t2 + 1, 2 * o2, 2 * i2), a2.push(v2 || [], t2 + 1, 2 * o2, 2 * i2 + 1), a2.push(w2 || [], t2 + 1, 2 * o2 + 1, 2 * i2), a2.push(x2 || [], t2 + 1, 2 * o2 + 1, 2 * i2 + 1);
          }
        }
        getTile(e2, t2, o2) {
          e2 = +e2, t2 = +t2, o2 = +o2;
          const i2 = this.options, { extent: r2, debug: s2 } = i2;
          if (e2 < 0 || e2 > 24)
            return null;
          const n2 = 1 << e2, a2 = se2(e2, t2 = t2 + n2 & n2 - 1, o2);
          if (this.tiles[a2])
            return K(this.tiles[a2], r2);
          s2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, o2);
          let l3, c2 = e2, u2 = t2, h2 = o2;
          for (;!l3 && c2 > 0; )
            c2--, u2 >>= 1, h2 >>= 1, l3 = this.tiles[se2(c2, u2, h2)];
          return l3 && l3.source ? (s2 > 1 && (console.log("found parent tile z%d-%d-%d", c2, u2, h2), console.time("drilling down")), this.splitTile(l3.source, c2, u2, h2, e2, t2, o2), s2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? K(this.tiles[a2], r2) : null) : null;
        }
      }
      function se2(e2, t2, o2) {
        return 32 * ((1 << e2) * o2 + t2) + e2;
      }
      function ne2(e2, t2) {
        return t2 ? e2.properties[t2] : e2.id;
      }
      function ae(e2, t2) {
        if (e2 == null)
          return true;
        if (e2.type === "Feature")
          return ne2(e2, t2) != null;
        if (e2.type === "FeatureCollection") {
          const o2 = new Set;
          for (const i2 of e2.features) {
            const e3 = ne2(i2, t2);
            if (e3 == null)
              return false;
            if (o2.has(e3))
              return false;
            o2.add(e3);
          }
          return true;
        }
        return false;
      }
      function le2(e2, t2) {
        const o2 = new Map;
        if (e2 == null)
          ;
        else if (e2.type === "Feature")
          o2.set(ne2(e2, t2), e2);
        else
          for (const i2 of e2.features)
            o2.set(ne2(i2, t2), i2);
        return o2;
      }

      class ce2 extends s {
        constructor() {
          super(...arguments), this._dataUpdateable = new Map;
        }
        loadVectorTile(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = t2.tileID.canonical;
            if (!this._geoJSONIndex)
              throw new Error("Unable to parse the data into a cluster or geojson");
            const o3 = this._geoJSONIndex.getTile(e2.z, e2.x, e2.y);
            if (!o3)
              return null;
            const i2 = new f(o3.features);
            let r2 = w(i2);
            return r2.byteOffset === 0 && r2.byteLength === r2.buffer.byteLength || (r2 = new Uint8Array(r2)), { vectorTile: i2, rawData: r2.buffer };
          });
        }
        loadData(t2) {
          return e._(this, undefined, undefined, function* () {
            var o2;
            (o2 = this._pendingRequest) === null || o2 === undefined || o2.abort();
            const i2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.cE(t2.request);
            this._pendingRequest = new AbortController;
            try {
              this._pendingData = this.loadAndProcessGeoJSON(t2, this._pendingRequest), this._geoJSONIndex = t2.cluster ? new P(function({ superclusterOptions: t3, clusterProperties: o4 }) {
                if (!o4 || !t3)
                  return t3;
                const i3 = {}, r3 = {}, s2 = { accumulated: null, zoom: 0 }, n2 = { properties: null }, a2 = Object.keys(o4);
                for (const t4 of a2) {
                  const [s3, n3] = o4[t4], a3 = e.cL(n3), l3 = e.cL(typeof s3 == "string" ? [s3, ["accumulated"], ["get", t4]] : s3);
                  i3[t4] = a3.value, r3[t4] = l3.value;
                }
                return t3.map = (e2) => {
                  n2.properties = e2;
                  const t4 = {};
                  for (const e3 of a2)
                    t4[e3] = i3[e3].evaluate(s2, n2);
                  return t4;
                }, t3.reduce = (e2, t4) => {
                  n2.properties = t4;
                  for (const t5 of a2)
                    s2.accumulated = e2[t5], e2[t5] = r3[t5].evaluate(s2, n2);
                }, t3;
              }(t2)).load((yield this._pendingData).features) : (r2 = yield this._pendingData, new re2(r2, t2.geojsonVtOptions)), this.loaded = {};
              const o3 = {};
              if (i2) {
                const e2 = i2.finish();
                e2 && (o3.resourceTiming = {}, o3.resourceTiming[t2.source] = JSON.parse(JSON.stringify(e2)));
              }
              return o3;
            } catch (t3) {
              if (delete this._pendingRequest, e.cp(t3))
                return { abandoned: true };
              throw t3;
            }
            var r2;
          });
        }
        getData() {
          return e._(this, undefined, undefined, function* () {
            return this._pendingData;
          });
        }
        reloadTile(e2) {
          const t2 = this.loaded;
          return t2 && t2[e2.uid] ? super.reloadTile(e2) : this.loadTile(e2);
        }
        loadAndProcessGeoJSON(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            let i2 = yield this.loadGeoJSON(t2, o2);
            if (delete this._pendingRequest, typeof i2 != "object")
              throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
            if (u(i2, true), t2.filter) {
              const o3 = e.cL(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
              if (o3.result === "error")
                throw new Error(o3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
              const r2 = i2.features.filter((e2) => o3.value.evaluate({ zoom: 0 }, e2));
              i2 = { type: "FeatureCollection", features: r2 };
            }
            return i2;
          });
        }
        loadGeoJSON(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            const { promoteId: i2 } = t2;
            if (t2.request) {
              const r2 = yield e.j(t2.request, o2);
              return this._dataUpdateable = ae(r2.data, i2) ? le2(r2.data, i2) : undefined, r2.data;
            }
            if (typeof t2.data == "string")
              try {
                const e2 = JSON.parse(t2.data);
                return this._dataUpdateable = ae(e2, i2) ? le2(e2, i2) : undefined, e2;
              } catch (e2) {
                throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
              }
            if (!t2.dataDiff)
              throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable)
              throw new Error(`Cannot update existing geojson data in ${t2.source}`);
            return function(e2, t3, o3) {
              var i3, r2, s2, n2;
              if (t3.removeAll && e2.clear(), t3.remove)
                for (const o4 of t3.remove)
                  e2.delete(o4);
              if (t3.add)
                for (const i4 of t3.add) {
                  const t4 = ne2(i4, o3);
                  t4 != null && e2.set(t4, i4);
                }
              if (t3.update)
                for (const o4 of t3.update) {
                  let t4 = e2.get(o4.id);
                  if (t4 == null)
                    continue;
                  const a2 = !o4.removeAllProperties && (((i3 = o4.removeProperties) === null || i3 === undefined ? undefined : i3.length) > 0 || ((r2 = o4.addOrUpdateProperties) === null || r2 === undefined ? undefined : r2.length) > 0);
                  if ((o4.newGeometry || o4.removeAllProperties || a2) && (t4 = Object.assign({}, t4), e2.set(o4.id, t4), a2 && (t4.properties = Object.assign({}, t4.properties))), o4.newGeometry && (t4.geometry = o4.newGeometry), o4.removeAllProperties)
                    t4.properties = {};
                  else if (((s2 = o4.removeProperties) === null || s2 === undefined ? undefined : s2.length) > 0)
                    for (const e3 of o4.removeProperties)
                      Object.prototype.hasOwnProperty.call(t4.properties, e3) && delete t4.properties[e3];
                  if (((n2 = o4.addOrUpdateProperties) === null || n2 === undefined ? undefined : n2.length) > 0)
                    for (const { key: e3, value: i4 } of o4.addOrUpdateProperties)
                      t4.properties[e3] = i4;
                }
            }(this._dataUpdateable, t2.dataDiff, i2), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(t2) {
          return e._(this, undefined, undefined, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(e2) {
          return this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId);
        }
        getClusterChildren(e2) {
          return this._geoJSONIndex.getChildren(e2.clusterId);
        }
        getClusterLeaves(e2) {
          return this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset);
        }
      }

      class ue2 {
        constructor(t2) {
          this.self = t2, this.actor = new e.H(t2), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e2, t3) => {
            if (this.externalWorkerSourceTypes[e2])
              throw new Error(`Worker source with name "${e2}" already registered.`);
            this.externalWorkerSourceTypes[e2] = t3;
          }, this.self.addProtocol = e.cr, this.self.removeProtocol = e.cs, this.self.registerRTLTextPlugin = (t3) => {
            e.cM.setMethods(t3);
          }, this.actor.registerMessageHandler("LDT", (e2, t3) => this._getDEMWorkerSource(e2, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RDT", (t3, o2) => e._(this, undefined, undefined, function* () {
            this._getDEMWorkerSource(t3, o2.source).removeTile(o2);
          })), this.actor.registerMessageHandler("GCEZ", (t3, o2) => e._(this, undefined, undefined, function* () {
            return this._getWorkerSource(t3, o2.type, o2.source).getClusterExpansionZoom(o2);
          })), this.actor.registerMessageHandler("GCC", (t3, o2) => e._(this, undefined, undefined, function* () {
            return this._getWorkerSource(t3, o2.type, o2.source).getClusterChildren(o2);
          })), this.actor.registerMessageHandler("GCL", (t3, o2) => e._(this, undefined, undefined, function* () {
            return this._getWorkerSource(t3, o2.type, o2.source).getClusterLeaves(o2);
          })), this.actor.registerMessageHandler("LD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadData(t3)), this.actor.registerMessageHandler("GD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).getData()), this.actor.registerMessageHandler("LT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).reloadTile(t3)), this.actor.registerMessageHandler("AT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).abortTile(t3)), this.actor.registerMessageHandler("RMT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).removeTile(t3)), this.actor.registerMessageHandler("RS", (t3, o2) => e._(this, undefined, undefined, function* () {
            if (!this.workerSources[t3] || !this.workerSources[t3][o2.type] || !this.workerSources[t3][o2.type][o2.source])
              return;
            const e2 = this.workerSources[t3][o2.type][o2.source];
            delete this.workerSources[t3][o2.type][o2.source], e2.removeSource !== undefined && e2.removeSource(o2);
          })), this.actor.registerMessageHandler("RM", (t3) => e._(this, undefined, undefined, function* () {
            delete this.layerIndexes[t3], delete this.availableImages[t3], delete this.workerSources[t3], delete this.demWorkerSources[t3];
          })), this.actor.registerMessageHandler("SR", (t3, o2) => e._(this, undefined, undefined, function* () {
            this.referrer = o2;
          })), this.actor.registerMessageHandler("SRPS", (e2, t3) => this._syncRTLPluginState(e2, t3)), this.actor.registerMessageHandler("IS", (t3, o2) => e._(this, undefined, undefined, function* () {
            this.self.importScripts(o2);
          })), this.actor.registerMessageHandler("SI", (e2, t3) => this._setImages(e2, t3)), this.actor.registerMessageHandler("UL", (t3, o2) => e._(this, undefined, undefined, function* () {
            this._getLayerIndex(t3).update(o2.layers, o2.removedIds);
          })), this.actor.registerMessageHandler("SL", (t3, o2) => e._(this, undefined, undefined, function* () {
            this._getLayerIndex(t3).replace(o2);
          }));
        }
        _setImages(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            this.availableImages[t2] = o2;
            for (const e2 in this.workerSources[t2]) {
              const i2 = this.workerSources[t2][e2];
              for (const e3 in i2)
                i2[e3].availableImages = o2;
            }
          });
        }
        _syncRTLPluginState(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            return yield e.cM.syncState(o2, this.self.importScripts);
          });
        }
        _getAvailableImages(e2) {
          let t2 = this.availableImages[e2];
          return t2 || (t2 = []), t2;
        }
        _getLayerIndex(e2) {
          let o2 = this.layerIndexes[e2];
          return o2 || (o2 = this.layerIndexes[e2] = new t), o2;
        }
        _getWorkerSource(e2, t2, o2) {
          if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][o2]) {
            const i2 = { sendAsync: (t3, o3) => (t3.targetMapId = e2, this.actor.sendAsync(t3, o3)) };
            switch (t2) {
              case "vector":
                this.workerSources[e2][t2][o2] = new s(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                break;
              case "geojson":
                this.workerSources[e2][t2][o2] = new ce2(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                break;
              default:
                this.workerSources[e2][t2][o2] = new this.externalWorkerSourceTypes[t2](i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
            }
          }
          return this.workerSources[e2][t2][o2];
        }
        _getDEMWorkerSource(e2, t2) {
          return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new n), this.demWorkerSources[e2][t2];
        }
      }
      return e.i(self) && (self.worker = new ue2(self)), ue2;
    });
    define2("index", ["exports", "./shared"], function(e, t) {
      var i = "5.5.0";
      function r() {
        var e2 = new t.A(4);
        return t.A != Float32Array && (e2[1] = 0, e2[2] = 0), e2[0] = 1, e2[3] = 1, e2;
      }
      let o, a;
      const s = { now: typeof performance != "undefined" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(e2, i2, r2) {
        const o2 = requestAnimationFrame((e3) => {
          a2(), i2(e3);
        }), { unsubscribe: a2 } = t.s(e2.signal, "abort", () => {
          a2(), cancelAnimationFrame(o2), r2(t.c());
        }, false);
      }, frameAsync(e2) {
        return new Promise((t2, i2) => {
          this.frame(e2, t2, i2);
        });
      }, getImageData(e2, t2 = 0) {
        return this.getImageCanvasContext(e2).getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
      }, getImageCanvasContext(e2) {
        const t2 = window.document.createElement("canvas"), i2 = t2.getContext("2d", { willReadFrequently: true });
        if (!i2)
          throw new Error("failed to create canvas 2d context");
        return t2.width = e2.width, t2.height = e2.height, i2.drawImage(e2, 0, 0, e2.width, e2.height), i2;
      }, resolveURL: (e2) => (o || (o = document.createElement("a")), o.href = e2, o.href), hardwareConcurrency: typeof navigator != "undefined" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (a == null && (a = matchMedia("(prefers-reduced-motion: reduce)")), a.matches);
      } };

      class n {
        static testProp(e2) {
          if (!n.docStyle)
            return e2[0];
          for (let t2 = 0;t2 < e2.length; t2++)
            if (e2[t2] in n.docStyle)
              return e2[t2];
          return e2[0];
        }
        static create(e2, t2, i2) {
          const r2 = window.document.createElement(e2);
          return t2 !== undefined && (r2.className = t2), i2 && i2.appendChild(r2), r2;
        }
        static createNS(e2, t2) {
          return window.document.createElementNS(e2, t2);
        }
        static disableDrag() {
          n.docStyle && n.selectProp && (n.userSelect = n.docStyle[n.selectProp], n.docStyle[n.selectProp] = "none");
        }
        static enableDrag() {
          n.docStyle && n.selectProp && (n.docStyle[n.selectProp] = n.userSelect);
        }
        static setTransform(e2, t2) {
          e2.style[n.transformProp] = t2;
        }
        static addEventListener(e2, t2, i2, r2 = {}) {
          e2.addEventListener(t2, i2, "passive" in r2 ? r2 : r2.capture);
        }
        static removeEventListener(e2, t2, i2, r2 = {}) {
          e2.removeEventListener(t2, i2, "passive" in r2 ? r2 : r2.capture);
        }
        static suppressClickInternal(e2) {
          e2.preventDefault(), e2.stopPropagation(), window.removeEventListener("click", n.suppressClickInternal, true);
        }
        static suppressClick() {
          window.addEventListener("click", n.suppressClickInternal, true), window.setTimeout(() => {
            window.removeEventListener("click", n.suppressClickInternal, true);
          }, 0);
        }
        static getScale(e2) {
          const t2 = e2.getBoundingClientRect();
          return { x: t2.width / e2.offsetWidth || 1, y: t2.height / e2.offsetHeight || 1, boundingClientRect: t2 };
        }
        static getPoint(e2, i2, r2) {
          const o2 = i2.boundingClientRect;
          return new t.P((r2.clientX - o2.left) / i2.x - e2.clientLeft, (r2.clientY - o2.top) / i2.y - e2.clientTop);
        }
        static mousePos(e2, t2) {
          const i2 = n.getScale(e2);
          return n.getPoint(e2, i2, t2);
        }
        static touchPos(e2, t2) {
          const i2 = [], r2 = n.getScale(e2);
          for (let o2 = 0;o2 < t2.length; o2++)
            i2.push(n.getPoint(e2, r2, t2[o2]));
          return i2;
        }
        static mouseButton(e2) {
          return e2.button;
        }
        static remove(e2) {
          e2.parentNode && e2.parentNode.removeChild(e2);
        }
        static sanitize(e2) {
          const t2 = new DOMParser().parseFromString(e2, "text/html").body || document.createElement("body"), i2 = t2.querySelectorAll("script");
          for (const e3 of i2)
            e3.remove();
          return n.clean(t2), t2.innerHTML;
        }
        static isPossiblyDangerous(e2, t2) {
          const i2 = t2.replace(/\s+/g, "").toLowerCase();
          return !(!["src", "href", "xlink:href"].includes(e2) || !i2.includes("javascript:") && !i2.includes("data:")) || !!e2.startsWith("on") || undefined;
        }
        static clean(e2) {
          const t2 = e2.children;
          for (const e3 of t2)
            n.removeAttributes(e3), n.clean(e3);
        }
        static removeAttributes(e2) {
          for (const { name: t2, value: i2 } of e2.attributes)
            n.isPossiblyDangerous(t2, i2) && e2.removeAttribute(t2);
        }
      }
      n.docStyle = typeof window != "undefined" && window.document && window.document.documentElement.style, n.selectProp = n.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), n.transformProp = n.testProp(["transform", "WebkitTransform"]);
      const l2 = { supported: false, testSupport: function(e2) {
        !u && h && (d ? _(e2) : c = e2);
      } };
      let c, h, u = false, d = false;
      function _(e2) {
        const t2 = e2.createTexture();
        e2.bindTexture(e2.TEXTURE_2D, t2);
        try {
          if (e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, e2.RGBA, e2.UNSIGNED_BYTE, h), e2.isContextLost())
            return;
          l2.supported = true;
        } catch (e3) {
        }
        e2.deleteTexture(t2), u = true;
      }
      var p;
      typeof document != "undefined" && (h = document.createElement("img"), h.onload = () => {
        c && _(c), c = null, d = true;
      }, h.onerror = () => {
        u = true, c = null;
      }, h.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e2) {
        let i2, r2, o2, a2;
        e2.resetRequestQueue = () => {
          i2 = [], r2 = 0, o2 = 0, a2 = {};
        }, e2.addThrottleControl = (e3) => {
          const t2 = o2++;
          return a2[t2] = e3, t2;
        }, e2.removeThrottleControl = (e3) => {
          delete a2[e3], n2();
        }, e2.getImage = (e3, r3, o3 = true) => new Promise((a3, s3) => {
          l2.supported && (e3.headers || (e3.headers = {}), e3.headers.accept = "image/webp,*/*"), t.e(e3, { type: "image" }), i2.push({ abortController: r3, requestParameters: e3, supportImageRefresh: o3, state: "queued", onError: (e4) => {
            s3(e4);
          }, onSuccess: (e4) => {
            a3(e4);
          } }), n2();
        });
        const s2 = (e3) => t._(this, undefined, undefined, function* () {
          e3.state = "running";
          const { requestParameters: i3, supportImageRefresh: o3, onError: a3, onSuccess: s3, abortController: l3 } = e3, h2 = o3 === false && !t.i(self) && !t.g(i3.url) && (!i3.headers || Object.keys(i3.headers).reduce((e4, t2) => e4 && t2 === "accept", true));
          r2++;
          const u2 = h2 ? c2(i3, l3) : t.m(i3, l3);
          try {
            const i4 = yield u2;
            delete e3.abortController, e3.state = "completed", i4.data instanceof HTMLImageElement || t.b(i4.data) ? s3(i4) : i4.data && s3({ data: yield (d2 = i4.data, typeof createImageBitmap == "function" ? t.f(d2) : t.h(d2)), cacheControl: i4.cacheControl, expires: i4.expires });
          } catch (t2) {
            delete e3.abortController, a3(t2);
          } finally {
            r2--, n2();
          }
          var d2;
        }), n2 = () => {
          const e3 = (() => {
            for (const e4 of Object.keys(a2))
              if (a2[e4]())
                return true;
            return false;
          })() ? t.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let t2 = r2;t2 < e3 && i2.length > 0; t2++) {
            const e4 = i2.shift();
            e4.abortController.signal.aborted ? t2-- : s2(e4);
          }
        }, c2 = (e3, i3) => new Promise((r3, o3) => {
          const a3 = new Image, s3 = e3.url, n3 = e3.credentials;
          n3 && n3 === "include" ? a3.crossOrigin = "use-credentials" : (n3 && n3 === "same-origin" || !t.d(s3)) && (a3.crossOrigin = "anonymous"), i3.signal.addEventListener("abort", () => {
            a3.src = "", o3(t.c());
          }), a3.fetchPriority = "high", a3.onload = () => {
            a3.onerror = a3.onload = null, r3({ data: a3 });
          }, a3.onerror = () => {
            a3.onerror = a3.onload = null, i3.signal.aborted || o3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, a3.src = s3;
        });
      }(p || (p = {})), p.resetRequestQueue();

      class m {
        constructor(e2) {
          this._transformRequestFn = e2;
        }
        transformRequest(e2, t2) {
          return this._transformRequestFn && this._transformRequestFn(e2, t2) || { url: e2 };
        }
        setTransformRequest(e2) {
          this._transformRequestFn = e2;
        }
      }
      function f(e2) {
        const t2 = [];
        if (typeof e2 == "string")
          t2.push({ id: "default", url: e2 });
        else if (e2 && e2.length > 0) {
          const i2 = [];
          for (const { id: r2, url: o2 } of e2) {
            const e3 = `${r2}${o2}`;
            i2.indexOf(e3) === -1 && (i2.push(e3), t2.push({ id: r2, url: o2 }));
          }
        }
        return t2;
      }
      function g(e2, t2, i2) {
        try {
          const r2 = new URL(e2);
          return r2.pathname += `${t2}${i2}`, r2.toString();
        } catch (t3) {
          throw new Error(`Invalid sprite URL "${e2}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
        }
      }

      class v {
        constructor(e2, t2, i2, r2) {
          this.context = e2, this.format = i2, this.texture = e2.gl.createTexture(), this.update(t2, r2);
        }
        update(e2, i2, r2) {
          const { width: o2, height: a2 } = e2, s2 = !(this.size && this.size[0] === o2 && this.size[1] === a2 || r2), { context: n2 } = this, { gl: l3 } = n2;
          if (this.useMipmap = Boolean(i2 && i2.useMipmap), l3.bindTexture(l3.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(false), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l3.RGBA && (!i2 || i2.premultiply !== false)), s2)
            this.size = [o2, a2], e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t.b(e2) ? l3.texImage2D(l3.TEXTURE_2D, 0, this.format, this.format, l3.UNSIGNED_BYTE, e2) : l3.texImage2D(l3.TEXTURE_2D, 0, this.format, o2, a2, 0, this.format, l3.UNSIGNED_BYTE, e2.data);
          else {
            const { x: i3, y: s3 } = r2 || { x: 0, y: 0 };
            e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t.b(e2) ? l3.texSubImage2D(l3.TEXTURE_2D, 0, i3, s3, l3.RGBA, l3.UNSIGNED_BYTE, e2) : l3.texSubImage2D(l3.TEXTURE_2D, 0, i3, s3, o2, a2, l3.RGBA, l3.UNSIGNED_BYTE, e2.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && l3.generateMipmap(l3.TEXTURE_2D), n2.pixelStoreUnpackFlipY.setDefault(), n2.pixelStoreUnpack.setDefault(), n2.pixelStoreUnpackPremultiplyAlpha.setDefault();
        }
        bind(e2, t2, i2) {
          const { context: r2 } = this, { gl: o2 } = r2;
          o2.bindTexture(o2.TEXTURE_2D, this.texture), i2 !== o2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i2 = o2.LINEAR), e2 !== this.filter && (o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MAG_FILTER, e2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MIN_FILTER, i2 || e2), this.filter = e2), t2 !== this.wrap && (o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, t2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, t2), this.wrap = t2);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: e2 } = this.context;
          e2.deleteTexture(this.texture), this.texture = null;
        }
      }
      function x(e2) {
        const { userImage: t2 } = e2;
        return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
      }

      class b extends t.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({ width: 1, height: 1 }), this.dirty = true;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(e2) {
          if (this.loaded !== e2 && (this.loaded = e2, e2)) {
            for (const { ids: e3, promiseResolve: t2 } of this.requestors)
              t2(this._getImagesForIds(e3));
            this.requestors = [];
          }
        }
        getImage(e2) {
          const i2 = this.images[e2];
          if (i2 && !i2.data && i2.spriteData) {
            const e3 = i2.spriteData;
            i2.data = new t.R({ width: e3.width, height: e3.height }, e3.context.getImageData(e3.x, e3.y, e3.width, e3.height).data), i2.spriteData = null;
          }
          return i2;
        }
        addImage(e2, t2) {
          if (this.images[e2])
            throw new Error(`Image id ${e2} already exist, use updateImage instead`);
          this._validate(e2, t2) && (this.images[e2] = t2);
        }
        _validate(e2, i2) {
          let r2 = true;
          const o2 = i2.data || i2.spriteData;
          return this._validateStretch(i2.stretchX, o2 && o2.width) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "stretchX" value`))), r2 = false), this._validateStretch(i2.stretchY, o2 && o2.height) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "stretchY" value`))), r2 = false), this._validateContent(i2.content, i2) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "content" value`))), r2 = false), r2;
        }
        _validateStretch(e2, t2) {
          if (!e2)
            return true;
          let i2 = 0;
          for (const r2 of e2) {
            if (r2[0] < i2 || r2[1] < r2[0] || t2 < r2[1])
              return false;
            i2 = r2[1];
          }
          return true;
        }
        _validateContent(e2, t2) {
          if (!e2)
            return true;
          if (e2.length !== 4)
            return false;
          const i2 = t2.spriteData, r2 = i2 && i2.width || t2.data.width, o2 = i2 && i2.height || t2.data.height;
          return !(e2[0] < 0 || r2 < e2[0] || e2[1] < 0 || o2 < e2[1] || e2[2] < 0 || r2 < e2[2] || e2[3] < 0 || o2 < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]);
        }
        updateImage(e2, t2, i2 = true) {
          const r2 = this.getImage(e2);
          if (i2 && (r2.data.width !== t2.data.width || r2.data.height !== t2.data.height))
            throw new Error(`size mismatch between old image (${r2.data.width}x${r2.data.height}) and new image (${t2.data.width}x${t2.data.height}).`);
          t2.version = r2.version + 1, this.images[e2] = t2, this.updatedImages[e2] = true;
        }
        removeImage(e2) {
          const t2 = this.images[e2];
          delete this.images[e2], delete this.patterns[e2], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(e2) {
          return new Promise((t2, i2) => {
            let r2 = true;
            if (!this.isLoaded())
              for (const t3 of e2)
                this.images[t3] || (r2 = false);
            this.isLoaded() || r2 ? t2(this._getImagesForIds(e2)) : this.requestors.push({ ids: e2, promiseResolve: t2 });
          });
        }
        _getImagesForIds(e2) {
          const i2 = {};
          for (const r2 of e2) {
            let e3 = this.getImage(r2);
            e3 || (this.fire(new t.l("styleimagemissing", { id: r2 })), e3 = this.getImage(r2)), e3 ? i2[r2] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, textFitWidth: e3.textFitWidth, textFitHeight: e3.textFitHeight, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : t.w(`Image "${r2}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return i2;
        }
        getPixelSize() {
          const { width: e2, height: t2 } = this.atlasImage;
          return { width: e2, height: t2 };
        }
        getPattern(e2) {
          const i2 = this.patterns[e2], r2 = this.getImage(e2);
          if (!r2)
            return null;
          if (i2 && i2.position.version === r2.version)
            return i2.position;
          if (i2)
            i2.position.version = r2.version;
          else {
            const i3 = { w: r2.data.width + 2, h: r2.data.height + 2, x: 0, y: 0 }, o2 = new t.I(i3, r2);
            this.patterns[e2] = { bin: i3, position: o2 };
          }
          return this._updatePatternAtlas(), this.patterns[e2].position;
        }
        bind(e2) {
          const t2 = e2.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new v(e2, this.atlasImage, t2.RGBA), this.atlasTexture.bind(t2.LINEAR, t2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const e2 = [];
          for (const t2 in this.patterns)
            e2.push(this.patterns[t2].bin);
          const { w: i2, h: r2 } = t.p(e2), o2 = this.atlasImage;
          o2.resize({ width: i2 || 1, height: r2 || 1 });
          for (const e3 in this.patterns) {
            const { bin: i3 } = this.patterns[e3], r3 = i3.x + 1, a2 = i3.y + 1, s2 = this.getImage(e3).data, n2 = s2.width, l3 = s2.height;
            t.R.copy(s2, o2, { x: 0, y: 0 }, { x: r3, y: a2 }, { width: n2, height: l3 }), t.R.copy(s2, o2, { x: 0, y: l3 - 1 }, { x: r3, y: a2 - 1 }, { width: n2, height: 1 }), t.R.copy(s2, o2, { x: 0, y: 0 }, { x: r3, y: a2 + l3 }, { width: n2, height: 1 }), t.R.copy(s2, o2, { x: n2 - 1, y: 0 }, { x: r3 - 1, y: a2 }, { width: 1, height: l3 }), t.R.copy(s2, o2, { x: 0, y: 0 }, { x: r3 + n2, y: a2 }, { width: 1, height: l3 });
          }
          this.dirty = true;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(e2) {
          for (const i2 of e2) {
            if (this.callbackDispatchedThisFrame[i2])
              continue;
            this.callbackDispatchedThisFrame[i2] = true;
            const e3 = this.getImage(i2);
            e3 || t.w(`Image with ID: "${i2}" was not found`), x(e3) && this.updateImage(i2, e3);
          }
        }
      }
      const y = 100000000000000000000;
      function w(e2, t2, i2, r2, o2, a2, s2, n2, l3) {
        for (let c2 = t2;c2 < t2 + r2; c2++)
          T(e2, i2 * a2 + c2, a2, o2, s2, n2, l3);
        for (let c2 = i2;c2 < i2 + o2; c2++)
          T(e2, c2 * a2 + t2, 1, r2, s2, n2, l3);
      }
      function T(e2, t2, i2, r2, o2, a2, s2) {
        a2[0] = 0, s2[0] = -100000000000000000000, s2[1] = y, o2[0] = e2[t2];
        for (let n2 = 1, l3 = 0, c2 = 0;n2 < r2; n2++) {
          o2[n2] = e2[t2 + n2 * i2];
          const r3 = n2 * n2;
          do {
            const e3 = a2[l3];
            c2 = (o2[n2] - o2[e3] + r3 - e3 * e3) / (n2 - e3) / 2;
          } while (c2 <= s2[l3] && --l3 > -1);
          l3++, a2[l3] = n2, s2[l3] = c2, s2[l3 + 1] = y;
        }
        for (let n2 = 0, l3 = 0;n2 < r2; n2++) {
          for (;s2[l3 + 1] < n2; )
            l3++;
          const r3 = a2[l3], c2 = n2 - r3;
          e2[t2 + n2 * i2] = o2[r3] + c2 * c2;
        }
      }

      class P {
        constructor(e2, t2) {
          this.requestManager = e2, this.localIdeographFontFamily = t2, this.entries = {};
        }
        setURL(e2) {
          this.url = e2;
        }
        getGlyphs(e2) {
          return t._(this, undefined, undefined, function* () {
            const t2 = [];
            for (const i3 in e2)
              for (const r3 of e2[i3])
                t2.push(this._getAndCacheGlyphsPromise(i3, r3));
            const i2 = yield Promise.all(t2), r2 = {};
            for (const { stack: e3, id: t3, glyph: o2 } of i2)
              r2[e3] || (r2[e3] = {}), r2[e3][t3] = o2 && { id: o2.id, bitmap: o2.bitmap.clone(), metrics: o2.metrics };
            return r2;
          });
        }
        _getAndCacheGlyphsPromise(e2, i2) {
          return t._(this, undefined, undefined, function* () {
            let t2 = this.entries[e2];
            t2 || (t2 = this.entries[e2] = { glyphs: {}, requests: {}, ranges: {} });
            let r2 = t2.glyphs[i2];
            if (r2 !== undefined)
              return { stack: e2, id: i2, glyph: r2 };
            if (r2 = this._tinySDF(t2, e2, i2), r2)
              return t2.glyphs[i2] = r2, { stack: e2, id: i2, glyph: r2 };
            const o2 = Math.floor(i2 / 256);
            if (256 * o2 > 65535)
              throw new Error("glyphs > 65535 not supported");
            if (t2.ranges[o2])
              return { stack: e2, id: i2, glyph: r2 };
            if (!this.url)
              throw new Error("glyphsUrl is not set");
            if (!t2.requests[o2]) {
              const i3 = P.loadGlyphRange(e2, o2, this.url, this.requestManager);
              t2.requests[o2] = i3;
            }
            const a2 = yield t2.requests[o2];
            for (const e3 in a2)
              this._doesCharSupportLocalGlyph(+e3) || (t2.glyphs[+e3] = a2[+e3]);
            return t2.ranges[o2] = true, { stack: e2, id: i2, glyph: a2[i2] || null };
          });
        }
        _doesCharSupportLocalGlyph(e2) {
          return !!this.localIdeographFontFamily && (/\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(e2)) || t.u["CJK Unified Ideographs"](e2) || t.u["Hangul Syllables"](e2) || t.u.Hiragana(e2) || t.u.Katakana(e2) || t.u["CJK Symbols and Punctuation"](e2) || t.u["Halfwidth and Fullwidth Forms"](e2));
        }
        _tinySDF(e2, i2, r2) {
          const o2 = this.localIdeographFontFamily;
          if (!o2)
            return;
          if (!this._doesCharSupportLocalGlyph(r2))
            return;
          let a2 = e2.tinySDF;
          if (!a2) {
            let t2 = "400";
            /bold/i.test(i2) ? t2 = "900" : /medium/i.test(i2) ? t2 = "500" : /light/i.test(i2) && (t2 = "200"), a2 = e2.tinySDF = new P.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: o2, fontWeight: t2 });
          }
          const s2 = a2.draw(String.fromCharCode(r2));
          return { id: r2, bitmap: new t.q({ width: s2.width || 60, height: s2.height || 60 }, s2.data), metrics: { width: s2.glyphWidth / 2 || 24, height: s2.glyphHeight / 2 || 24, left: s2.glyphLeft / 2 + 0.5 || 0, top: s2.glyphTop / 2 - 27.5 || -8, advance: s2.glyphAdvance / 2 || 24, isDoubleResolution: true } };
        }
      }
      P.loadGlyphRange = function(e2, i2, r2, o2) {
        return t._(this, undefined, undefined, function* () {
          const a2 = 256 * i2, s2 = a2 + 255, n2 = o2.transformRequest(r2.replace("{fontstack}", e2).replace("{range}", `${a2}-${s2}`), "Glyphs"), l3 = yield t.n(n2, new AbortController);
          if (!l3 || !l3.data)
            throw new Error(`Could not load glyph range. range: ${i2}, ${a2}-${s2}`);
          const c2 = {};
          for (const e3 of t.o(l3.data))
            c2[e3.id] = e3;
          return c2;
        });
      }, P.TinySDF = class {
        constructor({ fontSize: e2 = 24, buffer: t2 = 3, radius: i2 = 8, cutoff: r2 = 0.25, fontFamily: o2 = "sans-serif", fontWeight: a2 = "normal", fontStyle: s2 = "normal" } = {}) {
          this.buffer = t2, this.cutoff = r2, this.radius = i2;
          const n2 = this.size = e2 + 4 * t2, l3 = this._createCanvas(n2), c2 = this.ctx = l3.getContext("2d", { willReadFrequently: true });
          c2.font = `${s2} ${a2} ${e2}px ${o2}`, c2.textBaseline = "alphabetic", c2.textAlign = "left", c2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
        }
        _createCanvas(e2) {
          const t2 = document.createElement("canvas");
          return t2.width = t2.height = e2, t2;
        }
        draw(e2) {
          const { width: t2, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: r2, actualBoundingBoxLeft: o2, actualBoundingBoxRight: a2 } = this.ctx.measureText(e2), s2 = Math.ceil(i2), n2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a2 - o2))), l3 = Math.min(this.size - this.buffer, s2 + Math.ceil(r2)), c2 = n2 + 2 * this.buffer, h2 = l3 + 2 * this.buffer, u2 = Math.max(c2 * h2, 0), d2 = new Uint8ClampedArray(u2), _2 = { data: d2, width: c2, height: h2, glyphWidth: n2, glyphHeight: l3, glyphTop: s2, glyphLeft: 0, glyphAdvance: t2 };
          if (n2 === 0 || l3 === 0)
            return _2;
          const { ctx: p2, buffer: m2, gridInner: f2, gridOuter: g2 } = this;
          p2.clearRect(m2, m2, n2, l3), p2.fillText(e2, m2, m2 + s2);
          const v2 = p2.getImageData(m2, m2, n2, l3);
          g2.fill(y, 0, u2), f2.fill(0, 0, u2);
          for (let e3 = 0;e3 < l3; e3++)
            for (let t3 = 0;t3 < n2; t3++) {
              const i3 = v2.data[4 * (e3 * n2 + t3) + 3] / 255;
              if (i3 === 0)
                continue;
              const r3 = (e3 + m2) * c2 + t3 + m2;
              if (i3 === 1)
                g2[r3] = 0, f2[r3] = y;
              else {
                const e4 = 0.5 - i3;
                g2[r3] = e4 > 0 ? e4 * e4 : 0, f2[r3] = e4 < 0 ? e4 * e4 : 0;
              }
            }
          w(g2, 0, 0, c2, h2, c2, this.f, this.v, this.z), w(f2, m2, m2, n2, l3, c2, this.f, this.v, this.z);
          for (let e3 = 0;e3 < u2; e3++) {
            const t3 = Math.sqrt(g2[e3]) - Math.sqrt(f2[e3]);
            d2[e3] = Math.round(255 - 255 * (t3 / this.radius + this.cutoff));
          }
          return _2;
        }
      };

      class C {
        constructor() {
          this.specification = t.v.light.position;
        }
        possiblyEvaluate(e2, i2) {
          return t.z(e2.expression.evaluate(i2));
        }
        interpolate(e2, i2, r2) {
          return { x: t.B.number(e2.x, i2.x, r2), y: t.B.number(e2.y, i2.y, r2), z: t.B.number(e2.z, i2.z, r2) };
        }
      }
      let M2;

      class I extends t.E {
        constructor(e2) {
          super(), M2 = M2 || new t.r({ anchor: new t.D(t.v.light.anchor), position: new C, color: new t.D(t.v.light.color), intensity: new t.D(t.v.light.intensity) }), this._transitionable = new t.T(M2), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(e2, i2 = {}) {
          if (!this._validate(t.t, e2, i2))
            for (const t2 in e2) {
              const i3 = e2[t2];
              t2.endsWith("-transition") ? this._transitionable.setTransition(t2.slice(0, -11), i3) : this._transitionable.setValue(t2, i3);
            }
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        _validate(e2, i2, r2) {
          return (!r2 || r2.validate !== false) && t.x(this, e2.call(t.y, { value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.v }));
        }
      }
      const E2 = new t.r({ "sky-color": new t.D(t.v.sky["sky-color"]), "horizon-color": new t.D(t.v.sky["horizon-color"]), "fog-color": new t.D(t.v.sky["fog-color"]), "fog-ground-blend": new t.D(t.v.sky["fog-ground-blend"]), "horizon-fog-blend": new t.D(t.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new t.D(t.v.sky["sky-horizon-blend"]), "atmosphere-blend": new t.D(t.v.sky["atmosphere-blend"]) });

      class S extends t.E {
        constructor(e2) {
          super(), this._transitionable = new t.T(E2), this.setSky(e2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.C(0));
        }
        setSky(e2, i2 = {}) {
          if (!this._validate(t.F, e2, i2)) {
            e2 || (e2 = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
            for (const t2 in e2) {
              const i3 = e2[t2];
              t2.endsWith("-transition") ? this._transitionable.setTransition(t2.slice(0, -11), i3) : this._transitionable.setValue(t2, i3);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        _validate(e2, i2, r2 = {}) {
          return (r2 == null ? undefined : r2.validate) !== false && t.x(this, e2.call(t.y, t.e({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.v })));
        }
        calculateFogBlendOpacity(e2) {
          return e2 < 60 ? 0 : e2 < 70 ? (e2 - 60) / 10 : 1;
        }
      }

      class R {
        constructor(e2, t2) {
          this.width = e2, this.height = t2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(e2, t2) {
          const i2 = e2.join(",") + String(t2);
          return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(e2, t2)), this.dashEntry[i2];
        }
        getDashRanges(e2, t2, i2) {
          const r2 = [];
          let o2 = e2.length % 2 == 1 ? -e2[e2.length - 1] * i2 : 0, a2 = e2[0] * i2, s2 = true;
          r2.push({ left: o2, right: a2, isDash: s2, zeroLength: e2[0] === 0 });
          let n2 = e2[0];
          for (let t3 = 1;t3 < e2.length; t3++) {
            s2 = !s2;
            const l3 = e2[t3];
            o2 = n2 * i2, n2 += l3, a2 = n2 * i2, r2.push({ left: o2, right: a2, isDash: s2, zeroLength: l3 === 0 });
          }
          return r2;
        }
        addRoundDash(e2, t2, i2) {
          const r2 = t2 / 2;
          for (let t3 = -i2;t3 <= i2; t3++) {
            const o2 = this.width * (this.nextRow + i2 + t3);
            let a2 = 0, s2 = e2[a2];
            for (let n2 = 0;n2 < this.width; n2++) {
              n2 / s2.right > 1 && (s2 = e2[++a2]);
              const l3 = Math.abs(n2 - s2.left), c2 = Math.abs(n2 - s2.right), h2 = Math.min(l3, c2);
              let u2;
              const d2 = t3 / i2 * (r2 + 1);
              if (s2.isDash) {
                const e3 = r2 - Math.abs(d2);
                u2 = Math.sqrt(h2 * h2 + e3 * e3);
              } else
                u2 = r2 - Math.sqrt(h2 * h2 + d2 * d2);
              this.data[o2 + n2] = Math.max(0, Math.min(255, u2 + 128));
            }
          }
        }
        addRegularDash(e2) {
          for (let t3 = e2.length - 1;t3 >= 0; --t3) {
            const i3 = e2[t3], r3 = e2[t3 + 1];
            i3.zeroLength ? e2.splice(t3, 1) : r3 && r3.isDash === i3.isDash && (r3.left = i3.left, e2.splice(t3, 1));
          }
          const t2 = e2[0], i2 = e2[e2.length - 1];
          t2.isDash === i2.isDash && (t2.left = i2.left - this.width, i2.right = t2.right + this.width);
          const r2 = this.width * this.nextRow;
          let o2 = 0, a2 = e2[o2];
          for (let t3 = 0;t3 < this.width; t3++) {
            t3 / a2.right > 1 && (a2 = e2[++o2]);
            const i3 = Math.abs(t3 - a2.left), s2 = Math.abs(t3 - a2.right), n2 = Math.min(i3, s2);
            this.data[r2 + t3] = Math.max(0, Math.min(255, (a2.isDash ? n2 : -n2) + 128));
          }
        }
        addDash(e2, i2) {
          const r2 = i2 ? 7 : 0, o2 = 2 * r2 + 1;
          if (this.nextRow + o2 > this.height)
            return t.w("LineAtlas out of space"), null;
          let a2 = 0;
          for (let t2 = 0;t2 < e2.length; t2++)
            a2 += e2[t2];
          if (a2 !== 0) {
            const t2 = this.width / a2, o3 = this.getDashRanges(e2, this.width, t2);
            i2 ? this.addRoundDash(o3, t2, r2) : this.addRegularDash(o3);
          }
          const s2 = { y: (this.nextRow + r2 + 0.5) / this.height, height: 2 * r2 / this.height, width: a2 };
          return this.nextRow += o2, this.dirty = true, s2;
        }
        bind(e2) {
          const t2 = e2.gl;
          this.texture ? (t2.bindTexture(t2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t2.texSubImage2D(t2.TEXTURE_2D, 0, 0, 0, this.width, this.height, t2.ALPHA, t2.UNSIGNED_BYTE, this.data))) : (this.texture = t2.createTexture(), t2.bindTexture(t2.TEXTURE_2D, this.texture), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_S, t2.REPEAT), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_T, t2.REPEAT), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MIN_FILTER, t2.LINEAR), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MAG_FILTER, t2.LINEAR), t2.texImage2D(t2.TEXTURE_2D, 0, t2.ALPHA, this.width, this.height, 0, t2.ALPHA, t2.UNSIGNED_BYTE, this.data));
        }
      }
      const z2 = "maplibre_preloaded_worker_pool";

      class D2 {
        constructor() {
          this.active = {};
        }
        acquire(e2) {
          if (!this.workers)
            for (this.workers = [];this.workers.length < D2.workerCount; )
              this.workers.push(new Worker(t.a.WORKER_URL));
          return this.active[e2] = true, this.workers.slice();
        }
        release(e2) {
          delete this.active[e2], this.numActive() === 0 && (this.workers.forEach((e3) => {
            e3.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[z2];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const A = Math.floor(s.hardwareConcurrency / 2);
      let L, k;
      function F2() {
        return L || (L = new D2), L;
      }
      D2.workerCount = t.G(globalThis) ? Math.max(Math.min(A, 3), 1) : 1;

      class B2 {
        constructor(e2, i2) {
          this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = i2;
          const r2 = this.workerPool.acquire(i2);
          for (let e3 = 0;e3 < r2.length; e3++) {
            const o2 = new t.H(r2[e3], i2);
            o2.name = `Worker ${e3}`, this.actors.push(o2);
          }
          if (!this.actors.length)
            throw new Error("No actors found");
        }
        broadcast(e2, t2) {
          const i2 = [];
          for (const r2 of this.actors)
            i2.push(r2.sendAsync({ type: e2, data: t2 }));
          return Promise.all(i2);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(e2 = true) {
          this.actors.forEach((e3) => {
            e3.remove();
          }), this.actors = [], e2 && this.workerPool.release(this.id);
        }
        registerMessageHandler(e2, t2) {
          for (const i2 of this.actors)
            i2.registerMessageHandler(e2, t2);
        }
      }
      function O() {
        return k || (k = new B2(F2(), t.J), k.registerMessageHandler("GR", (e2, i2, r2) => t.m(i2, r2))), k;
      }
      function j2(e2, i2) {
        const r2 = t.K();
        return t.L(r2, r2, [1, 1, 0]), t.M(r2, r2, [0.5 * e2.width, 0.5 * e2.height, 1]), e2.calculatePosMatrix ? t.N(r2, r2, e2.calculatePosMatrix(i2.toUnwrapped())) : r2;
      }
      function Z2(e2, t2, i2, r2, o2, a2, s2) {
        var n2;
        const l3 = function(e3, t3, i3) {
          if (e3)
            for (const r3 of e3) {
              const e4 = t3[r3];
              if (e4 && e4.source === i3 && e4.type === "fill-extrusion")
                return true;
            }
          else
            for (const e4 in t3) {
              const r3 = t3[e4];
              if (r3.source === i3 && r3.type === "fill-extrusion")
                return true;
            }
          return false;
        }((n2 = o2 == null ? undefined : o2.layers) !== null && n2 !== undefined ? n2 : null, t2, e2.id), c2 = a2.maxPitchScaleFactor(), h2 = e2.tilesIn(r2, c2, l3);
        h2.sort(N);
        const u2 = [];
        for (const r3 of h2)
          u2.push({ wrappedTileID: r3.tileID.wrapped().key, queryResults: r3.tile.queryRenderedFeatures(t2, i2, e2._state, r3.queryGeometry, r3.cameraQueryGeometry, r3.scale, o2, a2, c2, j2(e2.transform, r3.tileID), s2 ? (e3, t3) => s2(r3.tileID, e3, t3) : undefined) });
        return function(e3, t3) {
          for (const i3 in e3)
            for (const r3 of e3[i3])
              U(r3, t3);
          return e3;
        }(function(e3) {
          const t3 = {}, i3 = {};
          for (const r3 of e3) {
            const { queryResults: e4, wrappedTileID: o3 } = r3, a3 = i3[o3] = i3[o3] || {};
            for (const i4 in e4) {
              const r4 = e4[i4], o4 = a3[i4] = a3[i4] || {}, s3 = t3[i4] = t3[i4] || [];
              for (const e5 of r4)
                o4[e5.featureIndex] || (o4[e5.featureIndex] = true, s3.push(e5));
            }
          }
          return t3;
        }(u2), e2);
      }
      function N(e2, t2) {
        const i2 = e2.tileID, r2 = t2.tileID;
        return i2.overscaledZ - r2.overscaledZ || i2.canonical.y - r2.canonical.y || i2.wrap - r2.wrap || i2.canonical.x - r2.canonical.x;
      }
      function U(e2, t2) {
        const i2 = e2.feature, r2 = t2.getFeatureState(i2.layer["source-layer"], i2.id);
        i2.source = i2.layer.source, i2.layer["source-layer"] && (i2.sourceLayer = i2.layer["source-layer"]), i2.state = r2;
      }
      function G2(e2, i2, r2) {
        return t._(this, undefined, undefined, function* () {
          let o2 = e2;
          if (e2.url ? o2 = (yield t.j(i2.transformRequest(e2.url, "Source"), r2)).data : yield s.frameAsync(r2), !o2)
            return null;
          const a2 = t.O(t.e(o2, e2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in o2 && o2.vector_layers && (a2.vectorLayerIds = o2.vector_layers.map((e3) => e3.id)), a2;
        });
      }

      class V {
        constructor(e2, t2) {
          e2 && (t2 ? this.setSouthWest(e2).setNorthEast(t2) : Array.isArray(e2) && (e2.length === 4 ? this.setSouthWest([e2[0], e2[1]]).setNorthEast([e2[2], e2[3]]) : this.setSouthWest(e2[0]).setNorthEast(e2[1])));
        }
        setNorthEast(e2) {
          return this._ne = e2 instanceof t.Q ? new t.Q(e2.lng, e2.lat) : t.Q.convert(e2), this;
        }
        setSouthWest(e2) {
          return this._sw = e2 instanceof t.Q ? new t.Q(e2.lng, e2.lat) : t.Q.convert(e2), this;
        }
        extend(e2) {
          const i2 = this._sw, r2 = this._ne;
          let o2, a2;
          if (e2 instanceof t.Q)
            o2 = e2, a2 = e2;
          else {
            if (!(e2 instanceof V))
              return Array.isArray(e2) ? e2.length === 4 || e2.every(Array.isArray) ? this.extend(V.convert(e2)) : this.extend(t.Q.convert(e2)) : e2 && (("lng" in e2) || ("lon" in e2)) && ("lat" in e2) ? this.extend(t.Q.convert(e2)) : this;
            if (o2 = e2._sw, a2 = e2._ne, !o2 || !a2)
              return this;
          }
          return i2 || r2 ? (i2.lng = Math.min(o2.lng, i2.lng), i2.lat = Math.min(o2.lat, i2.lat), r2.lng = Math.max(a2.lng, r2.lng), r2.lat = Math.max(a2.lat, r2.lat)) : (this._sw = new t.Q(o2.lng, o2.lat), this._ne = new t.Q(a2.lng, a2.lat)), this;
        }
        getCenter() {
          return new t.Q((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new t.Q(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new t.Q(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e2) {
          const { lng: i2, lat: r2 } = t.Q.convert(e2);
          let o2 = this._sw.lng <= i2 && i2 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (o2 = this._sw.lng >= i2 && i2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && o2;
        }
        static convert(e2) {
          return e2 instanceof V ? e2 : e2 ? new V(e2) : e2;
        }
        static fromLngLat(e2, i2 = 0) {
          const r2 = 360 * i2 / 40075017, o2 = r2 / Math.cos(Math.PI / 180 * e2.lat);
          return new V(new t.Q(e2.lng - o2, e2.lat - r2), new t.Q(e2.lng + o2, e2.lat + r2));
        }
        adjustAntiMeridian() {
          const e2 = new t.Q(this._sw.lng, this._sw.lat), i2 = new t.Q(this._ne.lng, this._ne.lat);
          return new V(e2, e2.lng > i2.lng ? new t.Q(i2.lng + 360, i2.lat) : i2);
        }
      }

      class q {
        constructor(e2, t2, i2) {
          this.bounds = V.convert(this.validateBounds(e2)), this.minzoom = t2 || 0, this.maxzoom = i2 || 24;
        }
        validateBounds(e2) {
          return Array.isArray(e2) && e2.length === 4 ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
        }
        contains(e2) {
          const i2 = Math.pow(2, e2.z), r2 = Math.floor(t.U(this.bounds.getWest()) * i2), o2 = Math.floor(t.S(this.bounds.getNorth()) * i2), a2 = Math.ceil(t.U(this.bounds.getEast()) * i2), s2 = Math.ceil(t.S(this.bounds.getSouth()) * i2);
          return e2.x >= r2 && e2.x < a2 && e2.y >= o2 && e2.y < s2;
        }
      }

      class W2 extends t.E {
        constructor(e2, i2, r2, o2) {
          if (super(), this.id = e2, this.dispatcher = r2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.e(this, t.O(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.e({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(o2);
        }
        load() {
          return t._(this, undefined, undefined, function* () {
            this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController;
            try {
              const e2 = yield G2(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e2 && (t.e(this, e2), e2.bounds && (this.tileBounds = new q(e2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.l("data", { dataType: "source", sourceDataType: "content" })));
            } catch (e2) {
              this._tileJSONRequest = null, this.fire(new t.k(e2));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e2) {
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        setSourceProperty(e2) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), e2(), this.load();
        }
        setTiles(e2) {
          return this.setSourceProperty(() => {
            this._options.tiles = e2;
          }), this;
        }
        setUrl(e2) {
          return this.setSourceProperty(() => {
            this.url = e2, this._options.url = e2;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return t.e({}, this._options);
        }
        loadTile(e2) {
          return t._(this, undefined, undefined, function* () {
            const t2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i2 = { request: this.map._requestManager.transformRequest(t2, "Tile"), uid: e2.uid, tileID: e2.tileID, zoom: e2.tileID.overscaledZ, tileSize: this.tileSize * e2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
            i2.request.collectResourceTiming = this._collectResourceTiming;
            let r2 = "RT";
            if (e2.actor && e2.state !== "expired") {
              if (e2.state === "loading")
                return new Promise((t3, i3) => {
                  e2.reloadPromise = { resolve: t3, reject: i3 };
                });
            } else
              e2.actor = this.dispatcher.getActor(), r2 = "LT";
            e2.abortController = new AbortController;
            try {
              const t3 = yield e2.actor.sendAsync({ type: r2, data: i2 }, e2.abortController);
              if (delete e2.abortController, e2.aborted)
                return;
              this._afterTileLoadWorkerResponse(e2, t3);
            } catch (t3) {
              if (delete e2.abortController, e2.aborted)
                return;
              if (t3 && t3.status !== 404)
                throw t3;
              this._afterTileLoadWorkerResponse(e2, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(e2, t2) {
          if (t2 && t2.resourceTiming && (e2.resourceTiming = t2.resourceTiming), t2 && this.map._refreshExpiredTiles && e2.setExpiryData(t2), e2.loadVectorData(t2, this.map.painter), e2.reloadPromise) {
            const t3 = e2.reloadPromise;
            e2.reloadPromise = null, this.loadTile(e2).then(t3.resolve).catch(t3.reject);
          }
        }
        abortTile(e2) {
          return t._(this, undefined, undefined, function* () {
            e2.abortController && (e2.abortController.abort(), delete e2.abortController), e2.actor && (yield e2.actor.sendAsync({ type: "AT", data: { uid: e2.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(e2) {
          return t._(this, undefined, undefined, function* () {
            e2.unloadVectorData(), e2.actor && (yield e2.actor.sendAsync({ type: "RMT", data: { uid: e2.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return false;
        }
      }

      class H extends t.E {
        constructor(e2, i2, r2, o2) {
          super(), this.id = e2, this.dispatcher = r2, this.setEventedParent(o2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.e({ type: "raster" }, i2), t.e(this, t.O(i2, ["url", "scheme", "tileSize"]));
        }
        load() {
          return t._(this, arguments, undefined, function* (e2 = false) {
            this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController;
            try {
              const i2 = yield G2(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = true, i2 && (t.e(this, i2), i2.bounds && (this.tileBounds = new q(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e2 })));
            } catch (e3) {
              this._tileJSONRequest = null, this.fire(new t.k(e3));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(e2) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e2(), this.load(true);
        }
        setTiles(e2) {
          return this.setSourceProperty(() => {
            this._options.tiles = e2;
          }), this;
        }
        setUrl(e2) {
          return this.setSourceProperty(() => {
            this.url = e2, this._options.url = e2;
          }), this;
        }
        serialize() {
          return t.e({}, this._options);
        }
        hasTile(e2) {
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        loadTile(e2) {
          return t._(this, undefined, undefined, function* () {
            const t2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            e2.abortController = new AbortController;
            try {
              const i2 = yield p.getImage(this.map._requestManager.transformRequest(t2, "Tile"), e2.abortController, this.map._refreshExpiredTiles);
              if (delete e2.abortController, e2.aborted)
                return void (e2.state = "unloaded");
              if (i2 && i2.data) {
                this.map._refreshExpiredTiles && (i2.cacheControl || i2.expires) && e2.setExpiryData({ cacheControl: i2.cacheControl, expires: i2.expires });
                const t3 = this.map.painter.context, r2 = t3.gl, o2 = i2.data;
                e2.texture = this.map.painter.getTileTexture(o2.width), e2.texture ? e2.texture.update(o2, { useMipmap: true }) : (e2.texture = new v(t3, o2, r2.RGBA, { useMipmap: true }), e2.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST)), e2.state = "loaded";
              }
            } catch (t3) {
              if (delete e2.abortController, e2.aborted)
                e2.state = "unloaded";
              else if (t3)
                throw e2.state = "errored", t3;
            }
          });
        }
        abortTile(e2) {
          return t._(this, undefined, undefined, function* () {
            e2.abortController && (e2.abortController.abort(), delete e2.abortController);
          });
        }
        unloadTile(e2) {
          return t._(this, undefined, undefined, function* () {
            e2.texture && this.map.painter.saveTileTexture(e2.texture);
          });
        }
        hasTransition() {
          return false;
        }
      }

      class $2 extends H {
        constructor(e2, i2, r2, o2) {
          super(e2, i2, r2, o2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox", this.redFactor = i2.redFactor, this.greenFactor = i2.greenFactor, this.blueFactor = i2.blueFactor, this.baseShift = i2.baseShift;
        }
        loadTile(e2) {
          return t._(this, undefined, undefined, function* () {
            const i2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), r2 = this.map._requestManager.transformRequest(i2, "Tile");
            e2.neighboringTiles = this._getNeighboringTiles(e2.tileID), e2.abortController = new AbortController;
            try {
              const i3 = yield p.getImage(r2, e2.abortController, this.map._refreshExpiredTiles);
              if (delete e2.abortController, e2.aborted)
                return void (e2.state = "unloaded");
              if (i3 && i3.data) {
                const r3 = i3.data;
                this.map._refreshExpiredTiles && (i3.cacheControl || i3.expires) && e2.setExpiryData({ cacheControl: i3.cacheControl, expires: i3.expires });
                const o2 = t.b(r3) && t.V() ? r3 : yield this.readImageNow(r3), a2 = { type: this.type, uid: e2.uid, source: this.id, rawImageData: o2, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!e2.actor || e2.state === "expired") {
                  e2.actor = this.dispatcher.getActor();
                  const t2 = yield e2.actor.sendAsync({ type: "LDT", data: a2 });
                  e2.dem = t2, e2.needsHillshadePrepare = true, e2.needsTerrainPrepare = true, e2.state = "loaded";
                }
              }
            } catch (t2) {
              if (delete e2.abortController, e2.aborted)
                e2.state = "unloaded";
              else if (t2)
                throw e2.state = "errored", t2;
            }
          });
        }
        readImageNow(e2) {
          return t._(this, undefined, undefined, function* () {
            if (typeof VideoFrame != "undefined" && t.W()) {
              const i2 = e2.width + 2, r2 = e2.height + 2;
              try {
                return new t.R({ width: i2, height: r2 }, yield t.X(e2, -1, -1, i2, r2));
              } catch (e3) {
              }
            }
            return s.getImageData(e2, 1);
          });
        }
        _getNeighboringTiles(e2) {
          const i2 = e2.canonical, r2 = Math.pow(2, i2.z), o2 = (i2.x - 1 + r2) % r2, a2 = i2.x === 0 ? e2.wrap - 1 : e2.wrap, s2 = (i2.x + 1 + r2) % r2, n2 = i2.x + 1 === r2 ? e2.wrap + 1 : e2.wrap, l3 = {};
          return l3[new t.Y(e2.overscaledZ, a2, i2.z, o2, i2.y).key] = { backfilled: false }, l3[new t.Y(e2.overscaledZ, n2, i2.z, s2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l3[new t.Y(e2.overscaledZ, a2, i2.z, o2, i2.y - 1).key] = { backfilled: false }, l3[new t.Y(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l3[new t.Y(e2.overscaledZ, n2, i2.z, s2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < r2 && (l3[new t.Y(e2.overscaledZ, a2, i2.z, o2, i2.y + 1).key] = { backfilled: false }, l3[new t.Y(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l3[new t.Y(e2.overscaledZ, n2, i2.z, s2, i2.y + 1).key] = { backfilled: false }), l3;
        }
        unloadTile(e2) {
          return t._(this, undefined, undefined, function* () {
            e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded", e2.actor && (yield e2.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e2.uid, source: this.id } }));
          });
        }
      }

      class X extends t.E {
        constructor(e2, i2, r2, o2) {
          super(), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = r2.getActor(), this.setEventedParent(o2), this._data = i2.data, this._options = t.e({}, i2), this._collectResourceTiming = i2.collectResourceTiming, i2.maxzoom !== undefined && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId, i2.clusterMaxZoom !== undefined && this.maxzoom <= i2.clusterMaxZoom && t.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i2.clusterMaxZoom}".`), this.workerOptions = t.e({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(i2.buffer !== undefined ? i2.buffer : 128), tolerance: this._pixelsToTileUnits(i2.tolerance !== undefined ? i2.tolerance : 0.375), extent: t.Z, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: i2.clusterMaxZoom !== undefined ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: t.Z, radius: this._pixelsToTileUnits(i2.clusterRadius || 50), log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        _pixelsToTileUnits(e2) {
          return e2 * (t.Z / this.tileSize);
        }
        load() {
          return t._(this, undefined, undefined, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        setData(e2) {
          return this._data = e2, this._updateWorkerData(), this;
        }
        updateData(e2) {
          return this._updateWorkerData(e2), this;
        }
        getData() {
          return t._(this, undefined, undefined, function* () {
            const e2 = t.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: e2 });
          });
        }
        getCoordinatesFromGeometry(e2) {
          return e2.type === "GeometryCollection" ? e2.geometries.map((e3) => e3.coordinates).flat(1 / 0) : e2.coordinates.flat(1 / 0);
        }
        getBounds() {
          return t._(this, undefined, undefined, function* () {
            const e2 = new V, t2 = yield this.getData();
            let i2;
            switch (t2.type) {
              case "FeatureCollection":
                i2 = t2.features.map((e3) => this.getCoordinatesFromGeometry(e3.geometry)).flat(1 / 0);
                break;
              case "Feature":
                i2 = this.getCoordinatesFromGeometry(t2.geometry);
                break;
              default:
                i2 = this.getCoordinatesFromGeometry(t2);
            }
            if (i2.length == 0)
              return e2;
            for (let t3 = 0;t3 < i2.length - 1; t3 += 2)
              e2.extend([i2[t3], i2[t3 + 1]]);
            return e2;
          });
        }
        setClusterOptions(e2) {
          return this.workerOptions.cluster = e2.cluster, e2 && (e2.clusterRadius !== undefined && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e2.clusterRadius)), e2.clusterMaxZoom !== undefined && (this.workerOptions.superclusterOptions.maxZoom = e2.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e2) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e2, source: this.id } });
        }
        getClusterChildren(e2) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e2, source: this.id } });
        }
        getClusterLeaves(e2, t2, i2) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e2, limit: t2, offset: i2 } });
        }
        _updateWorkerData(e2) {
          return t._(this, undefined, undefined, function* () {
            const i2 = t.e({ type: this.type }, this.workerOptions);
            e2 ? i2.dataDiff = e2 : typeof this._data == "string" ? (i2.request = this.map._requestManager.transformRequest(s.resolveURL(this._data), "Source"), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new t.l("dataloading", { dataType: "source" }));
            try {
              const e3 = yield this.actor.sendAsync({ type: "LD", data: i2 });
              if (this._pendingLoads--, this._removed || e3.abandoned)
                return void this.fire(new t.l("dataabort", { dataType: "source" }));
              let r2 = null;
              e3.resourceTiming && e3.resourceTiming[this.id] && (r2 = e3.resourceTiming[this.id].slice(0));
              const o2 = { dataType: "source" };
              this._collectResourceTiming && r2 && r2.length > 0 && t.e(o2, { resourceTiming: r2 }), this.fire(new t.l("data", Object.assign(Object.assign({}, o2), { sourceDataType: "metadata" }))), this.fire(new t.l("data", Object.assign(Object.assign({}, o2), { sourceDataType: "content" })));
            } catch (e3) {
              if (this._pendingLoads--, this._removed)
                return void this.fire(new t.l("dataabort", { dataType: "source" }));
              this.fire(new t.k(e3));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(e2) {
          return t._(this, undefined, undefined, function* () {
            const t2 = e2.actor ? "RT" : "LT";
            e2.actor = this.actor;
            const i2 = { type: this.type, uid: e2.uid, tileID: e2.tileID, zoom: e2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
            e2.abortController = new AbortController;
            const r2 = yield this.actor.sendAsync({ type: t2, data: i2 }, e2.abortController);
            delete e2.abortController, e2.unloadVectorData(), e2.aborted || e2.loadVectorData(r2, this.map.painter, t2 === "RT");
          });
        }
        abortTile(e2) {
          return t._(this, undefined, undefined, function* () {
            e2.abortController && (e2.abortController.abort(), delete e2.abortController), e2.aborted = true;
          });
        }
        unloadTile(e2) {
          return t._(this, undefined, undefined, function* () {
            e2.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e2.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return t.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }

      class K extends t.E {
        constructor(e2, t2, i2, r2) {
          super(), this.flippedWindingOrder = false, this.id = e2, this.dispatcher = i2, this.coordinates = t2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(r2), this.options = t2;
        }
        load(e2) {
          return t._(this, undefined, undefined, function* () {
            this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController;
            try {
              const t2 = yield p.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = true, t2 && t2.data && (this.image = t2.data, e2 && (this.coordinates = e2), this._finishLoading());
            } catch (e3) {
              this._request = null, this._loaded = true, this.fire(new t.k(e3));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e2) {
          return e2.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e2.url, this.load(e2.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(e2) {
          this.coordinates = e2;
          const i2 = e2.map(t.$.fromLngLat);
          var r2;
          return this.tileID = function(e3) {
            let i3 = 1 / 0, r3 = 1 / 0, o2 = -1 / 0, a2 = -1 / 0;
            for (const t2 of e3)
              i3 = Math.min(i3, t2.x), r3 = Math.min(r3, t2.y), o2 = Math.max(o2, t2.x), a2 = Math.max(a2, t2.y);
            const s2 = Math.max(o2 - i3, a2 - r3), n2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), l3 = Math.pow(2, n2);
            return new t.a1(n2, Math.floor((i3 + o2) / 2 * l3), Math.floor((r3 + a2) / 2 * l3));
          }(i2), this.terrainTileRanges = this._getOverlappingTileRanges(i2), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i2.map((e3) => this.tileID.getTilePoint(e3)._round()), this.flippedWindingOrder = ((r2 = this.tileCoords)[1].x - r2[0].x) * (r2[2].y - r2[0].y) - (r2[1].y - r2[0].y) * (r2[2].x - r2[0].x) < 0, this.fire(new t.l("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image)
            return;
          const e2 = this.map.painter.context, i2 = e2.gl;
          this.texture || (this.texture = new v(e2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
          let r2 = false;
          for (const e3 in this.tiles) {
            const t2 = this.tiles[e3];
            t2.state !== "loaded" && (t2.state = "loaded", t2.texture = this.texture, r2 = true);
          }
          r2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(e2) {
          return t._(this, undefined, undefined, function* () {
            this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}) : e2.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
        _getOverlappingTileRanges(e2) {
          let i2 = 1 / 0, r2 = 1 / 0, o2 = -1 / 0, a2 = -1 / 0;
          for (const t2 of e2)
            i2 = Math.min(i2, t2.x), r2 = Math.min(r2, t2.y), o2 = Math.max(o2, t2.x), a2 = Math.max(a2, t2.y);
          const s2 = {};
          for (let e3 = 0;e3 <= t.a0; e3++) {
            const t2 = Math.pow(2, e3), n2 = Math.floor(i2 * t2), l3 = Math.floor(r2 * t2), c2 = Math.floor(o2 * t2), h2 = Math.floor(a2 * t2);
            s2[e3] = { minTileX: n2, minTileY: l3, maxTileX: c2, maxTileY: h2 };
          }
          return s2;
        }
      }

      class Q2 extends K {
        constructor(e2, t2, i2, r2) {
          super(e2, t2, i2, r2), this.roundZoom = true, this.type = "video", this.options = t2;
        }
        load() {
          return t._(this, undefined, undefined, function* () {
            this._loaded = false;
            const e2 = this.options;
            this.urls = [];
            for (const t2 of e2.urls)
              this.urls.push(this.map._requestManager.transformRequest(t2, "Source").url);
            try {
              const e3 = yield t.a2(this.urls);
              if (this._loaded = true, !e3)
                return;
              this.video = e3, this.video.loop = true, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (e3) {
              this.fire(new t.k(e3));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(e2) {
          if (this.video) {
            const i2 = this.video.seekable;
            e2 < i2.start(0) || e2 > i2.end(0) ? this.fire(new t.k(new t.a3(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = e2;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e2) {
          this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
            return;
          const e2 = this.map.painter.context, i2 = e2.gl;
          this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new v(e2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
          let r2 = false;
          for (const e3 in this.tiles) {
            const t2 = this.tiles[e3];
            t2.state !== "loaded" && (t2.state = "loaded", t2.texture = this.texture, r2 = true);
          }
          r2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }

      class Y2 extends K {
        constructor(e2, i2, r2, o2) {
          super(e2, i2, r2, o2), i2.coordinates ? Array.isArray(i2.coordinates) && i2.coordinates.length === 4 && !i2.coordinates.some((e3) => !Array.isArray(e3) || e3.length !== 2 || e3.some((e4) => typeof e4 != "number")) || this.fire(new t.k(new t.a3(`sources.${e2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.k(new t.a3(`sources.${e2}`, null, 'missing required property "coordinates"'))), i2.animate && typeof i2.animate != "boolean" && this.fire(new t.k(new t.a3(`sources.${e2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? typeof i2.canvas == "string" || i2.canvas instanceof HTMLCanvasElement || this.fire(new t.k(new t.a3(`sources.${e2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.k(new t.a3(`sources.${e2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = i2.animate === undefined || i2.animate;
        }
        load() {
          return t._(this, undefined, undefined, function* () {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e2) {
          this.map = e2, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let e2 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, e2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e2 = true), this._hasInvalidDimensions())
            return;
          if (Object.keys(this.tiles).length === 0)
            return;
          const i2 = this.map.painter.context, r2 = i2.gl;
          this.texture ? (e2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new v(i2, this.canvas, r2.RGBA, { premultiply: true });
          let o2 = false;
          for (const e3 in this.tiles) {
            const t2 = this.tiles[e3];
            t2.state !== "loaded" && (t2.state = "loaded", t2.texture = this.texture, o2 = true);
          }
          o2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e2 of [this.canvas.width, this.canvas.height])
            if (isNaN(e2) || e2 <= 0)
              return true;
          return false;
        }
      }
      const J2 = {}, ee2 = (e2) => {
        switch (e2) {
          case "geojson":
            return X;
          case "image":
            return K;
          case "raster":
            return H;
          case "raster-dem":
            return $2;
          case "vector":
            return W2;
          case "video":
            return Q2;
          case "canvas":
            return Y2;
        }
        return J2[e2];
      }, te2 = "RTLPluginLoaded";

      class ie2 extends t.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = O();
        }
        _syncState(e2) {
          return this.status = e2, this.dispatcher.broadcast("SRPS", { pluginStatus: e2, pluginURL: this.url }).catch((e3) => {
            throw this.status = "error", e3;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(e2) {
          return t._(this, arguments, undefined, function* (e3, t2 = false) {
            if (this.url)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            if (this.url = s.resolveURL(e3), !this.url)
              throw new Error(`requested url ${e3} is invalid`);
            if (this.status === "unavailable") {
              if (!t2)
                return this._requestImport();
              this.status = "deferred", this._syncState(this.status);
            } else if (this.status === "requested")
              return this._requestImport();
          });
        }
        _requestImport() {
          return t._(this, undefined, undefined, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new t.l(te2));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let re2 = null;
      function oe() {
        return re2 || (re2 = new ie2), re2;
      }

      class ae {
        constructor(e2, i2) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e2, this.uid = t.a4(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(e2) {
          const t2 = e2 + this.timeAdded;
          t2 < this.fadeEndTime || (this.fadeEndTime = t2);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(e2) {
          this.demTexture && e2.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(e2, i2, r2) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e2) {
            e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex, e2.rawTileData ? (this.latestRawTileData = e2.rawTileData, this.latestFeatureIndex.rawTileData = e2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e2.collisionBoxArray, this.buckets = function(e3, t2) {
              const i3 = {};
              if (!t2)
                return i3;
              for (const r3 of e3) {
                const e4 = r3.layerIds.map((e5) => t2.getLayer(e5)).filter(Boolean);
                if (e4.length !== 0) {
                  r3.layers = e4, r3.stateDependentLayerIds && (r3.stateDependentLayers = r3.stateDependentLayerIds.map((t3) => e4.filter((e5) => e5.id === t3)[0]));
                  for (const t3 of e4)
                    i3[t3.id] = r3;
                }
              }
              return i3;
            }(e2.buckets, i2 == null ? undefined : i2.style), this.hasSymbolBuckets = false;
            for (const e3 in this.buckets) {
              const i3 = this.buckets[e3];
              if (i3 instanceof t.a6) {
                if (this.hasSymbolBuckets = true, !r2)
                  break;
                i3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (const e3 in this.buckets) {
                const i3 = this.buckets[e3];
                if (i3 instanceof t.a6 && i3.hasRTLText) {
                  this.hasRTLText = true, oe().lazyLoad();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const e3 in this.buckets) {
              const t2 = this.buckets[e3];
              this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(e3).queryRadius(t2));
            }
            e2.imageAtlas && (this.imageAtlas = e2.imageAtlas), e2.glyphAtlasImage && (this.glyphAtlasImage = e2.glyphAtlasImage);
          } else
            this.collisionBoxArray = new t.a5;
        }
        unloadVectorData() {
          for (const e2 in this.buckets)
            this.buckets[e2].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(e2) {
          return this.buckets[e2.id];
        }
        upload(e2) {
          for (const t3 in this.buckets) {
            const i2 = this.buckets[t3];
            i2.uploadPending() && i2.upload(e2);
          }
          const t2 = e2.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new v(e2, this.imageAtlas.image, t2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new v(e2, this.glyphAtlasImage, t2.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(e2) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(e2, this.imageAtlasTexture);
        }
        queryRenderedFeatures(e2, t2, i2, r2, o2, a2, s2, n2, l3, c2, h2) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: r2, cameraQueryGeometry: o2, scale: a2, tileSize: this.tileSize, pixelPosMatrix: c2, transform: n2, params: s2, queryPadding: this.queryPadding * l3, getElevation: h2 }, e2, t2, i2) : {};
        }
        querySourceFeatures(e2, i2) {
          const r2 = this.latestFeatureIndex;
          if (!r2 || !r2.rawTileData)
            return;
          const o2 = r2.loadVTLayers(), a2 = i2 && i2.sourceLayer ? i2.sourceLayer : "", s2 = o2._geojsonTileLayer || o2[a2];
          if (!s2)
            return;
          const n2 = t.a7(i2 && i2.filter), { z: l3, x: c2, y: h2 } = this.tileID.canonical, u2 = { z: l3, x: c2, y: h2 };
          for (let i3 = 0;i3 < s2.length; i3++) {
            const o3 = s2.feature(i3);
            if (n2.needGeometry) {
              const e3 = t.a8(o3, true);
              if (!n2.filter(new t.C(this.tileID.overscaledZ), e3, this.tileID.canonical))
                continue;
            } else if (!n2.filter(new t.C(this.tileID.overscaledZ), o3))
              continue;
            const d2 = r2.getId(o3, a2), _2 = new t.a9(o3, l3, c2, h2, d2);
            _2.tile = u2, e2.push(_2);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(e2) {
          const i2 = this.expirationTime;
          if (e2.cacheControl) {
            const i3 = t.aa(e2.cacheControl);
            i3["max-age"] && (this.expirationTime = Date.now() + 1000 * i3["max-age"]);
          } else
            e2.expires && (this.expirationTime = new Date(e2.expires).getTime());
          if (this.expirationTime) {
            const e3 = Date.now();
            let t2 = false;
            if (this.expirationTime > e3)
              t2 = false;
            else if (i2)
              if (this.expirationTime < i2)
                t2 = true;
              else {
                const r2 = this.expirationTime - i2;
                r2 ? this.expirationTime = e3 + Math.max(r2, 30000) : t2 = true;
              }
            else
              t2 = true;
            t2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1000 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(e2, t2) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e2).length === 0)
            return;
          const i2 = this.latestFeatureIndex.loadVTLayers();
          for (const r2 in this.buckets) {
            if (!t2.style.hasLayer(r2))
              continue;
            const o2 = this.buckets[r2], a2 = o2.layers[0].sourceLayer || "_geojsonTileLayer", s2 = i2[a2], n2 = e2[a2];
            if (!s2 || !n2 || Object.keys(n2).length === 0)
              continue;
            o2.update(n2, s2, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const l3 = t2 && t2.style && t2.style.getLayer(r2);
            l3 && (this.queryPadding = Math.max(this.queryPadding, l3.queryRadius(o2)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== undefined;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < s.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = undefined;
        }
        setHoldDuration(e2) {
          this.symbolFadeHoldUntil = s.now() + e2;
        }
        setDependencies(e2, t2) {
          const i2 = {};
          for (const e3 of t2)
            i2[e3] = true;
          this.dependencies[e2] = i2;
        }
        hasDependency(e2, t2) {
          for (const i2 of e2) {
            const e3 = this.dependencies[i2];
            if (e3) {
              for (const i3 of t2)
                if (e3[i3])
                  return true;
            }
          }
          return false;
        }
      }

      class se2 {
        constructor(e2, t2) {
          this.max = e2, this.onRemove = t2, this.reset();
        }
        reset() {
          for (const e2 in this.data)
            for (const t2 of this.data[e2])
              t2.timeout && clearTimeout(t2.timeout), this.onRemove(t2.value);
          return this.data = {}, this.order = [], this;
        }
        add(e2, t2, i2) {
          const r2 = e2.wrapped().key;
          this.data[r2] === undefined && (this.data[r2] = []);
          const o2 = { value: t2, timeout: undefined };
          if (i2 !== undefined && (o2.timeout = setTimeout(() => {
            this.remove(e2, o2);
          }, i2)), this.data[r2].push(o2), this.order.push(r2), this.order.length > this.max) {
            const e3 = this._getAndRemoveByKey(this.order[0]);
            e3 && this.onRemove(e3);
          }
          return this;
        }
        has(e2) {
          return e2.wrapped().key in this.data;
        }
        getAndRemove(e2) {
          return this.has(e2) ? this._getAndRemoveByKey(e2.wrapped().key) : null;
        }
        _getAndRemoveByKey(e2) {
          const t2 = this.data[e2].shift();
          return t2.timeout && clearTimeout(t2.timeout), this.data[e2].length === 0 && delete this.data[e2], this.order.splice(this.order.indexOf(e2), 1), t2.value;
        }
        getByKey(e2) {
          const t2 = this.data[e2];
          return t2 ? t2[0].value : null;
        }
        get(e2) {
          return this.has(e2) ? this.data[e2.wrapped().key][0].value : null;
        }
        remove(e2, t2) {
          if (!this.has(e2))
            return this;
          const i2 = e2.wrapped().key, r2 = t2 === undefined ? 0 : this.data[i2].indexOf(t2), o2 = this.data[i2][r2];
          return this.data[i2].splice(r2, 1), o2.timeout && clearTimeout(o2.timeout), this.data[i2].length === 0 && delete this.data[i2], this.onRemove(o2.value), this.order.splice(this.order.indexOf(i2), 1), this;
        }
        setMaxSize(e2) {
          for (this.max = e2;this.order.length > this.max; ) {
            const e3 = this._getAndRemoveByKey(this.order[0]);
            e3 && this.onRemove(e3);
          }
          return this;
        }
        filter(e2) {
          const t2 = [];
          for (const i2 in this.data)
            for (const r2 of this.data[i2])
              e2(r2.value) || t2.push(r2);
          for (const e3 of t2)
            this.remove(e3.value.tileID, e3);
        }
      }

      class ne2 {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(e2, i2, r2) {
          const o2 = String(i2);
          if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][o2] = this.stateChanges[e2][o2] || {}, t.e(this.stateChanges[e2][o2], r2), this.deletedStates[e2] === null) {
            this.deletedStates[e2] = {};
            for (const t2 in this.state[e2])
              t2 !== o2 && (this.deletedStates[e2][t2] = null);
          } else if (this.deletedStates[e2] && this.deletedStates[e2][o2] === null) {
            this.deletedStates[e2][o2] = {};
            for (const t2 in this.state[e2][o2])
              r2[t2] || (this.deletedStates[e2][o2][t2] = null);
          } else
            for (const t2 in r2)
              this.deletedStates[e2] && this.deletedStates[e2][o2] && this.deletedStates[e2][o2][t2] === null && delete this.deletedStates[e2][o2][t2];
        }
        removeFeatureState(e2, t2, i2) {
          if (this.deletedStates[e2] === null)
            return;
          const r2 = String(t2);
          if (this.deletedStates[e2] = this.deletedStates[e2] || {}, i2 && t2 !== undefined)
            this.deletedStates[e2][r2] !== null && (this.deletedStates[e2][r2] = this.deletedStates[e2][r2] || {}, this.deletedStates[e2][r2][i2] = null);
          else if (t2 !== undefined)
            if (this.stateChanges[e2] && this.stateChanges[e2][r2])
              for (i2 in this.deletedStates[e2][r2] = {}, this.stateChanges[e2][r2])
                this.deletedStates[e2][r2][i2] = null;
            else
              this.deletedStates[e2][r2] = null;
          else
            this.deletedStates[e2] = null;
        }
        getState(e2, i2) {
          const r2 = String(i2), o2 = t.e({}, (this.state[e2] || {})[r2], (this.stateChanges[e2] || {})[r2]);
          if (this.deletedStates[e2] === null)
            return {};
          if (this.deletedStates[e2]) {
            const t2 = this.deletedStates[e2][i2];
            if (t2 === null)
              return {};
            for (const e3 in t2)
              delete o2[e3];
          }
          return o2;
        }
        initializeTileState(e2, t2) {
          e2.setFeatureState(this.state, t2);
        }
        coalesceChanges(e2, i2) {
          const r2 = {};
          for (const e3 in this.stateChanges) {
            this.state[e3] = this.state[e3] || {};
            const i3 = {};
            for (const r3 in this.stateChanges[e3])
              this.state[e3][r3] || (this.state[e3][r3] = {}), t.e(this.state[e3][r3], this.stateChanges[e3][r3]), i3[r3] = this.state[e3][r3];
            r2[e3] = i3;
          }
          for (const e3 in this.deletedStates) {
            this.state[e3] = this.state[e3] || {};
            const i3 = {};
            if (this.deletedStates[e3] === null)
              for (const t2 in this.state[e3])
                i3[t2] = {}, this.state[e3][t2] = {};
            else
              for (const t2 in this.deletedStates[e3]) {
                if (this.deletedStates[e3][t2] === null)
                  this.state[e3][t2] = {};
                else
                  for (const i4 of Object.keys(this.deletedStates[e3][t2]))
                    delete this.state[e3][t2][i4];
                i3[t2] = this.state[e3][t2];
              }
            r2[e3] = r2[e3] || {}, t.e(r2[e3], i3);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(r2).length !== 0)
            for (const t2 in e2)
              e2[t2].setFeatureState(r2, i2);
        }
      }
      const le2 = 89.25;
      function ce2(e2, i2) {
        const r2 = t.ae(i2.lat, -85.051129, t.af);
        return new t.P(t.U(i2.lng) * e2, t.S(r2) * e2);
      }
      function he2(e2, i2) {
        return new t.$(i2.x / e2, i2.y / e2).toLngLat();
      }
      function ue2(e2) {
        return e2.cameraToCenterDistance * Math.min(0.85 * Math.tan(t.ab(90 - e2.pitch)), Math.tan(t.ab(le2 - e2.pitch)));
      }
      function de2(e2, i2) {
        const r2 = e2.canonical, o2 = i2 / t.ac(r2.z), a2 = r2.x + Math.pow(2, r2.z) * e2.wrap, s2 = t.ad(new Float64Array(16));
        return t.L(s2, s2, [a2 * o2, r2.y * o2, 0]), t.M(s2, s2, [o2 / t.Z, o2 / t.Z, 1]), s2;
      }
      function _e2(e2, i2, r2, o2, a2) {
        const s2 = t.$.fromLngLat(e2, i2), n2 = a2 * t.ag(1, e2.lat), l3 = n2 * Math.cos(t.ab(r2)), c2 = Math.sqrt(n2 * n2 - l3 * l3), h2 = c2 * Math.sin(t.ab(-o2)), u2 = c2 * Math.cos(t.ab(-o2));
        return new t.$(s2.x + h2, s2.y + u2, s2.z + l3);
      }
      function pe2(e2, t2, i2) {
        const r2 = t2.intersectsFrustum(e2);
        if (!i2)
          return r2;
        const o2 = t2.intersectsPlane(i2);
        return r2 === 0 || o2 === 0 ? 0 : r2 === 2 && o2 === 2 ? 2 : 1;
      }
      function me2(e2, t2, i2) {
        let r2 = 0;
        const o2 = (i2 - t2) / 10;
        for (let a2 = 0;a2 < 10; a2++)
          r2 += o2 * Math.pow(Math.cos(t2 + (a2 + 0.5) / 10 * (i2 - t2)), e2);
        return r2;
      }
      function fe2(e2, i2) {
        return function(r2, o2, a2, s2, n2) {
          const l3 = 2 * ((e2 - 1) / t.ah(Math.cos(t.ab(le2 - n2)) / Math.cos(t.ab(le2))) - 1), c2 = Math.acos(a2 / s2), h2 = 2 * me2(l3 - 1, 0, t.ab(n2 / 2)), u2 = Math.min(t.ab(le2), c2 + t.ab(n2 / 2)), d2 = me2(l3 - 1, Math.min(u2, c2 - t.ab(n2 / 2)), u2), _2 = Math.atan(o2 / a2), p2 = Math.hypot(o2, a2);
          let m2 = r2;
          return m2 += t.ah(s2 / p2 / Math.max(0.5, Math.cos(t.ab(n2 / 2)))), m2 += l3 * t.ah(Math.cos(_2)) / 2, m2 -= t.ah(Math.max(1, d2 / h2 / i2)) / 2, m2;
        };
      }
      const ge2 = fe2(9.314, 3);
      function ve2(e2, i2) {
        const r2 = (i2.roundZoom ? Math.round : Math.floor)(e2.zoom + t.ah(e2.tileSize / i2.tileSize));
        return Math.max(0, r2);
      }
      function xe2(e2, i2) {
        const r2 = e2.getCameraFrustum(), o2 = e2.getClippingPlane(), a2 = e2.screenPointToMercatorCoordinate(e2.getCameraPoint()), s2 = t.$.fromLngLat(e2.center, e2.elevation);
        a2.z = s2.z + Math.cos(e2.pitchInRadians) * e2.cameraToCenterDistance / e2.worldSize;
        const n2 = e2.getCoveringTilesDetailsProvider(), l3 = n2.allowVariableZoom(e2, i2), c2 = ve2(e2, i2), h2 = i2.minzoom || 0, u2 = i2.maxzoom !== undefined ? i2.maxzoom : e2.maxZoom, d2 = Math.min(Math.max(0, c2), u2), _2 = Math.pow(2, d2), p2 = [_2 * a2.x, _2 * a2.y, 0], m2 = [_2 * s2.x, _2 * s2.y, 0], f2 = Math.hypot(s2.x - a2.x, s2.y - a2.y), g2 = Math.abs(s2.z - a2.z), v2 = Math.hypot(f2, g2), x2 = (e3) => ({ zoom: 0, x: 0, y: 0, wrap: e3, fullyVisible: false }), b2 = [], y2 = [];
        if (e2.renderWorldCopies && n2.allowWorldCopies())
          for (let e3 = 1;e3 <= 3; e3++)
            b2.push(x2(-e3)), b2.push(x2(e3));
        for (b2.push(x2(0));b2.length > 0; ) {
          const _3 = b2.pop(), f3 = _3.x, x3 = _3.y;
          let w2 = _3.fullyVisible;
          const T2 = { x: f3, y: x3, z: _3.zoom }, P2 = n2.getTileAABB(T2, _3.wrap, e2.elevation, i2);
          if (!w2) {
            const e3 = pe2(r2, P2, o2);
            if (e3 === 0)
              continue;
            w2 = e3 === 2;
          }
          const C2 = n2.distanceToTile2d(a2.x, a2.y, T2, P2);
          let M3 = c2;
          l3 && (M3 = (i2.calculateTileZoom || ge2)(e2.zoom + t.ah(e2.tileSize / i2.tileSize), C2, g2, v2, e2.fov)), M3 = (i2.roundZoom ? Math.round : Math.floor)(M3), M3 = Math.max(0, M3);
          const I2 = Math.min(M3, u2);
          if (_3.wrap = n2.getWrap(s2, T2, _3.wrap), _3.zoom >= I2) {
            if (_3.zoom < h2)
              continue;
            const e3 = d2 - _3.zoom, r3 = p2[0] - 0.5 - (f3 << e3), o3 = p2[1] - 0.5 - (x3 << e3), a3 = i2.reparseOverscaled ? Math.max(_3.zoom, M3) : _3.zoom;
            y2.push({ tileID: new t.Y(_3.zoom === u2 ? a3 : _3.zoom, _3.wrap, _3.zoom, f3, x3), distanceSq: t.ai([m2[0] - 0.5 - f3, m2[1] - 0.5 - x3]), tileDistanceToCamera: Math.sqrt(r3 * r3 + o3 * o3) });
          } else
            for (let e3 = 0;e3 < 4; e3++)
              b2.push({ zoom: _3.zoom + 1, x: (f3 << 1) + e3 % 2, y: (x3 << 1) + (e3 >> 1), wrap: _3.wrap, fullyVisible: w2 });
        }
        return y2.sort((e3, t2) => e3.distanceSq - t2.distanceSq).map((e3) => e3.tileID);
      }

      class be2 extends t.E {
        constructor(e2, t2, i2) {
          super(), this.id = e2, this.dispatcher = i2, this.on("data", (e3) => this._dataHandler(e3)), this.on("dataloading", () => {
            this._sourceErrored = false;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((e3, t3, i3, r2) => {
            const o2 = new (ee2(t3.type))(e3, t3, i3, r2);
            if (o2.id !== e3)
              throw new Error(`Expected Source id to be ${e3} instead of ${o2.id}`);
            return o2;
          })(e2, t2, i2, this), this._tiles = {}, this._cache = new se2(0, (e3) => this._unloadTile(e3)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ne2, this._didEmitContent = false, this._updated = false;
        }
        onAdd(e2) {
          this.map = e2, this._maxTileCacheSize = e2 ? e2._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e2 ? e2._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e2);
        }
        onRemove(e2) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e2);
        }
        loaded() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          if (!(this.used === undefined && this.usedForTerrain === undefined || this.used || this.usedForTerrain))
            return true;
          if (!this._updated)
            return false;
          for (const e2 in this._tiles) {
            const t2 = this._tiles[e2];
            if (t2.state !== "loaded" && t2.state !== "errored")
              return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused)
            return;
          const e2 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, e2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(e2, i2, r2) {
          return t._(this, undefined, undefined, function* () {
            try {
              yield this._source.loadTile(e2), this._tileLoaded(e2, i2, r2);
            } catch (i3) {
              e2.state = "errored", i3.status !== 404 ? this._source.fire(new t.k(i3, { tile: e2 })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(e2) {
          this._source.unloadTile && this._source.unloadTile(e2);
        }
        _abortTile(e2) {
          this._source.abortTile && this._source.abortTile(e2), this._source.fire(new t.l("dataabort", { tile: e2, coord: e2.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(e2) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const t2 in this._tiles) {
            const i2 = this._tiles[t2];
            i2.upload(e2), i2.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((e2) => e2.tileID).sort(ye2).map((e2) => e2.key);
        }
        getRenderableIds(e2) {
          const i2 = [];
          for (const t2 in this._tiles)
            this._isIdRenderable(t2, e2) && i2.push(this._tiles[t2]);
          return e2 ? i2.sort((e3, i3) => {
            const r2 = e3.tileID, o2 = i3.tileID, a2 = new t.P(r2.canonical.x, r2.canonical.y)._rotate(-this.transform.bearingInRadians), s2 = new t.P(o2.canonical.x, o2.canonical.y)._rotate(-this.transform.bearingInRadians);
            return r2.overscaledZ - o2.overscaledZ || s2.y - a2.y || s2.x - a2.x;
          }).map((e3) => e3.tileID.key) : i2.map((e3) => e3.tileID).sort(ye2).map((e3) => e3.key);
        }
        hasRenderableParent(e2) {
          const t2 = this.findLoadedParent(e2, 0);
          return !!t2 && this._isIdRenderable(t2.tileID.key);
        }
        _isIdRenderable(e2, t2) {
          return this._tiles[e2] && this._tiles[e2].hasData() && !this._coveredTiles[e2] && (t2 || !this._tiles[e2].holdingForFade());
        }
        reload(e2) {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const t2 in this._tiles)
              (e2 || this._tiles[t2].state !== "errored") && this._reloadTile(t2, "reloading");
          }
        }
        _reloadTile(e2, i2) {
          return t._(this, undefined, undefined, function* () {
            const t2 = this._tiles[e2];
            t2 && (t2.state !== "loading" && (t2.state = i2), yield this._loadTile(t2, e2, i2));
          });
        }
        _tileLoaded(e2, i2, r2) {
          e2.timeAdded = s.now(), r2 === "expired" && (e2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, e2), this.getSource().type === "raster-dem" && e2.dem && this._backfillDEM(e2), this._state.initializeTileState(e2, this.map ? this.map.painter : null), e2.aborted || this._source.fire(new t.l("data", { dataType: "source", tile: e2, coord: e2.tileID }));
        }
        _backfillDEM(e2) {
          const t2 = this.getRenderableIds();
          for (let r2 = 0;r2 < t2.length; r2++) {
            const o2 = t2[r2];
            if (e2.neighboringTiles && e2.neighboringTiles[o2]) {
              const t3 = this.getTileByID(o2);
              i2(e2, t3), i2(t3, e2);
            }
          }
          function i2(e3, t3) {
            e3.needsHillshadePrepare = true, e3.needsTerrainPrepare = true;
            let i3 = t3.tileID.canonical.x - e3.tileID.canonical.x;
            const r2 = t3.tileID.canonical.y - e3.tileID.canonical.y, o2 = Math.pow(2, e3.tileID.canonical.z), a2 = t3.tileID.key;
            i3 === 0 && r2 === 0 || Math.abs(r2) > 1 || (Math.abs(i3) > 1 && (Math.abs(i3 + o2) === 1 ? i3 += o2 : Math.abs(i3 - o2) === 1 && (i3 -= o2)), t3.dem && e3.dem && (e3.dem.backfillBorder(t3.dem, i3, r2), e3.neighboringTiles && e3.neighboringTiles[a2] && (e3.neighboringTiles[a2].backfilled = true)));
          }
        }
        getTile(e2) {
          return this.getTileByID(e2.key);
        }
        getTileByID(e2) {
          return this._tiles[e2];
        }
        _retainLoadedChildren(e2, t2, i2, r2) {
          for (const o2 in this._tiles) {
            let a2 = this._tiles[o2];
            if (r2[o2] || !a2.hasData() || a2.tileID.overscaledZ <= t2 || a2.tileID.overscaledZ > i2)
              continue;
            let s2 = a2.tileID;
            for (;a2 && a2.tileID.overscaledZ > t2 + 1; ) {
              const e3 = a2.tileID.scaledTo(a2.tileID.overscaledZ - 1);
              a2 = this._tiles[e3.key], a2 && a2.hasData() && (s2 = e3);
            }
            let n2 = s2;
            for (;n2.overscaledZ > t2; )
              if (n2 = n2.scaledTo(n2.overscaledZ - 1), e2[n2.key] || e2[n2.canonical.key]) {
                r2[s2.key] = s2;
                break;
              }
          }
        }
        findLoadedParent(e2, t2) {
          if (e2.key in this._loadedParentTiles) {
            const i2 = this._loadedParentTiles[e2.key];
            return i2 && i2.tileID.overscaledZ >= t2 ? i2 : null;
          }
          for (let i2 = e2.overscaledZ - 1;i2 >= t2; i2--) {
            const t3 = e2.scaledTo(i2), r2 = this._getLoadedTile(t3);
            if (r2)
              return r2;
          }
        }
        findLoadedSibling(e2) {
          return this._getLoadedTile(e2);
        }
        _getLoadedTile(e2) {
          const t2 = this._tiles[e2.key];
          return t2 && t2.hasData() ? t2 : this._cache.getByKey(e2.wrapped().key);
        }
        updateCacheSize(e2) {
          const i2 = Math.ceil(e2.width / this._source.tileSize) + 1, r2 = Math.ceil(e2.height / this._source.tileSize) + 1, o2 = Math.floor(i2 * r2 * (this._maxTileCacheZoomLevels === null ? t.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), a2 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, o2) : o2;
          this._cache.setMaxSize(a2);
        }
        handleWrapJump(e2) {
          const t2 = Math.round((e2 - (this._prevLng === undefined ? e2 : this._prevLng)) / 360);
          if (this._prevLng = e2, t2) {
            const e3 = {};
            for (const i2 in this._tiles) {
              const r2 = this._tiles[i2];
              r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + t2), e3[r2.tileID.key] = r2;
            }
            this._tiles = e3;
            for (const e4 in this._timers)
              clearTimeout(this._timers[e4]), delete this._timers[e4];
            for (const e4 in this._tiles)
              this._setTileReloadTimer(e4, this._tiles[e4]);
          }
        }
        _updateCoveredAndRetainedTiles(e2, t2, i2, r2, o2, a2) {
          const n2 = {}, l3 = {}, c2 = Object.keys(e2), h2 = s.now();
          for (const i3 of c2) {
            const r3 = e2[i3], o3 = this._tiles[i3];
            if (!o3 || o3.fadeEndTime !== 0 && o3.fadeEndTime <= h2)
              continue;
            const a3 = this.findLoadedParent(r3, t2), s2 = this.findLoadedSibling(r3), c3 = a3 || s2 || null;
            c3 && (this._addTile(c3.tileID), n2[c3.tileID.key] = c3.tileID), l3[i3] = r3;
          }
          this._retainLoadedChildren(l3, r2, i2, e2);
          for (const t3 in n2)
            e2[t3] || (this._coveredTiles[t3] = true, e2[t3] = n2[t3]);
          if (a2) {
            const t3 = {}, i3 = {};
            for (const e3 of o2)
              this._tiles[e3.key].hasData() ? t3[e3.key] = e3 : i3[e3.key] = e3;
            for (const r3 in i3) {
              const o3 = i3[r3].children(this._source.maxzoom);
              this._tiles[o3[0].key] && this._tiles[o3[1].key] && this._tiles[o3[2].key] && this._tiles[o3[3].key] && (t3[o3[0].key] = e2[o3[0].key] = o3[0], t3[o3[1].key] = e2[o3[1].key] = o3[1], t3[o3[2].key] = e2[o3[2].key] = o3[2], t3[o3[3].key] = e2[o3[3].key] = o3[3], delete i3[r3]);
            }
            for (const r3 in i3) {
              const o3 = i3[r3], a3 = this.findLoadedParent(o3, this._source.minzoom), s2 = this.findLoadedSibling(o3), n3 = a3 || s2 || null;
              if (n3) {
                t3[n3.tileID.key] = e2[n3.tileID.key] = n3.tileID;
                for (const e3 in t3)
                  t3[e3].isChildOf(n3.tileID) && delete t3[e3];
              }
            }
            for (const e3 in this._tiles)
              t3[e3] || (this._coveredTiles[e3] = true);
          }
        }
        update(e2, i2) {
          if (!this._sourceLoaded || this._paused)
            return;
          let r2;
          this.transform = e2, this.terrain = i2, this.updateCacheSize(e2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? r2 = e2.getVisibleUnwrappedCoordinates(this._source.tileID).map((e3) => new t.Y(e3.canonical.z, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y)) : (r2 = xe2(e2, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i2, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (r2 = r2.filter((e3) => this._source.hasTile(e3)))) : r2 = [];
          const o2 = ve2(e2, this._source), a2 = Math.max(o2 - be2.maxOverzooming, this._source.minzoom), s2 = Math.max(o2 + be2.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const e3 = {};
            for (const t2 of r2)
              if (t2.canonical.z > this._source.minzoom) {
                const i3 = t2.scaledTo(t2.canonical.z - 1);
                e3[i3.key] = i3;
                const r3 = t2.scaledTo(Math.max(this._source.minzoom, Math.min(t2.canonical.z, 5)));
                e3[r3.key] = r3;
              }
            r2 = r2.concat(Object.values(e3));
          }
          const n2 = r2.length === 0 && !this._updated && this._didEmitContent;
          this._updated = true, n2 && this.fire(new t.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const l3 = this._updateRetainedTiles(r2, o2);
          we(this._source.type) && this._updateCoveredAndRetainedTiles(l3, a2, s2, o2, r2, i2);
          for (const e3 in l3)
            this._tiles[e3].clearFadeHold();
          const c2 = t.aj(this._tiles, l3);
          for (const e3 of c2) {
            const t2 = this._tiles[e3];
            t2.hasSymbolBuckets && !t2.holdingForFade() ? t2.setHoldDuration(this.map._fadeDuration) : t2.hasSymbolBuckets && !t2.symbolFadeFinished() || this._removeTile(e3);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const e2 in this._tiles)
            this._tiles[e2].holdingForFade() && this._removeTile(e2);
        }
        _updateRetainedTiles(e2, t2) {
          var i2;
          const r2 = {}, o2 = {}, a2 = Math.max(t2 - be2.maxOverzooming, this._source.minzoom), s2 = Math.max(t2 + be2.maxUnderzooming, this._source.minzoom), n2 = {};
          for (const i3 of e2) {
            const e3 = this._addTile(i3);
            r2[i3.key] = i3, e3.hasData() || t2 < this._source.maxzoom && (n2[i3.key] = i3);
          }
          this._retainLoadedChildren(n2, t2, s2, r2);
          for (const s3 of e2) {
            let e3 = this._tiles[s3.key];
            if (e3.hasData())
              continue;
            if (t2 + 1 > this._source.maxzoom) {
              const e4 = s3.children(this._source.maxzoom)[0], t3 = this.getTile(e4);
              if (t3 && t3.hasData()) {
                r2[e4.key] = e4;
                continue;
              }
            } else {
              const e4 = s3.children(this._source.maxzoom);
              if (r2[e4[0].key] && r2[e4[1].key] && r2[e4[2].key] && r2[e4[3].key])
                continue;
            }
            let n3 = e3.wasRequested();
            for (let t3 = s3.overscaledZ - 1;t3 >= a2; --t3) {
              const a3 = s3.scaledTo(t3);
              if (o2[a3.key])
                break;
              if (o2[a3.key] = true, e3 = this.getTile(a3), !e3 && n3 && (e3 = this._addTile(a3)), e3) {
                const t4 = e3.hasData();
                if ((t4 || !((i2 = this.map) === null || i2 === undefined ? undefined : i2.cancelPendingTileRequestsWhileZooming) || n3) && (r2[a3.key] = a3), n3 = e3.wasRequested(), t4)
                  break;
              }
            }
          }
          return r2;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const e2 in this._tiles) {
            const t2 = [];
            let i2, r2 = this._tiles[e2].tileID;
            for (;r2.overscaledZ > 0; ) {
              if (r2.key in this._loadedParentTiles) {
                i2 = this._loadedParentTiles[r2.key];
                break;
              }
              t2.push(r2.key);
              const e3 = r2.scaledTo(r2.overscaledZ - 1);
              if (i2 = this._getLoadedTile(e3), i2)
                break;
              r2 = e3;
            }
            for (const e3 of t2)
              this._loadedParentTiles[e3] = i2;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const e2 in this._tiles) {
            const t2 = this._tiles[e2].tileID, i2 = this._getLoadedTile(t2);
            this._loadedSiblingTiles[t2.key] = i2;
          }
        }
        _addTile(e2) {
          let i2 = this._tiles[e2.key];
          if (i2)
            return i2;
          i2 = this._cache.getAndRemove(e2), i2 && (this._setTileReloadTimer(e2.key, i2), i2.tileID = e2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[e2.key] && (clearTimeout(this._cacheTimers[e2.key]), delete this._cacheTimers[e2.key], this._setTileReloadTimer(e2.key, i2)));
          const r2 = i2;
          return i2 || (i2 = new ae(e2, this._source.tileSize * e2.overscaleFactor()), this._loadTile(i2, e2.key, i2.state)), i2.uses++, this._tiles[e2.key] = i2, r2 || this._source.fire(new t.l("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
        }
        _setTileReloadTimer(e2, t2) {
          e2 in this._timers && (clearTimeout(this._timers[e2]), delete this._timers[e2]);
          const i2 = t2.getExpiryTimeout();
          i2 && (this._timers[e2] = setTimeout(() => {
            this._reloadTile(e2, "expired"), delete this._timers[e2];
          }, i2));
        }
        refreshTiles(e2) {
          for (const t2 in this._tiles)
            this._isIdRenderable(t2) && e2.some((e3) => e3.equals(this._tiles[t2].tileID.canonical)) && this._reloadTile(t2, "expired");
        }
        _removeTile(e2) {
          const t2 = this._tiles[e2];
          t2 && (t2.uses--, delete this._tiles[e2], this._timers[e2] && (clearTimeout(this._timers[e2]), delete this._timers[e2]), t2.uses > 0 || (t2.hasData() && t2.state !== "reloading" ? this._cache.add(t2.tileID, t2, t2.getExpiryTimeout()) : (t2.aborted = true, this._abortTile(t2), this._unloadTile(t2))));
        }
        _dataHandler(e2) {
          const t2 = e2.sourceDataType;
          e2.dataType === "source" && t2 === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && e2.dataType === "source" && t2 === "content" && (this.reload(e2.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const e2 in this._tiles)
            this._removeTile(e2);
          this._cache.reset();
        }
        tilesIn(e2, i2, r2) {
          const o2 = [], a2 = this.transform;
          if (!a2)
            return o2;
          const s2 = r2 ? a2.getCameraQueryGeometry(e2) : e2, n2 = e2.map((e3) => a2.screenPointToMercatorCoordinate(e3, this.terrain)), l3 = s2.map((e3) => a2.screenPointToMercatorCoordinate(e3, this.terrain)), c2 = this.getIds();
          let h2 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0;
          for (const e3 of l3)
            h2 = Math.min(h2, e3.x), u2 = Math.min(u2, e3.y), d2 = Math.max(d2, e3.x), _2 = Math.max(_2, e3.y);
          for (let e3 = 0;e3 < c2.length; e3++) {
            const r3 = this._tiles[c2[e3]];
            if (r3.holdingForFade())
              continue;
            const s3 = a2.getCoveringTilesDetailsProvider().allowWorldCopies() ? r3.tileID : r3.tileID.unwrapTo(0), p2 = Math.pow(2, a2.zoom - r3.tileID.overscaledZ), m2 = i2 * r3.queryPadding * t.Z / r3.tileSize / p2, f2 = [s3.getTilePoint(new t.$(h2, u2)), s3.getTilePoint(new t.$(d2, _2))];
            if (f2[0].x - m2 < t.Z && f2[0].y - m2 < t.Z && f2[1].x + m2 >= 0 && f2[1].y + m2 >= 0) {
              const e4 = n2.map((e5) => s3.getTilePoint(e5)), t2 = l3.map((e5) => s3.getTilePoint(e5));
              o2.push({ tile: r3, tileID: s3, queryGeometry: e4, cameraQueryGeometry: t2, scale: p2 });
            }
          }
          return o2;
        }
        getVisibleCoordinates(e2) {
          const t2 = this.getRenderableIds(e2).map((e3) => this._tiles[e3].tileID);
          return this.transform && this.transform.populateCache(t2), t2;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return true;
          if (we(this._source.type)) {
            const e2 = s.now();
            for (const t2 in this._tiles)
              if (this._tiles[t2].fadeEndTime >= e2)
                return true;
          }
          return false;
        }
        setFeatureState(e2, t2, i2) {
          this._state.updateState(e2 = e2 || "_geojsonTileLayer", t2, i2);
        }
        removeFeatureState(e2, t2, i2) {
          this._state.removeFeatureState(e2 = e2 || "_geojsonTileLayer", t2, i2);
        }
        getFeatureState(e2, t2) {
          return this._state.getState(e2 = e2 || "_geojsonTileLayer", t2);
        }
        setDependencies(e2, t2, i2) {
          const r2 = this._tiles[e2];
          r2 && r2.setDependencies(t2, i2);
        }
        reloadTilesForDependencies(e2, t2) {
          for (const i2 in this._tiles)
            this._tiles[i2].hasDependency(e2, t2) && this._reloadTile(i2, "reloading");
          this._cache.filter((i2) => !i2.hasDependency(e2, t2));
        }
      }
      function ye2(e2, t2) {
        const i2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0), r2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0);
        return e2.overscaledZ - t2.overscaledZ || r2 - i2 || t2.canonical.y - e2.canonical.y || t2.canonical.x - e2.canonical.x;
      }
      function we(e2) {
        return e2 === "raster" || e2 === "image" || e2 === "video";
      }
      be2.maxOverzooming = 10, be2.maxUnderzooming = 3;

      class Te2 {
        constructor(e2, t2) {
          this.reset(e2, t2);
        }
        reset(e2, t2) {
          this.points = e2 || [], this._distances = [0];
          for (let e3 = 1;e3 < this.points.length; e3++)
            this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(e2) {
          if (this.points.length === 1)
            return this.points[0];
          e2 = t.ae(e2, 0, 1);
          let i2 = 1, r2 = this._distances[i2];
          const o2 = e2 * this.paddedLength + this.padding;
          for (;r2 < o2 && i2 < this._distances.length; )
            r2 = this._distances[++i2];
          const a2 = i2 - 1, s2 = this._distances[a2], n2 = r2 - s2, l3 = n2 > 0 ? (o2 - s2) / n2 : 0;
          return this.points[a2].mult(1 - l3).add(this.points[i2].mult(l3));
        }
      }
      function Pe2(e2, t2) {
        let i2 = true;
        return e2 === "always" || e2 !== "never" && t2 !== "never" || (i2 = false), i2;
      }

      class Ce2 {
        constructor(e2, t2, i2) {
          const r2 = this.boxCells = [], o2 = this.circleCells = [];
          this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
          for (let e3 = 0;e3 < this.xCellCount * this.yCellCount; e3++)
            r2.push([]), o2.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e2, t2, i2, r2, o2) {
          this._forEachCell(t2, i2, r2, o2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(r2), this.bboxes.push(o2);
        }
        insertCircle(e2, t2, i2, r2) {
          this._forEachCell(t2 - r2, i2 - r2, t2 + r2, i2 + r2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(r2);
        }
        _insertBoxCell(e2, t2, i2, r2, o2, a2) {
          this.boxCells[o2].push(a2);
        }
        _insertCircleCell(e2, t2, i2, r2, o2, a2) {
          this.circleCells[o2].push(a2);
        }
        _query(e2, t2, i2, r2, o2, a2, s2) {
          if (i2 < 0 || e2 > this.width || r2 < 0 || t2 > this.height)
            return [];
          const n2 = [];
          if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= r2) {
            if (o2)
              return [{ key: null, x1: e2, y1: t2, x2: i2, y2: r2 }];
            for (let e3 = 0;e3 < this.boxKeys.length; e3++)
              n2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
            for (let e3 = 0;e3 < this.circleKeys.length; e3++) {
              const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], r3 = this.circles[3 * e3 + 2];
              n2.push({ key: this.circleKeys[e3], x1: t3 - r3, y1: i3 - r3, x2: t3 + r3, y2: i3 + r3 });
            }
          } else
            this._forEachCell(e2, t2, i2, r2, this._queryCell, n2, { hitTest: o2, overlapMode: a2, seenUids: { box: {}, circle: {} } }, s2);
          return n2;
        }
        query(e2, t2, i2, r2) {
          return this._query(e2, t2, i2, r2, false, null);
        }
        hitTest(e2, t2, i2, r2, o2, a2) {
          return this._query(e2, t2, i2, r2, true, o2, a2).length > 0;
        }
        hitTestCircle(e2, t2, i2, r2, o2) {
          const a2 = e2 - i2, s2 = e2 + i2, n2 = t2 - i2, l3 = t2 + i2;
          if (s2 < 0 || a2 > this.width || l3 < 0 || n2 > this.height)
            return false;
          const c2 = [];
          return this._forEachCell(a2, n2, s2, l3, this._queryCellCircle, c2, { hitTest: true, overlapMode: r2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, o2), c2.length > 0;
        }
        _queryCell(e2, t2, i2, r2, o2, a2, s2, n2) {
          const { seenUids: l3, hitTest: c2, overlapMode: h2 } = s2, u2 = this.boxCells[o2];
          if (u2 !== null) {
            const o3 = this.bboxes;
            for (const s3 of u2)
              if (!l3.box[s3]) {
                l3.box[s3] = true;
                const u3 = 4 * s3, d3 = this.boxKeys[s3];
                if (e2 <= o3[u3 + 2] && t2 <= o3[u3 + 3] && i2 >= o3[u3 + 0] && r2 >= o3[u3 + 1] && (!n2 || n2(d3)) && (!c2 || !Pe2(h2, d3.overlapMode)) && (a2.push({ key: d3, x1: o3[u3], y1: o3[u3 + 1], x2: o3[u3 + 2], y2: o3[u3 + 3] }), c2))
                  return true;
              }
          }
          const d2 = this.circleCells[o2];
          if (d2 !== null) {
            const o3 = this.circles;
            for (const s3 of d2)
              if (!l3.circle[s3]) {
                l3.circle[s3] = true;
                const u3 = 3 * s3, d3 = this.circleKeys[s3];
                if (this._circleAndRectCollide(o3[u3], o3[u3 + 1], o3[u3 + 2], e2, t2, i2, r2) && (!n2 || n2(d3)) && (!c2 || !Pe2(h2, d3.overlapMode))) {
                  const e3 = o3[u3], t3 = o3[u3 + 1], i3 = o3[u3 + 2];
                  if (a2.push({ key: d3, x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 }), c2)
                    return true;
                }
              }
          }
          return false;
        }
        _queryCellCircle(e2, t2, i2, r2, o2, a2, s2, n2) {
          const { circle: l3, seenUids: c2, overlapMode: h2 } = s2, u2 = this.boxCells[o2];
          if (u2 !== null) {
            const e3 = this.bboxes;
            for (const t3 of u2)
              if (!c2.box[t3]) {
                c2.box[t3] = true;
                const i3 = 4 * t3, r3 = this.boxKeys[t3];
                if (this._circleAndRectCollide(l3.x, l3.y, l3.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!n2 || n2(r3)) && !Pe2(h2, r3.overlapMode))
                  return a2.push(true), true;
              }
          }
          const d2 = this.circleCells[o2];
          if (d2 !== null) {
            const e3 = this.circles;
            for (const t3 of d2)
              if (!c2.circle[t3]) {
                c2.circle[t3] = true;
                const i3 = 3 * t3, r3 = this.circleKeys[t3];
                if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l3.x, l3.y, l3.radius) && (!n2 || n2(r3)) && !Pe2(h2, r3.overlapMode))
                  return a2.push(true), true;
              }
          }
        }
        _forEachCell(e2, t2, i2, r2, o2, a2, s2, n2) {
          const l3 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(r2);
          for (let d2 = l3;d2 <= h2; d2++)
            for (let l4 = c2;l4 <= u2; l4++)
              if (o2.call(this, e2, t2, i2, r2, this.xCellCount * l4 + d2, a2, s2, n2))
                return;
        }
        _convertToXCellCoord(e2) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
        }
        _convertToYCellCoord(e2) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
        }
        _circlesCollide(e2, t2, i2, r2, o2, a2) {
          const s2 = r2 - e2, n2 = o2 - t2, l3 = i2 + a2;
          return l3 * l3 > s2 * s2 + n2 * n2;
        }
        _circleAndRectCollide(e2, t2, i2, r2, o2, a2, s2) {
          const n2 = (a2 - r2) / 2, l3 = Math.abs(e2 - (r2 + n2));
          if (l3 > n2 + i2)
            return false;
          const c2 = (s2 - o2) / 2, h2 = Math.abs(t2 - (o2 + c2));
          if (h2 > c2 + i2)
            return false;
          if (l3 <= n2 || h2 <= c2)
            return true;
          const u2 = l3 - n2, d2 = h2 - c2;
          return u2 * u2 + d2 * d2 <= i2 * i2;
        }
      }
      function Me2(e2, i2, o2) {
        const a2 = t.K();
        if (!e2) {
          const { vecSouth: e3, vecEast: t2 } = Ee2(i2), o3 = r();
          o3[0] = t2[0], o3[1] = t2[1], o3[2] = e3[0], o3[3] = e3[1], s2 = o3, (d2 = (l3 = (n2 = o3)[0]) * (u2 = n2[3]) - (h2 = n2[2]) * (c2 = n2[1])) && (s2[0] = u2 * (d2 = 1 / d2), s2[1] = -c2 * d2, s2[2] = -h2 * d2, s2[3] = l3 * d2), a2[0] = o3[0], a2[1] = o3[1], a2[4] = o3[2], a2[5] = o3[3];
        }
        var s2, n2, l3, c2, h2, u2, d2;
        return t.M(a2, a2, [1 / o2, 1 / o2, 1]), a2;
      }
      function Ie2(e2, i2, r2, o2) {
        if (e2) {
          const e3 = t.K();
          if (!i2) {
            const { vecSouth: t2, vecEast: i3 } = Ee2(r2);
            e3[0] = i3[0], e3[1] = i3[1], e3[4] = t2[0], e3[5] = t2[1];
          }
          return t.M(e3, e3, [o2, o2, 1]), e3;
        }
        return r2.pixelsToClipSpaceMatrix;
      }
      function Ee2(e2) {
        const i2 = Math.cos(e2.rollInRadians), r2 = Math.sin(e2.rollInRadians), o2 = Math.cos(e2.pitchInRadians), a2 = Math.cos(e2.bearingInRadians), s2 = Math.sin(e2.bearingInRadians), n2 = t.ao();
        n2[0] = -a2 * o2 * r2 - s2 * i2, n2[1] = -s2 * o2 * r2 + a2 * i2;
        const l3 = t.ap(n2);
        l3 < 0.000000001 ? t.aq(n2) : t.ar(n2, n2, 1 / l3);
        const c2 = t.ao();
        c2[0] = a2 * o2 * i2 - s2 * r2, c2[1] = s2 * o2 * i2 + a2 * r2;
        const h2 = t.ap(c2);
        return h2 < 0.000000001 ? t.aq(c2) : t.ar(c2, c2, 1 / h2), { vecEast: c2, vecSouth: n2 };
      }
      function Se2(e2, i2, r2, o2) {
        let a2;
        o2 ? (a2 = [e2, i2, o2(e2, i2), 1], t.at(a2, a2, r2)) : (a2 = [e2, i2, 0, 1], We2(a2, a2, r2));
        const s2 = a2[3];
        return { point: new t.P(a2[0] / s2, a2[1] / s2), signedDistanceFromCamera: s2, isOccluded: false };
      }
      function Re2(e2, t2) {
        return 0.5 + e2 / t2 * 0.5;
      }
      function ze2(e2, t2) {
        return e2.x >= -t2[0] && e2.x <= t2[0] && e2.y >= -t2[1] && e2.y <= t2[1];
      }
      function De(e2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2, d2, _2) {
        const p2 = r2 ? e2.textSizeData : e2.iconSizeData, m2 = t.ak(p2, i2.transform.zoom), f2 = [256 / i2.width * 2 + 1, 256 / i2.height * 2 + 1], g2 = r2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
        g2.clear();
        const v2 = e2.lineVertexArray, x2 = r2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, b2 = i2.transform.width / i2.transform.height;
        let y2 = false;
        for (let r3 = 0;r3 < x2.length; r3++) {
          const w2 = x2.get(r3);
          if (w2.hidden || w2.writingMode === t.al.vertical && !y2) {
            qe2(w2.numGlyphs, g2);
            continue;
          }
          y2 = false;
          const T2 = new t.P(w2.anchorX, w2.anchorY), P2 = { getElevation: _2, pitchedLabelPlaneMatrix: o2, lineVertexArray: v2, pitchWithMap: s2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: undefined, anyProjectionOccluded: false }, transform: i2.transform, tileAnchorPoint: T2, unwrappedTileID: c2, width: h2, height: u2, translation: d2 }, C2 = Ze2(w2.anchorX, w2.anchorY, P2);
          if (!ze2(C2.point, f2)) {
            qe2(w2.numGlyphs, g2);
            continue;
          }
          const M3 = Re2(i2.transform.cameraToCenterDistance, C2.signedDistanceFromCamera), I2 = t.am(p2, m2, w2), E3 = s2 ? I2 * i2.transform.getPitchedTextCorrection(w2.anchorX, w2.anchorY, c2) / M3 : I2 * M3, S2 = ke2({ projectionContext: P2, pitchedLabelPlaneMatrixInverse: a2, symbol: w2, fontSize: E3, flip: false, keepUpright: n2, glyphOffsetArray: e2.glyphOffsetArray, dynamicLayoutVertexArray: g2, aspectRatio: b2, rotateToLine: l3 });
          y2 = S2.useVertical, (S2.notEnoughRoom || y2 || S2.needsFlipping && ke2({ projectionContext: P2, pitchedLabelPlaneMatrixInverse: a2, symbol: w2, fontSize: E3, flip: true, keepUpright: n2, glyphOffsetArray: e2.glyphOffsetArray, dynamicLayoutVertexArray: g2, aspectRatio: b2, rotateToLine: l3 }).notEnoughRoom) && qe2(w2.numGlyphs, g2);
        }
        r2 ? e2.text.dynamicLayoutVertexBuffer.updateData(g2) : e2.icon.dynamicLayoutVertexBuffer.updateData(g2);
      }
      function Ae2(e2, t2, i2, r2, o2, a2, s2, n2) {
        const l3 = a2.glyphStartIndex + a2.numGlyphs, c2 = a2.lineStartIndex, h2 = a2.lineStartIndex + a2.lineLength, u2 = t2.getoffsetX(a2.glyphStartIndex), d2 = t2.getoffsetX(l3 - 1), _2 = Ge2(e2 * u2, i2, r2, o2, a2.segment, c2, h2, n2, s2);
        if (!_2)
          return null;
        const p2 = Ge2(e2 * d2, i2, r2, o2, a2.segment, c2, h2, n2, s2);
        return p2 ? n2.projectionCache.anyProjectionOccluded ? null : { first: _2, last: p2 } : null;
      }
      function Le2(e2, i2, r2, o2) {
        return e2 === t.al.horizontal && Math.abs(r2.y - i2.y) > Math.abs(r2.x - i2.x) * o2 ? { useVertical: true } : (e2 === t.al.vertical ? i2.y < r2.y : i2.x > r2.x) ? { needsFlipping: true } : null;
      }
      function ke2(e2) {
        const { projectionContext: i2, pitchedLabelPlaneMatrixInverse: r2, symbol: o2, fontSize: a2, flip: s2, keepUpright: n2, glyphOffsetArray: l3, dynamicLayoutVertexArray: c2, aspectRatio: h2, rotateToLine: u2 } = e2, d2 = a2 / 24, _2 = o2.lineOffsetX * d2, p2 = o2.lineOffsetY * d2;
        let m2;
        if (o2.numGlyphs > 1) {
          const e3 = o2.glyphStartIndex + o2.numGlyphs, t2 = o2.lineStartIndex, a3 = o2.lineStartIndex + o2.lineLength, c3 = Ae2(d2, l3, _2, p2, s2, o2, u2, i2);
          if (!c3)
            return { notEnoughRoom: true };
          const f2 = je2(c3.first.point.x, c3.first.point.y, i2, r2), g2 = je2(c3.last.point.x, c3.last.point.y, i2, r2);
          if (n2 && !s2) {
            const e4 = Le2(o2.writingMode, f2, g2, h2);
            if (e4)
              return e4;
          }
          m2 = [c3.first];
          for (let r3 = o2.glyphStartIndex + 1;r3 < e3 - 1; r3++)
            m2.push(Ge2(d2 * l3.getoffsetX(r3), _2, p2, s2, o2.segment, t2, a3, i2, u2));
          m2.push(c3.last);
        } else {
          if (n2 && !s2) {
            const e4 = Oe2(i2.tileAnchorPoint.x, i2.tileAnchorPoint.y, i2).point, a3 = o2.lineStartIndex + o2.segment + 1, s3 = new t.P(i2.lineVertexArray.getx(a3), i2.lineVertexArray.gety(a3)), n3 = Oe2(s3.x, s3.y, i2), l4 = n3.signedDistanceFromCamera > 0 ? n3.point : Fe2(i2.tileAnchorPoint, s3, e4, 1, i2), c3 = je2(e4.x, e4.y, i2, r2), u3 = je2(l4.x, l4.y, i2, r2), d3 = Le2(o2.writingMode, c3, u3, h2);
            if (d3)
              return d3;
          }
          const e3 = Ge2(d2 * l3.getoffsetX(o2.glyphStartIndex), _2, p2, s2, o2.segment, o2.lineStartIndex, o2.lineStartIndex + o2.lineLength, i2, u2);
          if (!e3 || i2.projectionCache.anyProjectionOccluded)
            return { notEnoughRoom: true };
          m2 = [e3];
        }
        for (const e3 of m2)
          t.as(c2, e3.point, e3.angle);
        return {};
      }
      function Fe2(e2, t2, i2, r2, o2) {
        const a2 = e2.add(e2.sub(t2)._unit()), s2 = Oe2(a2.x, a2.y, o2).point, n2 = i2.sub(s2);
        return i2.add(n2._mult(r2 / n2.mag()));
      }
      function Be2(e2, i2, r2) {
        const o2 = i2.projectionCache;
        if (o2.projections[e2])
          return o2.projections[e2];
        const a2 = new t.P(i2.lineVertexArray.getx(e2), i2.lineVertexArray.gety(e2)), s2 = Oe2(a2.x, a2.y, i2);
        if (s2.signedDistanceFromCamera > 0)
          return o2.projections[e2] = s2.point, o2.anyProjectionOccluded = o2.anyProjectionOccluded || s2.isOccluded, s2.point;
        const n2 = e2 - r2.direction;
        return Fe2(r2.distanceFromAnchor === 0 ? i2.tileAnchorPoint : new t.P(i2.lineVertexArray.getx(n2), i2.lineVertexArray.gety(n2)), a2, r2.previousVertex, r2.absOffsetX - r2.distanceFromAnchor + 1, i2);
      }
      function Oe2(e2, t2, i2) {
        const r2 = e2 + i2.translation[0], o2 = t2 + i2.translation[1];
        let a2;
        return i2.pitchWithMap ? (a2 = Se2(r2, o2, i2.pitchedLabelPlaneMatrix, i2.getElevation), a2.isOccluded = false) : (a2 = i2.transform.projectTileCoordinates(r2, o2, i2.unwrappedTileID, i2.getElevation), a2.point.x = (0.5 * a2.point.x + 0.5) * i2.width, a2.point.y = (0.5 * -a2.point.y + 0.5) * i2.height), a2;
      }
      function je2(e2, i2, r2, o2) {
        if (r2.pitchWithMap) {
          const a2 = [e2, i2, 0, 1];
          return t.at(a2, a2, o2), r2.transform.projectTileCoordinates(a2[0] / a2[3], a2[1] / a2[3], r2.unwrappedTileID, r2.getElevation).point;
        }
        return { x: e2 / r2.width * 2 - 1, y: i2 / r2.height * 2 - 1 };
      }
      function Ze2(e2, t2, i2) {
        return i2.transform.projectTileCoordinates(e2, t2, i2.unwrappedTileID, i2.getElevation);
      }
      function Ne2(e2, t2, i2) {
        return e2._unit()._perp()._mult(t2 * i2);
      }
      function Ue2(e2, i2, r2, o2, a2, s2, n2, l3, c2) {
        if (l3.projectionCache.offsets[e2])
          return l3.projectionCache.offsets[e2];
        const h2 = r2.add(i2);
        if (e2 + c2.direction < o2 || e2 + c2.direction >= a2)
          return l3.projectionCache.offsets[e2] = h2, h2;
        const u2 = Be2(e2 + c2.direction, l3, c2), d2 = Ne2(u2.sub(r2), n2, c2.direction), _2 = r2.add(d2), p2 = u2.add(d2);
        return l3.projectionCache.offsets[e2] = t.au(s2, h2, _2, p2) || h2, l3.projectionCache.offsets[e2];
      }
      function Ge2(e2, t2, i2, r2, o2, a2, s2, n2, l3) {
        const c2 = r2 ? e2 - t2 : e2 + t2;
        let h2 = c2 > 0 ? 1 : -1, u2 = 0;
        r2 && (h2 *= -1, u2 = Math.PI), h2 < 0 && (u2 += Math.PI);
        let d2, _2 = h2 > 0 ? a2 + o2 : a2 + o2 + 1;
        n2.projectionCache.cachedAnchorPoint ? d2 = n2.projectionCache.cachedAnchorPoint : (d2 = Oe2(n2.tileAnchorPoint.x, n2.tileAnchorPoint.y, n2).point, n2.projectionCache.cachedAnchorPoint = d2);
        let p2, m2, f2 = d2, g2 = d2, v2 = 0, x2 = 0;
        const b2 = Math.abs(c2), y2 = [];
        let w2;
        for (;v2 + x2 <= b2; ) {
          if (_2 += h2, _2 < a2 || _2 >= s2)
            return null;
          v2 += x2, g2 = f2, m2 = p2;
          const e3 = { absOffsetX: b2, direction: h2, distanceFromAnchor: v2, previousVertex: g2 };
          if (f2 = Be2(_2, n2, e3), i2 === 0)
            y2.push(g2), w2 = f2.sub(g2);
          else {
            let t3;
            const r3 = f2.sub(g2);
            t3 = r3.mag() === 0 ? Ne2(Be2(_2 + h2, n2, e3).sub(f2), i2, h2) : Ne2(r3, i2, h2), m2 || (m2 = g2.add(t3)), p2 = Ue2(_2, t3, f2, a2, s2, m2, i2, n2, e3), y2.push(m2), w2 = p2.sub(m2);
          }
          x2 = w2.mag();
        }
        const T2 = w2._mult((b2 - v2) / x2)._add(m2 || g2), P2 = u2 + Math.atan2(f2.y - g2.y, f2.x - g2.x);
        return y2.push(T2), { point: T2, angle: l3 ? P2 : 0, path: y2 };
      }
      const Ve2 = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function qe2(e2, t2) {
        for (let i2 = 0;i2 < e2; i2++) {
          const e3 = t2.length;
          t2.resize(e3 + 4), t2.float32.set(Ve2, 3 * e3);
        }
      }
      function We2(e2, t2, i2) {
        const r2 = t2[0], o2 = t2[1];
        return e2[0] = i2[0] * r2 + i2[4] * o2 + i2[12], e2[1] = i2[1] * r2 + i2[5] * o2 + i2[13], e2[3] = i2[3] * r2 + i2[7] * o2 + i2[15], e2;
      }
      const He2 = 100;

      class $e2 {
        constructor(e2, t2 = new Ce2(e2.width + 200, e2.height + 200, 25), i2 = new Ce2(e2.width + 200, e2.height + 200, 25)) {
          this.transform = e2, this.grid = t2, this.ignoredGrid = i2, this.pitchFactor = Math.cos(e2.pitch * Math.PI / 180) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + He2, this.screenBottomBoundary = e2.height + He2, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(e2, t2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2) {
          const d2 = this.projectAndGetPerspectiveRatio(e2.anchorPointX + n2[0], e2.anchorPointY + n2[1], o2, c2, u2), _2 = i2 * d2.perspectiveRatio;
          let p2;
          if (a2 || s2)
            p2 = this._projectCollisionBox(e2, _2, r2, o2, a2, s2, n2, d2, c2, h2, u2);
          else {
            const t3 = d2.x + (h2 ? h2.x * _2 : 0), i3 = d2.y + (h2 ? h2.y * _2 : 0);
            p2 = { allPointsOccluded: false, box: [t3 + e2.x1 * _2, i3 + e2.y1 * _2, t3 + e2.x2 * _2, i3 + e2.y2 * _2] };
          }
          const [m2, f2, g2, v2] = p2.box, x2 = a2 ? p2.allPointsOccluded : d2.isOccluded;
          let b2 = x2;
          return b2 || (b2 = d2.perspectiveRatio < this.perspectiveRatioCutoff), b2 || (b2 = !this.isInsideGrid(m2, f2, g2, v2)), b2 || t2 !== "always" && this.grid.hitTest(m2, f2, g2, v2, t2, l3) ? { box: [m2, f2, g2, v2], placeable: false, offscreen: false, occluded: x2 } : { box: [m2, f2, g2, v2], placeable: true, offscreen: this.isOffscreen(m2, f2, g2, v2), occluded: x2 };
        }
        placeCollisionCircles(e2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2, d2, _2, p2) {
          const m2 = [], f2 = new t.P(i2.anchorX, i2.anchorY), g2 = this.getPerspectiveRatio(f2.x, f2.y, s2, p2), v2 = (c2 ? a2 * this.transform.getPitchedTextCorrection(i2.anchorX, i2.anchorY, s2) / g2 : a2 * g2) / t.ay, x2 = { getElevation: p2, pitchedLabelPlaneMatrix: n2, lineVertexArray: r2, pitchWithMap: c2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: undefined, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: f2, unwrappedTileID: s2, width: this.transform.width, height: this.transform.height, translation: _2 }, b2 = Ae2(v2, o2, i2.lineOffsetX * v2, i2.lineOffsetY * v2, false, i2, false, x2);
          let y2 = false, w2 = false, T2 = true;
          if (b2) {
            const i3 = 0.5 * u2 * g2 + d2, r3 = new t.P(-100, -100), o3 = new t.P(this.screenRightBoundary, this.screenBottomBoundary), a3 = new Te2, s3 = b2.first, n3 = b2.last;
            let _3 = [];
            for (let e3 = s3.path.length - 1;e3 >= 1; e3--)
              _3.push(s3.path[e3]);
            for (let e3 = 1;e3 < n3.path.length; e3++)
              _3.push(n3.path[e3]);
            const p3 = 2.5 * i3;
            if (c2) {
              const e3 = this.projectPathToScreenSpace(_3, x2);
              _3 = e3.some((e4) => e4.signedDistanceFromCamera <= 0) ? [] : e3.map((e4) => e4.point);
            }
            let f3 = [];
            if (_3.length > 0) {
              const e3 = _3[0].clone(), i4 = _3[0].clone();
              for (let t2 = 1;t2 < _3.length; t2++)
                e3.x = Math.min(e3.x, _3[t2].x), e3.y = Math.min(e3.y, _3[t2].y), i4.x = Math.max(i4.x, _3[t2].x), i4.y = Math.max(i4.y, _3[t2].y);
              f3 = e3.x >= r3.x && i4.x <= o3.x && e3.y >= r3.y && i4.y <= o3.y ? [_3] : i4.x < r3.x || e3.x > o3.x || i4.y < r3.y || e3.y > o3.y ? [] : t.av([_3], r3.x, r3.y, o3.x, o3.y);
            }
            for (const t2 of f3) {
              a3.reset(t2, 0.25 * i3);
              let r4 = 0;
              r4 = a3.length <= 0.5 * i3 ? 1 : Math.ceil(a3.paddedLength / p3) + 1;
              for (let t3 = 0;t3 < r4; t3++) {
                const o4 = t3 / Math.max(r4 - 1, 1), s4 = a3.lerp(o4), n4 = s4.x + He2, c3 = s4.y + He2;
                m2.push(n4, c3, i3, 0);
                const u3 = n4 - i3, d3 = c3 - i3, _4 = n4 + i3, p4 = c3 + i3;
                if (T2 = T2 && this.isOffscreen(u3, d3, _4, p4), w2 = w2 || this.isInsideGrid(u3, d3, _4, p4), e2 !== "always" && this.grid.hitTestCircle(n4, c3, i3, e2, h2) && (y2 = true, !l3))
                  return { circles: [], offscreen: false, collisionDetected: y2 };
              }
            }
          }
          return { circles: !l3 && y2 || !w2 || g2 < this.perspectiveRatioCutoff ? [] : m2, offscreen: T2, collisionDetected: y2 };
        }
        projectPathToScreenSpace(e2, i2) {
          const r2 = function(e3, i3) {
            const r3 = t.K();
            return t.an(r3, i3.pitchedLabelPlaneMatrix), e3.map((e4) => {
              const t2 = Se2(e4.x, e4.y, r3, i3.getElevation), o2 = i3.transform.projectTileCoordinates(t2.point.x, t2.point.y, i3.unwrappedTileID, i3.getElevation);
              return o2.point.x = (0.5 * o2.point.x + 0.5) * i3.width, o2.point.y = (0.5 * -o2.point.y + 0.5) * i3.height, o2;
            });
          }(e2, i2);
          return function(e3) {
            let t2 = 0, i3 = 0, r3 = 0, o2 = 0;
            for (let a2 = 0;a2 < e3.length; a2++)
              e3[a2].isOccluded ? (r3 = a2 + 1, o2 = 0) : (o2++, o2 > i3 && (i3 = o2, t2 = r3));
            return e3.slice(t2, t2 + i3);
          }(r2);
        }
        queryRenderedSymbols(e2) {
          if (e2.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
            return {};
          const i2 = [];
          let r2 = 1 / 0, o2 = 1 / 0, a2 = -1 / 0, s2 = -1 / 0;
          for (const n3 of e2) {
            const e3 = new t.P(n3.x + He2, n3.y + He2);
            r2 = Math.min(r2, e3.x), o2 = Math.min(o2, e3.y), a2 = Math.max(a2, e3.x), s2 = Math.max(s2, e3.y), i2.push(e3);
          }
          const n2 = this.grid.query(r2, o2, a2, s2).concat(this.ignoredGrid.query(r2, o2, a2, s2)), l3 = {}, c2 = {};
          for (const e3 of n2) {
            const r3 = e3.key;
            if (l3[r3.bucketInstanceId] === undefined && (l3[r3.bucketInstanceId] = {}), l3[r3.bucketInstanceId][r3.featureIndex])
              continue;
            const o3 = [new t.P(e3.x1, e3.y1), new t.P(e3.x2, e3.y1), new t.P(e3.x2, e3.y2), new t.P(e3.x1, e3.y2)];
            t.aw(i2, o3) && (l3[r3.bucketInstanceId][r3.featureIndex] = true, c2[r3.bucketInstanceId] === undefined && (c2[r3.bucketInstanceId] = []), c2[r3.bucketInstanceId].push(r3.featureIndex));
          }
          return c2;
        }
        insertCollisionBox(e2, t2, i2, r2, o2, a2) {
          (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: r2, featureIndex: o2, collisionGroupID: a2, overlapMode: t2 }, e2[0], e2[1], e2[2], e2[3]);
        }
        insertCollisionCircles(e2, t2, i2, r2, o2, a2) {
          const s2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: r2, featureIndex: o2, collisionGroupID: a2, overlapMode: t2 };
          for (let t3 = 0;t3 < e2.length; t3 += 4)
            s2.insertCircle(n2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
        }
        projectAndGetPerspectiveRatio(e2, i2, r2, o2, a2) {
          if (a2) {
            let r3;
            o2 ? (r3 = [e2, i2, o2(e2, i2), 1], t.at(r3, r3, a2)) : (r3 = [e2, i2, 0, 1], We2(r3, r3, a2));
            const s2 = r3[3];
            return { x: (r3[0] / s2 + 1) / 2 * this.transform.width + He2, y: (-r3[1] / s2 + 1) / 2 * this.transform.height + He2, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / s2 * 0.5, isOccluded: false, signedDistanceFromCamera: s2 };
          }
          {
            const t2 = this.transform.projectTileCoordinates(e2, i2, r2, o2);
            return { x: (t2.point.x + 1) / 2 * this.transform.width + He2, y: (1 - t2.point.y) / 2 * this.transform.height + He2, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / t2.signedDistanceFromCamera * 0.5, isOccluded: t2.isOccluded, signedDistanceFromCamera: t2.signedDistanceFromCamera };
          }
        }
        getPerspectiveRatio(e2, t2, i2, r2) {
          const o2 = this.transform.projectTileCoordinates(e2, t2, i2, r2);
          return 0.5 + this.transform.cameraToCenterDistance / o2.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(e2, t2, i2, r2) {
          return i2 < He2 || e2 >= this.screenRightBoundary || r2 < He2 || t2 > this.screenBottomBoundary;
        }
        isInsideGrid(e2, t2, i2, r2) {
          return i2 >= 0 && e2 < this.gridRightBoundary && r2 >= 0 && t2 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const e2 = t.ad([]);
          return t.L(e2, e2, [-100, -100, 0]), e2;
        }
        _projectCollisionBox(e2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2) {
          let d2 = 1, _2 = 0, p2 = 0, m2 = 1;
          const f2 = e2.anchorPointX + n2[0], g2 = e2.anchorPointY + n2[1];
          if (s2 && !a2) {
            const e3 = this.projectAndGetPerspectiveRatio(f2 + 1, g2, o2, c2, u2), t2 = e3.x - l3.x, i3 = Math.atan((e3.y - l3.y) / t2) + (t2 < 0 ? Math.PI : 0), r3 = Math.sin(i3), a3 = Math.cos(i3);
            d2 = a3, _2 = r3, p2 = -r3, m2 = a3;
          } else if (!s2 && a2) {
            const e3 = Ee2(this.transform);
            d2 = e3.vecEast[0], _2 = e3.vecEast[1], p2 = e3.vecSouth[0], m2 = e3.vecSouth[1];
          }
          let { x: v2, y: x2 } = l3, b2 = i2;
          a2 && (v2 = f2, x2 = g2, b2 = Math.pow(2, -(this.transform.zoom - r2.overscaledZ)), b2 *= this.transform.getPitchedTextCorrection(f2, g2, o2), h2 || (b2 *= t.ae(0.5 + l3.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), h2 && (v2 += d2 * h2.x * b2 + p2 * h2.y * b2, x2 += _2 * h2.x * b2 + m2 * h2.y * b2);
          const y2 = e2.x1 * b2, w2 = e2.x2 * b2, T2 = (y2 + w2) / 2, P2 = e2.y1 * b2, C2 = e2.y2 * b2, M3 = (P2 + C2) / 2, I2 = [{ offsetX: y2, offsetY: P2 }, { offsetX: T2, offsetY: P2 }, { offsetX: w2, offsetY: P2 }, { offsetX: w2, offsetY: M3 }, { offsetX: w2, offsetY: C2 }, { offsetX: T2, offsetY: C2 }, { offsetX: y2, offsetY: C2 }, { offsetX: y2, offsetY: M3 }];
          let E3 = [];
          for (const { offsetX: e3, offsetY: i3 } of I2)
            E3.push(new t.P(v2 + d2 * e3 + p2 * i3, x2 + _2 * e3 + m2 * i3));
          let S2 = false;
          if (a2) {
            const e3 = E3.map((e4) => this.projectAndGetPerspectiveRatio(e4.x, e4.y, o2, c2, u2));
            S2 = e3.some((e4) => !e4.isOccluded), E3 = e3.map((e4) => new t.P(e4.x, e4.y));
          } else
            S2 = true;
          return { box: t.ax(E3), allPointsOccluded: !S2 };
        }
      }

      class Xe2 {
        constructor(e2, t2, i2, r2) {
          this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : r2 && i2 ? 1 : 0, this.placed = i2;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }

      class Ke2 {
        constructor(e2, t2, i2, r2, o2) {
          this.text = new Xe2(e2 ? e2.text : null, t2, i2, o2), this.icon = new Xe2(e2 ? e2.icon : null, t2, r2, o2);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }

      class Qe2 {
        constructor(e2, t2, i2) {
          this.text = e2, this.icon = t2, this.skipFade = i2;
        }
      }

      class Ye2 {
        constructor(e2, t2, i2, r2, o2) {
          this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = r2, this.tileID = o2;
        }
      }

      class Je2 {
        constructor(e2) {
          this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e2) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[e2]) {
            const t2 = ++this.maxGroupID;
            this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
          }
          return this.collisionGroups[e2];
        }
      }
      function et(e2, i2, r2, o2, a2) {
        const { horizontalAlign: s2, verticalAlign: n2 } = t.aE(e2);
        return new t.P(-(s2 - 0.5) * i2 + o2[0] * a2, -(n2 - 0.5) * r2 + o2[1] * a2);
      }

      class tt2 {
        constructor(e2, t2, i2, r2, o2) {
          this.transform = e2.clone(), this.terrain = t2, this.collisionIndex = new $e2(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i2, this.retainedQueryData = {}, this.collisionGroups = new Je2(r2), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = o2, o2 && (o2.prevPlacement = undefined), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(e2) {
          const t2 = this.terrain;
          return t2 ? (i2, r2) => t2.getElevation(e2, i2, r2) : null;
        }
        getBucketParts(e2, i2, r2, o2) {
          const a2 = r2.getBucket(i2), s2 = r2.latestFeatureIndex;
          if (!a2 || !s2 || i2.id !== a2.layerIds[0])
            return;
          const n2 = r2.collisionBoxArray, l3 = a2.layers[0].layout, c2 = a2.layers[0].paint, h2 = Math.pow(2, this.transform.zoom - r2.tileID.overscaledZ), u2 = r2.tileSize / t.Z, d2 = r2.tileID.toUnwrapped(), _2 = l3.get("text-rotation-alignment") === "map", p2 = t.az(r2, 1, this.transform.zoom), m2 = t.aA(this.collisionIndex.transform, r2, c2.get("text-translate"), c2.get("text-translate-anchor")), f2 = t.aA(this.collisionIndex.transform, r2, c2.get("icon-translate"), c2.get("icon-translate-anchor")), g2 = Me2(_2, this.transform, p2);
          this.retainedQueryData[a2.bucketInstanceId] = new Ye2(a2.bucketInstanceId, s2, a2.sourceLayerIndex, a2.index, r2.tileID);
          const v2 = { bucket: a2, layout: l3, translationText: m2, translationIcon: f2, unwrappedTileID: d2, pitchedLabelPlaneMatrix: g2, scale: h2, textPixelRatio: u2, holdingForFade: r2.holdingForFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: t.ak(a2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a2.sourceID) };
          if (o2)
            for (const t2 of a2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: r3, symbolInstanceEnd: o3 } = t2;
              e2.push({ sortKey: i3, symbolInstanceStart: r3, symbolInstanceEnd: o3, parameters: v2 });
            }
          else
            e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: a2.symbolInstances.length, parameters: v2 });
        }
        attemptAnchorPlacement(e2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2, d2, _2, p2, m2, f2, g2, v2, x2, b2) {
          const y2 = t.aB[e2.textAnchor], w2 = [e2.textOffset0, e2.textOffset1], T2 = et(y2, r2, o2, w2, a2), P2 = this.collisionIndex.placeCollisionBox(i2, d2, l3, c2, h2, n2, s2, f2, u2.predicate, x2, T2, b2);
          if ((!v2 || this.collisionIndex.placeCollisionBox(v2, d2, l3, c2, h2, n2, s2, g2, u2.predicate, x2, T2, b2).placeable) && P2.placeable) {
            let e3;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[_2.crossTileID] && this.prevPlacement.placements[_2.crossTileID] && this.prevPlacement.placements[_2.crossTileID].text && (e3 = this.prevPlacement.variableOffsets[_2.crossTileID].anchor), _2.crossTileID === 0)
              throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[_2.crossTileID] = { textOffset: w2, width: r2, height: o2, anchor: y2, textBoxScale: a2, prevAnchor: e3 }, this.markUsedJustification(p2, y2, _2, m2), p2.allowVerticalPlacement && (this.markUsedOrientation(p2, m2, _2), this.placedOrientations[_2.crossTileID] = m2), { shift: T2, placedGlyphBoxes: P2 };
          }
        }
        placeLayerBucketPart(e2, i2, r2) {
          const { bucket: o2, layout: a2, translationText: s2, translationIcon: n2, unwrappedTileID: l3, pitchedLabelPlaneMatrix: c2, textPixelRatio: h2, holdingForFade: u2, collisionBoxArray: d2, partiallyEvaluatedTextSize: _2, collisionGroup: p2 } = e2.parameters, m2 = a2.get("text-optional"), f2 = a2.get("icon-optional"), g2 = t.aC(a2, "text-overlap", "text-allow-overlap"), v2 = g2 === "always", x2 = t.aC(a2, "icon-overlap", "icon-allow-overlap"), b2 = x2 === "always", y2 = a2.get("text-rotation-alignment") === "map", w2 = a2.get("text-pitch-alignment") === "map", T2 = a2.get("icon-text-fit") !== "none", P2 = a2.get("symbol-z-order") === "viewport-y", C2 = v2 && (b2 || !o2.hasIconData() || f2), M3 = b2 && (v2 || !o2.hasTextData() || m2);
          !o2.collisionArrays && d2 && o2.deserializeCollisionBoxes(d2);
          const I2 = this.retainedQueryData[o2.bucketInstanceId].tileID, E3 = this._getTerrainElevationFunc(I2), S2 = this.transform.getFastPathSimpleProjectionMatrix(I2), R2 = (e3, d3, b3) => {
            var P3, R3;
            if (i2[e3.crossTileID])
              return;
            if (u2)
              return void (this.placements[e3.crossTileID] = new Qe2(false, false, false));
            let z3 = false, D3 = false, A2 = true, L2 = null, k2 = { box: null, placeable: false, offscreen: null, occluded: false }, F3 = { placeable: false }, B3 = null, O2 = null, j3 = null, Z3 = 0, N2 = 0, U2 = 0;
            d3.textFeatureIndex ? Z3 = d3.textFeatureIndex : e3.useRuntimeCollisionCircles && (Z3 = e3.featureIndex), d3.verticalTextFeatureIndex && (N2 = d3.verticalTextFeatureIndex);
            const G3 = d3.textBox;
            if (G3) {
              const i3 = (i4) => {
                let r3 = t.al.horizontal;
                if (o2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                  const t2 = this.prevPlacement.placedOrientations[e3.crossTileID];
                  t2 && (this.placedOrientations[e3.crossTileID] = t2, r3 = t2, this.markUsedOrientation(o2, r3, e3));
                }
                return r3;
              }, a3 = (i4, r3) => {
                if (o2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && d3.verticalTextBox) {
                  for (const e4 of o2.writingModes)
                    if (e4 === t.al.vertical ? (k2 = r3(), F3 = k2) : k2 = i4(), k2 && k2.placeable)
                      break;
                } else
                  k2 = i4();
              }, c3 = e3.textAnchorOffsetStartIndex, u3 = e3.textAnchorOffsetEndIndex;
              if (u3 === c3) {
                const r3 = (t2, i4) => {
                  const r4 = this.collisionIndex.placeCollisionBox(t2, g2, h2, I2, l3, w2, y2, s2, p2.predicate, E3, undefined, S2);
                  return r4 && r4.placeable && (this.markUsedOrientation(o2, i4, e3), this.placedOrientations[e3.crossTileID] = i4), r4;
                };
                a3(() => r3(G3, t.al.horizontal), () => {
                  const i4 = d3.verticalTextBox;
                  return o2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i4 ? r3(i4, t.al.vertical) : { box: null, offscreen: null };
                }), i3(k2 && k2.placeable);
              } else {
                let _3 = t.aB[(R3 = (P3 = this.prevPlacement) === null || P3 === undefined ? undefined : P3.variableOffsets[e3.crossTileID]) === null || R3 === undefined ? undefined : R3.anchor];
                const m3 = (t2, i4, a4) => {
                  const d4 = t2.x2 - t2.x1, m4 = t2.y2 - t2.y1, f4 = e3.textBoxScale, v3 = T2 && x2 === "never" ? i4 : null;
                  let b4 = null, P4 = g2 === "never" ? 1 : 2, C3 = "never";
                  _3 && P4++;
                  for (let i5 = 0;i5 < P4; i5++) {
                    for (let i6 = c3;i6 < u3; i6++) {
                      const r3 = o2.textAnchorOffsets.get(i6);
                      if (_3 && r3.textAnchor !== _3)
                        continue;
                      const c4 = this.attemptAnchorPlacement(r3, t2, d4, m4, f4, y2, w2, h2, I2, l3, p2, C3, e3, o2, a4, s2, n2, v3, E3);
                      if (c4 && (b4 = c4.placedGlyphBoxes, b4 && b4.placeable))
                        return z3 = true, L2 = c4.shift, b4;
                    }
                    _3 ? _3 = null : C3 = g2;
                  }
                  return r2 && !b4 && (b4 = { box: this.collisionIndex.placeCollisionBox(G3, "always", h2, I2, l3, w2, y2, s2, p2.predicate, E3, undefined, S2).box, offscreen: false, placeable: false, occluded: false }), b4;
                };
                a3(() => m3(G3, d3.iconBox, t.al.horizontal), () => {
                  const i4 = d3.verticalTextBox;
                  return o2.allowVerticalPlacement && (!k2 || !k2.placeable) && e3.numVerticalGlyphVertices > 0 && i4 ? m3(i4, d3.verticalIconBox, t.al.vertical) : { box: null, occluded: true, offscreen: null };
                }), k2 && (z3 = k2.placeable, A2 = k2.offscreen);
                const f3 = i3(k2 && k2.placeable);
                if (!z3 && this.prevPlacement) {
                  const t2 = this.prevPlacement.variableOffsets[e3.crossTileID];
                  t2 && (this.variableOffsets[e3.crossTileID] = t2, this.markUsedJustification(o2, t2.anchor, e3, f3));
                }
              }
            }
            if (B3 = k2, z3 = B3 && B3.placeable, A2 = B3 && B3.offscreen, e3.useRuntimeCollisionCircles) {
              const i3 = o2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), n3 = t.am(o2.textSizeData, _2, i3), h3 = a2.get("text-padding");
              O2 = this.collisionIndex.placeCollisionCircles(g2, i3, o2.lineVertexArray, o2.glyphOffsetArray, n3, l3, c2, r2, w2, p2.predicate, e3.collisionCircleDiameter, h3, s2, E3), O2.circles.length && O2.collisionDetected && !r2 && t.w("Collisions detected, but collision boxes are not shown"), z3 = v2 || O2.circles.length > 0 && !O2.collisionDetected, A2 = A2 && O2.offscreen;
            }
            if (d3.iconFeatureIndex && (U2 = d3.iconFeatureIndex), d3.iconBox) {
              const e4 = (e5) => this.collisionIndex.placeCollisionBox(e5, x2, h2, I2, l3, w2, y2, n2, p2.predicate, E3, T2 && L2 ? L2 : undefined, S2);
              F3 && F3.placeable && d3.verticalIconBox ? (j3 = e4(d3.verticalIconBox), D3 = j3.placeable) : (j3 = e4(d3.iconBox), D3 = j3.placeable), A2 = A2 && j3.offscreen;
            }
            const V2 = m2 || e3.numHorizontalGlyphVertices === 0 && e3.numVerticalGlyphVertices === 0, q2 = f2 || e3.numIconVertices === 0;
            V2 || q2 ? q2 ? V2 || (D3 = D3 && z3) : z3 = D3 && z3 : D3 = z3 = D3 && z3;
            const W3 = D3 && j3.placeable;
            if (z3 && B3.placeable && this.collisionIndex.insertCollisionBox(B3.box, g2, a2.get("text-ignore-placement"), o2.bucketInstanceId, F3 && F3.placeable && N2 ? N2 : Z3, p2.ID), W3 && this.collisionIndex.insertCollisionBox(j3.box, x2, a2.get("icon-ignore-placement"), o2.bucketInstanceId, U2, p2.ID), O2 && z3 && this.collisionIndex.insertCollisionCircles(O2.circles, g2, a2.get("text-ignore-placement"), o2.bucketInstanceId, Z3, p2.ID), r2 && this.storeCollisionData(o2.bucketInstanceId, b3, d3, B3, j3, O2), e3.crossTileID === 0)
              throw new Error("symbolInstance.crossTileID can't be 0");
            if (o2.bucketInstanceId === 0)
              throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[e3.crossTileID] = new Qe2((z3 || C2) && !(B3 == null ? undefined : B3.occluded), (D3 || M3) && !(j3 == null ? undefined : j3.occluded), A2 || o2.justReloaded), i2[e3.crossTileID] = true;
          };
          if (P2) {
            if (e2.symbolInstanceStart !== 0)
              throw new Error("bucket.bucketInstanceId should be 0");
            const t2 = o2.getSortedSymbolIndexes(-this.transform.bearingInRadians);
            for (let e3 = t2.length - 1;e3 >= 0; --e3) {
              const i3 = t2[e3];
              R2(o2.symbolInstances.get(i3), o2.collisionArrays[i3], i3);
            }
          } else
            for (let t2 = e2.symbolInstanceStart;t2 < e2.symbolInstanceEnd; t2++)
              R2(o2.symbolInstances.get(t2), o2.collisionArrays[t2], t2);
          o2.justReloaded = false;
        }
        storeCollisionData(e2, t2, i2, r2, o2, a2) {
          if (i2.textBox || i2.iconBox) {
            let a3, s2;
            this.collisionBoxArrays.has(e2) ? a3 = this.collisionBoxArrays.get(e2) : (a3 = new Map, this.collisionBoxArrays.set(e2, a3)), a3.has(t2) ? s2 = a3.get(t2) : (s2 = { text: null, icon: null }, a3.set(t2, s2)), i2.textBox && (s2.text = r2.box), i2.iconBox && (s2.icon = o2.box);
          }
          if (a2) {
            let t3 = this.collisionCircleArrays[e2];
            t3 === undefined && (t3 = this.collisionCircleArrays[e2] = []);
            for (let e3 = 0;e3 < a2.circles.length; e3 += 4)
              t3.push(a2.circles[e3 + 0] - He2), t3.push(a2.circles[e3 + 1] - He2), t3.push(a2.circles[e3 + 2]), t3.push(a2.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(e2, i2, r2, o2) {
          let a2;
          a2 = o2 === t.al.vertical ? r2.verticalPlacedTextSymbolIndex : { left: r2.leftJustifiedTextSymbolIndex, center: r2.centerJustifiedTextSymbolIndex, right: r2.rightJustifiedTextSymbolIndex }[t.aD(i2)];
          const s2 = [r2.leftJustifiedTextSymbolIndex, r2.centerJustifiedTextSymbolIndex, r2.rightJustifiedTextSymbolIndex, r2.verticalPlacedTextSymbolIndex];
          for (const t2 of s2)
            t2 >= 0 && (e2.text.placedSymbolArray.get(t2).crossTileID = a2 >= 0 && t2 !== a2 ? 0 : r2.crossTileID);
        }
        markUsedOrientation(e2, i2, r2) {
          const o2 = i2 === t.al.horizontal || i2 === t.al.horizontalOnly ? i2 : 0, a2 = i2 === t.al.vertical ? i2 : 0, s2 = [r2.leftJustifiedTextSymbolIndex, r2.centerJustifiedTextSymbolIndex, r2.rightJustifiedTextSymbolIndex];
          for (const t2 of s2)
            e2.text.placedSymbolArray.get(t2).placedOrientation = o2;
          r2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(r2.verticalPlacedTextSymbolIndex).placedOrientation = a2);
        }
        commit(e2) {
          this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const t2 = this.prevPlacement;
          let i2 = false;
          this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
          const r2 = t2 ? t2.symbolFadeChange(e2) : 1, o2 = t2 ? t2.opacities : {}, a2 = t2 ? t2.variableOffsets : {}, s2 = t2 ? t2.placedOrientations : {};
          for (const e3 in this.placements) {
            const t3 = this.placements[e3], a3 = o2[e3];
            a3 ? (this.opacities[e3] = new Ke2(a3, r2, t3.text, t3.icon), i2 = i2 || t3.text !== a3.text.placed || t3.icon !== a3.icon.placed) : (this.opacities[e3] = new Ke2(null, r2, t3.text, t3.icon, t3.skipFade), i2 = i2 || t3.text || t3.icon);
          }
          for (const e3 in o2) {
            const t3 = o2[e3];
            if (!this.opacities[e3]) {
              const o3 = new Ke2(t3, r2, false, false);
              o3.isHidden() || (this.opacities[e3] = o3, i2 = i2 || t3.text.placed || t3.icon.placed);
            }
          }
          for (const e3 in a2)
            this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = a2[e3]);
          for (const e3 in s2)
            this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = s2[e3]);
          if (t2 && t2.lastPlacementChangeTime === undefined)
            throw new Error("Last placement time for previous placement is not defined");
          i2 ? this.lastPlacementChangeTime = e2 : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
        }
        updateLayerOpacities(e2, t2) {
          const i2 = {};
          for (const r2 of t2) {
            const t3 = r2.getBucket(e2);
            t3 && r2.latestFeatureIndex && e2.id === t3.layerIds[0] && this.updateBucketOpacities(t3, r2.tileID, i2, r2.collisionBoxArray);
          }
        }
        updateBucketOpacities(e2, i2, r2, o2) {
          e2.hasTextData() && (e2.text.opacityVertexArray.clear(), e2.text.hasVisibleVertices = false), e2.hasIconData() && (e2.icon.opacityVertexArray.clear(), e2.icon.hasVisibleVertices = false), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
          const a2 = e2.layers[0], s2 = a2.layout, n2 = new Ke2(null, 0, false, false, true), l3 = s2.get("text-allow-overlap"), c2 = s2.get("icon-allow-overlap"), h2 = a2._unevaluatedLayout.hasValue("text-variable-anchor") || a2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u2 = s2.get("text-rotation-alignment") === "map", d2 = s2.get("text-pitch-alignment") === "map", _2 = s2.get("icon-text-fit") !== "none", p2 = new Ke2(null, 0, l3 && (c2 || !e2.hasIconData() || s2.get("icon-optional")), c2 && (l3 || !e2.hasTextData() || s2.get("text-optional")), true);
          !e2.collisionArrays && o2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(o2);
          const m2 = (e3, t2, i3) => {
            for (let r3 = 0;r3 < t2 / 4; r3++)
              e3.opacityVertexArray.emplaceBack(i3);
            e3.hasVisibleVertices = e3.hasVisibleVertices || i3 !== ut2;
          }, f2 = this.collisionBoxArrays.get(e2.bucketInstanceId);
          for (let i3 = 0;i3 < e2.symbolInstances.length; i3++) {
            const o3 = e2.symbolInstances.get(i3), { numHorizontalGlyphVertices: a3, numVerticalGlyphVertices: s3, crossTileID: l4 } = o3;
            let c3 = this.opacities[l4];
            r2[l4] ? c3 = n2 : c3 || (c3 = p2, this.opacities[l4] = c3), r2[l4] = true;
            const g2 = o3.numIconVertices > 0, v2 = this.placedOrientations[o3.crossTileID], x2 = v2 === t.al.vertical, b2 = v2 === t.al.horizontal || v2 === t.al.horizontalOnly;
            if (a3 > 0 || s3 > 0) {
              const t2 = ht2(c3.text);
              m2(e2.text, a3, x2 ? ut2 : t2), m2(e2.text, s3, b2 ? ut2 : t2);
              const i4 = c3.text.isHidden();
              [o3.rightJustifiedTextSymbolIndex, o3.centerJustifiedTextSymbolIndex, o3.leftJustifiedTextSymbolIndex].forEach((t3) => {
                t3 >= 0 && (e2.text.placedSymbolArray.get(t3).hidden = i4 || x2 ? 1 : 0);
              }), o3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(o3.verticalPlacedTextSymbolIndex).hidden = i4 || b2 ? 1 : 0);
              const r3 = this.variableOffsets[o3.crossTileID];
              r3 && this.markUsedJustification(e2, r3.anchor, o3, v2);
              const n3 = this.placedOrientations[o3.crossTileID];
              n3 && (this.markUsedJustification(e2, "left", o3, n3), this.markUsedOrientation(e2, n3, o3));
            }
            if (g2) {
              const t2 = ht2(c3.icon), i4 = !(_2 && o3.verticalPlacedIconSymbolIndex && x2);
              o3.placedIconSymbolIndex >= 0 && (m2(e2.icon, o3.numIconVertices, i4 ? t2 : ut2), e2.icon.placedSymbolArray.get(o3.placedIconSymbolIndex).hidden = c3.icon.isHidden()), o3.verticalPlacedIconSymbolIndex >= 0 && (m2(e2.icon, o3.numVerticalIconVertices, i4 ? ut2 : t2), e2.icon.placedSymbolArray.get(o3.verticalPlacedIconSymbolIndex).hidden = c3.icon.isHidden());
            }
            const y2 = f2 && f2.has(i3) ? f2.get(i3) : { text: null, icon: null };
            if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
              const r3 = e2.collisionArrays[i3];
              if (r3) {
                let i4 = new t.P(0, 0);
                if (r3.textBox || r3.verticalTextBox) {
                  let t2 = true;
                  if (h2) {
                    const e3 = this.variableOffsets[l4];
                    e3 ? (i4 = et(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textBoxScale), u2 && i4._rotate(d2 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t2 = false;
                  }
                  if (r3.textBox || r3.verticalTextBox) {
                    let o4;
                    r3.textBox && (o4 = x2), r3.verticalTextBox && (o4 = b2), it2(e2.textCollisionBox.collisionVertexArray, c3.text.placed, !t2 || o4, y2.text, i4.x, i4.y);
                  }
                }
                if (r3.iconBox || r3.verticalIconBox) {
                  const t2 = Boolean(!b2 && r3.verticalIconBox);
                  let o4;
                  r3.iconBox && (o4 = t2), r3.verticalIconBox && (o4 = !t2), it2(e2.iconCollisionBox.collisionVertexArray, c3.icon.placed, o4, y2.icon, _2 ? i4.x : 0, _2 ? i4.y : 0);
                }
              }
            }
          }
          if (e2.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.text.opacityVertexArray.length !== e2.text.layoutVertexArray.length / 4)
            throw new Error(`bucket.text.opacityVertexArray.length (= ${e2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e2.text.layoutVertexArray.length}) / 4`);
          if (e2.icon.opacityVertexArray.length !== e2.icon.layoutVertexArray.length / 4)
            throw new Error(`bucket.icon.opacityVertexArray.length (= ${e2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e2.icon.layoutVertexArray.length}) / 4`);
          e2.bucketInstanceId in this.collisionCircleArrays && (e2.collisionCircleArray = this.collisionCircleArrays[e2.bucketInstanceId], delete this.collisionCircleArrays[e2.bucketInstanceId]);
        }
        symbolFadeChange(e2) {
          return this.fadeDuration === 0 ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e2) {
          return Math.max(0, (this.transform.zoom - e2) / 1.5);
        }
        hasTransitions(e2) {
          return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e2, t2) {
          const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
          return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
        }
        setStale() {
          this.stale = true;
        }
      }
      function it2(e2, t2, i2, r2, o2, a2) {
        r2 && r2.length !== 0 || (r2 = [0, 0, 0, 0]);
        const s2 = r2[0] - He2, n2 = r2[1] - He2, l3 = r2[2] - He2, c2 = r2[3] - He2;
        e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0, s2, n2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0, l3, n2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0, l3, c2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0, s2, c2);
      }
      const rt2 = Math.pow(2, 25), ot2 = Math.pow(2, 24), at2 = Math.pow(2, 17), st2 = Math.pow(2, 16), nt2 = Math.pow(2, 9), lt2 = Math.pow(2, 8), ct2 = Math.pow(2, 1);
      function ht2(e2) {
        if (e2.opacity === 0 && !e2.placed)
          return 0;
        if (e2.opacity === 1 && e2.placed)
          return 4294967295;
        const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
        return i2 * rt2 + t2 * ot2 + i2 * at2 + t2 * st2 + i2 * nt2 + t2 * lt2 + i2 * ct2 + t2;
      }
      const ut2 = 0;

      class dt2 {
        constructor(e2) {
          this._sortAcrossTiles = e2.layout.get("symbol-z-order") !== "viewport-y" && !e2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(e2, t2, i2, r2, o2) {
          const a2 = this._bucketParts;
          for (;this._currentTileIndex < e2.length; )
            if (t2.getBucketParts(a2, r2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, o2())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a2.sort((e3, t3) => e3.sortKey - t3.sortKey));this._currentPartIndex < a2.length; )
            if (t2.placeLayerBucketPart(a2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, o2())
              return true;
          return false;
        }
      }

      class _t2 {
        constructor(e2, t2, i2, r2, o2, a2, s2, n2) {
          this.placement = new tt2(e2, t2, a2, s2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = r2, this._showCollisionBoxes = o2, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(e2, t2, i2) {
          const r2 = s.now(), o2 = () => !this._forceFullPlacement && s.now() - r2 > 2;
          for (;this._currentPlacementIndex >= 0; ) {
            const r3 = t2[e2[this._currentPlacementIndex]], a2 = this.placement.collisionIndex.transform.zoom;
            if (r3.type === "symbol" && (!r3.minzoom || r3.minzoom <= a2) && (!r3.maxzoom || r3.maxzoom > a2)) {
              if (this._inProgressLayer || (this._inProgressLayer = new dt2(r3)), this._inProgressLayer.continuePlacement(i2[r3.source], this.placement, this._showCollisionBoxes, r3, o2))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(e2) {
          return this.placement.commit(e2), this.placement;
        }
      }
      const pt2 = 512 / t.Z / 2;

      class mt2 {
        constructor(e2, i2, r2) {
          this.tileID = e2, this.bucketInstanceId = r2, this._symbolsByKey = {};
          const o2 = new Map;
          for (let e3 = 0;e3 < i2.length; e3++) {
            const t2 = i2.get(e3), r3 = t2.key, a2 = o2.get(r3);
            a2 ? a2.push(t2) : o2.set(r3, [t2]);
          }
          for (const [e3, i3] of o2) {
            const r3 = { positions: i3.map((e4) => ({ x: Math.floor(e4.anchorX * pt2), y: Math.floor(e4.anchorY * pt2) })), crossTileIDs: i3.map((e4) => e4.crossTileID) };
            if (r3.positions.length > 128) {
              const e4 = new t.aF(r3.positions.length, 16, Uint16Array);
              for (const { x: t2, y: i4 } of r3.positions)
                e4.add(t2, i4);
              e4.finish(), delete r3.positions, r3.index = e4;
            }
            this._symbolsByKey[e3] = r3;
          }
        }
        getScaledCoordinates(e2, i2) {
          const { x: r2, y: o2, z: a2 } = this.tileID.canonical, { x: s2, y: n2, z: l3 } = i2.canonical, c2 = pt2 / Math.pow(2, l3 - a2), h2 = (n2 * t.Z + e2.anchorY) * c2, u2 = o2 * t.Z * pt2;
          return { x: Math.floor((s2 * t.Z + e2.anchorX) * c2 - r2 * t.Z * pt2), y: Math.floor(h2 - u2) };
        }
        findMatches(e2, t2, i2) {
          const r2 = this.tileID.canonical.z < t2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t2.canonical.z);
          for (let o2 = 0;o2 < e2.length; o2++) {
            const a2 = e2.get(o2);
            if (a2.crossTileID)
              continue;
            const s2 = this._symbolsByKey[a2.key];
            if (!s2)
              continue;
            const n2 = this.getScaledCoordinates(a2, t2);
            if (s2.index) {
              const e3 = s2.index.range(n2.x - r2, n2.y - r2, n2.x + r2, n2.y + r2).sort();
              for (const t3 of e3) {
                const e4 = s2.crossTileIDs[t3];
                if (!i2[e4]) {
                  i2[e4] = true, a2.crossTileID = e4;
                  break;
                }
              }
            } else if (s2.positions)
              for (let e3 = 0;e3 < s2.positions.length; e3++) {
                const t3 = s2.positions[e3], o3 = s2.crossTileIDs[e3];
                if (Math.abs(t3.x - n2.x) <= r2 && Math.abs(t3.y - n2.y) <= r2 && !i2[o3]) {
                  i2[o3] = true, a2.crossTileID = o3;
                  break;
                }
              }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: e2 }) => e2);
        }
      }

      class ft2 {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }

      class gt2 {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e2) {
          const t2 = Math.round((e2 - this.lng) / 360);
          if (t2 !== 0)
            for (const e3 in this.indexes) {
              const i2 = this.indexes[e3], r2 = {};
              for (const e4 in i2) {
                const o2 = i2[e4];
                o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + t2), r2[o2.tileID.key] = o2;
              }
              this.indexes[e3] = r2;
            }
          this.lng = e2;
        }
        addBucket(e2, t2, i2) {
          if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
            if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
          }
          for (let e3 = 0;e3 < t2.symbolInstances.length; e3++)
            t2.symbolInstances.get(e3).crossTileID = 0;
          this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = {});
          const r2 = this.usedCrossTileIDs[e2.overscaledZ];
          for (const i3 in this.indexes) {
            const o2 = this.indexes[i3];
            if (Number(i3) > e2.overscaledZ)
              for (const i4 in o2) {
                const a2 = o2[i4];
                a2.tileID.isChildOf(e2) && a2.findMatches(t2.symbolInstances, e2, r2);
              }
            else {
              const a2 = o2[e2.scaledTo(Number(i3)).key];
              a2 && a2.findMatches(t2.symbolInstances, e2, r2);
            }
          }
          for (let e3 = 0;e3 < t2.symbolInstances.length; e3++) {
            const o2 = t2.symbolInstances.get(e3);
            o2.crossTileID || (o2.crossTileID = i2.generate(), r2[o2.crossTileID] = true);
          }
          return this.indexes[e2.overscaledZ] === undefined && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new mt2(e2, t2.symbolInstances, t2.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(e2, t2) {
          for (const i2 of t2.getCrossTileIDsLists())
            for (const t3 of i2)
              delete this.usedCrossTileIDs[e2][t3];
        }
        removeStaleBuckets(e2) {
          let t2 = false;
          for (const i2 in this.indexes) {
            const r2 = this.indexes[i2];
            for (const o2 in r2)
              e2[r2[o2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, r2[o2]), delete r2[o2], t2 = true);
          }
          return t2;
        }
      }

      class vt2 {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new ft2, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e2, t2, i2) {
          let r2 = this.layerIndexes[e2.id];
          r2 === undefined && (r2 = this.layerIndexes[e2.id] = new gt2);
          let o2 = false;
          const a2 = {};
          r2.handleWrapJump(i2);
          for (const i3 of t2) {
            const t3 = i3.getBucket(e2);
            t3 && e2.id === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), r2.addBucket(i3.tileID, t3, this.crossTileIDs) && (o2 = true), a2[t3.bucketInstanceId] = true);
          }
          return r2.removeStaleBuckets(a2) && (o2 = true), o2;
        }
        pruneUnusedLayers(e2) {
          const t2 = {};
          e2.forEach((e3) => {
            t2[e3] = true;
          });
          for (const e3 in this.layerIndexes)
            t2[e3] || delete this.layerIndexes[e3];
        }
      }
      var xt2 = "void main() {fragColor=vec4(1.0);}";
      const bt2 = { prelude: yt2(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: yt2("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: yt2("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: yt2(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: yt2(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: yt2(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: yt2(xt2, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: yt2(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: yt2(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: yt2("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: yt2("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: yt2("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: yt2(xt2, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: yt2(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: yt2(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: yt2(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: yt2(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: yt2(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: yt2(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: yt2(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: yt2(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;switch(u_method){case BASIC:
basic_hillshade(deriv);break;case COMBINED:
combined_hillshade(deriv);break;case IGOR:
igor_hillshade(deriv);break;case MULTIDIRECTIONAL:
multidirectional_hillshade(deriv);break;case STANDARD:
default:
standard_hillshade(deriv);break;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: yt2(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: yt2(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: yt2(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: yt2(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: yt2(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: yt2(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: yt2(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: yt2(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: yt2("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: yt2("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: yt2("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: yt2("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: yt2("in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: yt2("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function yt2(e2, t2) {
        const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r2 = t2.match(/in ([\w]+) ([\w]+)/g), o2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s2 = a2 ? a2.concat(o2) : o2, n2 = {};
        return { fragmentSource: e2 = e2.replace(i2, (e3, t3, i3, r3, o3) => (n2[o3] = true, t3 === "define" ? `
#ifndef HAS_UNIFORM_u_${o3}
in ${i3} ${r3} ${o3};
#else
uniform ${i3} ${r3} u_${o3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${o3}
    ${i3} ${r3} ${o3} = u_${o3};
#endif
`)), vertexSource: t2 = t2.replace(i2, (e3, t3, i3, r3, o3) => {
          const a3 = r3 === "float" ? "vec2" : "vec4", s3 = o3.match(/color/) ? "color" : a3;
          return n2[o3] ? t3 === "define" ? `
#ifndef HAS_UNIFORM_u_${o3}
uniform lowp float u_${o3}_t;
in ${i3} ${a3} a_${o3};
out ${i3} ${r3} ${o3};
#else
uniform ${i3} ${r3} u_${o3};
#endif
` : s3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${o3}
    ${o3} = a_${o3};
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${o3}
    ${o3} = unpack_mix_${s3}(a_${o3}, u_${o3}_t);
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
` : t3 === "define" ? `
#ifndef HAS_UNIFORM_u_${o3}
uniform lowp float u_${o3}_t;
in ${i3} ${a3} a_${o3};
#else
uniform ${i3} ${r3} u_${o3};
#endif
` : s3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${o3}
    ${i3} ${r3} ${o3} = a_${o3};
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${o3}
    ${i3} ${r3} ${o3} = unpack_mix_${s3}(a_${o3}, u_${o3}_t);
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
`;
        }), staticAttributes: r2, staticUniforms: s2 };
      }

      class wt {
        constructor(e2, t2, i2) {
          this.vertexBuffer = e2, this.indexBuffer = t2, this.segments = i2;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      var Tt2 = t.aG([{ name: "a_pos", type: "Int16", components: 2 }]);
      const Pt2 = "#define PROJECTION_MERCATOR", Ct = "mercator";

      class Mt2 {
        constructor() {
          this._cachedMesh = null;
        }
        get name() {
          return "mercator";
        }
        get useSubdivision() {
          return false;
        }
        get shaderVariantName() {
          return Ct;
        }
        get shaderDefine() {
          return Pt2;
        }
        get shaderPreludeCode() {
          return bt2.projectionMercator;
        }
        get vertexShaderPreludeCode() {
          return bt2.projectionMercator.vertexSource;
        }
        get subdivisionGranularity() {
          return t.aH.noSubdivision;
        }
        get useGlobeControls() {
          return false;
        }
        get transitionState() {
          return 0;
        }
        get latitudeErrorCorrectionRadians() {
          return 0;
        }
        destroy() {
        }
        updateGPUdependent(e2) {
        }
        getMeshFromTileID(e2, i2, r2, o2, a2) {
          if (this._cachedMesh)
            return this._cachedMesh;
          const s2 = new t.aI;
          s2.emplaceBack(0, 0), s2.emplaceBack(t.Z, 0), s2.emplaceBack(0, t.Z), s2.emplaceBack(t.Z, t.Z);
          const n2 = e2.createVertexBuffer(s2, Tt2.members), l3 = t.aJ.simpleSegment(0, 0, 4, 2), c2 = new t.aK;
          c2.emplaceBack(1, 0, 2), c2.emplaceBack(1, 2, 3);
          const h2 = e2.createIndexBuffer(c2);
          return this._cachedMesh = new wt(n2, h2, l3), this._cachedMesh;
        }
        recalculate() {
        }
        hasTransition() {
          return false;
        }
        setErrorQueryLatitudeDegrees(e2) {
        }
      }

      class It2 {
        constructor(e2 = 0, t2 = 0, i2 = 0, r2 = 0) {
          if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(r2) || r2 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e2, this.bottom = t2, this.left = i2, this.right = r2;
        }
        interpolate(e2, i2, r2) {
          return i2.top != null && e2.top != null && (this.top = t.B.number(e2.top, i2.top, r2)), i2.bottom != null && e2.bottom != null && (this.bottom = t.B.number(e2.bottom, i2.bottom, r2)), i2.left != null && e2.left != null && (this.left = t.B.number(e2.left, i2.left, r2)), i2.right != null && e2.right != null && (this.right = t.B.number(e2.right, i2.right, r2)), this;
        }
        getCenter(e2, i2) {
          const r2 = t.ae((this.left + e2 - this.right) / 2, 0, e2), o2 = t.ae((this.top + i2 - this.bottom) / 2, 0, i2);
          return new t.P(r2, o2);
        }
        equals(e2) {
          return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
        }
        clone() {
          return new It2(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function Et2(e2, t2) {
        if (!e2.renderWorldCopies || e2.lngRange)
          return;
        const i2 = t2.lng - e2.center.lng;
        t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
      }
      function St2(e2) {
        return Math.max(0, Math.floor(e2));
      }

      class Rt2 {
        constructor(e2, i2, r2, o2, a2, s2) {
          this._callbacks = e2, this._tileSize = 512, this._renderWorldCopies = s2 === undefined || !!s2, this._minZoom = i2 || 0, this._maxZoom = r2 || 22, this._minPitch = o2 == null ? 0 : o2, this._maxPitch = a2 == null ? 60 : a2, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t.Q(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = St2(this._zoom), this._scale = t.ac(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new It2, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
        }
        apply(e2, i2, r2) {
          this._latRange = e2.latRange, this._lngRange = e2.lngRange, this._width = e2.width, this._height = e2.height, this._center = e2.center, this._elevation = e2.elevation, this._minElevationForCurrentTile = e2.minElevationForCurrentTile, this._zoom = e2.zoom, this._tileZoom = St2(this._zoom), this._scale = t.ac(this._zoom), this._bearingInRadians = e2.bearingInRadians, this._fovInRadians = e2.fovInRadians, this._pitchInRadians = e2.pitchInRadians, this._rollInRadians = e2.rollInRadians, this._unmodified = e2.unmodified, this._edgeInsets = new It2(e2.padding.top, e2.padding.bottom, e2.padding.left, e2.padding.right), this._minZoom = e2.minZoom, this._maxZoom = e2.maxZoom, this._minPitch = e2.minPitch, this._maxPitch = e2.maxPitch, this._renderWorldCopies = e2.renderWorldCopies, this._cameraToCenterDistance = e2.cameraToCenterDistance, this._nearZ = e2.nearZ, this._farZ = e2.farZ, this._autoCalculateNearFarZ = !r2 && e2.autoCalculateNearFarZ, i2 && this._constrain(), this._calcMatrices();
        }
        get pixelsToClipSpaceMatrix() {
          return this._pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._clipSpaceToPixelsMatrix;
        }
        get minElevationForCurrentTile() {
          return this._minElevationForCurrentTile;
        }
        setMinElevationForCurrentTile(e2) {
          this._minElevationForCurrentTile = e2;
        }
        get tileSize() {
          return this._tileSize;
        }
        get tileZoom() {
          return this._tileZoom;
        }
        get scale() {
          return this._scale;
        }
        get width() {
          return this._width;
        }
        get height() {
          return this._height;
        }
        get bearingInRadians() {
          return this._bearingInRadians;
        }
        get lngRange() {
          return this._lngRange;
        }
        get latRange() {
          return this._latRange;
        }
        get pixelsToGLUnits() {
          return this._pixelsToGLUnits;
        }
        get minZoom() {
          return this._minZoom;
        }
        setMinZoom(e2) {
          this._minZoom !== e2 && (this._minZoom = e2, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        setMaxZoom(e2) {
          this._maxZoom !== e2 && (this._maxZoom = e2, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
        }
        get minPitch() {
          return this._minPitch;
        }
        setMinPitch(e2) {
          this._minPitch !== e2 && (this._minPitch = e2, this.setPitch(Math.max(this.pitch, e2)));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        setMaxPitch(e2) {
          this._maxPitch !== e2 && (this._maxPitch = e2, this.setPitch(Math.min(this.pitch, e2)));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        setRenderWorldCopies(e2) {
          e2 === undefined ? e2 = true : e2 === null && (e2 = false), this._renderWorldCopies = e2;
        }
        get worldSize() {
          return this._tileSize * this._scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new t.P(this._width, this._height);
        }
        get bearing() {
          return this._bearingInRadians / Math.PI * 180;
        }
        setBearing(e2) {
          const i2 = t.aL(e2, -180, 180) * Math.PI / 180;
          var o2, a2, s2, n2, l3, c2, h2, u2, d2;
          this._bearingInRadians !== i2 && (this._unmodified = false, this._bearingInRadians = i2, this._calcMatrices(), this._rotationMatrix = r(), o2 = this._rotationMatrix, s2 = -this._bearingInRadians, n2 = (a2 = this._rotationMatrix)[0], l3 = a2[1], c2 = a2[2], h2 = a2[3], u2 = Math.sin(s2), d2 = Math.cos(s2), o2[0] = n2 * d2 + c2 * u2, o2[1] = l3 * d2 + h2 * u2, o2[2] = n2 * -u2 + c2 * d2, o2[3] = l3 * -u2 + h2 * d2);
        }
        get rotationMatrix() {
          return this._rotationMatrix;
        }
        get pitchInRadians() {
          return this._pitchInRadians;
        }
        get pitch() {
          return this._pitchInRadians / Math.PI * 180;
        }
        setPitch(e2) {
          const i2 = t.ae(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitchInRadians !== i2 && (this._unmodified = false, this._pitchInRadians = i2, this._calcMatrices());
        }
        get rollInRadians() {
          return this._rollInRadians;
        }
        get roll() {
          return this._rollInRadians / Math.PI * 180;
        }
        setRoll(e2) {
          const t2 = e2 / 180 * Math.PI;
          this._rollInRadians !== t2 && (this._unmodified = false, this._rollInRadians = t2, this._calcMatrices());
        }
        get fovInRadians() {
          return this._fovInRadians;
        }
        get fov() {
          return t.aM(this._fovInRadians);
        }
        setFov(e2) {
          e2 = t.ae(e2, 0.1, 150), this.fov !== e2 && (this._unmodified = false, this._fovInRadians = t.ab(e2), this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        setZoom(e2) {
          const i2 = this.getConstrained(this._center, e2).zoom;
          this._zoom !== i2 && (this._unmodified = false, this._zoom = i2, this._tileZoom = Math.max(0, Math.floor(i2)), this._scale = t.ac(i2), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        setCenter(e2) {
          e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        setElevation(e2) {
          e2 !== this._elevation && (this._elevation = e2, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        setPadding(e2) {
          this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this._width, this._height);
        }
        get pixelsPerMeter() {
          return this._pixelPerMeter;
        }
        get unmodified() {
          return this._unmodified;
        }
        get cameraToCenterDistance() {
          return this._cameraToCenterDistance;
        }
        get nearZ() {
          return this._nearZ;
        }
        get farZ() {
          return this._farZ;
        }
        get autoCalculateNearFarZ() {
          return this._autoCalculateNearFarZ;
        }
        overrideNearFarZ(e2, t2) {
          this._autoCalculateNearFarZ = false, this._nearZ = e2, this._farZ = t2, this._calcMatrices();
        }
        clearNearFarZOverride() {
          this._autoCalculateNearFarZ = true, this._calcMatrices();
        }
        isPaddingEqual(e2) {
          return this._edgeInsets.equals(e2);
        }
        interpolatePadding(e2, t2, i2) {
          this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
        }
        resize(e2, t2, i2 = true) {
          this._width = e2, this._height = t2, i2 && this._constrain(), this._calcMatrices();
        }
        getMaxBounds() {
          return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new V([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
        }
        setMaxBounds(e2) {
          e2 ? (this._lngRange = [e2.getWest(), e2.getEast()], this._latRange = [e2.getSouth(), e2.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, t.af]);
        }
        getConstrained(e2, t2) {
          return this._callbacks.getConstrained(e2, t2);
        }
        getCameraQueryGeometry(e2, i2) {
          if (i2.length === 1)
            return [i2[0], e2];
          {
            let { x: r2, y: o2, x: a2, y: s2 } = e2;
            for (const e3 of i2)
              r2 = Math.min(r2, e3.x), o2 = Math.min(o2, e3.y), a2 = Math.max(a2, e3.x), s2 = Math.max(s2, e3.y);
            return [new t.P(r2, o2), new t.P(a2, o2), new t.P(a2, s2), new t.P(r2, s2), new t.P(r2, o2)];
          }
        }
        _constrain() {
          if (!this.center || !this._width || !this._height || this._constraining)
            return;
          this._constraining = true;
          const e2 = this._unmodified, { center: t2, zoom: i2 } = this.getConstrained(this.center, this.zoom);
          this.setCenter(t2), this.setZoom(i2), this._unmodified = e2, this._constraining = false;
        }
        _calcMatrices() {
          if (this._width && this._height) {
            this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
            let e2 = t.ad(new Float64Array(16));
            t.M(e2, e2, [this._width / 2, -this._height / 2, 1]), t.L(e2, e2, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e2, e2 = t.ad(new Float64Array(16)), t.M(e2, e2, [1, -1, 1]), t.L(e2, e2, [-1, -1, 0]), t.M(e2, e2, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e2, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
          }
          this._callbacks.calcMatrices();
        }
        calculateCenterFromCameraLngLatAlt(e2, i2, r2, o2) {
          const a2 = r2 !== undefined ? r2 : this.bearing, s2 = o2 = o2 !== undefined ? o2 : this.pitch, n2 = t.$.fromLngLat(e2, i2), l3 = -Math.cos(t.ab(s2)), c2 = Math.sin(t.ab(s2)), h2 = c2 * Math.sin(t.ab(a2)), u2 = -c2 * Math.cos(t.ab(a2));
          let d2 = this.elevation;
          const _2 = i2 - d2;
          let p2;
          l3 * _2 >= 0 || Math.abs(l3) < 0.1 ? (p2 = 1e4, d2 = i2 + p2 * l3) : p2 = -_2 / l3;
          let m2, f2, g2 = t.aN(1, n2.y), v2 = 0;
          do {
            if (v2 += 1, v2 > 10)
              break;
            f2 = p2 / g2, m2 = new t.$(n2.x + h2 * f2, n2.y + u2 * f2), g2 = 1 / m2.meterInMercatorCoordinateUnits();
          } while (Math.abs(p2 - f2 * g2) > 0.000000000001);
          return { center: m2.toLngLat(), elevation: d2, zoom: t.ah(this.height / 2 / Math.tan(this.fovInRadians / 2) / f2 / this.tileSize) };
        }
        recalculateZoomAndCenter(e2) {
          if (this.elevation - e2 == 0)
            return;
          const i2 = t.ag(1, this.center.lat) * this.worldSize, r2 = this.cameraToCenterDistance / i2, o2 = t.$.fromLngLat(this.center, this.elevation), a2 = _e2(this.center, this.elevation, this.pitch, this.bearing, r2);
          this._elevation = e2;
          const s2 = this.calculateCenterFromCameraLngLatAlt(a2.toLngLat(), t.aN(a2.z, o2.y), this.bearing, this.pitch);
          this._elevation = s2.elevation, this._center = s2.center, this.setZoom(s2.zoom);
        }
        getCameraPoint() {
          const e2 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new t.P(e2 * Math.sin(this.rollInRadians), e2 * Math.cos(this.rollInRadians)));
        }
        getCameraAltitude() {
          return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
        }
        getCameraLngLat() {
          const e2 = t.ag(1, this.center.lat) * this.worldSize;
          return _e2(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e2).toLngLat();
        }
        getMercatorTileCoordinates(e2) {
          if (!e2)
            return [0, 0, 1, 1];
          const i2 = e2.canonical.z >= 0 ? 1 << e2.canonical.z : Math.pow(2, e2.canonical.z);
          return [e2.canonical.x / i2, e2.canonical.y / i2, 1 / i2 / t.Z, 1 / i2 / t.Z];
        }
      }

      class zt2 {
        constructor(e2, i2) {
          this.min = e2, this.max = i2, this.center = t.aO([], t.aP([], this.min, this.max), 0.5);
        }
        quadrant(e2) {
          const i2 = [e2 % 2 == 0, e2 < 2], r2 = t.aQ(this.min), o2 = t.aQ(this.max);
          for (let e3 = 0;e3 < i2.length; e3++)
            r2[e3] = i2[e3] ? this.min[e3] : this.center[e3], o2[e3] = i2[e3] ? this.center[e3] : this.max[e3];
          return o2[2] = this.max[2], new zt2(r2, o2);
        }
        distanceX(e2) {
          return Math.max(Math.min(this.max[0], e2[0]), this.min[0]) - e2[0];
        }
        distanceY(e2) {
          return Math.max(Math.min(this.max[1], e2[1]), this.min[1]) - e2[1];
        }
        intersectsFrustum(e2) {
          let t2 = true;
          for (let i2 = 0;i2 < e2.planes.length; i2++) {
            const r2 = this.intersectsPlane(e2.planes[i2]);
            if (r2 === 0)
              return 0;
            r2 === 1 && (t2 = false);
          }
          return t2 ? 2 : e2.aabb.min[0] > this.max[0] || e2.aabb.min[1] > this.max[1] || e2.aabb.min[2] > this.max[2] || e2.aabb.max[0] < this.min[0] || e2.aabb.max[1] < this.min[1] || e2.aabb.max[2] < this.min[2] ? 0 : 1;
        }
        intersectsPlane(e2) {
          let t2 = e2[3], i2 = e2[3];
          for (let r2 = 0;r2 < 3; r2++)
            e2[r2] > 0 ? (t2 += e2[r2] * this.min[r2], i2 += e2[r2] * this.max[r2]) : (i2 += e2[r2] * this.min[r2], t2 += e2[r2] * this.max[r2]);
          return t2 >= 0 ? 2 : i2 < 0 ? 0 : 1;
        }
      }

      class Dt2 {
        distanceToTile2d(e2, t2, i2, r2) {
          const o2 = r2.distanceX([e2, t2]), a2 = r2.distanceY([e2, t2]);
          return Math.hypot(o2, a2);
        }
        getWrap(e2, t2, i2) {
          return i2;
        }
        getTileAABB(e2, i2, r2, o2) {
          var a2, s2;
          let n2 = r2, l3 = r2;
          if (o2.terrain) {
            const c3 = new t.Y(e2.z, i2, e2.z, e2.x, e2.y), h2 = o2.terrain.getMinMaxElevation(c3);
            n2 = (a2 = h2.minElevation) !== null && a2 !== undefined ? a2 : r2, l3 = (s2 = h2.maxElevation) !== null && s2 !== undefined ? s2 : r2;
          }
          const c2 = 1 << e2.z;
          return new zt2([i2 + e2.x / c2, e2.y / c2, n2], [i2 + (e2.x + 1) / c2, (e2.y + 1) / c2, l3]);
        }
        allowVariableZoom(e2, i2) {
          const r2 = e2.fov * (Math.abs(Math.cos(e2.rollInRadians)) * e2.height + Math.abs(Math.sin(e2.rollInRadians)) * e2.width) / e2.height, o2 = t.ae(78.5 - r2 / 2, 0, 60);
          return !!i2.terrain || e2.pitch > o2;
        }
        allowWorldCopies() {
          return true;
        }
        recalculateCache() {
        }
      }

      class At2 {
        constructor(e2, t2, i2) {
          this.points = e2, this.planes = t2, this.aabb = i2;
        }
        static fromInvProjectionMatrix(e2, i2 = 1, r2 = 0) {
          const o2 = Math.pow(2, r2), a2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r3) => {
            const a3 = 1 / (r3 = t.at([], r3, e2))[3] / i2 * o2;
            return t.aR(r3, r3, [a3, a3, 1 / r3[3], a3]);
          }), s2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e3) => {
            const i3 = t.aS([], a2[e3[0]], a2[e3[1]]), r3 = t.aS([], a2[e3[2]], a2[e3[1]]), o3 = t.aT([], t.aU([], i3, r3)), s3 = -t.aV(o3, a2[e3[1]]);
            return o3.concat(s3);
          }), n2 = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], l3 = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
          for (const e3 of a2)
            for (let t2 = 0;t2 < 3; t2++)
              n2[t2] = Math.min(n2[t2], e3[t2]), l3[t2] = Math.max(l3[t2], e3[t2]);
          return new At2(a2, s2, new zt2(n2, l3));
        }
      }

      class Lt2 {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(e2) {
          this._helper.setMinZoom(e2);
        }
        setMaxZoom(e2) {
          this._helper.setMaxZoom(e2);
        }
        setMinPitch(e2) {
          this._helper.setMinPitch(e2);
        }
        setMaxPitch(e2) {
          this._helper.setMaxPitch(e2);
        }
        setRenderWorldCopies(e2) {
          this._helper.setRenderWorldCopies(e2);
        }
        setBearing(e2) {
          this._helper.setBearing(e2);
        }
        setPitch(e2) {
          this._helper.setPitch(e2);
        }
        setRoll(e2) {
          this._helper.setRoll(e2);
        }
        setFov(e2) {
          this._helper.setFov(e2);
        }
        setZoom(e2) {
          this._helper.setZoom(e2);
        }
        setCenter(e2) {
          this._helper.setCenter(e2);
        }
        setElevation(e2) {
          this._helper.setElevation(e2);
        }
        setMinElevationForCurrentTile(e2) {
          this._helper.setMinElevationForCurrentTile(e2);
        }
        setPadding(e2) {
          this._helper.setPadding(e2);
        }
        interpolatePadding(e2, t2, i2) {
          return this._helper.interpolatePadding(e2, t2, i2);
        }
        isPaddingEqual(e2) {
          return this._helper.isPaddingEqual(e2);
        }
        resize(e2, t2, i2 = true) {
          this._helper.resize(e2, t2, i2);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(e2) {
          this._helper.setMaxBounds(e2);
        }
        overrideNearFarZ(e2, t2) {
          this._helper.overrideNearFarZ(e2, t2);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(e2) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        setTransitionState(e2, t2) {
        }
        constructor(e2, t2, i2, r2, o2) {
          this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this._helper = new Rt2({ calcMatrices: () => {
            this._calcMatrices();
          }, getConstrained: (e3, t3) => this.getConstrained(e3, t3) }, e2, t2, i2, r2, o2), this._coveringTilesDetailsProvider = new Dt2;
        }
        clone() {
          const e2 = new Lt2;
          return e2.apply(this), e2;
        }
        apply(e2, t2, i2) {
          this._helper.apply(e2, t2, i2);
        }
        get cameraPosition() {
          return this._cameraPosition;
        }
        get projectionMatrix() {
          return this._projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this._viewProjMatrix;
        }
        get inverseProjectionMatrix() {
          return this._invProjMatrix;
        }
        get mercatorMatrix() {
          return this._mercatorMatrix;
        }
        getVisibleUnwrappedCoordinates(e2) {
          const i2 = [new t.aW(0, e2)];
          if (this._helper._renderWorldCopies) {
            const r2 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), o2 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, 0)), a2 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, this._helper._height)), s2 = this.screenPointToMercatorCoordinate(new t.P(0, this._helper._height)), n2 = Math.floor(Math.min(r2.x, o2.x, a2.x, s2.x)), l3 = Math.floor(Math.max(r2.x, o2.x, a2.x, s2.x)), c2 = 1;
            for (let r3 = n2 - c2;r3 <= l3 + c2; r3++)
              r3 !== 0 && i2.push(new t.aW(r3, e2));
          }
          return i2;
        }
        getCameraFrustum() {
          return At2.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
        }
        getClippingPlane() {
          return null;
        }
        getCoveringTilesDetailsProvider() {
          return this._coveringTilesDetailsProvider;
        }
        recalculateZoomAndCenter(e2) {
          const t2 = this.screenPointToLocation(this.centerPoint, e2), i2 = e2 ? e2.getElevationForLngLatZoom(t2, this._helper._tileZoom) : 0;
          this._helper.recalculateZoomAndCenter(i2);
        }
        setLocationAtPoint(e2, i2) {
          const r2 = t.ag(this.elevation, this.center.lat), o2 = this.screenPointToMercatorCoordinateAtZ(i2, r2), a2 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, r2), s2 = t.$.fromLngLat(e2), n2 = new t.$(s2.x - (o2.x - a2.x), s2.y - (o2.y - a2.y));
          this.setCenter(n2 == null ? undefined : n2.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
        }
        locationToScreenPoint(e2, i2) {
          return i2 ? this.coordinatePoint(t.$.fromLngLat(e2), i2.getElevationForLngLatZoom(e2, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(t.$.fromLngLat(e2));
        }
        screenPointToLocation(e2, t2) {
          var i2;
          return (i2 = this.screenPointToMercatorCoordinate(e2, t2)) === null || i2 === undefined ? undefined : i2.toLngLat();
        }
        screenPointToMercatorCoordinate(e2, t2) {
          if (t2) {
            const i2 = t2.pointCoordinate(e2);
            if (i2 != null)
              return i2;
          }
          return this.screenPointToMercatorCoordinateAtZ(e2);
        }
        screenPointToMercatorCoordinateAtZ(e2, i2) {
          const r2 = i2 || 0, o2 = [e2.x, e2.y, 0, 1], a2 = [e2.x, e2.y, 1, 1];
          t.at(o2, o2, this._pixelMatrixInverse), t.at(a2, a2, this._pixelMatrixInverse);
          const s2 = o2[3], n2 = a2[3], l3 = o2[1] / s2, c2 = a2[1] / n2, h2 = o2[2] / s2, u2 = a2[2] / n2, d2 = h2 === u2 ? 0 : (r2 - h2) / (u2 - h2);
          return new t.$(t.B.number(o2[0] / s2, a2[0] / n2, d2) / this.worldSize, t.B.number(l3, c2, d2) / this.worldSize, r2);
        }
        coordinatePoint(e2, i2 = 0, r2 = this._pixelMatrix) {
          const o2 = [e2.x * this.worldSize, e2.y * this.worldSize, i2, 1];
          return t.at(o2, o2, r2), new t.P(o2[0] / o2[3], o2[1] / o2[3]);
        }
        getBounds() {
          const e2 = Math.max(0, this._helper._height / 2 - ue2(this));
          return new V().extend(this.screenPointToLocation(new t.P(0, e2))).extend(this.screenPointToLocation(new t.P(this._helper._width, e2))).extend(this.screenPointToLocation(new t.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t.P(0, this._helper._height)));
        }
        isPointOnMapSurface(e2, t2) {
          return t2 ? t2.pointCoordinate(e2) != null : e2.y > this.height / 2 - ue2(this);
        }
        calculatePosMatrix(e2, i2 = false, r2) {
          var o2;
          const a2 = (o2 = e2.key) !== null && o2 !== undefined ? o2 : t.aX(e2.wrap, e2.canonical.z, e2.canonical.z, e2.canonical.x, e2.canonical.y), s2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (s2.has(a2)) {
            const e3 = s2.get(a2);
            return r2 ? e3.f32 : e3.f64;
          }
          const n2 = de2(e2, this.worldSize);
          t.N(n2, i2 ? this._alignedProjMatrix : this._viewProjMatrix, n2);
          const l3 = { f64: n2, f32: new Float32Array(n2) };
          return s2.set(a2, l3), r2 ? l3.f32 : l3.f64;
        }
        calculateFogMatrix(e2) {
          const i2 = e2.key, r2 = this._fogMatrixCacheF32;
          if (r2.has(i2))
            return r2.get(i2);
          const o2 = de2(e2, this.worldSize);
          return t.N(o2, this._fogMatrix, o2), r2.set(i2, new Float32Array(o2)), r2.get(i2);
        }
        getConstrained(e2, i2) {
          i2 = t.ae(+i2, this.minZoom, this.maxZoom);
          const r2 = { center: new t.Q(e2.lng, e2.lat), zoom: i2 };
          let o2 = this._helper._lngRange;
          this._helper._renderWorldCopies || o2 !== null || (o2 = [-179.9999999999, 180 - 0.0000000001]);
          const a2 = this.tileSize * t.ac(r2.zoom);
          let s2 = 0, n2 = a2, l3 = 0, c2 = a2, h2 = 0, u2 = 0;
          const { x: d2, y: _2 } = this.size;
          if (this._helper._latRange) {
            const e3 = this._helper._latRange;
            s2 = t.S(e3[1]) * a2, n2 = t.S(e3[0]) * a2, n2 - s2 < _2 && (h2 = _2 / (n2 - s2));
          }
          o2 && (l3 = t.aL(t.U(o2[0]) * a2, 0, a2), c2 = t.aL(t.U(o2[1]) * a2, 0, a2), c2 < l3 && (c2 += a2), c2 - l3 < d2 && (u2 = d2 / (c2 - l3)));
          const { x: p2, y: m2 } = ce2(a2, e2);
          let f2, g2;
          const v2 = Math.max(u2 || 0, h2 || 0);
          if (v2) {
            const e3 = new t.P(u2 ? (c2 + l3) / 2 : p2, h2 ? (n2 + s2) / 2 : m2);
            return r2.center = he2(a2, e3).wrap(), r2.zoom += t.ah(v2), r2;
          }
          if (this._helper._latRange) {
            const e3 = _2 / 2;
            m2 - e3 < s2 && (g2 = s2 + e3), m2 + e3 > n2 && (g2 = n2 - e3);
          }
          if (o2) {
            const e3 = (l3 + c2) / 2;
            let i3 = p2;
            this._helper._renderWorldCopies && (i3 = t.aL(p2, e3 - a2 / 2, e3 + a2 / 2));
            const r3 = d2 / 2;
            i3 - r3 < l3 && (f2 = l3 + r3), i3 + r3 > c2 && (f2 = c2 - r3);
          }
          if (f2 !== undefined || g2 !== undefined) {
            const e3 = new t.P(f2 != null ? f2 : p2, g2 != null ? g2 : m2);
            r2.center = he2(a2, e3).wrap();
          }
          return r2;
        }
        calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2) {
          return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2);
        }
        _calculateNearFarZIfNeeded(e2, i2, r2) {
          if (!this._helper.autoCalculateNearFarZ)
            return;
          const o2 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), a2 = e2 - o2 * this._helper._pixelPerMeter / Math.cos(i2), s2 = o2 < 0 ? a2 : e2, n2 = Math.PI / 2 + this.pitchInRadians, l3 = t.ab(this.fov) * (Math.abs(Math.cos(t.ab(this.roll))) * this.height + Math.abs(Math.sin(t.ab(this.roll))) * this.width) / this.height * (0.5 + r2.y / this.height), c2 = Math.sin(l3) * s2 / Math.sin(t.ae(Math.PI - n2 - l3, 0.01, Math.PI - 0.01)), h2 = ue2(this), u2 = Math.atan(h2 / this._helper.cameraToCenterDistance), d2 = t.ab(0.75), _2 = u2 > d2 ? 2 * u2 * (0.5 + r2.y / (2 * h2)) : d2, p2 = Math.sin(_2) * s2 / Math.sin(t.ae(Math.PI - n2 - _2, 0.01, Math.PI - 0.01)), m2 = Math.min(c2, p2);
          this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i2) * m2 + s2), this._helper._nearZ = this._helper._height / 50;
        }
        _calcMatrices() {
          if (!this._helper._height)
            return;
          const e2 = this.centerOffset, i2 = ce2(this.worldSize, this.center), r2 = i2.x, o2 = i2.y;
          this._helper._pixelPerMeter = t.ag(1, this.center.lat) * this.worldSize;
          const a2 = t.ab(Math.min(this.pitch, le2)), s2 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(a2));
          let n2;
          this._calculateNearFarZIfNeeded(s2, a2, e2), n2 = new Float64Array(16), t.aY(n2, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t.an(this._invProjMatrix, n2), n2[8] = 2 * -e2.x / this._helper._width, n2[9] = 2 * e2.y / this._helper._height, this._projectionMatrix = t.aZ(n2), t.M(n2, n2, [1, -1, 1]), t.L(n2, n2, [0, 0, -this._helper.cameraToCenterDistance]), t.a_(n2, n2, -this.rollInRadians), t.a$(n2, n2, this.pitchInRadians), t.a_(n2, n2, -this.bearingInRadians), t.L(n2, n2, [-r2, -o2, 0]), this._mercatorMatrix = t.M([], n2, [this.worldSize, this.worldSize, this.worldSize]), t.M(n2, n2, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = t.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, n2), t.L(n2, n2, [0, 0, -this.elevation]), this._viewProjMatrix = n2, this._invViewProjMatrix = t.an([], n2);
          const l3 = [0, 0, -1, 1];
          t.at(l3, l3, this._invViewProjMatrix), this._cameraPosition = [l3[0] / l3[3], l3[1] / l3[3], l3[2] / l3[3]], this._fogMatrix = new Float64Array(16), t.aY(this._fogMatrix, this.fovInRadians, this.width / this.height, s2, this._helper._farZ), this._fogMatrix[8] = 2 * -e2.x / this.width, this._fogMatrix[9] = 2 * e2.y / this.height, t.M(this._fogMatrix, this._fogMatrix, [1, -1, 1]), t.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), t.a_(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t.a$(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t.a_(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t.L(this._fogMatrix, this._fogMatrix, [-r2, -o2, 0]), t.M(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), t.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = t.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, n2);
          const c2 = this._helper._width % 2 / 2, h2 = this._helper._height % 2 / 2, u2 = Math.cos(this.bearingInRadians), d2 = Math.sin(-this.bearingInRadians), _2 = r2 - Math.round(r2) + u2 * c2 + d2 * h2, p2 = o2 - Math.round(o2) + u2 * h2 + d2 * c2, m2 = new Float64Array(n2);
          if (t.L(m2, m2, [_2 > 0.5 ? _2 - 1 : _2, p2 > 0.5 ? p2 - 1 : p2, 0]), this._alignedProjMatrix = m2, n2 = t.an(new Float64Array(16), this._pixelMatrix), !n2)
            throw new Error("failed to invert matrix");
          this._pixelMatrixInverse = n2, this._clearMatrixCaches();
        }
        _clearMatrixCaches() {
          this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
        }
        maxPitchScaleFactor() {
          if (!this._pixelMatrixInverse)
            return 1;
          const e2 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
          return t.at(i2, i2, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          const e2 = t.ag(1, this.center.lat) * this.worldSize;
          return _e2(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e2).toLngLat();
        }
        lngLatToCameraDepth(e2, i2) {
          const r2 = t.$.fromLngLat(e2), o2 = [r2.x * this.worldSize, r2.y * this.worldSize, i2, 1];
          return t.at(o2, o2, this._viewProjMatrix), o2[2] / o2[3];
        }
        getProjectionData(e2) {
          const { overscaledTileID: i2, aligned: r2, applyTerrainMatrix: o2 } = e2, a2 = this._helper.getMercatorTileCoordinates(i2), s2 = i2 ? this.calculatePosMatrix(i2, r2, true) : null;
          let n2;
          return n2 = i2 && i2.terrainRttPosMatrix32f && o2 ? i2.terrainRttPosMatrix32f : s2 || t.b0(), { mainMatrix: n2, tileMercatorCoords: a2, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: n2 };
        }
        isLocationOccluded(e2) {
          return false;
        }
        getPixelScale() {
          return 1;
        }
        getCircleRadiusCorrection() {
          return 1;
        }
        getPitchedTextCorrection(e2, t2, i2) {
          return 1;
        }
        transformLightDirection(e2) {
          return t.aQ(e2);
        }
        getRayDirectionFromPixel(e2) {
          throw new Error("Not implemented.");
        }
        projectTileCoordinates(e2, i2, r2, o2) {
          const a2 = this.calculatePosMatrix(r2);
          let s2;
          o2 ? (s2 = [e2, i2, o2(e2, i2), 1], t.at(s2, s2, a2)) : (s2 = [e2, i2, 0, 1], We2(s2, s2, a2));
          const n2 = s2[3];
          return { point: new t.P(s2[0] / n2, s2[1] / n2), signedDistanceFromCamera: n2, isOccluded: false };
        }
        populateCache(e2) {
          for (const t2 of e2)
            this.calculatePosMatrix(t2);
        }
        getMatrixForModel(e2, i2) {
          const r2 = t.$.fromLngLat(e2, i2), o2 = r2.meterInMercatorCoordinateUnits(), a2 = t.b1();
          return t.L(a2, a2, [r2.x, r2.y, r2.z]), t.a_(a2, a2, Math.PI), t.a$(a2, a2, Math.PI / 2), t.M(a2, a2, [-o2, o2, o2]), a2;
        }
        getProjectionDataForCustomLayer(e2 = true) {
          const i2 = new t.Y(0, 0, 0, 0, 0), r2 = this.getProjectionData({ overscaledTileID: i2, applyGlobeMatrix: e2 }), o2 = de2(i2, this.worldSize);
          t.N(o2, this._viewProjMatrix, o2), r2.tileMercatorCoords = [0, 0, 1, 1];
          const a2 = [t.Z, t.Z, this.worldSize / this._helper.pixelsPerMeter], s2 = t.b2();
          return t.M(s2, o2, a2), r2.fallbackMatrix = s2, r2.mainMatrix = s2, r2;
        }
        getFastPathSimpleProjectionMatrix(e2) {
          return this.calculatePosMatrix(e2);
        }
      }
      function kt2() {
        t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
      }
      function Ft2(e2) {
        if (e2.useSlerp)
          if (e2.k < 1) {
            const i2 = t.b3(e2.startEulerAngles.roll, e2.startEulerAngles.pitch, e2.startEulerAngles.bearing), r2 = t.b3(e2.endEulerAngles.roll, e2.endEulerAngles.pitch, e2.endEulerAngles.bearing), o2 = new Float64Array(4);
            t.b4(o2, i2, r2, e2.k);
            const a2 = t.b5(o2);
            e2.tr.setRoll(a2.roll), e2.tr.setPitch(a2.pitch), e2.tr.setBearing(a2.bearing);
          } else
            e2.tr.setRoll(e2.endEulerAngles.roll), e2.tr.setPitch(e2.endEulerAngles.pitch), e2.tr.setBearing(e2.endEulerAngles.bearing);
        else
          e2.tr.setRoll(t.B.number(e2.startEulerAngles.roll, e2.endEulerAngles.roll, e2.k)), e2.tr.setPitch(t.B.number(e2.startEulerAngles.pitch, e2.endEulerAngles.pitch, e2.k)), e2.tr.setBearing(t.B.number(e2.startEulerAngles.bearing, e2.endEulerAngles.bearing, e2.k));
      }
      function Bt2(e2, i2, r2, o2, a2) {
        const s2 = a2.padding, n2 = ce2(a2.worldSize, r2.getNorthWest()), l3 = ce2(a2.worldSize, r2.getNorthEast()), c2 = ce2(a2.worldSize, r2.getSouthEast()), h2 = ce2(a2.worldSize, r2.getSouthWest()), u2 = t.ab(-o2), d2 = n2.rotate(u2), _2 = l3.rotate(u2), p2 = c2.rotate(u2), m2 = h2.rotate(u2), f2 = new t.P(Math.max(d2.x, _2.x, m2.x, p2.x), Math.max(d2.y, _2.y, m2.y, p2.y)), g2 = new t.P(Math.min(d2.x, _2.x, m2.x, p2.x), Math.min(d2.y, _2.y, m2.y, p2.y)), v2 = f2.sub(g2), x2 = (a2.width - (s2.left + s2.right + i2.left + i2.right)) / v2.x, b2 = (a2.height - (s2.top + s2.bottom + i2.top + i2.bottom)) / v2.y;
        if (b2 < 0 || x2 < 0)
          return void kt2();
        const y2 = Math.min(t.ah(a2.scale * Math.min(x2, b2)), e2.maxZoom), w2 = t.P.convert(e2.offset), T2 = new t.P((i2.left - i2.right) / 2, (i2.top - i2.bottom) / 2).rotate(t.ab(o2)), P2 = w2.add(T2).mult(a2.scale / t.ac(y2));
        return { center: he2(a2.worldSize, n2.add(c2).div(2).sub(P2)), zoom: y2, bearing: o2 };
      }

      class Ot2 {
        get useGlobeControls() {
          return false;
        }
        handlePanInertia(e2, t2) {
          return { easingOffset: e2, easingCenter: t2.center };
        }
        handleMapControlsRollPitchBearingZoom(e2, t2) {
          e2.bearingDelta && t2.setBearing(t2.bearing + e2.bearingDelta), e2.pitchDelta && t2.setPitch(t2.pitch + e2.pitchDelta), e2.rollDelta && t2.setRoll(t2.roll + e2.rollDelta), e2.zoomDelta && t2.setZoom(t2.zoom + e2.zoomDelta);
        }
        handleMapControlsPan(e2, t2, i2) {
          e2.around.distSqr(t2.centerPoint) < 0.01 || t2.setLocationAtPoint(i2, e2.around);
        }
        cameraForBoxAndBearing(e2, t2, i2, r2, o2) {
          return Bt2(e2, t2, i2, r2, o2);
        }
        handleJumpToCenterZoom(e2, i2) {
          e2.zoom !== (i2.zoom !== undefined ? +i2.zoom : e2.zoom) && e2.setZoom(+i2.zoom), i2.center !== undefined && e2.setCenter(t.Q.convert(i2.center));
        }
        handleEaseTo(e2, i2) {
          const { zoom: r2, padding: o2 } = e2, a2 = { roll: e2.roll, pitch: e2.pitch, bearing: e2.bearing }, s2 = { roll: i2.roll === undefined ? e2.roll : i2.roll, pitch: i2.pitch === undefined ? e2.pitch : i2.pitch, bearing: i2.bearing === undefined ? e2.bearing : i2.bearing }, n2 = i2.zoom !== undefined, l3 = !e2.isPaddingEqual(i2.padding);
          let c2 = false;
          const h2 = n2 ? +i2.zoom : e2.zoom;
          let u2 = e2.centerPoint.add(i2.offsetAsPoint);
          const d2 = e2.screenPointToLocation(u2), { center: _2, zoom: p2 } = e2.getConstrained(t.Q.convert(i2.center || d2), h2 != null ? h2 : r2);
          Et2(e2, _2);
          const m2 = ce2(e2.worldSize, d2), f2 = ce2(e2.worldSize, _2).sub(m2), g2 = t.ac(p2 - r2);
          return c2 = p2 !== r2, { easeFunc: (n3) => {
            if (c2 && e2.setZoom(t.B.number(r2, p2, n3)), t.b6(a2, s2) || Ft2({ startEulerAngles: a2, endEulerAngles: s2, tr: e2, k: n3, useSlerp: a2.roll != s2.roll }), l3 && (e2.interpolatePadding(o2, i2.padding, n3), u2 = e2.centerPoint.add(i2.offsetAsPoint)), i2.around)
              e2.setLocationAtPoint(i2.around, i2.aroundPoint);
            else {
              const i3 = t.ac(e2.zoom - r2), o3 = p2 > r2 ? Math.min(2, g2) : Math.max(0.5, g2), a3 = Math.pow(o3, 1 - n3), s3 = he2(e2.worldSize, m2.add(f2.mult(n3 * a3)).mult(i3));
              e2.setLocationAtPoint(e2.renderWorldCopies ? s3.wrap() : s3, u2);
            }
          }, isZooming: c2, elevationCenter: _2 };
        }
        handleFlyTo(e2, i2) {
          const r2 = i2.zoom !== undefined, o2 = e2.zoom, a2 = e2.getConstrained(t.Q.convert(i2.center || i2.locationAtOffset), r2 ? +i2.zoom : o2), s2 = a2.center, n2 = a2.zoom;
          Et2(e2, s2);
          const l3 = ce2(e2.worldSize, i2.locationAtOffset), c2 = ce2(e2.worldSize, s2).sub(l3), h2 = c2.mag(), u2 = t.ac(n2 - o2);
          let d2;
          if (i2.minZoom !== undefined) {
            const r3 = Math.min(+i2.minZoom, o2, n2), a3 = e2.getConstrained(s2, r3).zoom;
            d2 = t.ac(a3 - o2);
          }
          return { easeFunc: (i3, r3, a3, h3) => {
            e2.setZoom(i3 === 1 ? n2 : o2 + t.ah(r3));
            const u3 = i3 === 1 ? s2 : he2(e2.worldSize, l3.add(c2.mult(a3)).mult(r3));
            e2.setLocationAtPoint(e2.renderWorldCopies ? u3.wrap() : u3, h3);
          }, scaleOfZoom: u2, targetCenter: s2, scaleOfMinZoom: d2, pixelPathLength: h2 };
        }
      }

      class jt2 {
        constructor(e2, t2, i2) {
          this.blendFunction = e2, this.blendColor = t2, this.mask = i2;
        }
      }
      jt2.Replace = [1, 0], jt2.disabled = new jt2(jt2.Replace, t.b7.transparent, [false, false, false, false]), jt2.unblended = new jt2(jt2.Replace, t.b7.transparent, [true, true, true, true]), jt2.alphaBlended = new jt2([1, 771], t.b7.transparent, [true, true, true, true]);
      const Zt2 = 2305;

      class Nt2 {
        constructor(e2, t2, i2) {
          this.enable = e2, this.mode = t2, this.frontFace = i2;
        }
      }
      Nt2.disabled = new Nt2(false, 1029, Zt2), Nt2.backCCW = new Nt2(true, 1029, Zt2), Nt2.frontCCW = new Nt2(true, 1028, Zt2);

      class Ut {
        constructor(e2, t2, i2) {
          this.func = e2, this.mask = t2, this.range = i2;
        }
      }
      Ut.ReadOnly = false, Ut.ReadWrite = true, Ut.disabled = new Ut(519, Ut.ReadOnly, [0, 1]);
      const Gt2 = 7680;

      class Vt2 {
        constructor(e2, t2, i2, r2, o2, a2) {
          this.test = e2, this.ref = t2, this.mask = i2, this.fail = r2, this.depthFail = o2, this.pass = a2;
        }
      }
      Vt2.disabled = new Vt2({ func: 519, mask: 0 }, 0, 0, Gt2, Gt2, Gt2);
      const qt2 = new WeakMap;
      function Wt2(e2) {
        var t2;
        if (qt2.has(e2))
          return qt2.get(e2);
        {
          const i2 = (t2 = e2.getParameter(e2.VERSION)) === null || t2 === undefined ? undefined : t2.startsWith("WebGL 2.0");
          return qt2.set(e2, i2), i2;
        }
      }

      class Ht2 {
        get awaitingQuery() {
          return !!this._readbackQueue;
        }
        constructor(e2) {
          this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1000, this._readbackQueue = null, this._cachedRenderContext = e2;
          const i2 = e2.context, r2 = i2.gl;
          this._texFormat = r2.RGBA, this._texType = r2.UNSIGNED_BYTE;
          const o2 = new t.aI;
          o2.emplaceBack(-1, -1), o2.emplaceBack(2, -1), o2.emplaceBack(-1, 2);
          const a2 = new t.aK;
          a2.emplaceBack(0, 1, 2), this._fullscreenTriangle = new wt(i2.createVertexBuffer(o2, Tt2.members), i2.createIndexBuffer(a2), t.aJ.simpleSegment(0, 0, o2.length, a2.length)), this._resultBuffer = new Uint8Array(4), i2.activeTexture.set(r2.TEXTURE1);
          const s2 = r2.createTexture();
          r2.bindTexture(r2.TEXTURE_2D, s2), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, r2.CLAMP_TO_EDGE), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, r2.CLAMP_TO_EDGE), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.NEAREST), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.NEAREST), r2.texImage2D(r2.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i2.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(s2), Wt2(r2) && (this._pbo = r2.createBuffer(), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, this._pbo), r2.bufferData(r2.PIXEL_PACK_BUFFER, 4, r2.STREAM_READ), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, null));
        }
        destroy() {
          const e2 = this._cachedRenderContext.context.gl;
          this._fullscreenTriangle.destroy(), this._fbo.destroy(), e2.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
        }
        updateErrorLoop(e2, t2) {
          const i2 = this._updateCount;
          return this._readbackQueue ? i2 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i2 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e2, t2), this._updateCount++, this._measuredError;
        }
        _bindFramebuffer() {
          const e2 = this._cachedRenderContext.context, t2 = e2.gl;
          e2.activeTexture.set(t2.TEXTURE1), t2.bindTexture(t2.TEXTURE_2D, this._fbo.colorAttachment.get()), e2.bindFramebuffer.set(this._fbo.framebuffer);
        }
        _renderErrorTexture(e2, i2) {
          const r2 = this._cachedRenderContext.context, o2 = r2.gl;
          if (this._bindFramebuffer(), r2.viewport.set([0, 0, this._texWidth, this._texHeight]), r2.clear({ color: t.b7.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(r2, o2.TRIANGLES, Ut.disabled, Vt2.disabled, jt2.unblended, Nt2.disabled, ((e3, t2) => ({ u_input: e3, u_output_expected: t2 }))(e2, i2), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Wt2(o2)) {
            o2.bindBuffer(o2.PIXEL_PACK_BUFFER, this._pbo), o2.readBuffer(o2.COLOR_ATTACHMENT0), o2.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), o2.bindBuffer(o2.PIXEL_PACK_BUFFER, null);
            const e3 = o2.fenceSync(o2.SYNC_GPU_COMMANDS_COMPLETE, 0);
            o2.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: e3 };
          } else
            this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
        }
        _tryReadback() {
          const e2 = this._cachedRenderContext.context.gl;
          if (this._pbo && this._readbackQueue && Wt2(e2)) {
            const i2 = e2.clientWaitSync(this._readbackQueue.sync, 0, 0);
            if (i2 === e2.WAIT_FAILED)
              return t.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
            if (i2 === e2.TIMEOUT_EXPIRED)
              return;
            e2.bindBuffer(e2.PIXEL_PACK_BUFFER, this._pbo), e2.getBufferSubData(e2.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e2.bindBuffer(e2.PIXEL_PACK_BUFFER, null);
          } else
            this._bindFramebuffer(), e2.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
          this._readbackQueue = null, this._measuredError = Ht2._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
        }
        static _parseRGBA8float(e2) {
          let t2 = 0;
          return t2 += e2[0] / 256, t2 += e2[1] / 65536, t2 += e2[2] / 16777216, e2[3] < 127 && (t2 = -t2), t2 / 128;
        }
      }
      const $t2 = t.Z / 128;
      function Xt2(e2, i2) {
        const r2 = e2.granularity !== undefined ? Math.max(e2.granularity, 1) : 1, o2 = r2 + (e2.generateBorders ? 2 : 0), a2 = r2 + (e2.extendToNorthPole || e2.generateBorders ? 1 : 0) + (e2.extendToSouthPole || e2.generateBorders ? 1 : 0), s2 = o2 + 1, n2 = a2 + 1, l3 = e2.generateBorders ? -1 : 0, c2 = e2.generateBorders || e2.extendToNorthPole ? -1 : 0, h2 = r2 + (e2.generateBorders ? 1 : 0), u2 = r2 + (e2.generateBorders || e2.extendToSouthPole ? 1 : 0), d2 = s2 * n2, _2 = o2 * a2 * 6, p2 = s2 * n2 > 65536;
        if (p2 && i2 === "16bit")
          throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
        const m2 = p2 || i2 === "32bit", f2 = new Int16Array(2 * d2);
        let g2 = 0;
        for (let i3 = c2;i3 <= u2; i3++)
          for (let o3 = l3;o3 <= h2; o3++) {
            let a3 = o3 / r2 * t.Z;
            o3 === -1 && (a3 = -64), o3 === r2 + 1 && (a3 = t.Z + $t2);
            let s3 = i3 / r2 * t.Z;
            i3 === -1 && (s3 = e2.extendToNorthPole ? t.b9 : -64), i3 === r2 + 1 && (s3 = e2.extendToSouthPole ? t.ba : t.Z + $t2), f2[g2++] = a3, f2[g2++] = s3;
          }
        const v2 = m2 ? new Uint32Array(_2) : new Uint16Array(_2);
        let x2 = 0;
        for (let e3 = 0;e3 < a2; e3++)
          for (let t2 = 0;t2 < o2; t2++) {
            const i3 = t2 + 1 + e3 * s2, r3 = t2 + (e3 + 1) * s2, o3 = t2 + 1 + (e3 + 1) * s2;
            v2[x2++] = t2 + e3 * s2, v2[x2++] = r3, v2[x2++] = i3, v2[x2++] = i3, v2[x2++] = r3, v2[x2++] = o3;
          }
        return { vertices: f2.buffer.slice(0), indices: v2.buffer.slice(0), uses32bitIndices: m2 };
      }
      const Kt2 = new t.aH({ fill: new t.bb(128, 2), line: new t.bb(512, 0), tile: new t.bb(128, 32), stencil: new t.bb(128, 1), circle: 3 });

      class Qt2 {
        constructor() {
          this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1000;
        }
        get name() {
          return "vertical-perspective";
        }
        get transitionState() {
          return 1;
        }
        get useSubdivision() {
          return true;
        }
        get shaderVariantName() {
          return "globe";
        }
        get shaderDefine() {
          return "#define GLOBE";
        }
        get shaderPreludeCode() {
          return bt2.projectionGlobe;
        }
        get vertexShaderPreludeCode() {
          return bt2.projectionMercator.vertexSource;
        }
        get subdivisionGranularity() {
          return Kt2;
        }
        get useGlobeControls() {
          return true;
        }
        get latitudeErrorCorrectionRadians() {
          return this._errorCorrectionUsable;
        }
        destroy() {
          this._errorMeasurement && this._errorMeasurement.destroy();
        }
        updateGPUdependent(e2) {
          this._errorMeasurement || (this._errorMeasurement = new Ht2(e2));
          const i2 = t.S(this._errorQueryLatitudeDegrees), r2 = 2 * Math.atan(Math.exp(Math.PI - i2 * Math.PI * 2)) - 0.5 * Math.PI, o2 = this._errorMeasurement.updateErrorLoop(i2, r2), a2 = s.now();
          o2 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = o2, this._errorMeasurementLastChangeTime = a2);
          const n2 = Math.min(Math.max((a2 - this._errorMeasurementLastChangeTime) / 1000 / 0.5, 0), 1);
          this._errorCorrectionUsable = t.bc(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t.bd(n2));
        }
        _getMeshKey(e2) {
          return `${e2.granularity.toString(36)}_${e2.generateBorders ? "b" : ""}${e2.extendToNorthPole ? "n" : ""}${e2.extendToSouthPole ? "s" : ""}`;
        }
        getMeshFromTileID(e2, t2, i2, r2, o2) {
          const a2 = (o2 === "stencil" ? Kt2.stencil : Kt2.tile).getGranularityForZoomLevel(t2.z);
          return this._getMesh(e2, { granularity: a2, generateBorders: i2, extendToNorthPole: t2.y === 0 && r2, extendToSouthPole: t2.y === (1 << t2.z) - 1 && r2 });
        }
        _getMesh(e2, i2) {
          const r2 = this._getMeshKey(i2);
          if (r2 in this._tileMeshCache)
            return this._tileMeshCache[r2];
          const o2 = function(e3, i3) {
            const r3 = Xt2(i3, "16bit"), o3 = t.aI.deserialize({ arrayBuffer: r3.vertices, length: r3.vertices.byteLength / 2 / 2 }), a2 = t.aK.deserialize({ arrayBuffer: r3.indices, length: r3.indices.byteLength / 2 / 3 });
            return new wt(e3.createVertexBuffer(o3, Tt2.members), e3.createIndexBuffer(a2), t.aJ.simpleSegment(0, 0, o3.length, a2.length));
          }(e2, i2);
          return this._tileMeshCache[r2] = o2, o2;
        }
        recalculate(e2) {
        }
        hasTransition() {
          const e2 = s.now();
          let t2 = false;
          return t2 = t2 || (e2 - this._errorMeasurementLastChangeTime) / 1000 < 0.7, t2 = t2 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t2;
        }
        setErrorQueryLatitudeDegrees(e2) {
          this._errorQueryLatitudeDegrees = e2;
        }
      }
      const Yt2 = new t.r({ type: new t.D(t.v.projection.type) });

      class Jt2 extends t.E {
        constructor(e2) {
          super(), this._transitionable = new t.T(Yt2), this.setProjection(e2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.C(0)), this._mercatorProjection = new Mt2, this._verticalPerspectiveProjection = new Qt2;
        }
        get transitionState() {
          const e2 = this.properties.get("type");
          if (typeof e2 == "string" && e2 === "mercator")
            return 0;
          if (typeof e2 == "string" && e2 === "vertical-perspective")
            return 1;
          if (e2 instanceof t.be) {
            if (e2.from === "vertical-perspective" && e2.to === "mercator")
              return 1 - e2.transition;
            if (e2.from === "mercator" && e2.to === "vertical-perspective")
              return e2.transition;
          }
          return 1;
        }
        get useGlobeRendering() {
          return this.transitionState > 0;
        }
        get latitudeErrorCorrectionRadians() {
          return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
        }
        get currentProjection() {
          return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
        }
        get name() {
          return "globe";
        }
        get useSubdivision() {
          return this.currentProjection.useSubdivision;
        }
        get shaderVariantName() {
          return this.currentProjection.shaderVariantName;
        }
        get shaderDefine() {
          return this.currentProjection.shaderDefine;
        }
        get shaderPreludeCode() {
          return this.currentProjection.shaderPreludeCode;
        }
        get vertexShaderPreludeCode() {
          return this.currentProjection.vertexShaderPreludeCode;
        }
        get subdivisionGranularity() {
          return this.currentProjection.subdivisionGranularity;
        }
        get useGlobeControls() {
          return this.transitionState > 0;
        }
        destroy() {
          this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
        }
        updateGPUdependent(e2) {
          this._mercatorProjection.updateGPUdependent(e2), this._verticalPerspectiveProjection.updateGPUdependent(e2);
        }
        getMeshFromTileID(e2, t2, i2, r2, o2) {
          return this.currentProjection.getMeshFromTileID(e2, t2, i2, r2, o2);
        }
        setProjection(e2) {
          this._transitionable.setValue("type", (e2 == null ? undefined : e2.type) || "mercator");
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        setErrorQueryLatitudeDegrees(e2) {
          this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e2), this._mercatorProjection.setErrorQueryLatitudeDegrees(e2);
        }
      }
      function ei2(e2) {
        const t2 = ri2(e2.worldSize, e2.center.lat);
        return 2 * Math.PI * t2;
      }
      function ti2(e2, i2, r2, o2, a2) {
        const s2 = 1 / (1 << a2), n2 = i2 / t.Z * s2 + o2 * s2, l3 = t.bg((e2 / t.Z * s2 + r2 * s2) * Math.PI * 2 + Math.PI, 2 * Math.PI), c2 = 2 * Math.atan(Math.exp(Math.PI - n2 * Math.PI * 2)) - 0.5 * Math.PI, h2 = Math.cos(c2), u2 = new Float64Array(3);
        return u2[0] = Math.sin(l3) * h2, u2[1] = Math.sin(c2), u2[2] = Math.cos(l3) * h2, u2;
      }
      function ii2(e2) {
        return function(e3, t2) {
          const i2 = Math.cos(t2), r2 = new Float64Array(3);
          return r2[0] = Math.sin(e3) * i2, r2[1] = Math.sin(t2), r2[2] = Math.cos(e3) * i2, r2;
        }(e2.lng * Math.PI / 180, e2.lat * Math.PI / 180);
      }
      function ri2(e2, t2) {
        return e2 / (2 * Math.PI) / Math.cos(t2 * Math.PI / 180);
      }
      function oi2(e2) {
        const i2 = Math.asin(e2[1]) / Math.PI * 180, r2 = Math.sqrt(e2[0] * e2[0] + e2[2] * e2[2]);
        if (r2 > 0.000001) {
          const o2 = e2[0] / r2, a2 = Math.acos(e2[2] / r2), s2 = (o2 > 0 ? a2 : -a2) / Math.PI * 180;
          return new t.Q(t.aL(s2, -180, 180), i2);
        }
        return new t.Q(0, i2);
      }
      function ai2(e2) {
        return Math.cos(e2 * Math.PI / 180);
      }
      function si2(e2, i2) {
        const r2 = ai2(e2), o2 = ai2(i2);
        return t.ah(o2 / r2);
      }
      function ni2(e2, i2) {
        const r2 = e2.rotate(i2.bearingInRadians), o2 = i2.zoom + si2(i2.center.lat, 0), a2 = t.bc(1 / ai2(i2.center.lat), 1 / ai2(Math.min(Math.abs(i2.center.lat), 60)), t.bf(o2, 7, 3, 0, 1)), s2 = 360 / ei2({ worldSize: i2.worldSize, center: { lat: i2.center.lat } });
        return new t.Q(i2.center.lng - r2.x * s2 * a2, t.ae(i2.center.lat + r2.y * s2, -85.051129, t.af));
      }
      function li2(e2) {
        const t2 = 0.5 * e2, i2 = Math.sin(t2), r2 = Math.cos(t2);
        return Math.log(i2 + r2) - Math.log(r2 - i2);
      }
      function ci2(e2, i2, r2, o2) {
        const a2 = e2.lat + r2 * o2;
        if (Math.abs(r2) > 1) {
          const s2 = (Math.sign(e2.lat + r2) !== Math.sign(e2.lat) ? -Math.abs(e2.lat) : Math.abs(e2.lat)) * Math.PI / 180, n2 = Math.abs(e2.lat + r2) * Math.PI / 180, l3 = li2(s2 + o2 * (n2 - s2)), c2 = li2(s2), h2 = li2(n2);
          return new t.Q(e2.lng + i2 * ((l3 - c2) / (h2 - c2)), a2);
        }
        return new t.Q(e2.lng + i2 * o2, a2);
      }

      class hi2 {
        constructor(e2) {
          this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = false, this._aabbFactory = e2;
        }
        recalculateCache() {
          if (!this._hadAnyChanges)
            return;
          const e2 = this._cachePrevious;
          this._cachePrevious = this._cache, this._cache = e2, this._cache.clear(), this._hadAnyChanges = false;
        }
        getTileAABB(e2, t2, i2, r2) {
          const o2 = `${e2.z}_${e2.x}_${e2.y}`, a2 = this._cache.get(o2);
          if (a2)
            return a2;
          const s2 = this._cachePrevious.get(o2);
          if (s2)
            return this._cache.set(o2, s2), s2;
          const n2 = this._aabbFactory(e2, t2, i2, r2);
          return this._cache.set(o2, n2), this._hadAnyChanges = true, n2;
        }
      }
      function ui2(e2, t2, i2) {
        const r2 = e2 - t2;
        return r2 < 0 ? -r2 : Math.max(0, r2 - i2);
      }
      function di2(e2, t2, i2, r2, o2) {
        const a2 = e2 - i2;
        let s2;
        return s2 = a2 < 0 ? Math.min(-a2, 1 + a2 - o2) : a2 > 1 ? Math.min(Math.max(a2 - o2, 0), 1 - a2) : 0, Math.max(s2, ui2(t2, r2, o2));
      }

      class _i2 {
        constructor() {
          this._aabbCache = new hi2(this._computeTileAABB);
        }
        recalculateCache() {
          this._aabbCache.recalculateCache();
        }
        distanceToTile2d(e2, t2, i2, r2) {
          const o2 = 1 << i2.z, a2 = 1 / o2, s2 = i2.x / o2, n2 = i2.y / o2;
          let l3 = 2;
          return l3 = Math.min(l3, di2(e2, t2, s2, n2, a2)), l3 = Math.min(l3, di2(e2, t2, s2 + 0.5, -n2 - a2, a2)), l3 = Math.min(l3, di2(e2, t2, s2 + 0.5, 2 - n2 - a2, a2)), l3;
        }
        getWrap(e2, t2, i2) {
          const r2 = 1 << t2.z, o2 = 1 / r2, a2 = t2.x / r2, s2 = ui2(e2.x, a2, o2), n2 = ui2(e2.x, a2 - 1, o2), l3 = ui2(e2.x, a2 + 1, o2), c2 = Math.min(s2, n2, l3);
          return c2 === l3 ? 1 : c2 === n2 ? -1 : 0;
        }
        allowVariableZoom(e2, t2) {
          return ve2(e2, t2) > 4;
        }
        allowWorldCopies() {
          return false;
        }
        getTileAABB(e2, t2, i2, r2) {
          return this._aabbCache.getTileAABB(e2, t2, i2, r2);
        }
        _computeTileAABB(e2, i2, r2, o2) {
          if (e2.z <= 0)
            return new zt2([-1, -1, -1], [1, 1, 1]);
          if (e2.z === 1)
            return new zt2([e2.x === 0 ? -1 : 0, e2.y === 0 ? 0 : -1, -1], [e2.x === 0 ? 0 : 1, e2.y === 0 ? 1 : 0, 1]);
          {
            const i3 = [ti2(0, 0, e2.x, e2.y, e2.z), ti2(t.Z, 0, e2.x, e2.y, e2.z), ti2(t.Z, t.Z, e2.x, e2.y, e2.z), ti2(0, t.Z, e2.x, e2.y, e2.z)], r3 = [1, 1, 1], o3 = [-1, -1, -1];
            for (const e3 of i3)
              for (let t2 = 0;t2 < 3; t2++)
                r3[t2] = Math.min(r3[t2], e3[t2]), o3[t2] = Math.max(o3[t2], e3[t2]);
            if (e2.y === 0 || e2.y === (1 << e2.z) - 1) {
              const t2 = [0, e2.y === 0 ? 1 : -1, 0];
              for (let e3 = 0;e3 < 3; e3++)
                r3[e3] = Math.min(r3[e3], t2[e3]), o3[e3] = Math.max(o3[e3], t2[e3]);
            }
            return new zt2(r3, o3);
          }
        }
      }

      class pi2 {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(e2) {
          this._helper.setMinZoom(e2);
        }
        setMaxZoom(e2) {
          this._helper.setMaxZoom(e2);
        }
        setMinPitch(e2) {
          this._helper.setMinPitch(e2);
        }
        setMaxPitch(e2) {
          this._helper.setMaxPitch(e2);
        }
        setRenderWorldCopies(e2) {
          this._helper.setRenderWorldCopies(e2);
        }
        setBearing(e2) {
          this._helper.setBearing(e2);
        }
        setPitch(e2) {
          this._helper.setPitch(e2);
        }
        setRoll(e2) {
          this._helper.setRoll(e2);
        }
        setFov(e2) {
          this._helper.setFov(e2);
        }
        setZoom(e2) {
          this._helper.setZoom(e2);
        }
        setCenter(e2) {
          this._helper.setCenter(e2);
        }
        setElevation(e2) {
          this._helper.setElevation(e2);
        }
        setMinElevationForCurrentTile(e2) {
          this._helper.setMinElevationForCurrentTile(e2);
        }
        setPadding(e2) {
          this._helper.setPadding(e2);
        }
        interpolatePadding(e2, t2, i2) {
          return this._helper.interpolatePadding(e2, t2, i2);
        }
        isPaddingEqual(e2) {
          return this._helper.isPaddingEqual(e2);
        }
        resize(e2, t2) {
          this._helper.resize(e2, t2);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(e2) {
          this._helper.setMaxBounds(e2);
        }
        overrideNearFarZ(e2, t2) {
          this._helper.overrideNearFarZ(e2, t2);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(e2) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        setTransitionState(e2) {
        }
        constructor() {
          this._cachedClippingPlane = t.bk(), this._projectionMatrix = t.b1(), this._globeViewProjMatrix32f = t.b0(), this._globeViewProjMatrixNoCorrection = t.b1(), this._globeViewProjMatrixNoCorrectionInverted = t.b1(), this._globeProjMatrixInverted = t.b1(), this._cameraPosition = t.bh(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Rt2({ calcMatrices: () => {
            this._calcMatrices();
          }, getConstrained: (e2, t2) => this.getConstrained(e2, t2) }), this._coveringTilesDetailsProvider = new _i2;
        }
        clone() {
          const e2 = new pi2;
          return e2.apply(this), e2;
        }
        apply(e2, t2) {
          this._globeLatitudeErrorCorrectionRadians = t2 || 0, this._helper.apply(e2);
        }
        get projectionMatrix() {
          return this._projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this._globeViewProjMatrixNoCorrection;
        }
        get inverseProjectionMatrix() {
          return this._globeProjMatrixInverted;
        }
        get cameraPosition() {
          const e2 = t.bh();
          return e2[0] = this._cameraPosition[0], e2[1] = this._cameraPosition[1], e2[2] = this._cameraPosition[2], e2;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        getProjectionData(e2) {
          const { overscaledTileID: t2, applyGlobeMatrix: i2 } = e2, r2 = this._helper.getMercatorTileCoordinates(t2);
          return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: r2, clippingPlane: this._cachedClippingPlane, projectionTransition: i2 ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
        }
        _computeClippingPlane(e2) {
          const i2 = this.pitchInRadians, r2 = this.cameraToCenterDistance / e2, o2 = Math.sin(i2) * r2, a2 = Math.cos(i2) * r2 + 1, s2 = 1 / Math.sqrt(o2 * o2 + a2 * a2) * 1;
          let n2 = -o2, l3 = a2;
          const c2 = Math.sqrt(n2 * n2 + l3 * l3);
          n2 /= c2, l3 /= c2;
          const h2 = [0, n2, l3];
          t.bl(h2, h2, [0, 0, 0], -this.bearingInRadians), t.bm(h2, h2, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), t.bn(h2, h2, [0, 0, 0], this.center.lng * Math.PI / 180);
          const u2 = 1 / t.bo(h2);
          return t.aO(h2, h2, u2), [...h2, -s2 * u2];
        }
        isLocationOccluded(e2) {
          return !this.isSurfacePointVisible(ii2(e2));
        }
        transformLightDirection(e2) {
          const i2 = this._helper._center.lng * Math.PI / 180, r2 = this._helper._center.lat * Math.PI / 180, o2 = Math.cos(r2), a2 = [Math.sin(i2) * o2, Math.sin(r2), Math.cos(i2) * o2], s2 = [a2[2], 0, -a2[0]], n2 = [0, 0, 0];
          t.aU(n2, s2, a2), t.aT(s2, s2), t.aT(n2, n2);
          const l3 = [0, 0, 0];
          return t.aT(l3, [s2[0] * e2[0] + n2[0] * e2[1] + a2[0] * e2[2], s2[1] * e2[0] + n2[1] * e2[1] + a2[1] * e2[2], s2[2] * e2[0] + n2[2] * e2[1] + a2[2] * e2[2]]), l3;
        }
        getPixelScale() {
          return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
        }
        getCircleRadiusCorrection() {
          return Math.cos(this._helper._center.lat * Math.PI / 180);
        }
        getPitchedTextCorrection(e2, i2, r2) {
          const o2 = function(e3, i3, r3) {
            const o3 = 1 / (1 << r3.z);
            return new t.$(e3 / t.Z * o3 + r3.x * o3, i3 / t.Z * o3 + r3.y * o3);
          }(e2, i2, r2.canonical), a2 = (s2 = o2.y, [t.bg(o2.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s2 * Math.PI * 2)) - 0.5 * Math.PI]);
          var s2;
          return this.getCircleRadiusCorrection() / Math.cos(a2[1]);
        }
        projectTileCoordinates(e2, i2, r2, o2) {
          const a2 = r2.canonical, s2 = ti2(e2, i2, a2.x, a2.y, a2.z), n2 = 1 + (o2 ? o2(e2, i2) : 0) / t.bu, l3 = [s2[0] * n2, s2[1] * n2, s2[2] * n2, 1];
          t.at(l3, l3, this._globeViewProjMatrixNoCorrection);
          const c2 = this._cachedClippingPlane, h2 = c2[0] * s2[0] + c2[1] * s2[1] + c2[2] * s2[2] + c2[3] < 0;
          return { point: new t.P(l3[0] / l3[3], l3[1] / l3[3]), signedDistanceFromCamera: l3[3], isOccluded: h2 };
        }
        _calcMatrices() {
          if (!this._helper._width || !this._helper._height)
            return;
          const e2 = ri2(this.worldSize, this.center.lat), i2 = t.b2(), r2 = t.b2();
          this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e2), t.aY(i2, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
          const o2 = this.centerOffset;
          i2[8] = 2 * -o2.x / this._helper._width, i2[9] = 2 * o2.y / this._helper._height, this._projectionMatrix = t.aZ(i2), this._globeProjMatrixInverted = t.b2(), t.an(this._globeProjMatrixInverted, i2), t.L(i2, i2, [0, 0, -this.cameraToCenterDistance]), t.a_(i2, i2, this.rollInRadians), t.a$(i2, i2, -this.pitchInRadians), t.a_(i2, i2, this.bearingInRadians), t.L(i2, i2, [0, 0, -e2]);
          const a2 = t.bh();
          a2[0] = e2, a2[1] = e2, a2[2] = e2, t.a$(r2, i2, this.center.lat * Math.PI / 180), t.bp(r2, r2, -this.center.lng * Math.PI / 180), t.M(r2, r2, a2), this._globeViewProjMatrixNoCorrection = r2, t.a$(i2, i2, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t.bp(i2, i2, -this.center.lng * Math.PI / 180), t.M(i2, i2, a2), this._globeViewProjMatrix32f = new Float32Array(i2), this._globeViewProjMatrixNoCorrectionInverted = t.b2(), t.an(this._globeViewProjMatrixNoCorrectionInverted, r2);
          const s2 = t.bh();
          this._cameraPosition = t.bh(), this._cameraPosition[2] = this.cameraToCenterDistance / e2, t.bl(this._cameraPosition, this._cameraPosition, s2, -this.rollInRadians), t.bm(this._cameraPosition, this._cameraPosition, s2, this.pitchInRadians), t.bl(this._cameraPosition, this._cameraPosition, s2, -this.bearingInRadians), t.aP(this._cameraPosition, this._cameraPosition, [0, 0, 1]), t.bm(this._cameraPosition, this._cameraPosition, s2, -this.center.lat * Math.PI / 180), t.bn(this._cameraPosition, this._cameraPosition, s2, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e2);
          const n2 = t.aZ(this._globeViewProjMatrixNoCorrectionInverted);
          t.M(n2, n2, [1, 1, -1]), this._cachedFrustum = At2.fromInvProjectionMatrix(n2);
        }
        calculateFogMatrix(e2) {
          t.w("calculateFogMatrix is not supported on globe projection.");
          const i2 = t.b2();
          return t.ad(i2), i2;
        }
        getVisibleUnwrappedCoordinates(e2) {
          return [new t.aW(0, e2)];
        }
        getCameraFrustum() {
          return this._cachedFrustum;
        }
        getClippingPlane() {
          return this._cachedClippingPlane;
        }
        getCoveringTilesDetailsProvider() {
          return this._coveringTilesDetailsProvider;
        }
        recalculateZoomAndCenter(e2) {
          e2 && t.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
        }
        maxPitchScaleFactor() {
          return 1;
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          return this._helper.getCameraLngLat();
        }
        lngLatToCameraDepth(e2, i2) {
          if (!this._globeViewProjMatrixNoCorrection)
            return 1;
          const r2 = ii2(e2);
          t.aO(r2, r2, 1 + i2 / t.bu);
          const o2 = t.bk();
          return t.at(o2, [r2[0], r2[1], r2[2], 1], this._globeViewProjMatrixNoCorrection), o2[2] / o2[3];
        }
        populateCache(e2) {
        }
        getBounds() {
          const e2 = 0.5 * this.width, i2 = 0.5 * this.height, r2 = [new t.P(0, 0), new t.P(e2, 0), new t.P(this.width, 0), new t.P(this.width, i2), new t.P(this.width, this.height), new t.P(e2, this.height), new t.P(0, this.height), new t.P(0, i2)], o2 = [];
          for (const e3 of r2)
            o2.push(this.unprojectScreenPoint(e3));
          let a2 = 0, s2 = 0, n2 = 0, l3 = 0;
          const c2 = this.center;
          for (const e3 of o2) {
            const i3 = t.bq(c2.lng, e3.lng), r3 = t.bq(c2.lat, e3.lat);
            i3 < s2 && (s2 = i3), i3 > a2 && (a2 = i3), r3 < l3 && (l3 = r3), r3 > n2 && (n2 = r3);
          }
          const h2 = [c2.lng + s2, c2.lat + l3, c2.lng + a2, c2.lat + n2];
          return this.isSurfacePointOnScreen([0, 1, 0]) && (h2[3] = 90, h2[0] = -180, h2[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (h2[1] = -90, h2[0] = -180, h2[2] = 180), new V(h2);
        }
        getConstrained(e2, i2) {
          const r2 = t.ae(e2.lat, -85.051129, t.af), o2 = t.ae(+i2, this.minZoom + si2(0, r2), this.maxZoom);
          return { center: new t.Q(e2.lng, r2), zoom: o2 };
        }
        calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2) {
          return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2);
        }
        setLocationAtPoint(e2, i2) {
          const r2 = ii2(this.unprojectScreenPoint(i2)), o2 = ii2(e2), a2 = t.bh();
          t.br(a2);
          const s2 = t.bh();
          t.bn(s2, r2, a2, -this.center.lng * Math.PI / 180), t.bm(s2, s2, a2, this.center.lat * Math.PI / 180);
          const n2 = o2[0] * o2[0] + o2[2] * o2[2], l3 = s2[0] * s2[0];
          if (n2 < l3)
            return;
          const c2 = Math.sqrt(n2 - l3), h2 = -c2, u2 = t.bs(o2[0], o2[2], s2[0], c2), d2 = t.bs(o2[0], o2[2], s2[0], h2), _2 = t.bh();
          t.bn(_2, o2, a2, -u2);
          const p2 = t.bs(_2[1], _2[2], s2[1], s2[2]), m2 = t.bh();
          t.bn(m2, o2, a2, -d2);
          const f2 = t.bs(m2[1], m2[2], s2[1], s2[2]), g2 = 0.5 * Math.PI, v2 = p2 >= -g2 && p2 <= g2, x2 = f2 >= -g2 && f2 <= g2;
          let b2, y2;
          if (v2 && x2) {
            const e3 = this.center.lng * Math.PI / 180, i3 = this.center.lat * Math.PI / 180;
            t.bv(u2, e3) + t.bv(p2, i3) < t.bv(d2, e3) + t.bv(f2, i3) ? (b2 = u2, y2 = p2) : (b2 = d2, y2 = f2);
          } else if (v2)
            b2 = u2, y2 = p2;
          else {
            if (!x2)
              return;
            b2 = d2, y2 = f2;
          }
          const w2 = b2 / Math.PI * 180, T2 = y2 / Math.PI * 180, P2 = this.center.lat;
          this.setCenter(new t.Q(w2, t.ae(T2, -90, 90))), this.setZoom(this.zoom + si2(P2, this.center.lat));
        }
        locationToScreenPoint(e2, i2) {
          const r2 = ii2(e2);
          if (i2) {
            const o2 = i2.getElevationForLngLatZoom(e2, this._helper._tileZoom);
            t.aO(r2, r2, 1 + o2 / t.bu);
          }
          return this._projectSurfacePointToScreen(r2);
        }
        _projectSurfacePointToScreen(e2) {
          const i2 = t.bk();
          return t.at(i2, [...e2, 1], this._globeViewProjMatrixNoCorrection), i2[0] /= i2[3], i2[1] /= i2[3], new t.P((0.5 * i2[0] + 0.5) * this.width, (0.5 * -i2[1] + 0.5) * this.height);
        }
        screenPointToMercatorCoordinate(e2, i2) {
          if (i2) {
            const t2 = i2.pointCoordinate(e2);
            if (t2)
              return t2;
          }
          return t.$.fromLngLat(this.unprojectScreenPoint(e2));
        }
        screenPointToLocation(e2, t2) {
          var i2;
          return (i2 = this.screenPointToMercatorCoordinate(e2, t2)) === null || i2 === undefined ? undefined : i2.toLngLat();
        }
        isPointOnMapSurface(e2, t2) {
          const i2 = this._cameraPosition, r2 = this.getRayDirectionFromPixel(e2);
          return !!this.rayPlanetIntersection(i2, r2);
        }
        getRayDirectionFromPixel(e2) {
          const i2 = t.bk();
          i2[0] = e2.x / this.width * 2 - 1, i2[1] = -1 * (e2.y / this.height * 2 - 1), i2[2] = 1, i2[3] = 1, t.at(i2, i2, this._globeViewProjMatrixNoCorrectionInverted), i2[0] /= i2[3], i2[1] /= i2[3], i2[2] /= i2[3];
          const r2 = t.bh();
          r2[0] = i2[0] - this._cameraPosition[0], r2[1] = i2[1] - this._cameraPosition[1], r2[2] = i2[2] - this._cameraPosition[2];
          const o2 = t.bh();
          return t.aT(o2, r2), o2;
        }
        isSurfacePointVisible(e2) {
          const t2 = this._cachedClippingPlane;
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] >= 0;
        }
        isSurfacePointOnScreen(e2) {
          if (!this.isSurfacePointVisible(e2))
            return false;
          const i2 = t.bk();
          return t.at(i2, [...e2, 1], this._globeViewProjMatrixNoCorrection), i2[0] /= i2[3], i2[1] /= i2[3], i2[2] /= i2[3], i2[0] > -1 && i2[0] < 1 && i2[1] > -1 && i2[1] < 1 && i2[2] > -1 && i2[2] < 1;
        }
        rayPlanetIntersection(e2, i2) {
          const r2 = t.aV(e2, i2), o2 = t.bh(), a2 = t.bh();
          t.aO(a2, i2, r2), t.aS(o2, e2, a2);
          const s2 = 1 - t.aV(o2, o2);
          if (s2 < 0)
            return null;
          const n2 = t.aV(e2, e2) - 1, l3 = -r2 + (r2 < 0 ? 1 : -1) * Math.sqrt(s2), c2 = n2 / l3, h2 = l3;
          return { tMin: Math.min(c2, h2), tMax: Math.max(c2, h2) };
        }
        unprojectScreenPoint(e2) {
          const i2 = this._cameraPosition, r2 = this.getRayDirectionFromPixel(e2), o2 = this.rayPlanetIntersection(i2, r2);
          if (o2) {
            const e3 = t.bh();
            t.aP(e3, i2, [r2[0] * o2.tMin, r2[1] * o2.tMin, r2[2] * o2.tMin]);
            const a3 = t.bh();
            return t.aT(a3, e3), oi2(a3);
          }
          const a2 = this._cachedClippingPlane, s2 = a2[0] * r2[0] + a2[1] * r2[1] + a2[2] * r2[2], n2 = -t.bt(a2, i2) / s2, l3 = t.bh();
          if (n2 > 0)
            t.aP(l3, i2, [r2[0] * n2, r2[1] * n2, r2[2] * n2]);
          else {
            const e3 = t.bh();
            t.aP(e3, i2, [2 * r2[0], 2 * r2[1], 2 * r2[2]]);
            const o3 = t.bt(this._cachedClippingPlane, e3);
            t.aS(l3, e3, [this._cachedClippingPlane[0] * o3, this._cachedClippingPlane[1] * o3, this._cachedClippingPlane[2] * o3]);
          }
          const c2 = function(e3) {
            const i3 = t.bh();
            return i3[0] = e3[0] * -e3[3], i3[1] = e3[1] * -e3[3], i3[2] = e3[2] * -e3[3], { center: i3, radius: Math.sqrt(1 - e3[3] * e3[3]) };
          }(a2);
          return oi2(function(e3, i3, r3) {
            const o3 = t.bh();
            t.aS(o3, r3, e3);
            const a3 = t.bh();
            return t.bi(a3, e3, o3, i3 / t.bj(o3)), a3;
          }(c2.center, c2.radius, l3));
        }
        getMatrixForModel(e2, i2) {
          const r2 = t.Q.convert(e2), o2 = 1 / t.bu, a2 = t.b1();
          return t.bp(a2, a2, r2.lng / 180 * Math.PI), t.a$(a2, a2, -r2.lat / 180 * Math.PI), t.L(a2, a2, [0, 0, 1 + i2 / t.bu]), t.a$(a2, a2, 0.5 * Math.PI), t.M(a2, a2, [o2, o2, o2]), a2;
        }
        getProjectionDataForCustomLayer(e2 = true) {
          const i2 = this.getProjectionData({ overscaledTileID: new t.Y(0, 0, 0, 0, 0), applyGlobeMatrix: e2 });
          return i2.tileMercatorCoords = [0, 0, 1, 1], i2;
        }
        getFastPathSimpleProjectionMatrix(e2) {
        }
      }

      class mi2 {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(e2) {
          this._helper.setMinZoom(e2);
        }
        setMaxZoom(e2) {
          this._helper.setMaxZoom(e2);
        }
        setMinPitch(e2) {
          this._helper.setMinPitch(e2);
        }
        setMaxPitch(e2) {
          this._helper.setMaxPitch(e2);
        }
        setRenderWorldCopies(e2) {
          this._helper.setRenderWorldCopies(e2);
        }
        setBearing(e2) {
          this._helper.setBearing(e2);
        }
        setPitch(e2) {
          this._helper.setPitch(e2);
        }
        setRoll(e2) {
          this._helper.setRoll(e2);
        }
        setFov(e2) {
          this._helper.setFov(e2);
        }
        setZoom(e2) {
          this._helper.setZoom(e2);
        }
        setCenter(e2) {
          this._helper.setCenter(e2);
        }
        setElevation(e2) {
          this._helper.setElevation(e2);
        }
        setMinElevationForCurrentTile(e2) {
          this._helper.setMinElevationForCurrentTile(e2);
        }
        setPadding(e2) {
          this._helper.setPadding(e2);
        }
        interpolatePadding(e2, t2, i2) {
          return this._helper.interpolatePadding(e2, t2, i2);
        }
        isPaddingEqual(e2) {
          return this._helper.isPaddingEqual(e2);
        }
        resize(e2, t2, i2 = true) {
          this._helper.resize(e2, t2, i2);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(e2) {
          this._helper.setMaxBounds(e2);
        }
        overrideNearFarZ(e2, t2) {
          this._helper.overrideNearFarZ(e2, t2);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(e2) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        get isGlobeRendering() {
          return this._globeness > 0;
        }
        setTransitionState(e2, t2) {
          this._globeness = e2, this._globeLatitudeErrorCorrectionRadians = t2, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(), this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache();
        }
        get currentTransform() {
          return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
        }
        constructor() {
          this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Rt2({ calcMatrices: () => {
            this._calcMatrices();
          }, getConstrained: (e2, t2) => this.getConstrained(e2, t2) }), this._globeness = 1, this._mercatorTransform = new Lt2, this._verticalPerspectiveTransform = new pi2;
        }
        clone() {
          const e2 = new mi2;
          return e2._globeness = this._globeness, e2._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e2.apply(this), e2;
        }
        apply(e2) {
          this._helper.apply(e2), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
        }
        get projectionMatrix() {
          return this.currentTransform.projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this.currentTransform.modelViewProjectionMatrix;
        }
        get inverseProjectionMatrix() {
          return this.currentTransform.inverseProjectionMatrix;
        }
        get cameraPosition() {
          return this.currentTransform.cameraPosition;
        }
        getProjectionData(e2) {
          const t2 = this._mercatorTransform.getProjectionData(e2), i2 = this._verticalPerspectiveTransform.getProjectionData(e2);
          return { mainMatrix: this.isGlobeRendering ? i2.mainMatrix : t2.mainMatrix, clippingPlane: i2.clippingPlane, tileMercatorCoords: i2.tileMercatorCoords, projectionTransition: e2.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: t2.fallbackMatrix };
        }
        isLocationOccluded(e2) {
          return this.currentTransform.isLocationOccluded(e2);
        }
        transformLightDirection(e2) {
          return this.currentTransform.transformLightDirection(e2);
        }
        getPixelScale() {
          return t.bc(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
        }
        getCircleRadiusCorrection() {
          return t.bc(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
        }
        getPitchedTextCorrection(e2, i2, r2) {
          const o2 = this._mercatorTransform.getPitchedTextCorrection(e2, i2, r2), a2 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e2, i2, r2);
          return t.bc(o2, a2, this._globeness);
        }
        projectTileCoordinates(e2, t2, i2, r2) {
          return this.currentTransform.projectTileCoordinates(e2, t2, i2, r2);
        }
        _calcMatrices() {
          this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
        }
        calculateFogMatrix(e2) {
          return this.currentTransform.calculateFogMatrix(e2);
        }
        getVisibleUnwrappedCoordinates(e2) {
          return this.currentTransform.getVisibleUnwrappedCoordinates(e2);
        }
        getCameraFrustum() {
          return this.currentTransform.getCameraFrustum();
        }
        getClippingPlane() {
          return this.currentTransform.getClippingPlane();
        }
        getCoveringTilesDetailsProvider() {
          return this.currentTransform.getCoveringTilesDetailsProvider();
        }
        recalculateZoomAndCenter(e2) {
          this._mercatorTransform.recalculateZoomAndCenter(e2), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e2);
        }
        maxPitchScaleFactor() {
          return this._mercatorTransform.maxPitchScaleFactor();
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          return this._helper.getCameraLngLat();
        }
        lngLatToCameraDepth(e2, t2) {
          return this.currentTransform.lngLatToCameraDepth(e2, t2);
        }
        populateCache(e2) {
          this._mercatorTransform.populateCache(e2), this._verticalPerspectiveTransform.populateCache(e2);
        }
        getBounds() {
          return this.currentTransform.getBounds();
        }
        getConstrained(e2, t2) {
          return this.currentTransform.getConstrained(e2, t2);
        }
        calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2) {
          return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2);
        }
        setLocationAtPoint(e2, t2) {
          if (!this.isGlobeRendering)
            return this._mercatorTransform.setLocationAtPoint(e2, t2), void this.apply(this._mercatorTransform);
          this._verticalPerspectiveTransform.setLocationAtPoint(e2, t2), this.apply(this._verticalPerspectiveTransform);
        }
        locationToScreenPoint(e2, t2) {
          return this.currentTransform.locationToScreenPoint(e2, t2);
        }
        screenPointToMercatorCoordinate(e2, t2) {
          return this.currentTransform.screenPointToMercatorCoordinate(e2, t2);
        }
        screenPointToLocation(e2, t2) {
          return this.currentTransform.screenPointToLocation(e2, t2);
        }
        isPointOnMapSurface(e2, t2) {
          return this.currentTransform.isPointOnMapSurface(e2, t2);
        }
        getRayDirectionFromPixel(e2) {
          return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e2);
        }
        getMatrixForModel(e2, t2) {
          return this.currentTransform.getMatrixForModel(e2, t2);
        }
        getProjectionDataForCustomLayer(e2 = true) {
          const t2 = this._mercatorTransform.getProjectionDataForCustomLayer(e2);
          if (!this.isGlobeRendering)
            return t2;
          const i2 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e2);
          return i2.fallbackMatrix = t2.mainMatrix, i2;
        }
        getFastPathSimpleProjectionMatrix(e2) {
          return this.currentTransform.getFastPathSimpleProjectionMatrix(e2);
        }
      }

      class fi2 {
        get useGlobeControls() {
          return true;
        }
        handlePanInertia(e2, i2) {
          const r2 = ni2(e2, i2);
          return Math.abs(r2.lng - i2.center.lng) > 180 && (r2.lng = i2.center.lng + 179.5 * Math.sign(r2.lng - i2.center.lng)), { easingCenter: r2, easingOffset: new t.P(0, 0) };
        }
        handleMapControlsRollPitchBearingZoom(e2, i2) {
          const r2 = e2.around, o2 = i2.screenPointToLocation(r2);
          e2.bearingDelta && i2.setBearing(i2.bearing + e2.bearingDelta), e2.pitchDelta && i2.setPitch(i2.pitch + e2.pitchDelta), e2.rollDelta && i2.setRoll(i2.roll + e2.rollDelta);
          const a2 = i2.zoom;
          e2.zoomDelta && i2.setZoom(i2.zoom + e2.zoomDelta);
          const s2 = i2.zoom - a2;
          if (s2 === 0)
            return;
          const n2 = t.bq(i2.center.lng, o2.lng), l3 = n2 / (Math.abs(n2 / 180) + 1), c2 = t.bq(i2.center.lat, o2.lat), h2 = i2.getRayDirectionFromPixel(r2), u2 = i2.cameraPosition, d2 = -1 * t.aV(u2, h2), _2 = t.bh();
          t.aP(_2, u2, [h2[0] * d2, h2[1] * d2, h2[2] * d2]);
          const p2 = t.bo(_2) - 1, m2 = Math.exp(0.5 * -Math.max(p2 - 0.3, 0)), f2 = ri2(i2.worldSize, i2.center.lat) / Math.min(i2.width, i2.height), g2 = t.bf(f2, 0.9, 0.5, 1, 0.25), v2 = (1 - t.ac(-s2)) * Math.min(m2, g2), x2 = i2.center.lat, b2 = i2.zoom, y2 = new t.Q(i2.center.lng + l3 * v2, t.ae(i2.center.lat + c2 * v2, -85.051129, t.af));
          i2.setLocationAtPoint(o2, r2);
          const w2 = i2.center, T2 = t.bf(Math.abs(n2), 45, 85, 0, 1), P2 = t.bf(f2, 0.75, 0.35, 0, 1), C2 = Math.pow(Math.max(T2, P2), 0.25), M3 = t.bq(w2.lng, y2.lng), I2 = t.bq(w2.lat, y2.lat);
          i2.setCenter(new t.Q(w2.lng + M3 * C2, w2.lat + I2 * C2).wrap()), i2.setZoom(b2 + si2(x2, i2.center.lat));
        }
        handleMapControlsPan(e2, t2, i2) {
          if (!e2.panDelta)
            return;
          const r2 = t2.center.lat, o2 = t2.zoom;
          t2.setCenter(ni2(e2.panDelta, t2).wrap()), t2.setZoom(o2 + si2(r2, t2.center.lat));
        }
        cameraForBoxAndBearing(e2, i2, r2, o2, a2) {
          const s2 = Bt2(e2, i2, r2, o2, a2), n2 = i2.left / a2.width * 2 - 1, l3 = (a2.width - i2.right) / a2.width * 2 - 1, c2 = i2.top / a2.height * -2 + 1, h2 = (a2.height - i2.bottom) / a2.height * -2 + 1, u2 = t.bq(r2.getWest(), r2.getEast()) < 0, d2 = u2 ? r2.getEast() : r2.getWest(), _2 = u2 ? r2.getWest() : r2.getEast(), p2 = Math.max(r2.getNorth(), r2.getSouth()), m2 = Math.min(r2.getNorth(), r2.getSouth()), f2 = d2 + 0.5 * t.bq(d2, _2), g2 = p2 + 0.5 * t.bq(p2, m2), v2 = a2.clone();
          v2.setCenter(s2.center), v2.setBearing(s2.bearing), v2.setPitch(0), v2.setRoll(0), v2.setZoom(s2.zoom);
          const x2 = v2.modelViewProjectionMatrix, b2 = [ii2(r2.getNorthWest()), ii2(r2.getNorthEast()), ii2(r2.getSouthWest()), ii2(r2.getSouthEast()), ii2(new t.Q(_2, g2)), ii2(new t.Q(d2, g2)), ii2(new t.Q(f2, p2)), ii2(new t.Q(f2, m2))], y2 = ii2(s2.center);
          let w2 = Number.POSITIVE_INFINITY;
          for (const e3 of b2)
            n2 < 0 && (w2 = fi2.getLesserNonNegativeNonNull(w2, fi2.solveVectorScale(e3, y2, x2, "x", n2))), l3 > 0 && (w2 = fi2.getLesserNonNegativeNonNull(w2, fi2.solveVectorScale(e3, y2, x2, "x", l3))), c2 > 0 && (w2 = fi2.getLesserNonNegativeNonNull(w2, fi2.solveVectorScale(e3, y2, x2, "y", c2))), h2 < 0 && (w2 = fi2.getLesserNonNegativeNonNull(w2, fi2.solveVectorScale(e3, y2, x2, "y", h2)));
          if (Number.isFinite(w2) && w2 !== 0)
            return s2.zoom = v2.zoom + t.ah(w2), s2;
          kt2();
        }
        handleJumpToCenterZoom(e2, i2) {
          const r2 = e2.center.lat, o2 = e2.getConstrained(i2.center ? t.Q.convert(i2.center) : e2.center, e2.zoom).center;
          e2.setCenter(o2.wrap());
          const a2 = i2.zoom !== undefined ? +i2.zoom : e2.zoom + si2(r2, o2.lat);
          e2.zoom !== a2 && e2.setZoom(a2);
        }
        handleEaseTo(e2, i2) {
          const { zoom: r2, center: o2, padding: a2 } = e2, s2 = { roll: e2.roll, pitch: e2.pitch, bearing: e2.bearing }, n2 = { roll: i2.roll === undefined ? e2.roll : i2.roll, pitch: i2.pitch === undefined ? e2.pitch : i2.pitch, bearing: i2.bearing === undefined ? e2.bearing : i2.bearing }, l3 = i2.zoom !== undefined, c2 = !e2.isPaddingEqual(i2.padding);
          let h2 = false;
          const u2 = i2.center ? t.Q.convert(i2.center) : o2, d2 = e2.getConstrained(u2, r2).center;
          Et2(e2, d2);
          const _2 = e2.clone();
          _2.setCenter(d2), _2.setZoom(l3 ? +i2.zoom : r2 + si2(o2.lat, u2.lat)), _2.setBearing(i2.bearing);
          const p2 = new t.P(t.ae(e2.centerPoint.x + i2.offsetAsPoint.x, 0, e2.width), t.ae(e2.centerPoint.y + i2.offsetAsPoint.y, 0, e2.height));
          _2.setLocationAtPoint(d2, p2);
          const m2 = (i2.offset && i2.offsetAsPoint.mag()) > 0 ? _2.center : d2, f2 = l3 ? +i2.zoom : r2 + si2(o2.lat, m2.lat), g2 = r2 + si2(o2.lat, 0), v2 = f2 + si2(m2.lat, 0), x2 = t.bq(o2.lng, m2.lng), b2 = t.bq(o2.lat, m2.lat), y2 = t.ac(v2 - g2);
          return h2 = f2 !== r2, { easeFunc: (r3) => {
            if (t.b6(s2, n2) || Ft2({ startEulerAngles: s2, endEulerAngles: n2, tr: e2, k: r3, useSlerp: s2.roll != n2.roll }), c2 && e2.interpolatePadding(a2, i2.padding, r3), i2.around)
              t.w("Easing around a point is not supported under globe projection."), e2.setLocationAtPoint(i2.around, i2.aroundPoint);
            else {
              const t2 = v2 > g2 ? Math.min(2, y2) : Math.max(0.5, y2), i3 = Math.pow(t2, 1 - r3), a3 = ci2(o2, x2, b2, r3 * i3);
              e2.setCenter(a3.wrap());
            }
            if (h2) {
              const i3 = t.B.number(g2, v2, r3) + si2(0, e2.center.lat);
              e2.setZoom(i3);
            }
          }, isZooming: h2, elevationCenter: m2 };
        }
        handleFlyTo(e2, i2) {
          const r2 = i2.zoom !== undefined, o2 = e2.center, a2 = e2.zoom, s2 = e2.padding, n2 = !e2.isPaddingEqual(i2.padding), l3 = e2.getConstrained(t.Q.convert(i2.center || i2.locationAtOffset), a2).center, c2 = r2 ? +i2.zoom : e2.zoom + si2(e2.center.lat, l3.lat), h2 = e2.clone();
          h2.setCenter(l3), h2.setZoom(c2), h2.setBearing(i2.bearing);
          const u2 = new t.P(t.ae(e2.centerPoint.x + i2.offsetAsPoint.x, 0, e2.width), t.ae(e2.centerPoint.y + i2.offsetAsPoint.y, 0, e2.height));
          h2.setLocationAtPoint(l3, u2);
          const d2 = h2.center;
          Et2(e2, d2);
          const _2 = function(e3, i3, r3) {
            const o3 = ii2(i3), a3 = ii2(r3), s3 = t.aV(o3, a3), n3 = Math.acos(s3), l4 = ei2(e3);
            return n3 / (2 * Math.PI) * l4;
          }(e2, o2, d2), p2 = a2 + si2(o2.lat, 0), m2 = c2 + si2(d2.lat, 0), f2 = t.ac(m2 - p2);
          let g2;
          if (typeof i2.minZoom == "number") {
            const r3 = +i2.minZoom + si2(d2.lat, 0), o3 = Math.min(r3, p2, m2) + si2(0, d2.lat), a3 = e2.getConstrained(d2, o3).zoom + si2(d2.lat, 0);
            g2 = t.ac(a3 - p2);
          }
          const v2 = t.bq(o2.lng, d2.lng), x2 = t.bq(o2.lat, d2.lat);
          return { easeFunc: (r3, a3, l4, h3) => {
            const u3 = ci2(o2, v2, x2, l4);
            n2 && e2.interpolatePadding(s2, i2.padding, r3);
            const _3 = r3 === 1 ? d2 : u3;
            e2.setCenter(_3.wrap());
            const m3 = p2 + t.ah(a3);
            e2.setZoom(r3 === 1 ? c2 : m3 + si2(0, _3.lat));
          }, scaleOfZoom: f2, targetCenter: d2, scaleOfMinZoom: g2, pixelPathLength: _2 };
        }
        static solveVectorScale(e2, t2, i2, r2, o2) {
          const a2 = r2 === "x" ? [i2[0], i2[4], i2[8], i2[12]] : [i2[1], i2[5], i2[9], i2[13]], s2 = [i2[3], i2[7], i2[11], i2[15]], n2 = e2[0] * a2[0] + e2[1] * a2[1] + e2[2] * a2[2], l3 = e2[0] * s2[0] + e2[1] * s2[1] + e2[2] * s2[2], c2 = t2[0] * a2[0] + t2[1] * a2[1] + t2[2] * a2[2], h2 = t2[0] * s2[0] + t2[1] * s2[1] + t2[2] * s2[2];
          return c2 + o2 * l3 === n2 + o2 * h2 || s2[3] * (n2 - c2) + a2[3] * (h2 - l3) + n2 * h2 == c2 * l3 ? null : (c2 + a2[3] - o2 * h2 - o2 * s2[3]) / (c2 - n2 - o2 * h2 + o2 * l3);
        }
        static getLesserNonNegativeNonNull(e2, t2) {
          return t2 !== null && t2 >= 0 && t2 < e2 ? t2 : e2;
        }
      }

      class gi2 {
        constructor(e2) {
          this._globe = e2, this._mercatorCameraHelper = new Ot2, this._verticalPerspectiveCameraHelper = new fi2;
        }
        get useGlobeControls() {
          return this._globe.useGlobeRendering;
        }
        get currentHelper() {
          return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
        }
        handlePanInertia(e2, t2) {
          return this.currentHelper.handlePanInertia(e2, t2);
        }
        handleMapControlsRollPitchBearingZoom(e2, t2) {
          return this.currentHelper.handleMapControlsRollPitchBearingZoom(e2, t2);
        }
        handleMapControlsPan(e2, t2, i2) {
          this.currentHelper.handleMapControlsPan(e2, t2, i2);
        }
        cameraForBoxAndBearing(e2, t2, i2, r2, o2) {
          return this.currentHelper.cameraForBoxAndBearing(e2, t2, i2, r2, o2);
        }
        handleJumpToCenterZoom(e2, t2) {
          this.currentHelper.handleJumpToCenterZoom(e2, t2);
        }
        handleEaseTo(e2, t2) {
          return this.currentHelper.handleEaseTo(e2, t2);
        }
        handleFlyTo(e2, t2) {
          return this.currentHelper.handleFlyTo(e2, t2);
        }
      }
      const vi2 = (e2, i2) => t.x(e2, i2 && i2.filter((e3) => e3.identifier !== "source.canvas")), xi2 = t.bw();

      class bi2 extends t.E {
        constructor(e2, i2 = {}) {
          super(), this._rtlPluginLoaded = () => {
            for (const e3 in this.sourceCaches) {
              const t2 = this.sourceCaches[e3].getSource().type;
              t2 !== "vector" && t2 !== "geojson" || this.sourceCaches[e3].reload();
            }
          }, this.map = e2, this.dispatcher = new B2(F2(), e2._getMapId()), this.dispatcher.registerMessageHandler("GG", (e3, t2) => this.getGlyphs(e3, t2)), this.dispatcher.registerMessageHandler("GI", (e3, t2) => this.getImages(e3, t2)), this.imageManager = new b, this.imageManager.setEventedParent(this), this.glyphManager = new P(e2._requestManager, i2.localIdeographFontFamily), this.lineAtlas = new R(256, 512), this.crossTileSymbolIndex = new vt2, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.bx, this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", t.by()), oe().on(te2, this._rtlPluginLoaded), this.on("data", (e3) => {
            if (e3.dataType !== "source" || e3.sourceDataType !== "metadata")
              return;
            const t2 = this.sourceCaches[e3.sourceId];
            if (!t2)
              return;
            const i3 = t2.getSource();
            if (i3 && i3.vectorLayerIds)
              for (const e4 in this._layers) {
                const t3 = this._layers[e4];
                t3.source === i3.id && this._validateLayer(t3);
              }
          });
        }
        loadURL(e2, i2 = {}, r2) {
          this.fire(new t.l("dataloading", { dataType: "style" })), i2.validate = typeof i2.validate != "boolean" || i2.validate;
          const o2 = this.map._requestManager.transformRequest(e2, "Style");
          this._loadStyleRequest = new AbortController;
          const a2 = this._loadStyleRequest;
          t.j(o2, this._loadStyleRequest).then((e3) => {
            this._loadStyleRequest = null, this._load(e3.data, i2, r2);
          }).catch((e3) => {
            this._loadStyleRequest = null, e3 && !a2.signal.aborted && this.fire(new t.k(e3));
          });
        }
        loadJSON(e2, i2 = {}, r2) {
          this.fire(new t.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController, s.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, i2.validate = i2.validate !== false, this._load(e2, i2, r2);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new t.l("dataloading", { dataType: "style" })), this._load(xi2, { validate: false });
        }
        _load(e2, i2, r2) {
          var o2, a2;
          const s2 = i2.transformStyle ? i2.transformStyle(r2, e2) : e2;
          if (!i2.validate || !vi2(this, t.y(s2))) {
            this._loaded = true, this.stylesheet = s2;
            for (const e3 in s2.sources)
              this.addSource(e3, s2.sources[e3], { validate: false });
            s2.sprite ? this._loadSprite(s2.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(s2.glyphs), this._createLayers(), this.light = new I(this.stylesheet.light), this._setProjectionInternal(((o2 = this.stylesheet.projection) === null || o2 === undefined ? undefined : o2.type) || "mercator"), this.sky = new S(this.stylesheet.sky), this.map.setTerrain((a2 = this.stylesheet.terrain) !== null && a2 !== undefined ? a2 : null), this.fire(new t.l("data", { dataType: "style" })), this.fire(new t.l("style.load"));
          }
        }
        _createLayers() {
          const e2 = t.bz(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", e2), this._order = e2.map((e3) => e3.id), this._layers = {}, this._serializedLayers = null;
          for (const i2 of e2) {
            const e3 = t.bA(i2);
            e3.setEventedParent(this, { layer: { id: i2.id } }), this._layers[i2.id] = e3;
          }
        }
        _loadSprite(e2, i2 = false, r2 = undefined) {
          let o2;
          this.imageManager.setLoaded(false), this._spriteRequest = new AbortController, function(e3, i3, r3, o3) {
            return t._(this, undefined, undefined, function* () {
              const a2 = f(e3), n2 = r3 > 1 ? "@2x" : "", l3 = {}, c2 = {};
              for (const { id: e4, url: r4 } of a2) {
                const a3 = i3.transformRequest(g(r4, n2, ".json"), "SpriteJSON");
                l3[e4] = t.j(a3, o3);
                const s2 = i3.transformRequest(g(r4, n2, ".png"), "SpriteImage");
                c2[e4] = p.getImage(s2, o3);
              }
              return yield Promise.all([...Object.values(l3), ...Object.values(c2)]), function(e4, i4) {
                return t._(this, undefined, undefined, function* () {
                  const t2 = {};
                  for (const r4 in e4) {
                    t2[r4] = {};
                    const o4 = s.getImageCanvasContext((yield i4[r4]).data), a3 = (yield e4[r4]).data;
                    for (const e5 in a3) {
                      const { width: i5, height: s2, x: n3, y: l4, sdf: c3, pixelRatio: h2, stretchX: u2, stretchY: d2, content: _2, textFitWidth: p2, textFitHeight: m2 } = a3[e5];
                      t2[r4][e5] = { data: null, pixelRatio: h2, sdf: c3, stretchX: u2, stretchY: d2, content: _2, textFitWidth: p2, textFitHeight: m2, spriteData: { width: i5, height: s2, x: n3, y: l4, context: o4 } };
                    }
                  }
                  return t2;
                });
              }(l3, c2);
            });
          }(e2, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((e3) => {
            if (this._spriteRequest = null, e3)
              for (const t2 in e3) {
                this._spritesImagesIds[t2] = [];
                const r3 = this._spritesImagesIds[t2] ? this._spritesImagesIds[t2].filter((t3) => !(t3 in e3)) : [];
                for (const e4 of r3)
                  this.imageManager.removeImage(e4), this._changedImages[e4] = true;
                for (const r4 in e3[t2]) {
                  const o3 = t2 === "default" ? r4 : `${t2}:${r4}`;
                  this._spritesImagesIds[t2].push(o3), o3 in this.imageManager.images ? this.imageManager.updateImage(o3, e3[t2][r4], false) : this.imageManager.addImage(o3, e3[t2][r4]), i2 && (this._changedImages[o3] = true);
                }
              }
          }).catch((e3) => {
            this._spriteRequest = null, o2 = e3, this.fire(new t.k(o2));
          }).finally(() => {
            this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i2 && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" })), r2 && r2(o2);
          });
        }
        _unloadSprite() {
          for (const e2 of Object.values(this._spritesImagesIds).flat())
            this.imageManager.removeImage(e2), this._changedImages[e2] = true;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
        }
        _validateLayer(e2) {
          const i2 = this.sourceCaches[e2.source];
          if (!i2)
            return;
          const r2 = e2.sourceLayer;
          if (!r2)
            return;
          const o2 = i2.getSource();
          (o2.type === "geojson" || o2.vectorLayerIds && o2.vectorLayerIds.indexOf(r2) === -1) && this.fire(new t.k(new Error(`Source layer "${r2}" does not exist on source "${o2.id}" as specified by style layer "${e2.id}".`)));
        }
        loaded() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._updatedSources).length)
            return false;
          for (const e2 in this.sourceCaches)
            if (!this.sourceCaches[e2].loaded())
              return false;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(e2, i2 = false) {
          const r2 = this._serializedAllLayers();
          if (!e2 || e2.length === 0)
            return Object.values(i2 ? t.bB(r2) : r2);
          const o2 = [];
          for (const a2 of e2)
            if (r2[a2]) {
              const e3 = i2 ? t.bB(r2[a2]) : r2[a2];
              o2.push(e3);
            }
          return o2;
        }
        _serializedAllLayers() {
          let e2 = this._serializedLayers;
          if (e2)
            return e2;
          e2 = this._serializedLayers = {};
          const t2 = Object.keys(this._layers);
          for (const i2 of t2) {
            const t3 = this._layers[i2];
            t3.type !== "custom" && (e2[i2] = t3.serialize());
          }
          return e2;
        }
        hasTransitions() {
          var e2, t2, i2;
          if ((e2 = this.light) === null || e2 === undefined ? undefined : e2.hasTransition())
            return true;
          if ((t2 = this.sky) === null || t2 === undefined ? undefined : t2.hasTransition())
            return true;
          if ((i2 = this.projection) === null || i2 === undefined ? undefined : i2.hasTransition())
            return true;
          for (const e3 in this.sourceCaches)
            if (this.sourceCaches[e3].hasTransition())
              return true;
          for (const e3 in this._layers)
            if (this._layers[e3].hasTransition())
              return true;
          return false;
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading.");
        }
        update(e2) {
          if (!this._loaded)
            return;
          const i2 = this._changed;
          if (i2) {
            const t2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
            (t2.length || i3.length) && this._updateWorkerLayers(t2, i3);
            for (const e3 in this._updatedSources) {
              const t3 = this._updatedSources[e3];
              if (t3 === "reload")
                this._reloadSource(e3);
              else {
                if (t3 !== "clear")
                  throw new Error(`Invalid action ${t3}`);
                this._clearSource(e3);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const t3 in this._updatedPaintProps)
              this._layers[t3].updateTransitions(e2);
            this.light.updateTransitions(e2), this.sky.updateTransitions(e2), this._resetUpdates();
          }
          const r2 = {};
          for (const e3 in this.sourceCaches) {
            const t2 = this.sourceCaches[e3];
            r2[e3] = t2.used, t2.used = false;
          }
          for (const t2 of this._order) {
            const i3 = this._layers[t2];
            i3.recalculate(e2, this._availableImages), !i3.isHidden(e2.zoom) && i3.source && (this.sourceCaches[i3.source].used = true);
          }
          for (const e3 in r2) {
            const i3 = this.sourceCaches[e3];
            !!r2[e3] != !!i3.used && i3.fire(new t.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: e3 }));
          }
          this.light.recalculate(e2), this.sky.recalculate(e2), this.projection.recalculate(e2), this.z = e2.zoom, i2 && this.fire(new t.l("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e2 = Object.keys(this._changedImages);
          if (e2.length) {
            for (const t2 in this.sourceCaches)
              this.sourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const e2 in this.sourceCaches)
              this.sourceCaches[e2].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = false;
          }
        }
        _updateWorkerLayers(e2, t2) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e2, false), removedIds: t2 });
        }
        _resetUpdates() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
        }
        setState(e2, i2 = {}) {
          var r2;
          this._checkLoaded();
          const o2 = this.serialize();
          if (e2 = i2.transformStyle ? i2.transformStyle(o2, e2) : e2, ((r2 = i2.validate) === null || r2 === undefined || r2) && vi2(this, t.y(e2)))
            return false;
          (e2 = t.bB(e2)).layers = t.bz(e2.layers);
          const a2 = t.bC(o2, e2), s2 = this._getOperationsToPerform(a2);
          if (s2.unimplemented.length > 0)
            throw new Error(`Unimplemented: ${s2.unimplemented.join(", ")}.`);
          if (s2.operations.length === 0)
            return false;
          for (const e3 of s2.operations)
            e3();
          return this.stylesheet = e2, this._serializedLayers = null, true;
        }
        _getOperationsToPerform(e2) {
          const t2 = [], i2 = [];
          for (const r2 of e2)
            switch (r2.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                t2.push(() => this.addLayer.apply(this, r2.args));
                break;
              case "removeLayer":
                t2.push(() => this.removeLayer.apply(this, r2.args));
                break;
              case "setPaintProperty":
                t2.push(() => this.setPaintProperty.apply(this, r2.args));
                break;
              case "setLayoutProperty":
                t2.push(() => this.setLayoutProperty.apply(this, r2.args));
                break;
              case "setFilter":
                t2.push(() => this.setFilter.apply(this, r2.args));
                break;
              case "addSource":
                t2.push(() => this.addSource.apply(this, r2.args));
                break;
              case "removeSource":
                t2.push(() => this.removeSource.apply(this, r2.args));
                break;
              case "setLayerZoomRange":
                t2.push(() => this.setLayerZoomRange.apply(this, r2.args));
                break;
              case "setLight":
                t2.push(() => this.setLight.apply(this, r2.args));
                break;
              case "setGeoJSONSourceData":
                t2.push(() => this.setGeoJSONSourceData.apply(this, r2.args));
                break;
              case "setGlyphs":
                t2.push(() => this.setGlyphs.apply(this, r2.args));
                break;
              case "setSprite":
                t2.push(() => this.setSprite.apply(this, r2.args));
                break;
              case "setTerrain":
                t2.push(() => this.map.setTerrain.apply(this, r2.args));
                break;
              case "setSky":
                t2.push(() => this.setSky.apply(this, r2.args));
                break;
              case "setProjection":
                this.setProjection.apply(this, r2.args);
                break;
              case "setTransition":
                t2.push(() => {
                });
                break;
              default:
                i2.push(r2.command);
            }
          return { operations: t2, unimplemented: i2 };
        }
        addImage(e2, i2) {
          if (this.getImage(e2))
            return this.fire(new t.k(new Error(`An image named "${e2}" already exists.`)));
          this.imageManager.addImage(e2, i2), this._afterImageUpdated(e2);
        }
        updateImage(e2, t2) {
          this.imageManager.updateImage(e2, t2);
        }
        getImage(e2) {
          return this.imageManager.getImage(e2);
        }
        removeImage(e2) {
          if (!this.getImage(e2))
            return this.fire(new t.k(new Error(`An image named "${e2}" does not exist.`)));
          this.imageManager.removeImage(e2), this._afterImageUpdated(e2);
        }
        _afterImageUpdated(e2) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(e2, i2, r2 = {}) {
          if (this._checkLoaded(), this.sourceCaches[e2] !== undefined)
            throw new Error(`Source "${e2}" already exists.`);
          if (!i2.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(t.y.source, `sources.${e2}`, i2, null, r2))
            return;
          this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
          const o2 = this.sourceCaches[e2] = new be2(e2, i2, this.dispatcher);
          o2.style = this, o2.setEventedParent(this, () => ({ isSourceLoaded: o2.loaded(), source: o2.serialize(), sourceId: e2 })), o2.onAdd(this.map), this._changed = true;
        }
        removeSource(e2) {
          if (this._checkLoaded(), this.sourceCaches[e2] === undefined)
            throw new Error("There is no source with this ID");
          for (const i3 in this._layers)
            if (this._layers[i3].source === e2)
              return this.fire(new t.k(new Error(`Source "${e2}" cannot be removed while layer "${i3}" is using it.`)));
          const i2 = this.sourceCaches[e2];
          delete this.sourceCaches[e2], delete this._updatedSources[e2], i2.fire(new t.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e2 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
        }
        setGeoJSONSourceData(e2, t2) {
          if (this._checkLoaded(), this.sourceCaches[e2] === undefined)
            throw new Error(`There is no source with this ID=${e2}`);
          const i2 = this.sourceCaches[e2].getSource();
          if (i2.type !== "geojson")
            throw new Error(`geojsonSource.type is ${i2.type}, which is !== 'geojson`);
          i2.setData(t2), this._changed = true;
        }
        getSource(e2) {
          return this.sourceCaches[e2] && this.sourceCaches[e2].getSource();
        }
        addLayer(e2, i2, r2 = {}) {
          this._checkLoaded();
          const o2 = e2.id;
          if (this.getLayer(o2))
            return void this.fire(new t.k(new Error(`Layer "${o2}" already exists on this map.`)));
          let a2;
          if (e2.type === "custom") {
            if (vi2(this, t.bD(e2)))
              return;
            a2 = t.bA(e2);
          } else {
            if ("source" in e2 && typeof e2.source == "object" && (this.addSource(o2, e2.source), e2 = t.bB(e2), e2 = t.e(e2, { source: o2 })), this._validate(t.y.layer, `layers.${o2}`, e2, { arrayIndex: -1 }, r2))
              return;
            a2 = t.bA(e2), this._validateLayer(a2), a2.setEventedParent(this, { layer: { id: o2 } });
          }
          const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
          if (i2 && s2 === -1)
            this.fire(new t.k(new Error(`Cannot add layer "${o2}" before non-existing layer "${i2}".`)));
          else {
            if (this._order.splice(s2, 0, o2), this._layerOrderChanged = true, this._layers[o2] = a2, this._removedLayers[o2] && a2.source && a2.type !== "custom") {
              const e3 = this._removedLayers[o2];
              delete this._removedLayers[o2], e3.type !== a2.type ? this._updatedSources[a2.source] = "clear" : (this._updatedSources[a2.source] = "reload", this.sourceCaches[a2.source].pause());
            }
            this._updateLayer(a2), a2.onAdd && a2.onAdd(this.map);
          }
        }
        moveLayer(e2, i2) {
          if (this._checkLoaded(), this._changed = true, !this._layers[e2])
            return void this.fire(new t.k(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
          if (e2 === i2)
            return;
          const r2 = this._order.indexOf(e2);
          this._order.splice(r2, 1);
          const o2 = i2 ? this._order.indexOf(i2) : this._order.length;
          i2 && o2 === -1 ? this.fire(new t.k(new Error(`Cannot move layer "${e2}" before non-existing layer "${i2}".`))) : (this._order.splice(o2, 0, e2), this._layerOrderChanged = true);
        }
        removeLayer(e2) {
          this._checkLoaded();
          const i2 = this._layers[e2];
          if (!i2)
            return void this.fire(new t.k(new Error(`Cannot remove non-existing layer "${e2}".`)));
          i2.setEventedParent(null);
          const r2 = this._order.indexOf(e2);
          this._order.splice(r2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e2] = i2, delete this._layers[e2], this._serializedLayers && delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], i2.onRemove && i2.onRemove(this.map);
        }
        getLayer(e2) {
          return this._layers[e2];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(e2) {
          return e2 in this._layers;
        }
        setLayerZoomRange(e2, i2, r2) {
          this._checkLoaded();
          const o2 = this.getLayer(e2);
          o2 ? o2.minzoom === i2 && o2.maxzoom === r2 || (i2 != null && (o2.minzoom = i2), r2 != null && (o2.maxzoom = r2), this._updateLayer(o2)) : this.fire(new t.k(new Error(`Cannot set the zoom range of non-existing layer "${e2}".`)));
        }
        setFilter(e2, i2, r2 = {}) {
          this._checkLoaded();
          const o2 = this.getLayer(e2);
          if (o2) {
            if (!t.bE(o2.filter, i2))
              return i2 == null ? (o2.filter = undefined, void this._updateLayer(o2)) : void (this._validate(t.y.filter, `layers.${o2.id}.filter`, i2, null, r2) || (o2.filter = t.bB(i2), this._updateLayer(o2)));
          } else
            this.fire(new t.k(new Error(`Cannot filter non-existing layer "${e2}".`)));
        }
        getFilter(e2) {
          return t.bB(this.getLayer(e2).filter);
        }
        setLayoutProperty(e2, i2, r2, o2 = {}) {
          this._checkLoaded();
          const a2 = this.getLayer(e2);
          a2 ? t.bE(a2.getLayoutProperty(i2), r2) || (a2.setLayoutProperty(i2, r2, o2), this._updateLayer(a2)) : this.fire(new t.k(new Error(`Cannot style non-existing layer "${e2}".`)));
        }
        getLayoutProperty(e2, i2) {
          const r2 = this.getLayer(e2);
          if (r2)
            return r2.getLayoutProperty(i2);
          this.fire(new t.k(new Error(`Cannot get style of non-existing layer "${e2}".`)));
        }
        setPaintProperty(e2, i2, r2, o2 = {}) {
          this._checkLoaded();
          const a2 = this.getLayer(e2);
          a2 ? t.bE(a2.getPaintProperty(i2), r2) || (a2.setPaintProperty(i2, r2, o2) && this._updateLayer(a2), this._changed = true, this._updatedPaintProps[e2] = true, this._serializedLayers = null) : this.fire(new t.k(new Error(`Cannot style non-existing layer "${e2}".`)));
        }
        getPaintProperty(e2, t2) {
          return this.getLayer(e2).getPaintProperty(t2);
        }
        setFeatureState(e2, i2) {
          this._checkLoaded();
          const { source: r2, sourceLayer: o2 } = e2, a2 = this.sourceCaches[r2];
          if (a2 === undefined)
            return void this.fire(new t.k(new Error(`The source '${r2}' does not exist in the map's style.`)));
          const s2 = a2.getSource().type;
          s2 === "geojson" && o2 ? this.fire(new t.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : s2 !== "vector" || o2 ? (e2.id === undefined && this.fire(new t.k(new Error("The feature id parameter must be provided."))), a2.setFeatureState(o2, e2.id, i2)) : this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(e2, i2) {
          this._checkLoaded();
          const r2 = e2.source, o2 = this.sourceCaches[r2];
          if (o2 === undefined)
            return void this.fire(new t.k(new Error(`The source '${r2}' does not exist in the map's style.`)));
          const a2 = o2.getSource().type, s2 = a2 === "vector" ? e2.sourceLayer : undefined;
          a2 !== "vector" || s2 ? i2 && typeof e2.id != "string" && typeof e2.id != "number" ? this.fire(new t.k(new Error("A feature id is required to remove its specific state property."))) : o2.removeFeatureState(s2, e2.id, i2) : this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(e2) {
          this._checkLoaded();
          const { source: i2, sourceLayer: r2 } = e2, o2 = this.sourceCaches[i2];
          if (o2 !== undefined)
            return o2.getSource().type !== "vector" || r2 ? (e2.id === undefined && this.fire(new t.k(new Error("The feature id parameter must be provided."))), o2.getFeatureState(r2, e2.id)) : void this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new t.k(new Error(`The source '${i2}' does not exist in the map's style.`)));
        }
        getTransition() {
          return t.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded)
            return;
          const e2 = t.bF(this.sourceCaches, (e3) => e3.serialize()), i2 = this._serializeByIds(this._order, true), r2 = this.map.getTerrain() || undefined, o2 = this.stylesheet;
          return t.bG({ version: o2.version, name: o2.name, metadata: o2.metadata, light: o2.light, sky: o2.sky, center: o2.center, zoom: o2.zoom, bearing: o2.bearing, pitch: o2.pitch, sprite: o2.sprite, glyphs: o2.glyphs, transition: o2.transition, projection: o2.projection, sources: e2, layers: i2, terrain: r2 }, (e3) => e3 !== undefined);
        }
        _updateLayer(e2) {
          this._updatedLayers[e2.id] = true, e2.source && !this._updatedSources[e2.source] && this.sourceCaches[e2.source].getSource().type !== "raster" && (this._updatedSources[e2.source] = "reload", this.sourceCaches[e2.source].pause()), this._serializedLayers = null, this._changed = true;
        }
        _flattenAndSortRenderedFeatures(e2) {
          const t2 = (e3) => this._layers[e3].type === "fill-extrusion", i2 = {}, r2 = [];
          for (let o3 = this._order.length - 1;o3 >= 0; o3--) {
            const a2 = this._order[o3];
            if (t2(a2)) {
              i2[a2] = o3;
              for (const t3 of e2) {
                const e3 = t3[a2];
                if (e3)
                  for (const t4 of e3)
                    r2.push(t4);
              }
            }
          }
          r2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
          const o2 = [];
          for (let a2 = this._order.length - 1;a2 >= 0; a2--) {
            const s2 = this._order[a2];
            if (t2(s2))
              for (let e3 = r2.length - 1;e3 >= 0; e3--) {
                const t3 = r2[e3].feature;
                if (i2[t3.layer.id] < a2)
                  break;
                o2.push(t3), r2.pop();
              }
            else
              for (const t3 of e2) {
                const e3 = t3[s2];
                if (e3)
                  for (const t4 of e3)
                    o2.push(t4.feature);
              }
          }
          return o2;
        }
        queryRenderedFeatures(e2, i2, r2) {
          i2 && i2.filter && this._validate(t.y.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
          const o2 = {};
          if (i2 && i2.layers) {
            if (!(Array.isArray(i2.layers) || i2.layers instanceof Set))
              return this.fire(new t.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
            for (const e3 of i2.layers) {
              const i3 = this._layers[e3];
              if (!i3)
                return this.fire(new t.k(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
              o2[i3.source] = true;
            }
          }
          const a2 = [];
          i2.availableImages = this._availableImages;
          const s2 = this._serializedAllLayers(), n2 = i2.layers instanceof Set ? i2.layers : Array.isArray(i2.layers) ? new Set(i2.layers) : null, l3 = Object.assign(Object.assign({}, i2), { layers: n2 });
          for (const t2 in this.sourceCaches)
            i2.layers && !o2[t2] || a2.push(Z2(this.sourceCaches[t2], this._layers, s2, e2, l3, r2, this.map.terrain ? (e3, t3, i3) => this.map.terrain.getElevation(e3, t3, i3) : undefined));
          return this.placement && a2.push(function(e3, t2, i3, r3, o3, a3, s3) {
            const n3 = {}, l4 = a3.queryRenderedSymbols(r3), c2 = [];
            for (const e4 of Object.keys(l4).map(Number))
              c2.push(s3[e4]);
            c2.sort(N);
            for (const i4 of c2) {
              const r4 = i4.featureIndex.lookupSymbolFeatures(l4[i4.bucketInstanceId], t2, i4.bucketIndex, i4.sourceLayerIndex, o3.filter, o3.layers, o3.availableImages, e3);
              for (const e4 in r4) {
                const t3 = n3[e4] = n3[e4] || [], o4 = r4[e4];
                o4.sort((e5, t4) => {
                  const r5 = i4.featureSortOrder;
                  if (r5) {
                    const i5 = r5.indexOf(e5.featureIndex);
                    return r5.indexOf(t4.featureIndex) - i5;
                  }
                  return t4.featureIndex - e5.featureIndex;
                });
                for (const e5 of o4)
                  t3.push(e5);
              }
            }
            return function(e4, t3, i4) {
              for (const r4 in e4)
                for (const o4 of e4[r4])
                  U(o4, i4[t3[r4].source]);
              return e4;
            }(n3, e3, i3);
          }(this._layers, s2, this.sourceCaches, e2, l3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a2);
        }
        querySourceFeatures(e2, i2) {
          i2 && i2.filter && this._validate(t.y.filter, "querySourceFeatures.filter", i2.filter, null, i2);
          const r2 = this.sourceCaches[e2];
          return r2 ? function(e3, t2) {
            const i3 = e3.getRenderableIds().map((t3) => e3.getTileByID(t3)), r3 = [], o2 = {};
            for (let e4 = 0;e4 < i3.length; e4++) {
              const a2 = i3[e4], s2 = a2.tileID.canonical.key;
              o2[s2] || (o2[s2] = true, a2.querySourceFeatures(r3, t2));
            }
            return r3;
          }(r2, i2) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(e2, i2 = {}) {
          this._checkLoaded();
          const r2 = this.light.getLight();
          let o2 = false;
          for (const i3 in e2)
            if (!t.bE(e2[i3], r2[i3])) {
              o2 = true;
              break;
            }
          if (!o2)
            return;
          const a2 = { now: s.now(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(e2, i2), this.light.updateTransitions(a2);
        }
        getProjection() {
          var e2;
          return (e2 = this.stylesheet) === null || e2 === undefined ? undefined : e2.projection;
        }
        setProjection(e2) {
          if (this._checkLoaded(), this.projection) {
            if (this.projection.name === e2.type)
              return;
            this.projection.destroy(), delete this.projection;
          }
          this.stylesheet.projection = e2, this._setProjectionInternal(e2.type);
        }
        getSky() {
          var e2;
          return (e2 = this.stylesheet) === null || e2 === undefined ? undefined : e2.sky;
        }
        setSky(e2, i2 = {}) {
          this._checkLoaded();
          const r2 = this.getSky();
          let o2 = false;
          if (!e2 && !r2)
            return;
          if (e2 && !r2)
            o2 = true;
          else if (!e2 && r2)
            o2 = true;
          else
            for (const i3 in e2)
              if (!t.bE(e2[i3], r2[i3])) {
                o2 = true;
                break;
              }
          if (!o2)
            return;
          const a2 = { now: s.now(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = e2, this.sky.setSky(e2, i2), this.sky.updateTransitions(a2);
        }
        _setProjectionInternal(e2) {
          const i2 = function(e3) {
            if (Array.isArray(e3)) {
              const t2 = new Jt2({ type: e3 });
              return { projection: t2, transform: new mi2, cameraHelper: new gi2(t2) };
            }
            switch (e3) {
              case "mercator":
                return { projection: new Mt2, transform: new Lt2, cameraHelper: new Ot2 };
              case "globe": {
                const e4 = new Jt2({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                return { projection: e4, transform: new mi2, cameraHelper: new gi2(e4) };
              }
              case "vertical-perspective":
                return { projection: new Qt2, transform: new pi2, cameraHelper: new fi2 };
              default:
                return t.w(`Unknown projection name: ${e3}. Falling back to mercator projection.`), { projection: new Mt2, transform: new Lt2, cameraHelper: new Ot2 };
            }
          }(e2);
          this.projection = i2.projection, this.map.migrateProjection(i2.transform, i2.cameraHelper);
          for (const e3 in this.sourceCaches)
            this.sourceCaches[e3].reload();
        }
        _validate(e2, i2, r2, o2, a2 = {}) {
          return (!a2 || a2.validate !== false) && vi2(this, e2.call(t.y, t.e({ key: i2, style: this.serialize(), value: r2, styleSpec: t.v }, o2)));
        }
        _remove(e2 = true) {
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), oe().off(te2, this._rtlPluginLoaded);
          for (const e3 in this._layers)
            this._layers[e3].setEventedParent(null);
          for (const e3 in this.sourceCaches) {
            const t2 = this.sourceCaches[e3];
            t2.setEventedParent(null), t2.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), e2 && this.dispatcher.broadcast("RM", undefined), this.dispatcher.remove(e2);
        }
        _clearSource(e2) {
          this.sourceCaches[e2].clearTiles();
        }
        _reloadSource(e2) {
          this.sourceCaches[e2].resume(), this.sourceCaches[e2].reload();
        }
        _updateSources(e2) {
          for (const t2 in this.sourceCaches)
            this.sourceCaches[t2].update(e2, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const e2 in this.sourceCaches)
            this._reloadSource(e2);
        }
        _updatePlacement(e2, t2, i2, r2, o2 = false) {
          let a2 = false, n2 = false;
          const l3 = {};
          for (const t3 of this._order) {
            const i3 = this._layers[t3];
            if (i3.type !== "symbol")
              continue;
            if (!l3[i3.source]) {
              const e3 = this.sourceCaches[i3.source];
              l3[i3.source] = e3.getRenderableIds(true).map((t4) => e3.getTileByID(t4)).sort((e4, t4) => t4.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t4.tileID) ? -1 : 1));
            }
            const r3 = this.crossTileSymbolIndex.addLayer(i3, l3[i3.source], e2.center.lng);
            a2 = a2 || r3;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o2 = o2 || this._layerOrderChanged || i2 === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(s.now(), e2.zoom)) && (this.pauseablePlacement = new _t2(e2, this.map.terrain, this._order, o2, t2, i2, r2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l3), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(s.now()), n2 = true), a2 && this.pauseablePlacement.placement.setStale()), n2 || a2)
            for (const e3 of this._order) {
              const t3 = this._layers[e3];
              t3.type === "symbol" && this.placement.updateLayerOpacities(t3, l3[t3.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(s.now());
        }
        _releaseSymbolFadeTiles() {
          for (const e2 in this.sourceCaches)
            this.sourceCaches[e2].releaseSymbolFadeTiles();
        }
        getImages(e2, i2) {
          return t._(this, undefined, undefined, function* () {
            const e3 = yield this.imageManager.getImages(i2.icons);
            this._updateTilesForChangedImages();
            const t2 = this.sourceCaches[i2.source];
            return t2 && t2.setDependencies(i2.tileID.key, i2.type, i2.icons), e3;
          });
        }
        getGlyphs(e2, i2) {
          return t._(this, undefined, undefined, function* () {
            const e3 = yield this.glyphManager.getGlyphs(i2.stacks), t2 = this.sourceCaches[i2.source];
            return t2 && t2.setDependencies(i2.tileID.key, i2.type, [""]), e3;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(e2, i2 = {}) {
          this._checkLoaded(), e2 && this._validate(t.y.glyphs, "glyphs", e2, null, i2) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e2, this.glyphManager.entries = {}, this.glyphManager.setURL(e2));
        }
        addSprite(e2, i2, r2 = {}, o2) {
          this._checkLoaded();
          const a2 = [{ id: e2, url: i2 }], s2 = [...f(this.stylesheet.sprite), ...a2];
          this._validate(t.y.sprite, "sprite", s2, null, r2) || (this.stylesheet.sprite = s2, this._loadSprite(a2, true, o2));
        }
        removeSprite(e2) {
          this._checkLoaded();
          const i2 = f(this.stylesheet.sprite);
          if (i2.find((t2) => t2.id === e2)) {
            if (this._spritesImagesIds[e2])
              for (const t2 of this._spritesImagesIds[e2])
                this.imageManager.removeImage(t2), this._changedImages[t2] = true;
            i2.splice(i2.findIndex((t2) => t2.id === e2), 1), this.stylesheet.sprite = i2.length > 0 ? i2 : undefined, delete this._spritesImagesIds[e2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
          } else
            this.fire(new t.k(new Error(`Sprite "${e2}" doesn't exists on this map.`)));
        }
        getSprite() {
          return f(this.stylesheet.sprite);
        }
        setSprite(e2, i2 = {}, r2) {
          this._checkLoaded(), e2 && this._validate(t.y.sprite, "sprite", e2, null, i2) || (this.stylesheet.sprite = e2, e2 ? this._loadSprite(e2, true, r2) : (this._unloadSprite(), r2 && r2(null)));
        }
      }
      var yi2 = t.aG([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);

      class wi2 {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(e2, t2, i2, r2, o2, a2, s2, n2, l3) {
          this.context = e2;
          let c2 = this.boundPaintVertexBuffers.length !== r2.length;
          for (let e3 = 0;!c2 && e3 < r2.length; e3++)
            this.boundPaintVertexBuffers[e3] !== r2[e3] && (c2 = true);
          !this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || c2 || this.boundIndexBuffer !== o2 || this.boundVertexOffset !== a2 || this.boundDynamicVertexBuffer !== s2 || this.boundDynamicVertexBuffer2 !== n2 || this.boundDynamicVertexBuffer3 !== l3 ? this.freshBind(t2, i2, r2, o2, a2, s2, n2, l3) : (e2.bindVertexArray.set(this.vao), s2 && s2.bind(), o2 && o2.dynamicDraw && o2.bind(), n2 && n2.bind(), l3 && l3.bind());
        }
        freshBind(e2, t2, i2, r2, o2, a2, s2, n2) {
          const l3 = e2.numAttributes, c2 = this.context, h2 = c2.gl;
          this.vao && this.destroy(), this.vao = c2.createVertexArray(), c2.bindVertexArray.set(this.vao), this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = r2, this.boundVertexOffset = o2, this.boundDynamicVertexBuffer = a2, this.boundDynamicVertexBuffer2 = s2, this.boundDynamicVertexBuffer3 = n2, t2.enableAttributes(h2, e2);
          for (const t3 of i2)
            t3.enableAttributes(h2, e2);
          a2 && a2.enableAttributes(h2, e2), s2 && s2.enableAttributes(h2, e2), n2 && n2.enableAttributes(h2, e2), t2.bind(), t2.setVertexAttribPointers(h2, e2, o2);
          for (const t3 of i2)
            t3.bind(), t3.setVertexAttribPointers(h2, e2, o2);
          a2 && (a2.bind(), a2.setVertexAttribPointers(h2, e2, o2)), r2 && r2.bind(), s2 && (s2.bind(), s2.setVertexAttribPointers(h2, e2, o2)), n2 && (n2.bind(), n2.setVertexAttribPointers(h2, e2, o2)), c2.currentNumAttributes = l3;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const Ti2 = (e2, i2, r2, o2, a2) => ({ u_texture: 0, u_ele_delta: e2, u_fog_matrix: i2, u_fog_color: r2 ? r2.properties.get("fog-color") : t.b7.white, u_fog_ground_blend: r2 ? r2.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: a2 ? 0 : r2 ? r2.calculateFogBlendOpacity(o2) : 0, u_horizon_color: r2 ? r2.properties.get("horizon-color") : t.b7.white, u_horizon_fog_blend: r2 ? r2.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: a2 ? 1 : 0 }), Pi2 = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
      function Ci2(e2) {
        const t2 = [];
        for (let i2 = 0;i2 < e2.length; i2++) {
          if (e2[i2] === null)
            continue;
          const r2 = e2[i2].split(" ");
          t2.push(r2.pop());
        }
        return t2;
      }

      class Mi2 {
        constructor(e2, i2, r2, o2, a2, s2, n2, l3, c2 = []) {
          const h2 = e2.gl;
          this.program = h2.createProgram();
          const u2 = Ci2(i2.staticAttributes), d2 = r2 ? r2.getBinderAttributes() : [], _2 = u2.concat(d2), p2 = bt2.prelude.staticUniforms ? Ci2(bt2.prelude.staticUniforms) : [], m2 = n2.staticUniforms ? Ci2(n2.staticUniforms) : [], f2 = i2.staticUniforms ? Ci2(i2.staticUniforms) : [], g2 = r2 ? r2.getBinderUniforms() : [], v2 = p2.concat(m2).concat(f2).concat(g2), x2 = [];
          for (const e3 of v2)
            x2.indexOf(e3) < 0 && x2.push(e3);
          const b2 = r2 ? r2.defines() : [];
          Wt2(h2) && b2.unshift("#version 300 es"), a2 && b2.push("#define OVERDRAW_INSPECTOR;"), s2 && b2.push("#define TERRAIN3D;"), l3 && b2.push(l3), c2 && b2.push(...c2);
          let y2 = b2.concat(bt2.prelude.fragmentSource, n2.fragmentSource, i2.fragmentSource).join(`
`), w2 = b2.concat(bt2.prelude.vertexSource, n2.vertexSource, i2.vertexSource).join(`
`);
          Wt2(h2) || (y2 = function(e3) {
            return e3.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
          }(y2), w2 = function(e3) {
            return e3.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
          }(w2));
          const T2 = h2.createShader(h2.FRAGMENT_SHADER);
          if (h2.isContextLost())
            return void (this.failedToCreate = true);
          if (h2.shaderSource(T2, y2), h2.compileShader(T2), !h2.getShaderParameter(T2, h2.COMPILE_STATUS))
            throw new Error(`Could not compile fragment shader: ${h2.getShaderInfoLog(T2)}`);
          h2.attachShader(this.program, T2);
          const P2 = h2.createShader(h2.VERTEX_SHADER);
          if (h2.isContextLost())
            return void (this.failedToCreate = true);
          if (h2.shaderSource(P2, w2), h2.compileShader(P2), !h2.getShaderParameter(P2, h2.COMPILE_STATUS))
            throw new Error(`Could not compile vertex shader: ${h2.getShaderInfoLog(P2)}`);
          h2.attachShader(this.program, P2), this.attributes = {};
          const C2 = {};
          this.numAttributes = _2.length;
          for (let e3 = 0;e3 < this.numAttributes; e3++)
            _2[e3] && (h2.bindAttribLocation(this.program, e3, _2[e3]), this.attributes[_2[e3]] = e3);
          if (h2.linkProgram(this.program), !h2.getProgramParameter(this.program, h2.LINK_STATUS))
            throw new Error(`Program failed to link: ${h2.getProgramInfoLog(this.program)}`);
          h2.deleteShader(P2), h2.deleteShader(T2);
          for (let e3 = 0;e3 < x2.length; e3++) {
            const t2 = x2[e3];
            if (t2 && !C2[t2]) {
              const e4 = h2.getUniformLocation(this.program, t2);
              e4 && (C2[t2] = e4);
            }
          }
          this.fixedUniforms = o2(e2, C2), this.terrainUniforms = ((e3, i3) => ({ u_depth: new t.bH(e3, i3.u_depth), u_terrain: new t.bH(e3, i3.u_terrain), u_terrain_dim: new t.b8(e3, i3.u_terrain_dim), u_terrain_matrix: new t.bJ(e3, i3.u_terrain_matrix), u_terrain_unpack: new t.bK(e3, i3.u_terrain_unpack), u_terrain_exaggeration: new t.b8(e3, i3.u_terrain_exaggeration) }))(e2, C2), this.projectionUniforms = ((e3, i3) => ({ u_projection_matrix: new t.bJ(e3, i3.u_projection_matrix), u_projection_tile_mercator_coords: new t.bK(e3, i3.u_projection_tile_mercator_coords), u_projection_clipping_plane: new t.bK(e3, i3.u_projection_clipping_plane), u_projection_transition: new t.b8(e3, i3.u_projection_transition), u_projection_fallback_matrix: new t.bJ(e3, i3.u_projection_fallback_matrix) }))(e2, C2), this.binderUniforms = r2 ? r2.getUniforms(e2, C2) : [];
        }
        draw(e2, t2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2, d2, _2, p2, m2, f2, g2, v2) {
          const x2 = e2.gl;
          if (this.failedToCreate)
            return;
          if (e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(r2), e2.setColorMode(o2), e2.setCullFace(a2), n2) {
            e2.activeTexture.set(x2.TEXTURE2), x2.bindTexture(x2.TEXTURE_2D, n2.depthTexture), e2.activeTexture.set(x2.TEXTURE3), x2.bindTexture(x2.TEXTURE_2D, n2.texture);
            for (const e3 in this.terrainUniforms)
              this.terrainUniforms[e3].set(n2[e3]);
          }
          if (l3)
            for (const e3 in l3)
              this.projectionUniforms[Pi2[e3]].set(l3[e3]);
          if (s2)
            for (const e3 in this.fixedUniforms)
              this.fixedUniforms[e3].set(s2[e3]);
          m2 && m2.setUniforms(e2, this.binderUniforms, _2, { zoom: p2 });
          let b2 = 0;
          switch (t2) {
            case x2.LINES:
              b2 = 2;
              break;
            case x2.TRIANGLES:
              b2 = 3;
              break;
            case x2.LINE_STRIP:
              b2 = 1;
          }
          for (const i3 of d2.get()) {
            const r3 = i3.vaos || (i3.vaos = {});
            (r3[c2] || (r3[c2] = new wi2)).bind(e2, this, h2, m2 ? m2.getPaintVertexBuffers() : [], u2, i3.vertexOffset, f2, g2, v2), x2.drawElements(t2, i3.primitiveLength * b2, x2.UNSIGNED_SHORT, i3.primitiveOffset * b2 * 2);
          }
        }
      }
      function Ii2(e2, i2, r2) {
        const o2 = 1 / t.az(r2, 1, i2.transform.tileZoom), a2 = Math.pow(2, r2.tileID.overscaledZ), s2 = r2.tileSize * Math.pow(2, i2.transform.tileZoom) / a2, n2 = s2 * (r2.tileID.canonical.x + r2.tileID.wrap * a2), l3 = s2 * r2.tileID.canonical.y;
        return { u_image: 0, u_texsize: r2.imageAtlasTexture.size, u_scale: [o2, e2.fromScale, e2.toScale], u_fade: e2.t, u_pixel_coord_upper: [n2 >> 16, l3 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & l3] };
      }
      const Ei2 = (e2, i2, r2, o2) => {
        const a2 = e2.style.light, s2 = a2.properties.get("position"), n2 = [s2.x, s2.y, s2.z], l3 = t.bN();
        a2.properties.get("anchor") === "viewport" && t.bO(l3, e2.transform.bearingInRadians), t.bP(n2, n2, l3);
        const c2 = e2.transform.transformLightDirection(n2), h2 = a2.properties.get("color");
        return { u_lightpos: n2, u_lightpos_globe: c2, u_lightintensity: a2.properties.get("intensity"), u_lightcolor: [h2.r, h2.g, h2.b], u_vertical_gradient: +i2, u_opacity: r2, u_fill_translate: o2 };
      }, Si2 = (e2, i2, r2, o2, a2, s2, n2) => t.e(Ei2(e2, i2, r2, o2), Ii2(s2, e2, n2), { u_height_factor: -Math.pow(2, a2.overscaledZ) / n2.tileSize / 8 }), Ri2 = (e2, i2, r2, o2) => t.e(Ii2(i2, e2, r2), { u_fill_translate: o2 }), zi2 = (e2, t2) => ({ u_world: e2, u_fill_translate: t2 }), Di2 = (e2, i2, r2, o2, a2) => t.e(Ri2(e2, i2, r2, a2), { u_world: o2 }), Ai2 = (e2, i2, r2, o2, a2) => {
        const s2 = e2.transform;
        let n2, l3, c2 = 0;
        if (r2.paint.get("circle-pitch-alignment") === "map") {
          const e3 = t.az(i2, 1, s2.zoom);
          n2 = true, l3 = [e3, e3], c2 = e3 / (t.Z * Math.pow(2, i2.tileID.overscaledZ)) * 2 * Math.PI * a2;
        } else
          n2 = false, l3 = s2.pixelsToGLUnits;
        return { u_camera_to_center_distance: s2.cameraToCenterDistance, u_scale_with_map: +(r2.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +n2, u_device_pixel_ratio: e2.pixelRatio, u_extrude_scale: l3, u_globe_extrude_scale: c2, u_translate: o2 };
      }, Li2 = (e2) => ({ u_pixel_extrude_scale: [1 / e2.width, 1 / e2.height] }), ki2 = (e2) => ({ u_viewport_size: [e2.width, e2.height] }), Fi2 = (e2, t2 = 1) => ({ u_color: e2, u_overlay: 0, u_overlay_scale: t2 }), Bi2 = (e2, i2, r2, o2) => {
        const a2 = t.az(e2, 1, i2) / (t.Z * Math.pow(2, e2.tileID.overscaledZ)) * 2 * Math.PI * o2;
        return { u_extrude_scale: t.az(e2, 1, i2), u_intensity: r2, u_globe_extrude_scale: a2 };
      }, Oi2 = (e2, i2, r2, o2) => {
        const a2 = t.K();
        t.bQ(a2, 0, e2.width, e2.height, 0, 0, 1);
        const s2 = e2.context.gl;
        return { u_matrix: a2, u_world: [s2.drawingBufferWidth, s2.drawingBufferHeight], u_image: r2, u_color_ramp: o2, u_opacity: i2.paint.get("heatmap-opacity") };
      }, ji2 = (e2, t2, i2) => {
        const r2 = i2.paint.get("hillshade-accent-color");
        let o2;
        switch (i2.paint.get("hillshade-method")) {
          case "basic":
            o2 = 4;
            break;
          case "combined":
            o2 = 1;
            break;
          case "igor":
            o2 = 2;
            break;
          case "multidirectional":
            o2 = 3;
            break;
          default:
            o2 = 0;
        }
        const a2 = i2.getIlluminationProperties();
        for (let t3 = 0;t3 < a2.directionRadians.length; t3++)
          i2.paint.get("hillshade-illumination-anchor") === "viewport" && (a2.directionRadians[t3] += e2.transform.bearingInRadians);
        return { u_image: 0, u_latrange: Ni2(0, t2.tileID), u_exaggeration: i2.paint.get("hillshade-exaggeration"), u_altitudes: a2.altitudeRadians, u_azimuths: a2.directionRadians, u_accent: r2, u_method: o2, u_highlights: a2.highlightColor, u_shadows: a2.shadowColor };
      }, Zi2 = (e2, i2) => {
        const r2 = i2.stride, o2 = t.K();
        return t.bQ(o2, 0, t.Z, -8192, 0, 0, 1), t.L(o2, o2, [0, -8192, 0]), { u_matrix: o2, u_image: 1, u_dimension: [r2, r2], u_zoom: e2.overscaledZ, u_unpack: i2.getUnpackVector() };
      };
      function Ni2(e2, i2) {
        const r2 = Math.pow(2, i2.canonical.z), o2 = i2.canonical.y;
        return [new t.$(0, o2 / r2).toLngLat().lat, new t.$(0, (o2 + 1) / r2).toLngLat().lat];
      }
      const Ui2 = (e2, i2, r2, o2) => {
        const a2 = e2.transform;
        return { u_translation: Hi2(e2, i2, r2), u_ratio: o2 / t.az(i2, 1, a2.zoom), u_device_pixel_ratio: e2.pixelRatio, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
      }, Gi2 = (e2, i2, r2, o2, a2) => t.e(Ui2(e2, i2, r2, o2), { u_image: 0, u_image_height: a2 }), Vi2 = (e2, i2, r2, o2, a2) => {
        const s2 = e2.transform, n2 = Wi2(i2, s2);
        return { u_translation: Hi2(e2, i2, r2), u_texsize: i2.imageAtlasTexture.size, u_ratio: o2 / t.az(i2, 1, s2.zoom), u_device_pixel_ratio: e2.pixelRatio, u_image: 0, u_scale: [n2, a2.fromScale, a2.toScale], u_fade: a2.t, u_units_to_pixels: [1 / s2.pixelsToGLUnits[0], 1 / s2.pixelsToGLUnits[1]] };
      }, qi2 = (e2, i2, r2, o2, a2, s2) => {
        const n2 = e2.lineAtlas, l3 = Wi2(i2, e2.transform), c2 = r2.layout.get("line-cap") === "round", h2 = n2.getDash(a2.from, c2), u2 = n2.getDash(a2.to, c2), d2 = h2.width * s2.fromScale, _2 = u2.width * s2.toScale;
        return t.e(Ui2(e2, i2, r2, o2), { u_patternscale_a: [l3 / d2, -h2.height / 2], u_patternscale_b: [l3 / _2, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(d2, _2) * e2.pixelRatio) / 2, u_image: 0, u_tex_y_a: h2.y, u_tex_y_b: u2.y, u_mix: s2.t });
      };
      function Wi2(e2, i2) {
        return 1 / t.az(e2, 1, i2.tileZoom);
      }
      function Hi2(e2, i2, r2) {
        return t.aA(e2.transform, i2, r2.paint.get("line-translate"), r2.paint.get("line-translate-anchor"));
      }
      const $i2 = (e2, t2, i2, r2, o2) => {
        return { u_tl_parent: e2, u_scale_parent: t2, u_buffer_scale: 1, u_fade_t: i2.mix, u_opacity: i2.opacity * r2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r2.paint.get("raster-brightness-min"), u_brightness_high: r2.paint.get("raster-brightness-max"), u_saturation_factor: (s2 = r2.paint.get("raster-saturation"), s2 > 0 ? 1 - 1 / (1.001 - s2) : -s2), u_contrast_factor: (a2 = r2.paint.get("raster-contrast"), a2 > 0 ? 1 / (1 - a2) : 1 + a2), u_spin_weights: Xi2(r2.paint.get("raster-hue-rotate")), u_coords_top: [o2[0].x, o2[0].y, o2[1].x, o2[1].y], u_coords_bottom: [o2[3].x, o2[3].y, o2[2].x, o2[2].y] };
        var a2, s2;
      };
      function Xi2(e2) {
        e2 *= Math.PI / 180;
        const t2 = Math.sin(e2), i2 = Math.cos(e2);
        return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
      }
      const Ki2 = (e2, t2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2, d2) => {
        const _2 = s2.transform;
        return { u_is_size_zoom_constant: +(e2 === "constant" || e2 === "source"), u_is_size_feature_constant: +(e2 === "constant" || e2 === "camera"), u_size_t: t2 ? t2.uSizeT : 0, u_size: t2 ? t2.uSize : 0, u_camera_to_center_distance: _2.cameraToCenterDistance, u_pitch: _2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: _2.width / _2.height, u_fade_change: s2.options.fadeDuration ? s2.symbolFadeChange : 1, u_label_plane_matrix: n2, u_coord_matrix: l3, u_is_text: +h2, u_pitch_with_map: +r2, u_is_along_line: o2, u_is_variable_anchor: a2, u_texsize: u2, u_texture: 0, u_translation: c2, u_pitched_scale: d2 };
      }, Qi2 = (e2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2, d2, _2, p2) => {
        const m2 = n2.transform;
        return t.e(Ki2(e2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2, d2, p2), { u_gamma_scale: o2 ? Math.cos(m2.pitch * Math.PI / 180) * m2.cameraToCenterDistance : 1, u_device_pixel_ratio: n2.pixelRatio, u_is_halo: 1 });
      }, Yi2 = (e2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2, d2, _2) => t.e(Qi2(e2, i2, r2, o2, a2, s2, n2, l3, c2, h2, true, u2, 0, _2), { u_texsize_icon: d2, u_texture_icon: 1 }), Ji2 = (e2, t2) => ({ u_opacity: e2, u_color: t2 }), er2 = (e2, i2, r2, o2, a2) => t.e(function(e3, i3, r3, o3) {
        const a3 = r3.imageManager.getPattern(e3.from.toString()), s2 = r3.imageManager.getPattern(e3.to.toString()), { width: n2, height: l3 } = r3.imageManager.getPixelSize(), c2 = Math.pow(2, o3.tileID.overscaledZ), h2 = o3.tileSize * Math.pow(2, r3.transform.tileZoom) / c2, u2 = h2 * (o3.tileID.canonical.x + o3.tileID.wrap * c2), d2 = h2 * o3.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: a3.tl, u_pattern_br_a: a3.br, u_pattern_tl_b: s2.tl, u_pattern_br_b: s2.br, u_texsize: [n2, l3], u_mix: i3.t, u_pattern_size_a: a3.displaySize, u_pattern_size_b: s2.displaySize, u_scale_a: i3.fromScale, u_scale_b: i3.toScale, u_tile_units_to_pixels: 1 / t.az(o3, 1, r3.transform.tileZoom), u_pixel_coord_upper: [u2 >> 16, d2 >> 16], u_pixel_coord_lower: [65535 & u2, 65535 & d2] };
      }(r2, a2, i2, o2), { u_opacity: e2 }), tr2 = (e2, t2) => {
      }, ir2 = { fillExtrusion: (e2, i2) => ({ u_lightpos: new t.bL(e2, i2.u_lightpos), u_lightpos_globe: new t.bL(e2, i2.u_lightpos_globe), u_lightintensity: new t.b8(e2, i2.u_lightintensity), u_lightcolor: new t.bL(e2, i2.u_lightcolor), u_vertical_gradient: new t.b8(e2, i2.u_vertical_gradient), u_opacity: new t.b8(e2, i2.u_opacity), u_fill_translate: new t.bM(e2, i2.u_fill_translate) }), fillExtrusionPattern: (e2, i2) => ({ u_lightpos: new t.bL(e2, i2.u_lightpos), u_lightpos_globe: new t.bL(e2, i2.u_lightpos_globe), u_lightintensity: new t.b8(e2, i2.u_lightintensity), u_lightcolor: new t.bL(e2, i2.u_lightcolor), u_vertical_gradient: new t.b8(e2, i2.u_vertical_gradient), u_height_factor: new t.b8(e2, i2.u_height_factor), u_opacity: new t.b8(e2, i2.u_opacity), u_fill_translate: new t.bM(e2, i2.u_fill_translate), u_image: new t.bH(e2, i2.u_image), u_texsize: new t.bM(e2, i2.u_texsize), u_pixel_coord_upper: new t.bM(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.bM(e2, i2.u_pixel_coord_lower), u_scale: new t.bL(e2, i2.u_scale), u_fade: new t.b8(e2, i2.u_fade) }), fill: (e2, i2) => ({ u_fill_translate: new t.bM(e2, i2.u_fill_translate) }), fillPattern: (e2, i2) => ({ u_image: new t.bH(e2, i2.u_image), u_texsize: new t.bM(e2, i2.u_texsize), u_pixel_coord_upper: new t.bM(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.bM(e2, i2.u_pixel_coord_lower), u_scale: new t.bL(e2, i2.u_scale), u_fade: new t.b8(e2, i2.u_fade), u_fill_translate: new t.bM(e2, i2.u_fill_translate) }), fillOutline: (e2, i2) => ({ u_world: new t.bM(e2, i2.u_world), u_fill_translate: new t.bM(e2, i2.u_fill_translate) }), fillOutlinePattern: (e2, i2) => ({ u_world: new t.bM(e2, i2.u_world), u_image: new t.bH(e2, i2.u_image), u_texsize: new t.bM(e2, i2.u_texsize), u_pixel_coord_upper: new t.bM(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.bM(e2, i2.u_pixel_coord_lower), u_scale: new t.bL(e2, i2.u_scale), u_fade: new t.b8(e2, i2.u_fade), u_fill_translate: new t.bM(e2, i2.u_fill_translate) }), circle: (e2, i2) => ({ u_camera_to_center_distance: new t.b8(e2, i2.u_camera_to_center_distance), u_scale_with_map: new t.bH(e2, i2.u_scale_with_map), u_pitch_with_map: new t.bH(e2, i2.u_pitch_with_map), u_extrude_scale: new t.bM(e2, i2.u_extrude_scale), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_globe_extrude_scale: new t.b8(e2, i2.u_globe_extrude_scale), u_translate: new t.bM(e2, i2.u_translate) }), collisionBox: (e2, i2) => ({ u_pixel_extrude_scale: new t.bM(e2, i2.u_pixel_extrude_scale) }), collisionCircle: (e2, i2) => ({ u_viewport_size: new t.bM(e2, i2.u_viewport_size) }), debug: (e2, i2) => ({ u_color: new t.bI(e2, i2.u_color), u_overlay: new t.bH(e2, i2.u_overlay), u_overlay_scale: new t.b8(e2, i2.u_overlay_scale) }), depth: tr2, clippingMask: tr2, heatmap: (e2, i2) => ({ u_extrude_scale: new t.b8(e2, i2.u_extrude_scale), u_intensity: new t.b8(e2, i2.u_intensity), u_globe_extrude_scale: new t.b8(e2, i2.u_globe_extrude_scale) }), heatmapTexture: (e2, i2) => ({ u_matrix: new t.bJ(e2, i2.u_matrix), u_world: new t.bM(e2, i2.u_world), u_image: new t.bH(e2, i2.u_image), u_color_ramp: new t.bH(e2, i2.u_color_ramp), u_opacity: new t.b8(e2, i2.u_opacity) }), hillshade: (e2, i2) => ({ u_image: new t.bH(e2, i2.u_image), u_latrange: new t.bM(e2, i2.u_latrange), u_exaggeration: new t.b8(e2, i2.u_exaggeration), u_altitudes: new t.bS(e2, i2.u_altitudes), u_azimuths: new t.bS(e2, i2.u_azimuths), u_accent: new t.bI(e2, i2.u_accent), u_method: new t.bH(e2, i2.u_method), u_shadows: new t.bR(e2, i2.u_shadows), u_highlights: new t.bR(e2, i2.u_highlights) }), hillshadePrepare: (e2, i2) => ({ u_matrix: new t.bJ(e2, i2.u_matrix), u_image: new t.bH(e2, i2.u_image), u_dimension: new t.bM(e2, i2.u_dimension), u_zoom: new t.b8(e2, i2.u_zoom), u_unpack: new t.bK(e2, i2.u_unpack) }), line: (e2, i2) => ({ u_translation: new t.bM(e2, i2.u_translation), u_ratio: new t.b8(e2, i2.u_ratio), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.bM(e2, i2.u_units_to_pixels) }), lineGradient: (e2, i2) => ({ u_translation: new t.bM(e2, i2.u_translation), u_ratio: new t.b8(e2, i2.u_ratio), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.bM(e2, i2.u_units_to_pixels), u_image: new t.bH(e2, i2.u_image), u_image_height: new t.b8(e2, i2.u_image_height) }), linePattern: (e2, i2) => ({ u_translation: new t.bM(e2, i2.u_translation), u_texsize: new t.bM(e2, i2.u_texsize), u_ratio: new t.b8(e2, i2.u_ratio), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_image: new t.bH(e2, i2.u_image), u_units_to_pixels: new t.bM(e2, i2.u_units_to_pixels), u_scale: new t.bL(e2, i2.u_scale), u_fade: new t.b8(e2, i2.u_fade) }), lineSDF: (e2, i2) => ({ u_translation: new t.bM(e2, i2.u_translation), u_ratio: new t.b8(e2, i2.u_ratio), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.bM(e2, i2.u_units_to_pixels), u_patternscale_a: new t.bM(e2, i2.u_patternscale_a), u_patternscale_b: new t.bM(e2, i2.u_patternscale_b), u_sdfgamma: new t.b8(e2, i2.u_sdfgamma), u_image: new t.bH(e2, i2.u_image), u_tex_y_a: new t.b8(e2, i2.u_tex_y_a), u_tex_y_b: new t.b8(e2, i2.u_tex_y_b), u_mix: new t.b8(e2, i2.u_mix) }), raster: (e2, i2) => ({ u_tl_parent: new t.bM(e2, i2.u_tl_parent), u_scale_parent: new t.b8(e2, i2.u_scale_parent), u_buffer_scale: new t.b8(e2, i2.u_buffer_scale), u_fade_t: new t.b8(e2, i2.u_fade_t), u_opacity: new t.b8(e2, i2.u_opacity), u_image0: new t.bH(e2, i2.u_image0), u_image1: new t.bH(e2, i2.u_image1), u_brightness_low: new t.b8(e2, i2.u_brightness_low), u_brightness_high: new t.b8(e2, i2.u_brightness_high), u_saturation_factor: new t.b8(e2, i2.u_saturation_factor), u_contrast_factor: new t.b8(e2, i2.u_contrast_factor), u_spin_weights: new t.bL(e2, i2.u_spin_weights), u_coords_top: new t.bK(e2, i2.u_coords_top), u_coords_bottom: new t.bK(e2, i2.u_coords_bottom) }), symbolIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.bH(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bH(e2, i2.u_is_size_feature_constant), u_size_t: new t.b8(e2, i2.u_size_t), u_size: new t.b8(e2, i2.u_size), u_camera_to_center_distance: new t.b8(e2, i2.u_camera_to_center_distance), u_pitch: new t.b8(e2, i2.u_pitch), u_rotate_symbol: new t.bH(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.b8(e2, i2.u_aspect_ratio), u_fade_change: new t.b8(e2, i2.u_fade_change), u_label_plane_matrix: new t.bJ(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.bJ(e2, i2.u_coord_matrix), u_is_text: new t.bH(e2, i2.u_is_text), u_pitch_with_map: new t.bH(e2, i2.u_pitch_with_map), u_is_along_line: new t.bH(e2, i2.u_is_along_line), u_is_variable_anchor: new t.bH(e2, i2.u_is_variable_anchor), u_texsize: new t.bM(e2, i2.u_texsize), u_texture: new t.bH(e2, i2.u_texture), u_translation: new t.bM(e2, i2.u_translation), u_pitched_scale: new t.b8(e2, i2.u_pitched_scale) }), symbolSDF: (e2, i2) => ({ u_is_size_zoom_constant: new t.bH(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bH(e2, i2.u_is_size_feature_constant), u_size_t: new t.b8(e2, i2.u_size_t), u_size: new t.b8(e2, i2.u_size), u_camera_to_center_distance: new t.b8(e2, i2.u_camera_to_center_distance), u_pitch: new t.b8(e2, i2.u_pitch), u_rotate_symbol: new t.bH(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.b8(e2, i2.u_aspect_ratio), u_fade_change: new t.b8(e2, i2.u_fade_change), u_label_plane_matrix: new t.bJ(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.bJ(e2, i2.u_coord_matrix), u_is_text: new t.bH(e2, i2.u_is_text), u_pitch_with_map: new t.bH(e2, i2.u_pitch_with_map), u_is_along_line: new t.bH(e2, i2.u_is_along_line), u_is_variable_anchor: new t.bH(e2, i2.u_is_variable_anchor), u_texsize: new t.bM(e2, i2.u_texsize), u_texture: new t.bH(e2, i2.u_texture), u_gamma_scale: new t.b8(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_is_halo: new t.bH(e2, i2.u_is_halo), u_translation: new t.bM(e2, i2.u_translation), u_pitched_scale: new t.b8(e2, i2.u_pitched_scale) }), symbolTextAndIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.bH(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bH(e2, i2.u_is_size_feature_constant), u_size_t: new t.b8(e2, i2.u_size_t), u_size: new t.b8(e2, i2.u_size), u_camera_to_center_distance: new t.b8(e2, i2.u_camera_to_center_distance), u_pitch: new t.b8(e2, i2.u_pitch), u_rotate_symbol: new t.bH(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.b8(e2, i2.u_aspect_ratio), u_fade_change: new t.b8(e2, i2.u_fade_change), u_label_plane_matrix: new t.bJ(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.bJ(e2, i2.u_coord_matrix), u_is_text: new t.bH(e2, i2.u_is_text), u_pitch_with_map: new t.bH(e2, i2.u_pitch_with_map), u_is_along_line: new t.bH(e2, i2.u_is_along_line), u_is_variable_anchor: new t.bH(e2, i2.u_is_variable_anchor), u_texsize: new t.bM(e2, i2.u_texsize), u_texsize_icon: new t.bM(e2, i2.u_texsize_icon), u_texture: new t.bH(e2, i2.u_texture), u_texture_icon: new t.bH(e2, i2.u_texture_icon), u_gamma_scale: new t.b8(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_is_halo: new t.bH(e2, i2.u_is_halo), u_translation: new t.bM(e2, i2.u_translation), u_pitched_scale: new t.b8(e2, i2.u_pitched_scale) }), background: (e2, i2) => ({ u_opacity: new t.b8(e2, i2.u_opacity), u_color: new t.bI(e2, i2.u_color) }), backgroundPattern: (e2, i2) => ({ u_opacity: new t.b8(e2, i2.u_opacity), u_image: new t.bH(e2, i2.u_image), u_pattern_tl_a: new t.bM(e2, i2.u_pattern_tl_a), u_pattern_br_a: new t.bM(e2, i2.u_pattern_br_a), u_pattern_tl_b: new t.bM(e2, i2.u_pattern_tl_b), u_pattern_br_b: new t.bM(e2, i2.u_pattern_br_b), u_texsize: new t.bM(e2, i2.u_texsize), u_mix: new t.b8(e2, i2.u_mix), u_pattern_size_a: new t.bM(e2, i2.u_pattern_size_a), u_pattern_size_b: new t.bM(e2, i2.u_pattern_size_b), u_scale_a: new t.b8(e2, i2.u_scale_a), u_scale_b: new t.b8(e2, i2.u_scale_b), u_pixel_coord_upper: new t.bM(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.bM(e2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.b8(e2, i2.u_tile_units_to_pixels) }), terrain: (e2, i2) => ({ u_texture: new t.bH(e2, i2.u_texture), u_ele_delta: new t.b8(e2, i2.u_ele_delta), u_fog_matrix: new t.bJ(e2, i2.u_fog_matrix), u_fog_color: new t.bI(e2, i2.u_fog_color), u_fog_ground_blend: new t.b8(e2, i2.u_fog_ground_blend), u_fog_ground_blend_opacity: new t.b8(e2, i2.u_fog_ground_blend_opacity), u_horizon_color: new t.bI(e2, i2.u_horizon_color), u_horizon_fog_blend: new t.b8(e2, i2.u_horizon_fog_blend), u_is_globe_mode: new t.b8(e2, i2.u_is_globe_mode) }), terrainDepth: (e2, i2) => ({ u_ele_delta: new t.b8(e2, i2.u_ele_delta) }), terrainCoords: (e2, i2) => ({ u_texture: new t.bH(e2, i2.u_texture), u_terrain_coords_id: new t.b8(e2, i2.u_terrain_coords_id), u_ele_delta: new t.b8(e2, i2.u_ele_delta) }), projectionErrorMeasurement: (e2, i2) => ({ u_input: new t.b8(e2, i2.u_input), u_output_expected: new t.b8(e2, i2.u_output_expected) }), atmosphere: (e2, i2) => ({ u_sun_pos: new t.bL(e2, i2.u_sun_pos), u_atmosphere_blend: new t.b8(e2, i2.u_atmosphere_blend), u_globe_position: new t.bL(e2, i2.u_globe_position), u_globe_radius: new t.b8(e2, i2.u_globe_radius), u_inv_proj_matrix: new t.bJ(e2, i2.u_inv_proj_matrix) }), sky: (e2, i2) => ({ u_sky_color: new t.bI(e2, i2.u_sky_color), u_horizon_color: new t.bI(e2, i2.u_horizon_color), u_horizon: new t.bM(e2, i2.u_horizon), u_horizon_normal: new t.bM(e2, i2.u_horizon_normal), u_sky_horizon_blend: new t.b8(e2, i2.u_sky_horizon_blend), u_sky_blend: new t.b8(e2, i2.u_sky_blend) }) };

      class rr2 {
        constructor(e2, t2, i2) {
          this.context = e2;
          const r2 = e2.gl;
          this.buffer = r2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), r2.bufferData(r2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || delete t2.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e2) {
          const t2 = this.context.gl;
          if (!this.dynamicDraw)
            throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const or2 = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };

      class ar2 {
        constructor(e2, t2, i2, r2) {
          this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = r2, this.context = e2;
          const o2 = e2.gl;
          this.buffer = o2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), o2.bufferData(o2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete t2.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e2) {
          if (e2.length !== this.length)
            throw new Error(`Length of new data is ${e2.length}, which doesn't match current length of ${this.length}`);
          const t2 = this.context.gl;
          this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
        }
        enableAttributes(e2, t2) {
          for (let i2 = 0;i2 < this.attributes.length; i2++) {
            const r2 = t2.attributes[this.attributes[i2].name];
            r2 !== undefined && e2.enableVertexAttribArray(r2);
          }
        }
        setVertexAttribPointers(e2, t2, i2) {
          for (let r2 = 0;r2 < this.attributes.length; r2++) {
            const o2 = this.attributes[r2], a2 = t2.attributes[o2.name];
            a2 !== undefined && e2.vertexAttribPointer(a2, o2.components, e2[or2[o2.type]], false, this.itemSize, o2.offset + this.itemSize * (i2 || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }

      class sr2 {
        constructor(e2) {
          this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(e2) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }

      class nr2 extends sr2 {
        getDefault() {
          return t.b7.transparent;
        }
        set(e2) {
          const t2 = this.current;
          (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
        }
      }

      class lr2 extends sr2 {
        getDefault() {
          return 1;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
        }
      }

      class cr2 extends sr2 {
        getDefault() {
          return 0;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
        }
      }

      class hr2 extends sr2 {
        getDefault() {
          return [true, true, true, true];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
        }
      }

      class ur2 extends sr2 {
        getDefault() {
          return true;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
        }
      }

      class dr2 extends sr2 {
        getDefault() {
          return 255;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
        }
      }

      class _r2 extends sr2 {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e2) {
          const t2 = this.current;
          (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
        }
      }

      class pr2 extends sr2 {
        getDefault() {
          const e2 = this.gl;
          return [e2.KEEP, e2.KEEP, e2.KEEP];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
        }
      }

      class mr2 extends sr2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
        }
      }

      class fr2 extends sr2 {
        getDefault() {
          return [0, 1];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
        }
      }

      class gr2 extends sr2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
        }
      }

      class vr2 extends sr2 {
        getDefault() {
          return this.gl.LESS;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
        }
      }

      class xr2 extends sr2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
        }
      }

      class br2 extends sr2 {
        getDefault() {
          const e2 = this.gl;
          return [e2.ONE, e2.ZERO];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
        }
      }

      class yr2 extends sr2 {
        getDefault() {
          return t.b7.transparent;
        }
        set(e2) {
          const t2 = this.current;
          (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
        }
      }

      class wr2 extends sr2 {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
        }
      }

      class Tr2 extends sr2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
        }
      }

      class Pr2 extends sr2 {
        getDefault() {
          return this.gl.BACK;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
        }
      }

      class Cr2 extends sr2 {
        getDefault() {
          return this.gl.CCW;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
        }
      }

      class Mr2 extends sr2 {
        getDefault() {
          return null;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
        }
      }

      class Ir2 extends sr2 {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
        }
      }

      class Er2 extends sr2 {
        getDefault() {
          const e2 = this.gl;
          return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
        }
      }

      class Sr2 extends sr2 {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }

      class Rr2 extends sr2 {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }

      class zr2 extends sr2 {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
        }
      }

      class Dr2 extends sr2 {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
        }
      }

      class Ar2 extends sr2 {
        getDefault() {
          return null;
        }
        set(e2) {
          const t2 = this.gl;
          t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
        }
      }

      class Lr2 extends sr2 {
        getDefault() {
          return null;
        }
        set(e2) {
          var t2;
          if (e2 === this.current && !this.dirty)
            return;
          const i2 = this.gl;
          Wt2(i2) ? i2.bindVertexArray(e2) : (t2 = i2.getExtension("OES_vertex_array_object")) === null || t2 === undefined || t2.bindVertexArrayOES(e2), this.current = e2, this.dirty = false;
        }
      }

      class kr2 extends sr2 {
        getDefault() {
          return 4;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
        }
      }

      class Fr2 extends sr2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
        }
      }

      class Br2 extends sr2 {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
        }
      }

      class Or2 extends sr2 {
        constructor(e2, t2) {
          super(e2), this.context = e2, this.parent = t2;
        }
        getDefault() {
          return null;
        }
      }

      class jr2 extends Or2 {
        setDirty() {
          this.dirty = true;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
        }
      }

      class Zr2 extends Or2 {
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferRenderbuffer(t2.FRAMEBUFFER, t2.DEPTH_ATTACHMENT, t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }

      class Nr2 extends Or2 {
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferRenderbuffer(t2.FRAMEBUFFER, t2.DEPTH_STENCIL_ATTACHMENT, t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      const Ur2 = "Framebuffer is not complete";

      class Gr2 {
        constructor(e2, t2, i2, r2, o2) {
          this.context = e2, this.width = t2, this.height = i2;
          const a2 = e2.gl, s2 = this.framebuffer = a2.createFramebuffer();
          if (this.colorAttachment = new jr2(e2, s2), r2)
            this.depthAttachment = o2 ? new Nr2(e2, s2) : new Zr2(e2, s2);
          else if (o2)
            throw new Error("Stencil cannot be set without depth");
          if (a2.checkFramebufferStatus(a2.FRAMEBUFFER) !== a2.FRAMEBUFFER_COMPLETE)
            throw new Error(Ur2);
        }
        destroy() {
          const e2 = this.context.gl, t2 = this.colorAttachment.get();
          if (t2 && e2.deleteTexture(t2), this.depthAttachment) {
            const t3 = this.depthAttachment.get();
            t3 && e2.deleteRenderbuffer(t3);
          }
          e2.deleteFramebuffer(this.framebuffer);
        }
      }

      class Vr2 {
        constructor(e2) {
          var t2, i2;
          if (this.gl = e2, this.clearColor = new nr2(this), this.clearDepth = new lr2(this), this.clearStencil = new cr2(this), this.colorMask = new hr2(this), this.depthMask = new ur2(this), this.stencilMask = new dr2(this), this.stencilFunc = new _r2(this), this.stencilOp = new pr2(this), this.stencilTest = new mr2(this), this.depthRange = new fr2(this), this.depthTest = new gr2(this), this.depthFunc = new vr2(this), this.blend = new xr2(this), this.blendFunc = new br2(this), this.blendColor = new yr2(this), this.blendEquation = new wr2(this), this.cullFace = new Tr2(this), this.cullFaceSide = new Pr2(this), this.frontFace = new Cr2(this), this.program = new Mr2(this), this.activeTexture = new Ir2(this), this.viewport = new Er2(this), this.bindFramebuffer = new Sr2(this), this.bindRenderbuffer = new Rr2(this), this.bindTexture = new zr2(this), this.bindVertexBuffer = new Dr2(this), this.bindElementBuffer = new Ar2(this), this.bindVertexArray = new Lr2(this), this.pixelStoreUnpack = new kr2(this), this.pixelStoreUnpackPremultiplyAlpha = new Fr2(this), this.pixelStoreUnpackFlipY = new Br2(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), Wt2(e2)) {
            this.HALF_FLOAT = e2.HALF_FLOAT;
            const r2 = e2.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (t2 = e2.RGBA16F) !== null && t2 !== undefined ? t2 : r2 == null ? undefined : r2.RGBA16F_EXT, this.RGB16F = (i2 = e2.RGB16F) !== null && i2 !== undefined ? i2 : r2 == null ? undefined : r2.RGB16F_EXT, e2.getExtension("EXT_color_buffer_float");
          } else {
            e2.getExtension("EXT_color_buffer_half_float"), e2.getExtension("OES_texture_half_float_linear");
            const t3 = e2.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = t3 == null ? undefined : t3.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(e2, t2) {
          return new rr2(this, e2, t2);
        }
        createVertexBuffer(e2, t2, i2) {
          return new ar2(this, e2, t2, i2);
        }
        createRenderbuffer(e2, t2, i2) {
          const r2 = this.gl, o2 = r2.createRenderbuffer();
          return this.bindRenderbuffer.set(o2), r2.renderbufferStorage(r2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), o2;
        }
        createFramebuffer(e2, t2, i2, r2) {
          return new Gr2(this, e2, t2, i2, r2);
        }
        clear({ color: e2, depth: t2, stencil: i2 }) {
          const r2 = this.gl;
          let o2 = 0;
          e2 && (o2 |= r2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), t2 !== undefined && (o2 |= r2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), i2 !== undefined && (o2 |= r2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), r2.clear(o2);
        }
        setCullFace(e2) {
          e2.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
        }
        setDepthMode(e2) {
          e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
        }
        setStencilMode(e2) {
          e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(e2) {
          t.bE(e2.blendFunction, jt2.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
        }
        createVertexArray() {
          var e2;
          return Wt2(this.gl) ? this.gl.createVertexArray() : (e2 = this.gl.getExtension("OES_vertex_array_object")) === null || e2 === undefined ? undefined : e2.createVertexArrayOES();
        }
        deleteVertexArray(e2) {
          var t2;
          return Wt2(this.gl) ? this.gl.deleteVertexArray(e2) : (t2 = this.gl.getExtension("OES_vertex_array_object")) === null || t2 === undefined ? undefined : t2.deleteVertexArrayOES(e2);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      let qr2;
      function Wr2(e2, i2, r2, o2, a2) {
        const { context: s2, transform: n2 } = e2, l3 = s2.gl, c2 = e2.useProgram("collisionBox"), h2 = [];
        let u2 = 0, d2 = 0;
        for (let t2 = 0;t2 < o2.length; t2++) {
          const _3 = o2[t2], p3 = i2.getTile(_3).getBucket(r2);
          if (!p3)
            continue;
          const m3 = a2 ? p3.textCollisionBox : p3.iconCollisionBox, f3 = p3.collisionCircleArray;
          f3.length > 0 && (h2.push({ circleArray: f3, circleOffset: d2, coord: _3 }), u2 += f3.length / 4, d2 = u2), m3 && c2.draw(s2, l3.LINES, Ut.disabled, Vt2.disabled, e2.colorModeForRenderPass(), Nt2.disabled, Li2(e2.transform), e2.style.map.terrain && e2.style.map.terrain.getTerrainData(_3), n2.getProjectionData({ overscaledTileID: _3, applyGlobeMatrix: true, applyTerrainMatrix: true }), r2.id, m3.layoutVertexBuffer, m3.indexBuffer, m3.segments, null, e2.transform.zoom, null, null, m3.collisionVertexBuffer);
        }
        if (!a2 || !h2.length)
          return;
        const _2 = e2.useProgram("collisionCircle"), p2 = new t.bT;
        p2.resize(4 * u2), p2._trim();
        let m2 = 0;
        for (const e3 of h2)
          for (let t2 = 0;t2 < e3.circleArray.length / 4; t2++) {
            const i3 = 4 * t2, r3 = e3.circleArray[i3 + 0], o3 = e3.circleArray[i3 + 1], a3 = e3.circleArray[i3 + 2], s3 = e3.circleArray[i3 + 3];
            p2.emplace(m2++, r3, o3, a3, s3, 0), p2.emplace(m2++, r3, o3, a3, s3, 1), p2.emplace(m2++, r3, o3, a3, s3, 2), p2.emplace(m2++, r3, o3, a3, s3, 3);
          }
        (!qr2 || qr2.length < 2 * u2) && (qr2 = function(e3) {
          const i3 = 2 * e3, r3 = new t.bV;
          r3.resize(i3), r3._trim();
          for (let e4 = 0;e4 < i3; e4++) {
            const t2 = 6 * e4;
            r3.uint16[t2 + 0] = 4 * e4 + 0, r3.uint16[t2 + 1] = 4 * e4 + 1, r3.uint16[t2 + 2] = 4 * e4 + 2, r3.uint16[t2 + 3] = 4 * e4 + 2, r3.uint16[t2 + 4] = 4 * e4 + 3, r3.uint16[t2 + 5] = 4 * e4 + 0;
          }
          return r3;
        }(u2));
        const f2 = s2.createIndexBuffer(qr2, true), g2 = s2.createVertexBuffer(p2, t.bU.members, true);
        for (const i3 of h2) {
          const o3 = ki2(e2.transform);
          _2.draw(s2, l3.TRIANGLES, Ut.disabled, Vt2.disabled, e2.colorModeForRenderPass(), Nt2.disabled, o3, e2.style.map.terrain && e2.style.map.terrain.getTerrainData(i3.coord), null, r2.id, g2, f2, t.aJ.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
        }
        g2.destroy(), f2.destroy();
      }
      const Hr2 = t.ad(new Float32Array(16));
      function $r2(e2, i2, r2, o2, a2, s2) {
        const { horizontalAlign: n2, verticalAlign: l3 } = t.aE(e2);
        return new t.P((-(n2 - 0.5) * i2 / a2 + o2[0]) * s2, (-(l3 - 0.5) * r2 / a2 + o2[1]) * s2);
      }
      function Xr2(e2, i2, r2, o2, a2, s2) {
        const n2 = i2.tileAnchorPoint.add(new t.P(i2.translation[0], i2.translation[1]));
        if (i2.pitchWithMap) {
          let e3 = o2.mult(s2);
          r2 || (e3 = e3.rotate(-a2));
          const t2 = n2.add(e3);
          return Se2(t2.x, t2.y, i2.pitchedLabelPlaneMatrix, i2.getElevation).point;
        }
        if (r2) {
          const t2 = Oe2(i2.tileAnchorPoint.x + 1, i2.tileAnchorPoint.y, i2).point.sub(e2), r3 = Math.atan(t2.y / t2.x) + (t2.x < 0 ? Math.PI : 0);
          return e2.add(o2.rotate(r3));
        }
        return e2.add(o2);
      }
      function Kr2(e2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2, d2) {
        const _2 = e2.text.placedSymbolArray, p2 = e2.text.dynamicLayoutVertexArray, m2 = e2.icon.dynamicLayoutVertexArray, f2 = {};
        p2.clear();
        for (let m3 = 0;m3 < _2.length; m3++) {
          const g2 = _2.get(m3), v2 = g2.hidden || !g2.crossTileID || e2.allowVerticalPlacement && !g2.placedOrientation ? null : o2[g2.crossTileID];
          if (v2) {
            const o3 = new t.P(g2.anchorX, g2.anchorY), _3 = { getElevation: d2, width: a2.width, height: a2.height, pitchedLabelPlaneMatrix: s2, pitchWithMap: r2, transform: a2, tileAnchorPoint: o3, translation: h2, unwrappedTileID: u2 }, m4 = r2 ? Ze2(o3.x, o3.y, _3) : Oe2(o3.x, o3.y, _3), x2 = Re2(a2.cameraToCenterDistance, m4.signedDistanceFromCamera);
            let b2 = t.am(e2.textSizeData, l3, g2) * x2 / t.ay;
            r2 && (b2 *= e2.tilePixelRatio / n2);
            const { width: y2, height: w2, anchor: T2, textOffset: P2, textBoxScale: C2 } = v2, M3 = $r2(T2, y2, w2, P2, C2, b2), I2 = a2.getPitchedTextCorrection(o3.x + h2[0], o3.y + h2[1], u2), E3 = Xr2(m4.point, _3, i2, M3, -a2.bearingInRadians, I2), S2 = e2.allowVerticalPlacement && g2.placedOrientation === t.al.vertical ? Math.PI / 2 : 0;
            for (let e3 = 0;e3 < g2.numGlyphs; e3++)
              t.as(p2, E3, S2);
            c2 && g2.associatedIconIndex >= 0 && (f2[g2.associatedIconIndex] = { shiftedAnchor: E3, angle: S2 });
          } else
            qe2(g2.numGlyphs, p2);
        }
        if (c2) {
          m2.clear();
          const i3 = e2.icon.placedSymbolArray;
          for (let e3 = 0;e3 < i3.length; e3++) {
            const r3 = i3.get(e3);
            if (r3.hidden)
              qe2(r3.numGlyphs, m2);
            else {
              const i4 = f2[e3];
              if (i4)
                for (let e4 = 0;e4 < r3.numGlyphs; e4++)
                  t.as(m2, i4.shiftedAnchor, i4.angle);
              else
                qe2(r3.numGlyphs, m2);
            }
          }
          e2.icon.dynamicLayoutVertexBuffer.updateData(m2);
        }
        e2.text.dynamicLayoutVertexBuffer.updateData(p2);
      }
      function Qr2(e2, t2, i2) {
        return i2.iconsInText && t2 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
      }
      function Yr2(e2, i2, r2, o2, a2, s2, n2, l3, c2, h2, u2, d2, _2) {
        const p2 = e2.context, m2 = p2.gl, f2 = e2.transform, g2 = l3 === "map", v2 = c2 === "map", x2 = l3 !== "viewport" && r2.layout.get("symbol-placement") !== "point", b2 = g2 && !v2 && !x2, y2 = !r2.layout.get("symbol-sort-key").isConstant();
        let w2 = false;
        const T2 = e2.getDepthModeForSublayer(0, Ut.ReadOnly), P2 = r2._unevaluatedLayout.hasValue("text-variable-anchor") || r2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), C2 = [], M3 = f2.getCircleRadiusCorrection();
        for (const l4 of o2) {
          const o3 = i2.getTile(l4), c3 = o3.getBucket(r2);
          if (!c3)
            continue;
          const u3 = a2 ? c3.text : c3.icon;
          if (!u3 || !u3.segments.get().length || !u3.hasVisibleVertices)
            continue;
          const d3 = u3.programConfigurations.get(r2.id), p3 = a2 || c3.sdfIcons, T3 = a2 ? c3.textSizeData : c3.iconSizeData, I2 = v2 || f2.pitch !== 0, E3 = e2.useProgram(Qr2(p3, a2, c3), d3), S2 = t.ak(T3, f2.zoom), R2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(l4);
          let z3, D3, A2, L2, k2 = [0, 0], F3 = null;
          if (a2)
            D3 = o3.glyphAtlasTexture, A2 = m2.LINEAR, z3 = o3.glyphAtlasTexture.size, c3.iconsInText && (k2 = o3.imageAtlasTexture.size, F3 = o3.imageAtlasTexture, L2 = I2 || e2.options.rotating || e2.options.zooming || T3.kind === "composite" || T3.kind === "camera" ? m2.LINEAR : m2.NEAREST);
          else {
            const t2 = r2.layout.get("icon-size").constantOr(0) !== 1 || c3.iconsNeedLinear;
            D3 = o3.imageAtlasTexture, A2 = p3 || e2.options.rotating || e2.options.zooming || t2 || I2 ? m2.LINEAR : m2.NEAREST, z3 = o3.imageAtlasTexture.size;
          }
          const B3 = t.az(o3, 1, e2.transform.zoom), O2 = Me2(g2, e2.transform, B3), j3 = t.K();
          t.an(j3, O2);
          const Z3 = Ie2(v2, g2, e2.transform, B3), N2 = t.aA(f2, o3, s2, n2), U2 = f2.getProjectionData({ overscaledTileID: l4, applyGlobeMatrix: !_2, applyTerrainMatrix: true }), G3 = P2 && c3.hasTextData(), V2 = r2.layout.get("icon-text-fit") !== "none" && G3 && c3.hasIconData();
          if (x2) {
            const t2 = e2.style.map.terrain ? (t3, i4) => e2.style.map.terrain.getElevation(l4, t3, i4) : null, i3 = r2.layout.get("text-rotation-alignment") === "map";
            De(c3, e2, a2, O2, j3, v2, h2, i3, l4.toUnwrapped(), f2.width, f2.height, N2, t2);
          }
          const q2 = a2 && P2 || V2, W3 = x2 || q2 ? Hr2 : v2 ? O2 : e2.transform.clipSpaceToPixelsMatrix, H2 = p3 && r2.paint.get(a2 ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let $3;
          $3 = p3 ? c3.iconsInText ? Yi2(T3.kind, S2, b2, v2, x2, q2, e2, W3, Z3, N2, z3, k2, M3) : Qi2(T3.kind, S2, b2, v2, x2, q2, e2, W3, Z3, N2, a2, z3, 0, M3) : Ki2(T3.kind, S2, b2, v2, x2, q2, e2, W3, Z3, N2, a2, z3, M3);
          const X2 = { program: E3, buffers: u3, uniformValues: $3, projectionData: U2, atlasTexture: D3, atlasTextureIcon: F3, atlasInterpolation: A2, atlasInterpolationIcon: L2, isSDF: p3, hasHalo: H2 };
          if (y2 && c3.canOverlap) {
            w2 = true;
            const e3 = u3.segments.get();
            for (const i3 of e3)
              C2.push({ segments: new t.aJ([i3]), sortKey: i3.sortKey, state: X2, terrainData: R2 });
          } else
            C2.push({ segments: u3.segments, sortKey: 0, state: X2, terrainData: R2 });
        }
        w2 && C2.sort((e3, t2) => e3.sortKey - t2.sortKey);
        for (const t2 of C2) {
          const i3 = t2.state;
          if (p2.activeTexture.set(m2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, m2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (p2.activeTexture.set(m2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, m2.CLAMP_TO_EDGE)), i3.isSDF) {
            const o3 = i3.uniformValues;
            i3.hasHalo && (o3.u_is_halo = 1, Jr2(i3.buffers, t2.segments, r2, e2, i3.program, T2, u2, d2, o3, i3.projectionData, t2.terrainData)), o3.u_is_halo = 0;
          }
          Jr2(i3.buffers, t2.segments, r2, e2, i3.program, T2, u2, d2, i3.uniformValues, i3.projectionData, t2.terrainData);
        }
      }
      function Jr2(e2, t2, i2, r2, o2, a2, s2, n2, l3, c2, h2) {
        const u2 = r2.context;
        o2.draw(u2, u2.gl.TRIANGLES, a2, s2, n2, Nt2.backCCW, l3, h2, c2, i2.id, e2.layoutVertexBuffer, e2.indexBuffer, t2, i2.paint, r2.transform.zoom, e2.programConfigurations.get(i2.id), e2.dynamicLayoutVertexBuffer, e2.opacityVertexBuffer);
      }
      function eo2(e2, i2, r2, o2, a2) {
        const s2 = e2.context, n2 = s2.gl, l3 = Vt2.disabled, c2 = new jt2([n2.ONE, n2.ONE], t.b7.transparent, [true, true, true, true]), h2 = i2.getBucket(r2);
        if (!h2)
          return;
        const u2 = o2.key;
        let d2 = r2.heatmapFbos.get(u2);
        d2 || (d2 = io2(s2, i2.tileSize, i2.tileSize), r2.heatmapFbos.set(u2, d2)), s2.bindFramebuffer.set(d2.framebuffer), s2.viewport.set([0, 0, i2.tileSize, i2.tileSize]), s2.clear({ color: t.b7.transparent });
        const _2 = h2.programConfigurations.get(r2.id), p2 = e2.useProgram("heatmap", _2, !a2), m2 = e2.transform.getProjectionData({ overscaledTileID: i2.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), f2 = e2.style.map.terrain.getTerrainData(o2);
        p2.draw(s2, n2.TRIANGLES, Ut.disabled, l3, c2, Nt2.disabled, Bi2(i2, e2.transform.zoom, r2.paint.get("heatmap-intensity"), 1), f2, m2, r2.id, h2.layoutVertexBuffer, h2.indexBuffer, h2.segments, r2.paint, e2.transform.zoom, _2);
      }
      function to2(e2, t2, i2, r2, o2) {
        const a2 = e2.context, s2 = a2.gl, n2 = e2.transform;
        a2.setColorMode(e2.colorModeForRenderPass());
        const l3 = ro2(a2, t2), c2 = i2.key, h2 = t2.heatmapFbos.get(c2);
        if (!h2)
          return;
        a2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, h2.colorAttachment.get()), a2.activeTexture.set(s2.TEXTURE1), l3.bind(s2.LINEAR, s2.CLAMP_TO_EDGE);
        const u2 = n2.getProjectionData({ overscaledTileID: i2, applyTerrainMatrix: o2, applyGlobeMatrix: !r2 });
        e2.useProgram("heatmapTexture").draw(a2, s2.TRIANGLES, Ut.disabled, Vt2.disabled, e2.colorModeForRenderPass(), Nt2.disabled, Oi2(e2, t2, 0, 1), null, u2, t2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments, t2.paint, n2.zoom), h2.destroy(), t2.heatmapFbos.delete(c2);
      }
      function io2(e2, t2, i2) {
        var r2, o2;
        const a2 = e2.gl, s2 = a2.createTexture();
        a2.bindTexture(a2.TEXTURE_2D, s2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, a2.CLAMP_TO_EDGE), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, a2.CLAMP_TO_EDGE), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, a2.LINEAR), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, a2.LINEAR);
        const n2 = (r2 = e2.HALF_FLOAT) !== null && r2 !== undefined ? r2 : a2.UNSIGNED_BYTE, l3 = (o2 = e2.RGBA16F) !== null && o2 !== undefined ? o2 : a2.RGBA;
        a2.texImage2D(a2.TEXTURE_2D, 0, l3, t2, i2, 0, a2.RGBA, n2, null);
        const c2 = e2.createFramebuffer(t2, i2, false, false);
        return c2.colorAttachment.set(s2), c2;
      }
      function ro2(e2, t2) {
        return t2.colorRampTexture || (t2.colorRampTexture = new v(e2, t2.colorRamp, e2.gl.RGBA)), t2.colorRampTexture;
      }
      function oo2(e2, t2, i2, r2, o2) {
        if (!i2 || !r2 || !r2.imageAtlas)
          return;
        const a2 = r2.imageAtlas.patternPositions;
        let s2 = a2[i2.to.toString()], n2 = a2[i2.from.toString()];
        if (!s2 && n2 && (s2 = n2), !n2 && s2 && (n2 = s2), !s2 || !n2) {
          const e3 = o2.getPaintProperty(t2);
          s2 = a2[e3], n2 = a2[e3];
        }
        s2 && n2 && e2.setConstantPatternPositions(s2, n2);
      }
      function ao2(e2, i2, r2, o2, a2, s2, n2, l3) {
        const c2 = e2.context.gl, h2 = "fill-pattern", u2 = r2.paint.get(h2), d2 = u2 && u2.constantOr(1), _2 = r2.getCrossfadeParameters();
        let p2, m2, f2, g2, v2;
        const x2 = e2.transform, b2 = r2.paint.get("fill-translate"), y2 = r2.paint.get("fill-translate-anchor");
        n2 ? (m2 = d2 && !r2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p2 = c2.LINES) : (m2 = d2 ? "fillPattern" : "fill", p2 = c2.TRIANGLES);
        const w2 = u2.constantOr(null);
        for (const u3 of o2) {
          const o3 = i2.getTile(u3);
          if (d2 && !o3.patternsLoaded())
            continue;
          const T2 = o3.getBucket(r2);
          if (!T2)
            continue;
          const P2 = T2.programConfigurations.get(r2.id), C2 = e2.useProgram(m2, P2), M3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(u3);
          d2 && (e2.context.activeTexture.set(c2.TEXTURE0), o3.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), P2.updatePaintBuffers(_2)), oo2(P2, h2, w2, o3, r2);
          const I2 = x2.getProjectionData({ overscaledTileID: u3, applyGlobeMatrix: !l3, applyTerrainMatrix: true }), E3 = t.aA(x2, o3, b2, y2);
          if (n2) {
            g2 = T2.indexBuffer2, v2 = T2.segments2;
            const t2 = [c2.drawingBufferWidth, c2.drawingBufferHeight];
            f2 = m2 === "fillOutlinePattern" && d2 ? Di2(e2, _2, o3, t2, E3) : zi2(t2, E3);
          } else
            g2 = T2.indexBuffer, v2 = T2.segments, f2 = d2 ? Ri2(e2, _2, o3, E3) : { u_fill_translate: E3 };
          const S2 = e2.stencilModeForClipping(u3);
          C2.draw(e2.context, p2, a2, S2, s2, Nt2.backCCW, f2, M3, I2, r2.id, T2.layoutVertexBuffer, g2, v2, r2.paint, e2.transform.zoom, P2);
        }
      }
      function so2(e2, i2, r2, o2, a2, s2, n2, l3) {
        const c2 = e2.context, h2 = c2.gl, u2 = "fill-extrusion-pattern", d2 = r2.paint.get(u2), _2 = d2.constantOr(1), p2 = r2.getCrossfadeParameters(), m2 = r2.paint.get("fill-extrusion-opacity"), f2 = d2.constantOr(null), g2 = e2.transform;
        for (const d3 of o2) {
          const o3 = i2.getTile(d3), v2 = o3.getBucket(r2);
          if (!v2)
            continue;
          const x2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(d3), b2 = v2.programConfigurations.get(r2.id), y2 = e2.useProgram(_2 ? "fillExtrusionPattern" : "fillExtrusion", b2);
          _2 && (e2.context.activeTexture.set(h2.TEXTURE0), o3.imageAtlasTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), b2.updatePaintBuffers(p2));
          const w2 = g2.getProjectionData({ overscaledTileID: d3, applyGlobeMatrix: !l3, applyTerrainMatrix: true });
          oo2(b2, u2, f2, o3, r2);
          const T2 = t.aA(g2, o3, r2.paint.get("fill-extrusion-translate"), r2.paint.get("fill-extrusion-translate-anchor")), P2 = r2.paint.get("fill-extrusion-vertical-gradient"), C2 = _2 ? Si2(e2, P2, m2, T2, d3, p2, o3) : Ei2(e2, P2, m2, T2);
          y2.draw(c2, c2.gl.TRIANGLES, a2, s2, n2, Nt2.backCCW, C2, x2, w2, r2.id, v2.layoutVertexBuffer, v2.indexBuffer, v2.segments, r2.paint, e2.transform.zoom, b2, e2.style.map.terrain && v2.centroidVertexBuffer);
        }
      }
      function no2(e2, t2, i2, r2, o2, a2, s2, n2, l3) {
        var c2;
        const h2 = e2.style.projection, u2 = e2.context, d2 = e2.transform, _2 = u2.gl, p2 = [`#define NUM_ILLUMINATION_SOURCES ${i2.paint.get("hillshade-highlight-color").values.length}`], m2 = e2.useProgram("hillshade", null, false, p2), f2 = !e2.options.moving;
        for (const p3 of r2) {
          const r3 = t2.getTile(p3), g2 = r3.fbo;
          if (!g2)
            continue;
          const v2 = h2.getMeshFromTileID(u2, p3.canonical, n2, true, "raster"), x2 = (c2 = e2.style.map.terrain) === null || c2 === undefined ? undefined : c2.getTerrainData(p3);
          u2.activeTexture.set(_2.TEXTURE0), _2.bindTexture(_2.TEXTURE_2D, g2.colorAttachment.get());
          const b2 = d2.getProjectionData({ overscaledTileID: p3, aligned: f2, applyGlobeMatrix: !l3, applyTerrainMatrix: true });
          m2.draw(u2, _2.TRIANGLES, a2, o2[p3.overscaledZ], s2, Nt2.backCCW, ji2(e2, r3, i2), x2, b2, i2.id, v2.vertexBuffer, v2.indexBuffer, v2.segments);
        }
      }
      const lo2 = [new t.P(0, 0), new t.P(t.Z, 0), new t.P(t.Z, t.Z), new t.P(0, t.Z)];
      function co2(e2, t2, i2, r2, o2, a2, s2, n2, l3 = false, c2 = false) {
        const h2 = r2[r2.length - 1].overscaledZ, u2 = e2.context, d2 = u2.gl, _2 = e2.useProgram("raster"), p2 = e2.transform, m2 = e2.style.projection, f2 = e2.colorModeForRenderPass(), g2 = !e2.options.moving;
        for (const v2 of r2) {
          const r3 = e2.getDepthModeForSublayer(v2.overscaledZ - h2, i2.paint.get("raster-opacity") === 1 ? Ut.ReadWrite : Ut.ReadOnly, d2.LESS), x2 = t2.getTile(v2);
          x2.registerFadeDuration(i2.paint.get("raster-fade-duration"));
          const b2 = t2.findLoadedParent(v2, 0), y2 = t2.findLoadedSibling(v2), w2 = ho2(x2, b2 || y2 || null, t2, i2, e2.transform, e2.style.map.terrain);
          let T2, P2;
          const C2 = i2.paint.get("raster-resampling") === "nearest" ? d2.NEAREST : d2.LINEAR;
          u2.activeTexture.set(d2.TEXTURE0), x2.texture.bind(C2, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST), u2.activeTexture.set(d2.TEXTURE1), b2 ? (b2.texture.bind(C2, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST), T2 = Math.pow(2, b2.tileID.overscaledZ - x2.tileID.overscaledZ), P2 = [x2.tileID.canonical.x * T2 % 1, x2.tileID.canonical.y * T2 % 1]) : x2.texture.bind(C2, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST), x2.texture.useMipmap && u2.extTextureFilterAnisotropic && e2.transform.pitch > 20 && d2.texParameterf(d2.TEXTURE_2D, u2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u2.extTextureFilterAnisotropicMax);
          const M3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(v2), I2 = p2.getProjectionData({ overscaledTileID: v2, aligned: g2, applyGlobeMatrix: !c2, applyTerrainMatrix: true }), E3 = $i2(P2 || [0, 0], T2 || 1, w2, i2, n2), S2 = m2.getMeshFromTileID(u2, v2.canonical, a2, s2, "raster");
          _2.draw(u2, d2.TRIANGLES, r3, o2 ? o2[v2.overscaledZ] : Vt2.disabled, f2, l3 ? Nt2.frontCCW : Nt2.backCCW, E3, M3, I2, i2.id, S2.vertexBuffer, S2.indexBuffer, S2.segments);
        }
      }
      function ho2(e2, i2, r2, o2, a2, n2) {
        const l3 = o2.paint.get("raster-fade-duration");
        if (!n2 && l3 > 0) {
          const o3 = s.now(), n3 = (o3 - e2.timeAdded) / l3, c2 = i2 ? (o3 - i2.timeAdded) / l3 : -1, h2 = r2.getSource(), u2 = ve2(a2, { tileSize: h2.tileSize, roundZoom: h2.roundZoom }), d2 = !i2 || Math.abs(i2.tileID.overscaledZ - u2) > Math.abs(e2.tileID.overscaledZ - u2), _2 = d2 && e2.refreshedUponExpiration ? 1 : t.ae(d2 ? n3 : 1 - c2, 0, 1);
          return e2.refreshedUponExpiration && n3 >= 1 && (e2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const uo2 = new t.b7(1, 0, 0, 1), _o2 = new t.b7(0, 1, 0, 1), po2 = new t.b7(0, 0, 1, 1), mo2 = new t.b7(1, 0, 1, 1), fo2 = new t.b7(0, 1, 1, 1);
      function go2(e2, t2, i2, r2) {
        xo2(e2, 0, t2 + i2 / 2, e2.transform.width, i2, r2);
      }
      function vo2(e2, t2, i2, r2) {
        xo2(e2, t2 - i2 / 2, 0, i2, e2.transform.height, r2);
      }
      function xo2(e2, t2, i2, r2, o2, a2) {
        const s2 = e2.context, n2 = s2.gl;
        n2.enable(n2.SCISSOR_TEST), n2.scissor(t2 * e2.pixelRatio, i2 * e2.pixelRatio, r2 * e2.pixelRatio, o2 * e2.pixelRatio), s2.clear({ color: a2 }), n2.disable(n2.SCISSOR_TEST);
      }
      function bo2(e2, i2, r2) {
        const o2 = e2.context, a2 = o2.gl, s2 = e2.useProgram("debug"), n2 = Ut.disabled, l3 = Vt2.disabled, c2 = e2.colorModeForRenderPass(), h2 = "$debug", u2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(r2);
        o2.activeTexture.set(a2.TEXTURE0);
        const d2 = i2.getTileByID(r2.key).latestRawTileData, _2 = Math.floor((d2 && d2.byteLength || 0) / 1024), p2 = i2.getTile(r2).tileSize, m2 = 512 / Math.min(p2, 512) * (r2.overscaledZ / e2.transform.zoom) * 0.5;
        let f2 = r2.canonical.toString();
        r2.overscaledZ !== r2.canonical.z && (f2 += ` => ${r2.overscaledZ}`), function(e3, t2) {
          e3.initDebugOverlayCanvas();
          const i3 = e3.debugOverlayCanvas, r3 = e3.context.gl, o3 = e3.debugOverlayCanvas.getContext("2d");
          o3.clearRect(0, 0, i3.width, i3.height), o3.shadowColor = "white", o3.shadowBlur = 2, o3.lineWidth = 1.5, o3.strokeStyle = "white", o3.textBaseline = "top", o3.font = "bold 36px Open Sans, sans-serif", o3.fillText(t2, 5, 5), o3.strokeText(t2, 5, 5), e3.debugOverlayTexture.update(i3), e3.debugOverlayTexture.bind(r3.LINEAR, r3.CLAMP_TO_EDGE);
        }(e2, `${f2} ${_2}kB`);
        const g2 = e2.transform.getProjectionData({ overscaledTileID: r2, applyGlobeMatrix: true, applyTerrainMatrix: true });
        s2.draw(o2, a2.TRIANGLES, n2, l3, jt2.alphaBlended, Nt2.disabled, Fi2(t.b7.transparent, m2), null, g2, h2, e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments), s2.draw(o2, a2.LINE_STRIP, n2, l3, c2, Nt2.disabled, Fi2(t.b7.red), u2, g2, h2, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
      }
      function yo2(e2, t2, i2, r2) {
        const { isRenderingGlobe: o2 } = r2, a2 = e2.context, s2 = a2.gl, n2 = e2.transform, l3 = e2.colorModeForRenderPass(), c2 = e2.getDepthModeFor3D(), h2 = e2.useProgram("terrain");
        a2.bindFramebuffer.set(null), a2.viewport.set([0, 0, e2.width, e2.height]);
        for (const r3 of i2) {
          const i3 = t2.getTerrainMesh(r3.tileID), u2 = e2.renderToTexture.getTexture(r3), d2 = t2.getTerrainData(r3.tileID);
          a2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, u2.texture);
          const _2 = t2.getMeshFrameDelta(n2.zoom), p2 = n2.calculateFogMatrix(r3.tileID.toUnwrapped()), m2 = Ti2(_2, p2, e2.style.sky, n2.pitch, o2), f2 = n2.getProjectionData({ overscaledTileID: r3.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
          h2.draw(a2, s2.TRIANGLES, c2, Vt2.disabled, l3, Nt2.backCCW, m2, d2, f2, "terrain", i3.vertexBuffer, i3.indexBuffer, i3.segments);
        }
      }
      function wo2(e2, i2) {
        if (!i2.mesh) {
          const r2 = new t.aI;
          r2.emplaceBack(-1, -1), r2.emplaceBack(1, -1), r2.emplaceBack(1, 1), r2.emplaceBack(-1, 1);
          const o2 = new t.aK;
          o2.emplaceBack(0, 1, 2), o2.emplaceBack(0, 2, 3), i2.mesh = new wt(e2.createVertexBuffer(r2, Tt2.members), e2.createIndexBuffer(o2), t.aJ.simpleSegment(0, 0, r2.length, o2.length));
        }
        return i2.mesh;
      }

      class To2 {
        constructor(e2, i2) {
          this.context = new Vr2(e2), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t.ad(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = be2.maxUnderzooming + be2.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new vt2;
        }
        resize(e2, t2, i2) {
          if (this.width = Math.floor(e2 * i2), this.height = Math.floor(t2 * i2), this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const e3 of this.style._order)
              this.style._layers[e3].resize();
        }
        setup() {
          const e2 = this.context, i2 = new t.aI;
          i2.emplaceBack(0, 0), i2.emplaceBack(t.Z, 0), i2.emplaceBack(0, t.Z), i2.emplaceBack(t.Z, t.Z), this.tileExtentBuffer = e2.createVertexBuffer(i2, Tt2.members), this.tileExtentSegments = t.aJ.simpleSegment(0, 0, 4, 2);
          const r2 = new t.aI;
          r2.emplaceBack(0, 0), r2.emplaceBack(t.Z, 0), r2.emplaceBack(0, t.Z), r2.emplaceBack(t.Z, t.Z), this.debugBuffer = e2.createVertexBuffer(r2, Tt2.members), this.debugSegments = t.aJ.simpleSegment(0, 0, 4, 5);
          const o2 = new t.b_;
          o2.emplaceBack(0, 0, 0, 0), o2.emplaceBack(t.Z, 0, t.Z, 0), o2.emplaceBack(0, t.Z, 0, t.Z), o2.emplaceBack(t.Z, t.Z, t.Z, t.Z), this.rasterBoundsBuffer = e2.createVertexBuffer(o2, yi2.members), this.rasterBoundsSegments = t.aJ.simpleSegment(0, 0, 4, 2);
          const a2 = new t.aI;
          a2.emplaceBack(0, 0), a2.emplaceBack(t.Z, 0), a2.emplaceBack(0, t.Z), a2.emplaceBack(t.Z, t.Z), this.rasterBoundsBufferPosOnly = e2.createVertexBuffer(a2, Tt2.members), this.rasterBoundsSegmentsPosOnly = t.aJ.simpleSegment(0, 0, 4, 5);
          const s2 = new t.aI;
          s2.emplaceBack(0, 0), s2.emplaceBack(1, 0), s2.emplaceBack(0, 1), s2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(s2, Tt2.members), this.viewportSegments = t.aJ.simpleSegment(0, 0, 4, 2);
          const n2 = new t.b$;
          n2.emplaceBack(0), n2.emplaceBack(1), n2.emplaceBack(3), n2.emplaceBack(2), n2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(n2);
          const l3 = new t.aK;
          l3.emplaceBack(1, 0, 2), l3.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(l3);
          const c2 = this.context.gl;
          this.stencilClearMode = new Vt2({ func: c2.ALWAYS, mask: 0 }, 0, 255, c2.ZERO, c2.ZERO, c2.ZERO), this.tileExtentMesh = new wt(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
        }
        clearStencil() {
          const e2 = this.context, i2 = e2.gl;
          this.nextStencilID = 1, this.currentStencilSource = undefined;
          const r2 = t.K();
          t.bQ(r2, 0, this.width, this.height, 0, 0, 1), t.M(r2, r2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]);
          const o2 = { mainMatrix: r2, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: r2 };
          this.useProgram("clippingMask", null, true).draw(e2, i2.TRIANGLES, Ut.disabled, this.stencilClearMode, jt2.disabled, Nt2.disabled, null, null, o2, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(e2, t2, i2) {
          if (this.currentStencilSource === e2.source || !e2.isTileClipped() || !t2 || !t2.length)
            return;
          this.currentStencilSource = e2.source, this.nextStencilID + t2.length > 256 && this.clearStencil();
          const r2 = this.context;
          r2.setColorMode(jt2.disabled), r2.setDepthMode(Ut.disabled);
          const o2 = {};
          for (const e3 of t2)
            o2[e3.key] = this.nextStencilID++;
          this._renderTileMasks(o2, t2, i2, true), this._renderTileMasks(o2, t2, i2, false), this._tileClippingMaskIDs = o2;
        }
        _renderTileMasks(e2, t2, i2, r2) {
          const o2 = this.context, a2 = o2.gl, s2 = this.style.projection, n2 = this.transform, l3 = this.useProgram("clippingMask");
          for (const c2 of t2) {
            const t3 = e2[c2.key], h2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(c2), u2 = s2.getMeshFromTileID(this.context, c2.canonical, r2, true, "stencil"), d2 = n2.getProjectionData({ overscaledTileID: c2, applyGlobeMatrix: !i2, applyTerrainMatrix: true });
            l3.draw(o2, a2.TRIANGLES, Ut.disabled, new Vt2({ func: a2.ALWAYS, mask: 0 }, t3, 255, a2.KEEP, a2.KEEP, a2.REPLACE), jt2.disabled, i2 ? Nt2.disabled : Nt2.backCCW, null, h2, d2, "$clipping", u2.vertexBuffer, u2.indexBuffer, u2.segments);
          }
        }
        _renderTilesDepthBuffer() {
          const e2 = this.context, t2 = e2.gl, i2 = this.style.projection, r2 = this.transform, o2 = this.useProgram("depth"), a2 = this.getDepthModeFor3D(), s2 = xe2(r2, { tileSize: r2.tileSize });
          for (const n2 of s2) {
            const s3 = this.style.map.terrain && this.style.map.terrain.getTerrainData(n2), l3 = i2.getMeshFromTileID(this.context, n2.canonical, true, true, "raster"), c2 = r2.getProjectionData({ overscaledTileID: n2, applyGlobeMatrix: true, applyTerrainMatrix: true });
            o2.draw(e2, t2.TRIANGLES, a2, Vt2.disabled, jt2.disabled, Nt2.backCCW, null, s3, c2, "$clipping", l3.vertexBuffer, l3.indexBuffer, l3.segments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = undefined, this.nextStencilID + 1 > 256 && this.clearStencil();
          const e2 = this.nextStencilID++, t2 = this.context.gl;
          return new Vt2({ func: t2.NOTEQUAL, mask: 255 }, e2, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
        }
        stencilModeForClipping(e2) {
          const t2 = this.context.gl;
          return new Vt2({ func: t2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e2.key], 0, t2.KEEP, t2.KEEP, t2.REPLACE);
        }
        getStencilConfigForOverlapAndUpdateStencilID(e2) {
          const t2 = this.context.gl, i2 = e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), r2 = i2[i2.length - 1].overscaledZ, o2 = i2[0].overscaledZ - r2 + 1;
          if (o2 > 1) {
            this.currentStencilSource = undefined, this.nextStencilID + o2 > 256 && this.clearStencil();
            const e3 = {};
            for (let i3 = 0;i3 < o2; i3++)
              e3[i3 + r2] = new Vt2({ func: t2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
            return this.nextStencilID += o2, [e3, i2];
          }
          return [{ [r2]: Vt2.disabled }, i2];
        }
        stencilConfigForOverlapTwoPass(e2) {
          const t2 = this.context.gl, i2 = e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), r2 = i2[i2.length - 1].overscaledZ, o2 = i2[0].overscaledZ - r2 + 1;
          if (this.clearStencil(), o2 > 1) {
            const e3 = {}, a2 = {};
            for (let i3 = 0;i3 < o2; i3++)
              e3[i3 + r2] = new Vt2({ func: t2.GREATER, mask: 255 }, o2 + 1 + i3, 255, t2.KEEP, t2.KEEP, t2.REPLACE), a2[i3 + r2] = new Vt2({ func: t2.GREATER, mask: 255 }, 1 + i3, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
            return this.nextStencilID = 2 * o2 + 1, [e3, a2, i2];
          }
          return this.nextStencilID = 3, [{ [r2]: new Vt2({ func: t2.GREATER, mask: 255 }, 2, 255, t2.KEEP, t2.KEEP, t2.REPLACE) }, { [r2]: new Vt2({ func: t2.GREATER, mask: 255 }, 1, 255, t2.KEEP, t2.KEEP, t2.REPLACE) }, i2];
        }
        colorModeForRenderPass() {
          const e2 = this.context.gl;
          if (this._showOverdrawInspector) {
            const i2 = 1 / 8;
            return new jt2([e2.CONSTANT_COLOR, e2.ONE], new t.b7(i2, i2, i2, 0), [true, true, true, true]);
          }
          return this.renderPass === "opaque" ? jt2.unblended : jt2.alphaBlended;
        }
        getDepthModeForSublayer(e2, t2, i2) {
          if (!this.opaquePassEnabledForLayer())
            return Ut.disabled;
          const r2 = 1 - ((1 + this.currentLayer) * this.numSublayers + e2) * this.depthEpsilon;
          return new Ut(i2 || this.context.gl.LEQUAL, t2, [r2, r2]);
        }
        getDepthModeFor3D() {
          return new Ut(this.context.gl.LEQUAL, Ut.ReadWrite, this.depthRangeFor3D);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(e2, i2) {
          var r2, o2;
          this.style = e2, this.options = i2, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(s.now()), this.imageManager.beginFrame();
          const a2 = this.style._order, n2 = this.style.sourceCaches, l3 = {}, c2 = {}, h2 = {}, u2 = { isRenderingToTexture: false, isRenderingGlobe: ((r2 = e2.projection) === null || r2 === undefined ? undefined : r2.transitionState) > 0 };
          for (const e3 in n2) {
            const t2 = n2[e3];
            t2.used && t2.prepare(this.context), l3[e3] = t2.getVisibleCoordinates(false), c2[e3] = l3[e3].slice().reverse(), h2[e3] = t2.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let e3 = 0;e3 < a2.length; e3++)
            if (this.style._layers[a2[e3]].is3D()) {
              this.opaquePassCutoff = e3;
              break;
            }
          this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const e3 of a2) {
            const t2 = this.style._layers[e3];
            if (!t2.hasOffscreenPass() || t2.isHidden(this.transform.zoom))
              continue;
            const i3 = c2[t2.source];
            (t2.type === "custom" || i3.length) && this.renderLayer(this, n2[t2.source], t2, i3, u2);
          }
          if ((o2 = this.style.projection) === null || o2 === undefined || o2.updateGPUdependent({ context: this.context, useProgram: (e3) => this.useProgram(e3) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.b7.black : t.b7.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(e3, t2) {
            const i3 = e3.context, r3 = i3.gl, o3 = ((e4, t3, i4) => {
              const r4 = Math.cos(t3.rollInRadians), o4 = Math.sin(t3.rollInRadians), a4 = ue2(t3), s3 = t3.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
              return { u_sky_color: e4.properties.get("sky-color"), u_horizon_color: e4.properties.get("horizon-color"), u_horizon: [(t3.width / 2 - a4 * o4) * i4, (t3.height / 2 + a4 * r4) * i4], u_horizon_normal: [-o4, r4], u_sky_horizon_blend: e4.properties.get("sky-horizon-blend") * t3.height / 2 * i4, u_sky_blend: s3 };
            })(t2, e3.style.map.transform, e3.pixelRatio), a3 = new Ut(r3.LEQUAL, Ut.ReadWrite, [0, 1]), s2 = Vt2.disabled, n3 = e3.colorModeForRenderPass(), l4 = e3.useProgram("sky"), c3 = wo2(i3, t2);
            l4.draw(i3, r3.TRIANGLES, a3, s2, n3, Nt2.disabled, o3, null, undefined, "sky", c3.vertexBuffer, c3.indexBuffer, c3.segments);
          }(this, this.style.sky), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
            for (this.renderPass = "opaque", this.currentLayer = a2.length - 1;this.currentLayer >= 0; this.currentLayer--) {
              const e3 = this.style._layers[a2[this.currentLayer]], t2 = n2[e3.source], i3 = l3[e3.source];
              this._renderTileClippingMasks(e3, i3, false), this.renderLayer(this, t2, e3, i3, u2);
            }
          this.renderPass = "translucent";
          let d2 = false;
          for (this.currentLayer = 0;this.currentLayer < a2.length; this.currentLayer++) {
            const e3 = this.style._layers[a2[this.currentLayer]], t2 = n2[e3.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(e3, u2))
              continue;
            this.opaquePassEnabledForLayer() || d2 || (d2 = true, u2.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
            const i3 = (e3.type === "symbol" ? h2 : c2)[e3.source];
            this._renderTileClippingMasks(e3, l3[e3.source], !!this.renderToTexture), this.renderLayer(this, t2, e3, i3, u2);
          }
          if (u2.isRenderingGlobe && function(e3, i3, r3) {
            const o3 = e3.context, a3 = o3.gl, s2 = e3.useProgram("atmosphere"), n3 = new Ut(a3.LEQUAL, Ut.ReadOnly, [0, 1]), l4 = e3.transform, c3 = function(e4, i4) {
              const r4 = e4.properties.get("position"), o4 = [-r4.x, -r4.y, -r4.z], a4 = t.ad(new Float64Array(16));
              return e4.properties.get("anchor") === "map" && (t.a_(a4, a4, i4.rollInRadians), t.a$(a4, a4, -i4.pitchInRadians), t.a_(a4, a4, i4.bearingInRadians), t.a$(a4, a4, i4.center.lat * Math.PI / 180), t.bp(a4, a4, -i4.center.lng * Math.PI / 180)), t.bZ(o4, o4, a4), o4;
            }(r3, e3.transform), h3 = l4.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), u3 = i3.properties.get("atmosphere-blend") * h3.projectionTransition;
            if (u3 === 0)
              return;
            const d3 = ri2(l4.worldSize, l4.center.lat), _2 = l4.inverseProjectionMatrix, p2 = new Float64Array(4);
            p2[3] = 1, t.at(p2, p2, l4.modelViewProjectionMatrix), p2[0] /= p2[3], p2[1] /= p2[3], p2[2] /= p2[3], p2[3] = 1, t.at(p2, p2, _2), p2[0] /= p2[3], p2[1] /= p2[3], p2[2] /= p2[3], p2[3] = 1;
            const m2 = ((e4, t2, i4, r4, o4) => ({ u_sun_pos: e4, u_atmosphere_blend: t2, u_globe_position: i4, u_globe_radius: r4, u_inv_proj_matrix: o4 }))(c3, u3, [p2[0], p2[1], p2[2]], d3, _2), f2 = wo2(o3, i3);
            s2.draw(o3, a3.TRIANGLES, n3, Vt2.disabled, jt2.alphaBlended, Nt2.disabled, m2, null, null, "atmosphere", f2.vertexBuffer, f2.indexBuffer, f2.segments);
          }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
            const e3 = function(e4, t2) {
              let i3 = null;
              const r3 = Object.values(e4._layers).flatMap((i4) => i4.source && !i4.isHidden(t2) ? [e4.sourceCaches[i4.source]] : []), o3 = r3.filter((e5) => e5.getSource().type === "vector"), a3 = r3.filter((e5) => e5.getSource().type !== "vector"), s2 = (e5) => {
                (!i3 || i3.getSource().maxzoom < e5.getSource().maxzoom) && (i3 = e5);
              };
              return o3.forEach((e5) => s2(e5)), i3 || a3.forEach((e5) => s2(e5)), i3;
            }(this.style, this.transform.zoom);
            e3 && function(e4, t2, i3) {
              for (let r3 = 0;r3 < i3.length; r3++)
                bo2(e4, t2, i3[r3]);
            }(this, e3, e3.getVisibleCoordinates());
          }
          this.options.showPadding && function(e3) {
            const t2 = e3.transform.padding;
            go2(e3, e3.transform.height - (t2.top || 0), 3, uo2), go2(e3, t2.bottom || 0, 3, _o2), vo2(e3, t2.left || 0, 3, po2), vo2(e3, e3.transform.width - (t2.right || 0), 3, mo2);
            const i3 = e3.transform.centerPoint;
            (function(e4, t3, i4, r3) {
              xo2(e4, t3 - 1, i4 - 10, 2, 20, r3), xo2(e4, t3 - 10, i4 - 1, 20, 2, r3);
            })(e3, i3.x, e3.transform.height - i3.y, fo2);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(e2) {
          if (!this.style || !this.style.map || !this.style.map.terrain)
            return;
          const i2 = this.terrainFacilitator.matrix, r2 = this.transform.modelViewProjectionMatrix;
          let o2 = this.terrainFacilitator.dirty;
          o2 || (o2 = e2 ? !t.c0(i2, r2) : !t.c1(i2, r2)), o2 || (o2 = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), o2 && (t.c2(i2, r2), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e3, i3) {
            const r3 = e3.context, o3 = r3.gl, a2 = e3.transform, s2 = jt2.unblended, n2 = new Ut(o3.LEQUAL, Ut.ReadWrite, [0, 1]), l3 = i3.sourceCache.getRenderableTiles(), c2 = e3.useProgram("terrainDepth");
            r3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), r3.viewport.set([0, 0, e3.width / devicePixelRatio, e3.height / devicePixelRatio]), r3.clear({ color: t.b7.transparent, depth: 1 });
            for (const e4 of l3) {
              const t2 = i3.getTerrainMesh(e4.tileID), l4 = i3.getTerrainData(e4.tileID), h2 = a2.getProjectionData({ overscaledTileID: e4.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), u2 = { u_ele_delta: i3.getMeshFrameDelta(a2.zoom) };
              c2.draw(r3, o3.TRIANGLES, n2, Vt2.disabled, s2, Nt2.backCCW, u2, l4, h2, "terrain", t2.vertexBuffer, t2.indexBuffer, t2.segments);
            }
            r3.bindFramebuffer.set(null), r3.viewport.set([0, 0, e3.width, e3.height]);
          }(this, this.style.map.terrain), function(e3, i3) {
            const r3 = e3.context, o3 = r3.gl, a2 = e3.transform, s2 = jt2.unblended, n2 = new Ut(o3.LEQUAL, Ut.ReadWrite, [0, 1]), l3 = i3.getCoordsTexture(), c2 = i3.sourceCache.getRenderableTiles(), h2 = e3.useProgram("terrainCoords");
            r3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), r3.viewport.set([0, 0, e3.width / devicePixelRatio, e3.height / devicePixelRatio]), r3.clear({ color: t.b7.transparent, depth: 1 }), i3.coordsIndex = [];
            for (const e4 of c2) {
              const t2 = i3.getTerrainMesh(e4.tileID), c3 = i3.getTerrainData(e4.tileID);
              r3.activeTexture.set(o3.TEXTURE0), o3.bindTexture(o3.TEXTURE_2D, l3.texture);
              const u2 = { u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i3.getMeshFrameDelta(a2.zoom) }, d2 = a2.getProjectionData({ overscaledTileID: e4.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
              h2.draw(r3, o3.TRIANGLES, n2, Vt2.disabled, s2, Nt2.backCCW, u2, c3, d2, "terrain", t2.vertexBuffer, t2.indexBuffer, t2.segments), i3.coordsIndex.push(e4.tileID.key);
            }
            r3.bindFramebuffer.set(null), r3.viewport.set([0, 0, e3.width, e3.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(e2, i2, r2, o2, a2) {
          r2.isHidden(this.transform.zoom) || (r2.type === "background" || r2.type === "custom" || (o2 || []).length) && (this.id = r2.id, t.c3(r2) ? function(e3, i3, r3, o3, a3, s2) {
            if (e3.renderPass !== "translucent")
              return;
            const { isRenderingToTexture: n2 } = s2, l3 = Vt2.disabled, c2 = e3.colorModeForRenderPass();
            (r3._unevaluatedLayout.hasValue("text-variable-anchor") || r3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e4, i4, r4, o4, a4, s3, n3, l4, c3) {
              const h2 = i4.transform, u2 = i4.style.map.terrain, d2 = a4 === "map", _2 = s3 === "map";
              for (const a5 of e4) {
                const e5 = o4.getTile(a5), s4 = e5.getBucket(r4);
                if (!s4 || !s4.text || !s4.text.segments.get().length)
                  continue;
                const p2 = t.ak(s4.textSizeData, h2.zoom), m2 = t.az(e5, 1, i4.transform.zoom), f2 = Me2(d2, i4.transform, m2), g2 = r4.layout.get("icon-text-fit") !== "none" && s4.hasIconData();
                if (p2) {
                  const i5 = Math.pow(2, h2.zoom - e5.tileID.overscaledZ), r5 = u2 ? (e6, t2) => u2.getElevation(a5, e6, t2) : null;
                  Kr2(s4, d2, _2, c3, h2, f2, i5, p2, g2, t.aA(h2, e5, n3, l4), a5.toUnwrapped(), r5);
                }
              }
            }(o3, e3, r3, i3, r3.layout.get("text-rotation-alignment"), r3.layout.get("text-pitch-alignment"), r3.paint.get("text-translate"), r3.paint.get("text-translate-anchor"), a3), r3.paint.get("icon-opacity").constantOr(1) !== 0 && Yr2(e3, i3, r3, o3, false, r3.paint.get("icon-translate"), r3.paint.get("icon-translate-anchor"), r3.layout.get("icon-rotation-alignment"), r3.layout.get("icon-pitch-alignment"), r3.layout.get("icon-keep-upright"), l3, c2, n2), r3.paint.get("text-opacity").constantOr(1) !== 0 && Yr2(e3, i3, r3, o3, true, r3.paint.get("text-translate"), r3.paint.get("text-translate-anchor"), r3.layout.get("text-rotation-alignment"), r3.layout.get("text-pitch-alignment"), r3.layout.get("text-keep-upright"), l3, c2, n2), i3.map.showCollisionBoxes && (Wr2(e3, i3, r3, o3, true), Wr2(e3, i3, r3, o3, false));
          }(e2, i2, r2, o2, this.style.placement.variableOffsets, a2) : t.c4(r2) ? function(e3, i3, r3, o3, a3) {
            if (e3.renderPass !== "translucent")
              return;
            const { isRenderingToTexture: s2 } = a3, n2 = r3.paint.get("circle-opacity"), l3 = r3.paint.get("circle-stroke-width"), c2 = r3.paint.get("circle-stroke-opacity"), h2 = !r3.layout.get("circle-sort-key").isConstant();
            if (n2.constantOr(1) === 0 && (l3.constantOr(1) === 0 || c2.constantOr(1) === 0))
              return;
            const u2 = e3.context, d2 = u2.gl, _2 = e3.transform, p2 = e3.getDepthModeForSublayer(0, Ut.ReadOnly), m2 = Vt2.disabled, f2 = e3.colorModeForRenderPass(), g2 = [], v2 = _2.getCircleRadiusCorrection();
            for (let a4 = 0;a4 < o3.length; a4++) {
              const n3 = o3[a4], l4 = i3.getTile(n3), c3 = l4.getBucket(r3);
              if (!c3)
                continue;
              const u3 = r3.paint.get("circle-translate"), d3 = r3.paint.get("circle-translate-anchor"), p3 = t.aA(_2, l4, u3, d3), m3 = c3.programConfigurations.get(r3.id), f3 = e3.useProgram("circle", m3), x2 = c3.layoutVertexBuffer, b2 = c3.indexBuffer, y2 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(n3), w2 = { programConfiguration: m3, program: f3, layoutVertexBuffer: x2, indexBuffer: b2, uniformValues: Ai2(e3, l4, r3, p3, v2), terrainData: y2, projectionData: _2.getProjectionData({ overscaledTileID: n3, applyGlobeMatrix: !s2, applyTerrainMatrix: true }) };
              if (h2) {
                const e4 = c3.segments.get();
                for (const i4 of e4)
                  g2.push({ segments: new t.aJ([i4]), sortKey: i4.sortKey, state: w2 });
              } else
                g2.push({ segments: c3.segments, sortKey: 0, state: w2 });
            }
            h2 && g2.sort((e4, t2) => e4.sortKey - t2.sortKey);
            for (const t2 of g2) {
              const { programConfiguration: i4, program: o4, layoutVertexBuffer: a4, indexBuffer: s3, uniformValues: n3, terrainData: l4, projectionData: c3 } = t2.state;
              o4.draw(u2, d2.TRIANGLES, p2, m2, f2, Nt2.backCCW, n3, l4, c3, r3.id, a4, s3, t2.segments, r3.paint, e3.transform.zoom, i4);
            }
          }(e2, i2, r2, o2, a2) : t.c5(r2) ? function(e3, i3, r3, o3, a3) {
            if (r3.paint.get("heatmap-opacity") === 0)
              return;
            const s2 = e3.context, { isRenderingToTexture: n2, isRenderingGlobe: l3 } = a3;
            if (e3.style.map.terrain) {
              for (const t2 of o3) {
                const o4 = i3.getTile(t2);
                i3.hasRenderableParent(t2) || (e3.renderPass === "offscreen" ? eo2(e3, o4, r3, t2, l3) : e3.renderPass === "translucent" && to2(e3, r3, t2, n2, l3));
              }
              s2.viewport.set([0, 0, e3.width, e3.height]);
            } else
              e3.renderPass === "offscreen" ? function(e4, i4, r4, o4) {
                const a4 = e4.context, s3 = a4.gl, n3 = e4.transform, l4 = Vt2.disabled, c2 = new jt2([s3.ONE, s3.ONE], t.b7.transparent, [true, true, true, true]);
                (function(e5, i5, r5) {
                  const o5 = e5.gl;
                  e5.activeTexture.set(o5.TEXTURE1), e5.viewport.set([0, 0, i5.width / 4, i5.height / 4]);
                  let a5 = r5.heatmapFbos.get(t.bW);
                  a5 ? (o5.bindTexture(o5.TEXTURE_2D, a5.colorAttachment.get()), e5.bindFramebuffer.set(a5.framebuffer)) : (a5 = io2(e5, i5.width / 4, i5.height / 4), r5.heatmapFbos.set(t.bW, a5));
                })(a4, e4, r4), a4.clear({ color: t.b7.transparent });
                for (let t2 = 0;t2 < o4.length; t2++) {
                  const h2 = o4[t2];
                  if (i4.hasRenderableParent(h2))
                    continue;
                  const u2 = i4.getTile(h2), d2 = u2.getBucket(r4);
                  if (!d2)
                    continue;
                  const _2 = d2.programConfigurations.get(r4.id), p2 = e4.useProgram("heatmap", _2), m2 = n3.getProjectionData({ overscaledTileID: h2, applyGlobeMatrix: true, applyTerrainMatrix: false }), f2 = n3.getCircleRadiusCorrection();
                  p2.draw(a4, s3.TRIANGLES, Ut.disabled, l4, c2, Nt2.backCCW, Bi2(u2, n3.zoom, r4.paint.get("heatmap-intensity"), f2), null, m2, r4.id, d2.layoutVertexBuffer, d2.indexBuffer, d2.segments, r4.paint, n3.zoom, _2);
                }
                a4.viewport.set([0, 0, e4.width, e4.height]);
              }(e3, i3, r3, o3) : e3.renderPass === "translucent" && function(e4, i4) {
                const r4 = e4.context, o4 = r4.gl;
                r4.setColorMode(e4.colorModeForRenderPass());
                const a4 = i4.heatmapFbos.get(t.bW);
                a4 && (r4.activeTexture.set(o4.TEXTURE0), o4.bindTexture(o4.TEXTURE_2D, a4.colorAttachment.get()), r4.activeTexture.set(o4.TEXTURE1), ro2(r4, i4).bind(o4.LINEAR, o4.CLAMP_TO_EDGE), e4.useProgram("heatmapTexture").draw(r4, o4.TRIANGLES, Ut.disabled, Vt2.disabled, e4.colorModeForRenderPass(), Nt2.disabled, Oi2(e4, i4, 0, 1), null, null, i4.id, e4.viewportBuffer, e4.quadTriangleIndexBuffer, e4.viewportSegments, i4.paint, e4.transform.zoom));
              }(e3, r3);
          }(e2, i2, r2, o2, a2) : t.c6(r2) ? function(e3, i3, r3, o3, a3) {
            if (e3.renderPass !== "translucent")
              return;
            const { isRenderingToTexture: s2 } = a3, n2 = r3.paint.get("line-opacity"), l3 = r3.paint.get("line-width");
            if (n2.constantOr(1) === 0 || l3.constantOr(1) === 0)
              return;
            const c2 = e3.getDepthModeForSublayer(0, Ut.ReadOnly), h2 = e3.colorModeForRenderPass(), u2 = r3.paint.get("line-dasharray"), d2 = r3.paint.get("line-pattern"), _2 = d2.constantOr(1), p2 = r3.paint.get("line-gradient"), m2 = r3.getCrossfadeParameters(), f2 = _2 ? "linePattern" : u2 ? "lineSDF" : p2 ? "lineGradient" : "line", g2 = e3.context, x2 = g2.gl, b2 = e3.transform;
            let y2 = true;
            for (const a4 of o3) {
              const o4 = i3.getTile(a4);
              if (_2 && !o4.patternsLoaded())
                continue;
              const n3 = o4.getBucket(r3);
              if (!n3)
                continue;
              const l4 = n3.programConfigurations.get(r3.id), w2 = e3.context.program.get(), T2 = e3.useProgram(f2, l4), P2 = y2 || T2.program !== w2, C2 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(a4), M3 = d2.constantOr(null);
              if (M3 && o4.imageAtlas) {
                const e4 = o4.imageAtlas, t2 = e4.patternPositions[M3.to.toString()], i4 = e4.patternPositions[M3.from.toString()];
                t2 && i4 && l4.setConstantPatternPositions(t2, i4);
              }
              const I2 = b2.getProjectionData({ overscaledTileID: a4, applyGlobeMatrix: !s2, applyTerrainMatrix: true }), E3 = b2.getPixelScale(), S2 = _2 ? Vi2(e3, o4, r3, E3, m2) : u2 ? qi2(e3, o4, r3, E3, u2, m2) : p2 ? Gi2(e3, o4, r3, E3, n3.lineClipsArray.length) : Ui2(e3, o4, r3, E3);
              if (_2)
                g2.activeTexture.set(x2.TEXTURE0), o4.imageAtlasTexture.bind(x2.LINEAR, x2.CLAMP_TO_EDGE), l4.updatePaintBuffers(m2);
              else if (u2 && (P2 || e3.lineAtlas.dirty))
                g2.activeTexture.set(x2.TEXTURE0), e3.lineAtlas.bind(g2);
              else if (p2) {
                const o5 = n3.gradients[r3.id];
                let s3 = o5.texture;
                if (r3.gradientVersion !== o5.version) {
                  let l5 = 256;
                  if (r3.stepInterpolant) {
                    const r4 = i3.getSource().maxzoom, o6 = a4.canonical.z === r4 ? Math.ceil(1 << e3.transform.maxZoom - a4.canonical.z) : 1;
                    l5 = t.ae(t.bX(n3.maxLineLength / t.Z * 1024 * o6), 256, g2.maxTextureSize);
                  }
                  o5.gradient = t.bY({ expression: r3.gradientExpression(), evaluationKey: "lineProgress", resolution: l5, image: o5.gradient || undefined, clips: n3.lineClipsArray }), o5.texture ? o5.texture.update(o5.gradient) : o5.texture = new v(g2, o5.gradient, x2.RGBA), o5.version = r3.gradientVersion, s3 = o5.texture;
                }
                g2.activeTexture.set(x2.TEXTURE0), s3.bind(r3.stepInterpolant ? x2.NEAREST : x2.LINEAR, x2.CLAMP_TO_EDGE);
              }
              const R2 = e3.stencilModeForClipping(a4);
              T2.draw(g2, x2.TRIANGLES, c2, R2, h2, Nt2.disabled, S2, C2, I2, r3.id, n3.layoutVertexBuffer, n3.indexBuffer, n3.segments, r3.paint, e3.transform.zoom, l4, n3.layoutVertexBuffer2), y2 = false;
            }
          }(e2, i2, r2, o2, a2) : t.c7(r2) ? function(e3, i3, r3, o3, a3) {
            const s2 = r3.paint.get("fill-color"), n2 = r3.paint.get("fill-opacity");
            if (n2.constantOr(1) === 0)
              return;
            const { isRenderingToTexture: l3 } = a3, c2 = e3.colorModeForRenderPass(), h2 = r3.paint.get("fill-pattern"), u2 = e3.opaquePassEnabledForLayer() && !h2.constantOr(1) && s2.constantOr(t.b7.transparent).a === 1 && n2.constantOr(0) === 1 ? "opaque" : "translucent";
            if (e3.renderPass === u2) {
              const t2 = e3.getDepthModeForSublayer(1, e3.renderPass === "opaque" ? Ut.ReadWrite : Ut.ReadOnly);
              ao2(e3, i3, r3, o3, t2, c2, false, l3);
            }
            if (e3.renderPass === "translucent" && r3.paint.get("fill-antialias")) {
              const t2 = e3.getDepthModeForSublayer(r3.getPaintProperty("fill-outline-color") ? 2 : 0, Ut.ReadOnly);
              ao2(e3, i3, r3, o3, t2, c2, true, l3);
            }
          }(e2, i2, r2, o2, a2) : t.c8(r2) ? function(e3, t2, i3, r3, o3) {
            const a3 = i3.paint.get("fill-extrusion-opacity");
            if (a3 === 0)
              return;
            const { isRenderingToTexture: s2 } = o3;
            if (e3.renderPass === "translucent") {
              const o4 = new Ut(e3.context.gl.LEQUAL, Ut.ReadWrite, e3.depthRangeFor3D);
              if (a3 !== 1 || i3.paint.get("fill-extrusion-pattern").constantOr(1))
                so2(e3, t2, i3, r3, o4, Vt2.disabled, jt2.disabled, s2), so2(e3, t2, i3, r3, o4, e3.stencilModeFor3D(), e3.colorModeForRenderPass(), s2);
              else {
                const a4 = e3.colorModeForRenderPass();
                so2(e3, t2, i3, r3, o4, Vt2.disabled, a4, s2);
              }
            }
          }(e2, i2, r2, o2, a2) : t.c9(r2) ? function(e3, t2, i3, r3, o3) {
            if (e3.renderPass !== "offscreen" && e3.renderPass !== "translucent")
              return;
            const { isRenderingToTexture: a3 } = o3, s2 = e3.context, n2 = e3.style.projection.useSubdivision, l3 = e3.getDepthModeForSublayer(0, Ut.ReadOnly), c2 = e3.colorModeForRenderPass();
            if (e3.renderPass === "offscreen")
              (function(e4, t3, i4, r4, o4, a4, s3) {
                const n3 = e4.context, l4 = n3.gl;
                for (const c3 of i4) {
                  const i5 = t3.getTile(c3), h2 = i5.dem;
                  if (!h2 || !h2.data)
                    continue;
                  if (!i5.needsHillshadePrepare)
                    continue;
                  const { dim: u2, stride: d2 } = h2, _2 = h2.getPixels();
                  if (n3.activeTexture.set(l4.TEXTURE1), n3.pixelStoreUnpackPremultiplyAlpha.set(false), i5.demTexture = i5.demTexture || e4.getTileTexture(d2), i5.demTexture) {
                    const e5 = i5.demTexture;
                    e5.update(_2, { premultiply: false }), e5.bind(l4.NEAREST, l4.CLAMP_TO_EDGE);
                  } else
                    i5.demTexture = new v(n3, _2, l4.RGBA, { premultiply: false }), i5.demTexture.bind(l4.NEAREST, l4.CLAMP_TO_EDGE);
                  n3.activeTexture.set(l4.TEXTURE0);
                  let p2 = i5.fbo;
                  if (!p2) {
                    const e5 = new v(n3, { width: u2, height: u2, data: null }, l4.RGBA);
                    e5.bind(l4.LINEAR, l4.CLAMP_TO_EDGE), p2 = i5.fbo = n3.createFramebuffer(u2, u2, true, false), p2.colorAttachment.set(e5.texture);
                  }
                  n3.bindFramebuffer.set(p2.framebuffer), n3.viewport.set([0, 0, u2, u2]), e4.useProgram("hillshadePrepare").draw(n3, l4.TRIANGLES, o4, a4, s3, Nt2.disabled, Zi2(i5.tileID, h2), null, null, r4.id, e4.rasterBoundsBuffer, e4.quadTriangleIndexBuffer, e4.rasterBoundsSegments), i5.needsHillshadePrepare = false;
                }
              })(e3, t2, r3, i3, l3, Vt2.disabled, c2), s2.viewport.set([0, 0, e3.width, e3.height]);
            else if (e3.renderPass === "translucent")
              if (n2) {
                const [o4, s3, n3] = e3.stencilConfigForOverlapTwoPass(r3);
                no2(e3, t2, i3, n3, o4, l3, c2, false, a3), no2(e3, t2, i3, n3, s3, l3, c2, true, a3);
              } else {
                const [o4, s3] = e3.getStencilConfigForOverlapAndUpdateStencilID(r3);
                no2(e3, t2, i3, s3, o4, l3, c2, false, a3);
              }
          }(e2, i2, r2, o2, a2) : t.ca(r2) ? function(e3, t2, i3, r3, o3) {
            if (e3.renderPass !== "translucent")
              return;
            if (i3.paint.get("raster-opacity") === 0)
              return;
            if (!r3.length)
              return;
            const { isRenderingToTexture: a3 } = o3, s2 = t2.getSource(), n2 = e3.style.projection.useSubdivision;
            if (s2 instanceof K)
              co2(e3, t2, i3, r3, null, false, false, s2.tileCoords, s2.flippedWindingOrder, a3);
            else if (n2) {
              const [o4, s3, n3] = e3.stencilConfigForOverlapTwoPass(r3);
              co2(e3, t2, i3, n3, o4, false, true, lo2, false, a3), co2(e3, t2, i3, n3, s3, true, true, lo2, false, a3);
            } else {
              const [o4, s3] = e3.getStencilConfigForOverlapAndUpdateStencilID(r3);
              co2(e3, t2, i3, s3, o4, false, true, lo2, false, a3);
            }
          }(e2, i2, r2, o2, a2) : t.cb(r2) ? function(e3, t2, i3, r3, o3) {
            const a3 = i3.paint.get("background-color"), s2 = i3.paint.get("background-opacity");
            if (s2 === 0)
              return;
            const { isRenderingToTexture: n2 } = o3, l3 = e3.context, c2 = l3.gl, h2 = e3.style.projection, u2 = e3.transform, d2 = u2.tileSize, _2 = i3.paint.get("background-pattern");
            if (e3.isPatternMissing(_2))
              return;
            const p2 = !_2 && a3.a === 1 && s2 === 1 && e3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (e3.renderPass !== p2)
              return;
            const m2 = Vt2.disabled, f2 = e3.getDepthModeForSublayer(0, p2 === "opaque" ? Ut.ReadWrite : Ut.ReadOnly), g2 = e3.colorModeForRenderPass(), v2 = e3.useProgram(_2 ? "backgroundPattern" : "background"), x2 = r3 || xe2(u2, { tileSize: d2, terrain: e3.style.map.terrain });
            _2 && (l3.activeTexture.set(c2.TEXTURE0), e3.imageManager.bind(e3.context));
            const b2 = i3.getCrossfadeParameters();
            for (const t3 of x2) {
              const r4 = u2.getProjectionData({ overscaledTileID: t3, applyGlobeMatrix: !n2, applyTerrainMatrix: true }), o4 = _2 ? er2(s2, e3, _2, { tileID: t3, tileSize: d2 }, b2) : Ji2(s2, a3), p3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(t3), x3 = h2.getMeshFromTileID(l3, t3.canonical, false, true, "raster");
              v2.draw(l3, c2.TRIANGLES, f2, m2, g2, Nt2.backCCW, o4, p3, r4, i3.id, x3.vertexBuffer, x3.indexBuffer, x3.segments);
            }
          }(e2, 0, r2, o2, a2) : t.cc(r2) && function(e3, t2, i3, r3) {
            const { isRenderingGlobe: o3 } = r3, a3 = e3.context, s2 = i3.implementation, n2 = e3.style.projection, l3 = e3.transform, c2 = l3.getProjectionDataForCustomLayer(o3), h2 = { farZ: l3.farZ, nearZ: l3.nearZ, fov: l3.fov * Math.PI / 180, modelViewProjectionMatrix: l3.modelViewProjectionMatrix, projectionMatrix: l3.projectionMatrix, shaderData: { variantName: n2.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${n2.shaderPreludeCode.vertexSource}`, define: n2.shaderDefine }, defaultProjectionData: c2 }, u2 = s2.renderingMode ? s2.renderingMode : "2d";
            if (e3.renderPass === "offscreen") {
              const t3 = s2.prerender;
              t3 && (e3.setCustomLayerDefaults(), a3.setColorMode(e3.colorModeForRenderPass()), t3.call(s2, a3.gl, h2), a3.setDirty(), e3.setBaseState());
            } else if (e3.renderPass === "translucent") {
              e3.setCustomLayerDefaults(), a3.setColorMode(e3.colorModeForRenderPass()), a3.setStencilMode(Vt2.disabled);
              const t3 = u2 === "3d" ? e3.getDepthModeFor3D() : e3.getDepthModeForSublayer(0, Ut.ReadOnly);
              a3.setDepthMode(t3), s2.render(a3.gl, h2), a3.setDirty(), e3.setBaseState(), a3.bindFramebuffer.set(null);
            }
          }(e2, 0, r2, a2));
        }
        saveTileTexture(e2) {
          const t2 = this._tileTextures[e2.size[0]];
          t2 ? t2.push(e2) : this._tileTextures[e2.size[0]] = [e2];
        }
        getTileTexture(e2) {
          const t2 = this._tileTextures[e2];
          return t2 && t2.length > 0 ? t2.pop() : null;
        }
        isPatternMissing(e2) {
          if (!e2)
            return false;
          if (!e2.from || !e2.to)
            return true;
          const t2 = this.imageManager.getPattern(e2.from.toString()), i2 = this.imageManager.getPattern(e2.to.toString());
          return !t2 || !i2;
        }
        useProgram(e2, t2, i2 = false, r2 = []) {
          this.cache = this.cache || {};
          const o2 = !!this.style.map.terrain, a2 = this.style.projection, s2 = i2 ? bt2.projectionMercator : a2.shaderPreludeCode, n2 = i2 ? Pt2 : a2.shaderDefine, l3 = e2 + (t2 ? t2.cacheKey : "") + `/${i2 ? Ct : a2.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (o2 ? "/terrain" : "") + (r2 ? `/${r2.join("/")}` : "");
          return this.cache[l3] || (this.cache[l3] = new Mi2(this.context, bt2[e2], t2, ir2[e2], this._showOverdrawInspector, o2, s2, n2, r2)), this.cache[l3];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e2 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new v(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: e2, drawingBufferHeight: t2 } = this.context.gl;
          return this.width !== e2 || this.height !== t2;
        }
      }
      function Po2(e2, t2) {
        let i2, r2 = false, o2 = null, a2 = null;
        const s2 = () => {
          o2 = null, r2 && (e2.apply(a2, i2), o2 = setTimeout(s2, t2), r2 = false);
        };
        return (...e3) => (r2 = true, a2 = this, i2 = e3, o2 || s2(), o2);
      }

      class Co2 {
        constructor(e2) {
          this._getCurrentHash = () => {
            const e3 = window.location.hash.replace("#", "");
            if (this._hashName) {
              let t2;
              return e3.split("&").map((e4) => e4.split("=")).forEach((e4) => {
                e4[0] === this._hashName && (t2 = e4);
              }), (t2 && t2[1] || "").split("/");
            }
            return e3.split("/");
          }, this._onHashChange = () => {
            const e3 = this._getCurrentHash();
            if (!this._isValidHash(e3))
              return false;
            const t2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e3[3] || 0) : this._map.getBearing();
            return this._map.jumpTo({ center: [+e3[2], +e3[1]], zoom: +e3[0], bearing: t2, pitch: +(e3[4] || 0) }), true;
          }, this._updateHashUnthrottled = () => {
            const e3 = window.location.href.replace(/(#.*)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, e3);
          }, this._removeHash = () => {
            const e3 = this._getCurrentHash();
            if (e3.length === 0)
              return;
            const t2 = e3.join("/");
            let i2 = t2;
            i2.split("&").length > 0 && (i2 = i2.split("&")[0]), this._hashName && (i2 = `${this._hashName}=${t2}`);
            let r2 = window.location.hash.replace(i2, "");
            r2.startsWith("#&") ? r2 = r2.slice(0, 1) + r2.slice(2) : r2 === "#" && (r2 = "");
            let o2 = window.location.href.replace(/(#.+)?$/, r2);
            o2 = o2.replace("&&", "&"), window.history.replaceState(window.history.state, null, o2);
          }, this._updateHash = Po2(this._updateHashUnthrottled, 300), this._hashName = e2 && encodeURIComponent(e2);
        }
        addTo(e2) {
          return this._map = e2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(e2) {
          const t2 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, r2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), o2 = Math.pow(10, r2), a2 = Math.round(t2.lng * o2) / o2, s2 = Math.round(t2.lat * o2) / o2, n2 = this._map.getBearing(), l3 = this._map.getPitch();
          let c2 = "";
          if (c2 += e2 ? `/${a2}/${s2}/${i2}` : `${i2}/${s2}/${a2}`, (n2 || l3) && (c2 += "/" + Math.round(10 * n2) / 10), l3 && (c2 += `/${Math.round(l3)}`), this._hashName) {
            const e3 = this._hashName;
            let t3 = false;
            const i3 = window.location.hash.slice(1).split("&").map((i4) => {
              const r3 = i4.split("=")[0];
              return r3 === e3 ? (t3 = true, `${r3}=${c2}`) : i4;
            }).filter((e4) => e4);
            return t3 || i3.push(`${e3}=${c2}`), `#${i3.join("&")}`;
          }
          return `#${c2}`;
        }
        _isValidHash(e2) {
          if (e2.length < 3 || e2.some(isNaN))
            return false;
          try {
            new t.Q(+e2[2], +e2[1]);
          } catch (e3) {
            return false;
          }
          const i2 = +e2[0], r2 = +(e2[3] || 0), o2 = +(e2[4] || 0);
          return i2 >= this._map.getMinZoom() && i2 <= this._map.getMaxZoom() && r2 >= -180 && r2 <= 180 && o2 >= this._map.getMinPitch() && o2 <= this._map.getMaxPitch();
        }
      }
      const Mo2 = { linearity: 0.3, easing: t.cd(0, 0, 0.3, 1) }, Io2 = t.e({ deceleration: 2500, maxSpeed: 1400 }, Mo2), Eo2 = t.e({ deceleration: 20, maxSpeed: 1400 }, Mo2), So2 = t.e({ deceleration: 1000, maxSpeed: 360 }, Mo2), Ro = t.e({ deceleration: 1000, maxSpeed: 90 }, Mo2), zo2 = t.e({ deceleration: 1000, maxSpeed: 360 }, Mo2);

      class Do2 {
        constructor(e2) {
          this._map = e2, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(e2) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: s.now(), settings: e2 });
        }
        _drainInertiaBuffer() {
          const e2 = this._inertiaBuffer, t2 = s.now();
          for (;e2.length > 0 && t2 - e2[0].time > 160; )
            e2.shift();
        }
        _onMoveEnd(e2) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const i2 = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new t.P(0, 0), pinchAround: undefined, around: undefined };
          for (const { settings: e3 } of this._inertiaBuffer)
            i2.zoom += e3.zoomDelta || 0, i2.bearing += e3.bearingDelta || 0, i2.pitch += e3.pitchDelta || 0, i2.roll += e3.rollDelta || 0, e3.panDelta && i2.pan._add(e3.panDelta), e3.around && (i2.around = e3.around), e3.pinchAround && (i2.pinchAround = e3.pinchAround);
          const r2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o2 = {};
          if (i2.pan.mag()) {
            const a2 = Lo2(i2.pan.mag(), r2, t.e({}, Io2, e2 || {})), s2 = i2.pan.mult(a2.amount / i2.pan.mag()), n2 = this._map.cameraHelper.handlePanInertia(s2, this._map.transform);
            o2.center = n2.easingCenter, o2.offset = n2.easingOffset, Ao2(o2, a2);
          }
          if (i2.zoom) {
            const e3 = Lo2(i2.zoom, r2, Eo2);
            o2.zoom = this._map.transform.zoom + e3.amount, Ao2(o2, e3);
          }
          if (i2.bearing) {
            const e3 = Lo2(i2.bearing, r2, So2);
            o2.bearing = this._map.transform.bearing + t.ae(e3.amount, -179, 179), Ao2(o2, e3);
          }
          if (i2.pitch) {
            const e3 = Lo2(i2.pitch, r2, Ro);
            o2.pitch = this._map.transform.pitch + e3.amount, Ao2(o2, e3);
          }
          if (i2.roll) {
            const e3 = Lo2(i2.roll, r2, zo2);
            o2.roll = this._map.transform.roll + t.ae(e3.amount, -179, 179), Ao2(o2, e3);
          }
          if (o2.zoom || o2.bearing) {
            const e3 = i2.pinchAround === undefined ? i2.around : i2.pinchAround;
            o2.around = e3 ? this._map.unproject(e3) : this._map.getCenter();
          }
          return this.clear(), t.e(o2, { noMoveStart: true });
        }
      }
      function Ao2(e2, t2) {
        (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
      }
      function Lo2(e2, i2, r2) {
        const { maxSpeed: o2, linearity: a2, deceleration: s2 } = r2, n2 = t.ae(e2 * a2 / (i2 / 1000), -o2, o2), l3 = Math.abs(n2) / (s2 * a2);
        return { easing: r2.easing, duration: 1000 * l3, amount: n2 * (l3 / 2) };
      }

      class ko2 extends t.l {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, i2, r2, o2 = {}) {
          r2 = r2 instanceof MouseEvent ? r2 : new MouseEvent(e2, r2);
          const a2 = n.mousePos(i2.getCanvas(), r2), s2 = i2.unproject(a2);
          super(e2, t.e({ point: a2, lngLat: s2, originalEvent: r2 }, o2)), this._defaultPrevented = false, this.target = i2;
        }
      }

      class Fo2 extends t.l {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, i2, r2) {
          const o2 = e2 === "touchend" ? r2.changedTouches : r2.touches, a2 = n.touchPos(i2.getCanvasContainer(), o2), s2 = a2.map((e3) => i2.unproject(e3)), l3 = a2.reduce((e3, t2, i3, r3) => e3.add(t2.div(r3.length)), new t.P(0, 0));
          super(e2, { points: a2, point: l3, lngLats: s2, lngLat: i2.unproject(l3), originalEvent: r2 }), this._defaultPrevented = false;
        }
      }

      class Bo2 extends t.l {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, t2, i2) {
          super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
        }
      }

      class Oo2 {
        constructor(e2, t2) {
          this._map = e2, this._clickTolerance = t2.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(e2) {
          return this._firePreventable(new Bo2(e2.type, this._map, e2));
        }
        mousedown(e2, t2) {
          return this._mousedownPos = t2, this._firePreventable(new ko2(e2.type, this._map, e2));
        }
        mouseup(e2) {
          this._map.fire(new ko2(e2.type, this._map, e2));
        }
        click(e2, t2) {
          this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || this._map.fire(new ko2(e2.type, this._map, e2));
        }
        dblclick(e2) {
          return this._firePreventable(new ko2(e2.type, this._map, e2));
        }
        mouseover(e2) {
          this._map.fire(new ko2(e2.type, this._map, e2));
        }
        mouseout(e2) {
          this._map.fire(new ko2(e2.type, this._map, e2));
        }
        touchstart(e2) {
          return this._firePreventable(new Fo2(e2.type, this._map, e2));
        }
        touchmove(e2) {
          this._map.fire(new Fo2(e2.type, this._map, e2));
        }
        touchend(e2) {
          this._map.fire(new Fo2(e2.type, this._map, e2));
        }
        touchcancel(e2) {
          this._map.fire(new Fo2(e2.type, this._map, e2));
        }
        _firePreventable(e2) {
          if (this._map.fire(e2), e2.defaultPrevented)
            return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }

      class jo2 {
        constructor(e2) {
          this._map = e2;
        }
        reset() {
          this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
        }
        mousemove(e2) {
          this._map.fire(new ko2(e2.type, this._map, e2));
        }
        mousedown() {
          this._delayContextMenu = true, this._ignoreContextMenu = false;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ko2("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e2) {
          this._delayContextMenu ? this._contextMenuEvent = e2 : this._ignoreContextMenu || this._map.fire(new ko2(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }

      class Zo2 {
        constructor(e2) {
          this._map = e2;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(e2) {
          return this.transform.screenPointToLocation(t.P.convert(e2), this._map.terrain);
        }
      }

      class No2 {
        constructor(e2, t2) {
          this._map = e2, this._tr = new Zo2(e2), this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(e2, t2) {
          this.isEnabled() && e2.shiftKey && e2.button === 0 && (n.disableDrag(), this._startPos = this._lastPos = t2, this._active = true);
        }
        mousemoveWindow(e2, t2) {
          if (!this._active)
            return;
          const i2 = t2;
          if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
            return;
          const r2 = this._startPos;
          this._lastPos = i2, this._box || (this._box = n.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e2));
          const o2 = Math.min(r2.x, i2.x), a2 = Math.max(r2.x, i2.x), s2 = Math.min(r2.y, i2.y), l3 = Math.max(r2.y, i2.y);
          n.setTransform(this._box, `translate(${o2}px,${s2}px)`), this._box.style.width = a2 - o2 + "px", this._box.style.height = l3 - s2 + "px";
        }
        mouseupWindow(e2, i2) {
          if (!this._active)
            return;
          if (e2.button !== 0)
            return;
          const r2 = this._startPos, o2 = i2;
          if (this.reset(), n.suppressClick(), r2.x !== o2.x || r2.y !== o2.y)
            return this._map.fire(new t.l("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (e3) => e3.fitScreenCoordinates(r2, o2, this._tr.bearing, { linear: true }) };
          this._fireEvent("boxzoomcancel", e2);
        }
        keydown(e2) {
          this._active && e2.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e2));
        }
        reset() {
          this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (n.remove(this._box), this._box = null), n.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(e2, i2) {
          return this._map.fire(new t.l(e2, { originalEvent: i2 }));
        }
      }
      function Uo2(e2, t2) {
        if (e2.length !== t2.length)
          throw new Error(`The number of touches and points are not equal - touches ${e2.length}, points ${t2.length}`);
        const i2 = {};
        for (let r2 = 0;r2 < e2.length; r2++)
          i2[e2[r2].identifier] = t2[r2];
        return i2;
      }

      class Go2 {
        constructor(e2) {
          this.reset(), this.numTouches = e2.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
        }
        touchstart(e2, i2, r2) {
          (this.centroid || r2.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === undefined && (this.startTime = e2.timeStamp), r2.length === this.numTouches && (this.centroid = function(e3) {
            const i3 = new t.P(0, 0);
            for (const t2 of e3)
              i3._add(t2);
            return i3.div(e3.length);
          }(i2), this.touches = Uo2(r2, i2)));
        }
        touchmove(e2, t2, i2) {
          if (this.aborted || !this.centroid)
            return;
          const r2 = Uo2(i2, t2);
          for (const e3 in this.touches) {
            const t3 = r2[e3];
            (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
          }
        }
        touchend(e2, t2, i2) {
          if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), i2.length === 0) {
            const e3 = !this.aborted && this.centroid;
            if (this.reset(), e3)
              return e3;
          }
        }
      }

      class Vo2 {
        constructor(e2) {
          this.singleTap = new Go2(e2), this.numTaps = e2.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(e2, t2, i2) {
          this.singleTap.touchstart(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          this.singleTap.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          const r2 = this.singleTap.touchend(e2, t2, i2);
          if (r2) {
            const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(r2) < 30;
            if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = r2, this.count === this.numTaps)
              return this.reset(), r2;
          }
        }
      }

      class qo2 {
        constructor(e2) {
          this._tr = new Zo2(e2), this._zoomIn = new Vo2({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Vo2({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e2, t2, i2) {
          this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          const r2 = this._zoomIn.touchend(e2, t2, i2), o2 = this._zoomOut.touchend(e2, t2, i2), a2 = this._tr;
          return r2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: a2.zoom + 1, around: a2.unproject(r2) }, { originalEvent: e2 }) }) : o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: a2.zoom - 1, around: a2.unproject(o2) }, { originalEvent: e2 }) }) : undefined;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class Wo {
        constructor(e2) {
          this._enabled = !!e2.enable, this._moveStateManager = e2.moveStateManager, this._clickTolerance = e2.clickTolerance || 1, this._moveFunction = e2.move, this._activateOnStart = !!e2.activateOnStart, e2.assignEvents(this), this.reset();
        }
        reset(e2) {
          this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e2);
        }
        _move(...e2) {
          const t2 = this._moveFunction(...e2);
          if (t2.bearingDelta || t2.pitchDelta || t2.rollDelta || t2.around || t2.panDelta)
            return this._active = true, t2;
        }
        dragStart(e2, t2) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e2) && (this._moveStateManager.startMove(e2), this._lastPoint = Array.isArray(t2) ? t2[0] : t2, this._activateOnStart && this._lastPoint && (this._active = true));
        }
        dragMove(e2, t2) {
          if (!this.isEnabled())
            return;
          const i2 = this._lastPoint;
          if (!i2)
            return;
          if (e2.preventDefault(), !this._moveStateManager.isValidMoveEvent(e2))
            return void this.reset(e2);
          const r2 = Array.isArray(t2) ? t2[0] : t2;
          return !this._moved && r2.dist(i2) < this._clickTolerance ? undefined : (this._moved = true, this._lastPoint = r2, this._move(i2, r2));
        }
        dragEnd(e2) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e2) && (this._moved && n.suppressClick(), this.reset(e2));
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const Ho = { 0: 1, 2: 2 };

      class $o2 {
        constructor(e2) {
          this._correctEvent = e2.checkCorrectEvent;
        }
        startMove(e2) {
          const t2 = n.mouseButton(e2);
          this._eventButton = t2;
        }
        endMove(e2) {
          delete this._eventButton;
        }
        isValidStartEvent(e2) {
          return this._correctEvent(e2);
        }
        isValidMoveEvent(e2) {
          return !function(e3, t2) {
            const i2 = Ho[t2];
            return e3.buttons === undefined || (e3.buttons & i2) !== i2;
          }(e2, this._eventButton);
        }
        isValidEndEvent(e2) {
          return n.mouseButton(e2) === this._eventButton;
        }
      }

      class Xo2 {
        constructor() {
          this._firstTouch = undefined;
        }
        _isOneFingerTouch(e2) {
          return e2.targetTouches.length === 1;
        }
        _isSameTouchEvent(e2) {
          return e2.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(e2) {
          this._firstTouch = e2.targetTouches[0].identifier;
        }
        endMove(e2) {
          delete this._firstTouch;
        }
        isValidStartEvent(e2) {
          return this._isOneFingerTouch(e2);
        }
        isValidMoveEvent(e2) {
          return this._isOneFingerTouch(e2) && this._isSameTouchEvent(e2);
        }
        isValidEndEvent(e2) {
          return this._isOneFingerTouch(e2) && this._isSameTouchEvent(e2);
        }
      }

      class Ko2 {
        constructor(e2 = new $o2({ checkCorrectEvent: () => true }), t2 = new Xo2) {
          this.mouseMoveStateManager = e2, this.oneFingerTouchMoveStateManager = t2;
        }
        _executeRelevantHandler(e2, t2, i2) {
          return e2 instanceof MouseEvent ? t2(e2) : typeof TouchEvent != "undefined" && e2 instanceof TouchEvent ? i2(e2) : undefined;
        }
        startMove(e2) {
          this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.startMove(e3), (e3) => this.oneFingerTouchMoveStateManager.startMove(e3));
        }
        endMove(e2) {
          this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.endMove(e3), (e3) => this.oneFingerTouchMoveStateManager.endMove(e3));
        }
        isValidStartEvent(e2) {
          return this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.isValidStartEvent(e3), (e3) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e3));
        }
        isValidMoveEvent(e2) {
          return this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.isValidMoveEvent(e3), (e3) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e3));
        }
        isValidEndEvent(e2) {
          return this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.isValidEndEvent(e3), (e3) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e3));
        }
      }
      const Qo2 = (e2) => {
        e2.mousedown = e2.dragStart, e2.mousemoveWindow = e2.dragMove, e2.mouseup = e2.dragEnd, e2.contextmenu = (e3) => {
          e3.preventDefault();
        };
      };

      class Yo2 {
        constructor(e2, t2) {
          this._clickTolerance = e2.clickTolerance || 1, this._map = t2, this.reset();
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new t.P(0, 0);
        }
        _shouldBePrevented(e2) {
          return e2 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(e2, t2, i2) {
          return this._calculateTransform(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          if (this._active) {
            if (!this._shouldBePrevented(i2.length))
              return e2.preventDefault(), this._calculateTransform(e2, t2, i2);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e2);
          }
        }
        touchend(e2, t2, i2) {
          this._calculateTransform(e2, t2, i2), this._active && this._shouldBePrevented(i2.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(e2, i2, r2) {
          r2.length > 0 && (this._active = true);
          const o2 = Uo2(r2, i2), a2 = new t.P(0, 0), s2 = new t.P(0, 0);
          let n2 = 0;
          for (const e3 in o2) {
            const t2 = o2[e3], i3 = this._touches[e3];
            i3 && (a2._add(t2), s2._add(t2.sub(i3)), n2++, o2[e3] = t2);
          }
          if (this._touches = o2, this._shouldBePrevented(n2) || !s2.mag())
            return;
          const l3 = s2.div(n2);
          return this._sum._add(l3), this._sum.mag() < this._clickTolerance ? undefined : { around: a2.div(n2), panDelta: l3 };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class Jo2 {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, delete this._firstTwoTouches;
        }
        touchstart(e2, t2, i2) {
          this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
        }
        touchmove(e2, t2, i2) {
          if (!this._firstTwoTouches)
            return;
          e2.preventDefault();
          const [r2, o2] = this._firstTwoTouches, a2 = ea(i2, t2, r2), s2 = ea(i2, t2, o2);
          if (!a2 || !s2)
            return;
          const n2 = this._aroundCenter ? null : a2.add(s2).div(2);
          return this._move([a2, s2], n2, e2);
        }
        touchend(e2, t2, i2) {
          if (!this._firstTwoTouches)
            return;
          const [r2, o2] = this._firstTwoTouches, a2 = ea(i2, t2, r2), s2 = ea(i2, t2, o2);
          a2 && s2 || (this._active && n.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e2) {
          this._enabled = true, this._aroundCenter = !!e2 && e2.around === "center";
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function ea(e2, t2, i2) {
        for (let r2 = 0;r2 < e2.length; r2++)
          if (e2[r2].identifier === i2)
            return t2[r2];
      }
      function ta(e2, t2) {
        return Math.log(e2 / t2) / Math.LN2;
      }

      class ia extends Jo2 {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(e2) {
          this._startDistance = this._distance = e2[0].dist(e2[1]);
        }
        _move(e2, t2) {
          const i2 = this._distance;
          if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(ta(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: ta(this._distance, i2), pinchAround: t2 };
        }
      }
      function ra(e2, t2) {
        return 180 * e2.angleWith(t2) / Math.PI;
      }

      class oa extends Jo2 {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(e2) {
          this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
        }
        _move(e2, t2, i2) {
          const r2 = this._vector;
          if (this._vector = e2[0].sub(e2[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = true, { bearingDelta: ra(this._vector, r2), pinchAround: t2 };
        }
        _isBelowThreshold(e2) {
          this._minDiameter = Math.min(this._minDiameter, e2.mag());
          const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = ra(e2, this._startVector);
          return Math.abs(i2) < t2;
        }
      }
      function aa(e2) {
        return Math.abs(e2.y) > Math.abs(e2.x);
      }

      class sa extends Jo2 {
        constructor(e2) {
          super(), this._currentTouchCount = 0, this._map = e2;
        }
        reset() {
          super.reset(), this._valid = undefined, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(e2, t2, i2) {
          super.touchstart(e2, t2, i2), this._currentTouchCount = i2.length;
        }
        _start(e2) {
          this._lastPoints = e2, aa(e2[0].sub(e2[1])) && (this._valid = false);
        }
        _move(e2, t2, i2) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3)
            return;
          const r2 = e2[0].sub(this._lastPoints[0]), o2 = e2[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(r2, o2, i2.timeStamp), this._valid ? (this._lastPoints = e2, this._active = true, { pitchDelta: (r2.y + o2.y) / 2 * -0.5 }) : undefined;
        }
        gestureBeginsVertically(e2, t2, i2) {
          if (this._valid !== undefined)
            return this._valid;
          const r2 = e2.mag() >= 2, o2 = t2.mag() >= 2;
          if (!r2 && !o2)
            return;
          if (!r2 || !o2)
            return this._firstMove === undefined && (this._firstMove = i2), i2 - this._firstMove < 100 && undefined;
          const a2 = e2.y > 0 == t2.y > 0;
          return aa(e2) && aa(t2) && a2;
        }
      }
      const na = { panStep: 100, bearingStep: 15, pitchStep: 10 };

      class la {
        constructor(e2) {
          this._tr = new Zo2(e2);
          const t2 = na;
          this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = false;
        }
        reset() {
          this._active = false;
        }
        keydown(e2) {
          if (e2.altKey || e2.ctrlKey || e2.metaKey)
            return;
          let t2 = 0, i2 = 0, r2 = 0, o2 = 0, a2 = 0;
          switch (e2.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              t2 = 1;
              break;
            case 189:
            case 109:
            case 173:
              t2 = -1;
              break;
            case 37:
              e2.shiftKey ? i2 = -1 : (e2.preventDefault(), o2 = -1);
              break;
            case 39:
              e2.shiftKey ? i2 = 1 : (e2.preventDefault(), o2 = 1);
              break;
            case 38:
              e2.shiftKey ? r2 = 1 : (e2.preventDefault(), a2 = -1);
              break;
            case 40:
              e2.shiftKey ? r2 = -1 : (e2.preventDefault(), a2 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i2 = 0, r2 = 0), { cameraAnimation: (s2) => {
            const n2 = this._tr;
            s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ca, zoom: t2 ? Math.round(n2.zoom) + t2 * (e2.shiftKey ? 2 : 1) : n2.zoom, bearing: n2.bearing + i2 * this._bearingStep, pitch: n2.pitch + r2 * this._pitchStep, offset: [-o2 * this._panStep, -a2 * this._panStep], center: n2.center }, { originalEvent: e2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function ca(e2) {
        return e2 * (2 - e2);
      }
      const ha = 4.000244140625;

      class ua {
        constructor(e2, t2) {
          this._onTimeout = (e3) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e3);
          }, this._map = e2, this._tr = new Zo2(e2), this._triggerRenderFrame = t2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(e2) {
          this._defaultZoomRate = e2;
        }
        setWheelZoomRate(e2) {
          this._wheelZoomRate = e2;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== undefined;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e2) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && e2.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        _shouldBePrevented(e2) {
          return !!this._map.cooperativeGestures.isEnabled() && !(e2.ctrlKey || this._map.cooperativeGestures.isBypassed(e2));
        }
        wheel(e2) {
          if (!this.isEnabled())
            return;
          if (this._shouldBePrevented(e2))
            return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e2);
          let t2 = e2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY;
          const i2 = s.now(), r2 = i2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = i2, t2 !== 0 && t2 % ha == 0 ? this._type = "wheel" : t2 !== 0 && Math.abs(t2) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = t2, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(r2 * t2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t2 += this._lastValue)), e2.shiftKey && t2 && (t2 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= t2, this._active || this._start(e2)), e2.preventDefault();
        }
        _start(e2) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const i2 = n.mousePos(this._map.getCanvas(), e2), r2 = this._tr;
          this._aroundPoint = this._aroundCenter ? r2.transform.locationToScreenPoint(t.Q.convert(r2.center)) : i2, this._frameId || (this._frameId = true, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId)
            return;
          if (this._frameId = null, !this.isActive())
            return;
          const e2 = this._tr.transform;
          if (typeof this._lastExpectedZoom == "number") {
            const t2 = e2.zoom - this._lastExpectedZoom;
            typeof this._startZoom == "number" && (this._startZoom += t2), typeof this._targetZoom == "number" && (this._targetZoom += t2);
          }
          if (this._delta !== 0) {
            const i3 = this._type === "wheel" && Math.abs(this._delta) > ha ? this._wheelZoomRate : this._defaultZoomRate;
            let r3 = 2 / (1 + Math.exp(-Math.abs(this._delta * i3)));
            this._delta < 0 && r3 !== 0 && (r3 = 1 / r3);
            const o3 = typeof this._targetZoom != "number" ? e2.scale : t.ac(this._targetZoom);
            this._targetZoom = e2.getConstrained(e2.getCameraLngLat(), t.ah(o3 * r3)).zoom, this._type === "wheel" && (this._startZoom = e2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const i2 = typeof this._targetZoom != "number" ? e2.zoom : this._targetZoom, r2 = this._startZoom, o2 = this._easing;
          let a2, n2 = false;
          if (this._type === "wheel" && r2 && o2) {
            const e3 = s.now() - this._lastWheelEventTime, l3 = Math.min((e3 + 5) / 200, 1), c2 = o2(l3);
            a2 = t.B.number(r2, i2, c2), l3 < 1 ? this._frameId || (this._frameId = true) : n2 = true;
          } else
            a2 = i2, n2 = true;
          return this._active = true, n2 && (this._active = false, this._finishTimeout = setTimeout(() => {
            this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
          }, 200)), this._lastExpectedZoom = a2, { noInertia: true, needsRenderFrame: !n2, zoomDelta: a2 - e2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(e2) {
          let i2 = t.cf;
          if (this._prevEase) {
            const e3 = this._prevEase, r2 = (s.now() - e3.start) / e3.duration, o2 = e3.easing(r2 + 0.01) - e3.easing(r2), a2 = 0.27 / Math.sqrt(o2 * o2 + 0.0001) * 0.01, n2 = Math.sqrt(0.0729 - a2 * a2);
            i2 = t.cd(a2, n2, 0.25, 1);
          }
          return this._prevEase = { start: s.now(), duration: e2, easing: i2 }, i2;
        }
        reset() {
          this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }

      class da {
        constructor(e2, t2) {
          this._clickZoom = e2, this._tapZoom = t2;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }

      class _a {
        constructor(e2) {
          this._tr = new Zo2(e2), this.reset();
        }
        reset() {
          this._active = false;
        }
        dblclick(e2, t2) {
          return e2.preventDefault(), { cameraAnimation: (i2) => {
            i2.easeTo({ duration: 300, zoom: this._tr.zoom + (e2.shiftKey ? -1 : 1), around: this._tr.unproject(t2) }, { originalEvent: e2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class pa {
        constructor() {
          this._tap = new Vo2({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(e2, t2, i2) {
          if (!this._swipePoint)
            if (this._tapTime) {
              const r2 = t2[0], o2 = e2.timeStamp - this._tapTime < 500, a2 = this._tapPoint.dist(r2) < 30;
              o2 && a2 ? i2.length > 0 && (this._swipePoint = r2, this._swipeTouch = i2[0].identifier) : this.reset();
            } else
              this._tap.touchstart(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i2[0].identifier !== this._swipeTouch)
                return;
              const r2 = t2[0], o2 = r2.y - this._swipePoint.y;
              return this._swipePoint = r2, e2.preventDefault(), this._active = true, { zoomDelta: o2 / 128 };
            }
          } else
            this._tap.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          if (this._tapTime)
            this._swipePoint && i2.length === 0 && this.reset();
          else {
            const r2 = this._tap.touchend(e2, t2, i2);
            r2 && (this._tapTime = e2.timeStamp, this._tapPoint = r2);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class ma {
        constructor(e2, t2, i2) {
          this._el = e2, this._mousePan = t2, this._touchPan = i2;
        }
        enable(e2) {
          this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }

      class fa {
        constructor(e2, t2, i2, r2) {
          this._pitchWithRotate = e2.pitchWithRotate, this._rollEnabled = e2.rollEnabled, this._mouseRotate = t2, this._mousePitch = i2, this._mouseRoll = r2;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
        }
      }

      class ga {
        constructor(e2, t2, i2, r2) {
          this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = r2, this._rotationDisabled = false, this._enabled = true;
        }
        enable(e2) {
          this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }

      class va {
        constructor(e2, t2) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e2, this._options = t2, this._enabled = false;
        }
        isActive() {
          return false;
        }
        reset() {
        }
        _setupUI() {
          if (this._container)
            return;
          const e2 = this._map.getCanvasContainer();
          e2.classList.add("maplibregl-cooperative-gestures"), this._container = n.create("div", "maplibregl-cooperative-gesture-screen", e2);
          let t2 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (t2 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const i2 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), r2 = document.createElement("div");
          r2.className = "maplibregl-desktop-message", r2.textContent = t2, this._container.appendChild(r2);
          const o2 = document.createElement("div");
          o2.className = "maplibregl-mobile-message", o2.textContent = i2, this._container.appendChild(o2), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (n.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = true;
        }
        disable() {
          this._enabled = false, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(e2) {
          return e2[this._bypassKey];
        }
        notifyGestureBlocked(e2, i2) {
          this._enabled && (this._map.fire(new t.l("cooperativegestureprevented", { gestureType: e2, originalEvent: i2 })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const xa = (e2) => e2.zoom || e2.drag || e2.roll || e2.pitch || e2.rotate;

      class ba extends t.l {
      }
      function ya(e2) {
        return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta || e2.rollDelta;
      }

      class wa {
        constructor(e2, i2) {
          this.handleWindowEvent = (e3) => {
            this.handleEvent(e3, `${e3.type}Window`);
          }, this.handleEvent = (e3, i3) => {
            if (e3.type === "blur")
              return void this.stop(true);
            this._updatingCamera = true;
            const r3 = e3.type === "renderFrame" ? undefined : e3, o2 = { needsRenderFrame: false }, a2 = {}, s2 = {};
            for (const { handlerName: l4, handler: c3, allowed: h2 } of this._handlers) {
              if (!c3.isEnabled())
                continue;
              let u2;
              if (this._blockedByActive(s2, h2, l4))
                c3.reset();
              else if (c3[i3 || e3.type]) {
                if (t.cg(e3, i3 || e3.type)) {
                  const t2 = n.mousePos(this._map.getCanvas(), e3);
                  u2 = c3[i3 || e3.type](e3, t2);
                } else if (t.ch(e3, i3 || e3.type)) {
                  const t2 = this._getMapTouches(e3.touches), r4 = n.touchPos(this._map.getCanvas(), t2);
                  u2 = c3[i3 || e3.type](e3, r4, t2);
                } else
                  t.ci(i3 || e3.type) || (u2 = c3[i3 || e3.type](e3));
                this.mergeHandlerResult(o2, a2, u2, l4, r3), u2 && u2.needsRenderFrame && this._triggerRenderFrame();
              }
              (u2 || c3.isActive()) && (s2[l4] = c3);
            }
            const l3 = {};
            for (const e4 in this._previousActiveHandlers)
              s2[e4] || (l3[e4] = r3);
            this._previousActiveHandlers = s2, (Object.keys(l3).length || ya(o2)) && (this._changes.push([o2, a2, l3]), this._triggerRenderFrame()), (Object.keys(s2).length || ya(o2)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: c2 } = o2;
            c2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], c2(this._map));
          }, this._map = e2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Do2(e2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i2);
          const r2 = this._el;
          this._listeners = [[r2, "touchstart", { passive: true }], [r2, "touchmove", { passive: false }], [r2, "touchend", undefined], [r2, "touchcancel", undefined], [r2, "mousedown", undefined], [r2, "mousemove", undefined], [r2, "mouseup", undefined], [document, "mousemove", { capture: true }], [document, "mouseup", undefined], [r2, "mouseover", undefined], [r2, "mouseout", undefined], [r2, "dblclick", undefined], [r2, "click", undefined], [r2, "keydown", { capture: false }], [r2, "keyup", undefined], [r2, "wheel", { passive: false }], [r2, "contextmenu", undefined], [window, "blur", undefined]];
          for (const [e3, t2, i3] of this._listeners)
            n.addEventListener(e3, t2, e3 === document ? this.handleWindowEvent : this.handleEvent, i3);
        }
        destroy() {
          for (const [e2, t2, i2] of this._listeners)
            n.removeEventListener(e2, t2, e2 === document ? this.handleWindowEvent : this.handleEvent, i2);
        }
        _addDefaultHandlers(e2) {
          const i2 = this._map, r2 = i2.getCanvasContainer();
          this._add("mapEvent", new Oo2(i2, e2));
          const o2 = i2.boxZoom = new No2(i2, e2);
          this._add("boxZoom", o2), e2.interactive && e2.boxZoom && o2.enable();
          const a2 = i2.cooperativeGestures = new va(i2, e2.cooperativeGestures);
          this._add("cooperativeGestures", a2), e2.cooperativeGestures && a2.enable();
          const s2 = new qo2(i2), l3 = new _a(i2);
          i2.doubleClickZoom = new da(l3, s2), this._add("tapZoom", s2), this._add("clickZoom", l3), e2.interactive && e2.doubleClickZoom && i2.doubleClickZoom.enable();
          const c2 = new pa;
          this._add("tapDragZoom", c2);
          const h2 = i2.touchPitch = new sa(i2);
          this._add("touchPitch", h2), e2.interactive && e2.touchPitch && i2.touchPitch.enable(e2.touchPitch);
          const u2 = () => i2.project(i2.getCenter()), d2 = function({ enable: e3, clickTolerance: i3, aroundCenter: r3 = true, minPixelCenterThreshold: o3 = 100, rotateDegreesPerPixelMoved: a3 = 0.8 }, s3) {
            const l4 = new $o2({ checkCorrectEvent: (e4) => n.mouseButton(e4) === 0 && e4.ctrlKey || n.mouseButton(e4) === 2 && !e4.ctrlKey });
            return new Wo({ clickTolerance: i3, move: (e4, i4) => {
              const n2 = s3();
              if (r3 && Math.abs(n2.y - e4.y) > o3)
                return { bearingDelta: t.ce(new t.P(e4.x, i4.y), i4, n2) };
              let l5 = (i4.x - e4.x) * a3;
              return r3 && i4.y < n2.y && (l5 = -l5), { bearingDelta: l5 };
            }, moveStateManager: l4, enable: e3, assignEvents: Qo2 });
          }(e2, u2), _2 = function({ enable: e3, clickTolerance: t2, pitchDegreesPerPixelMoved: i3 = -0.5 }) {
            const r3 = new $o2({ checkCorrectEvent: (e4) => n.mouseButton(e4) === 0 && e4.ctrlKey || n.mouseButton(e4) === 2 });
            return new Wo({ clickTolerance: t2, move: (e4, t3) => ({ pitchDelta: (t3.y - e4.y) * i3 }), moveStateManager: r3, enable: e3, assignEvents: Qo2 });
          }(e2), p2 = function({ enable: e3, clickTolerance: t2, rollDegreesPerPixelMoved: i3 = 0.3 }, r3) {
            const o3 = new $o2({ checkCorrectEvent: (e4) => n.mouseButton(e4) === 2 && e4.ctrlKey });
            return new Wo({ clickTolerance: t2, move: (e4, t3) => {
              const o4 = r3();
              let a3 = (t3.x - e4.x) * i3;
              return t3.y < o4.y && (a3 = -a3), { rollDelta: a3 };
            }, moveStateManager: o3, enable: e3, assignEvents: Qo2 });
          }(e2, u2);
          i2.dragRotate = new fa(e2, d2, _2, p2), this._add("mouseRotate", d2, ["mousePitch"]), this._add("mousePitch", _2, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p2, ["mousePitch"]), e2.interactive && e2.dragRotate && i2.dragRotate.enable();
          const m2 = function({ enable: e3, clickTolerance: t2 }) {
            const i3 = new $o2({ checkCorrectEvent: (e4) => n.mouseButton(e4) === 0 && !e4.ctrlKey });
            return new Wo({ clickTolerance: t2, move: (e4, t3) => ({ around: t3, panDelta: t3.sub(e4) }), activateOnStart: true, moveStateManager: i3, enable: e3, assignEvents: Qo2 });
          }(e2), f2 = new Yo2(e2, i2);
          i2.dragPan = new ma(r2, m2, f2), this._add("mousePan", m2), this._add("touchPan", f2, ["touchZoom", "touchRotate"]), e2.interactive && e2.dragPan && i2.dragPan.enable(e2.dragPan);
          const g2 = new oa, v2 = new ia;
          i2.touchZoomRotate = new ga(r2, v2, g2, c2), this._add("touchRotate", g2, ["touchPan", "touchZoom"]), this._add("touchZoom", v2, ["touchPan", "touchRotate"]), e2.interactive && e2.touchZoomRotate && i2.touchZoomRotate.enable(e2.touchZoomRotate);
          const x2 = i2.scrollZoom = new ua(i2, () => this._triggerRenderFrame());
          this._add("scrollZoom", x2, ["mousePan"]), e2.interactive && e2.scrollZoom && i2.scrollZoom.enable(e2.scrollZoom);
          const b2 = i2.keyboard = new la(i2);
          this._add("keyboard", b2), e2.interactive && e2.keyboard && i2.keyboard.enable(), this._add("blockableMapEvent", new jo2(i2));
        }
        _add(e2, t2, i2) {
          this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
        }
        stop(e2) {
          if (!this._updatingCamera) {
            for (const { handler: e3 } of this._handlers)
              e3.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: e2 } of this._handlers)
            if (e2.isActive())
              return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return Boolean(xa(this._eventsInProgress)) || this.isZooming();
        }
        _blockedByActive(e2, t2, i2) {
          for (const r2 in e2)
            if (r2 !== i2 && (!t2 || t2.indexOf(r2) < 0))
              return true;
          return false;
        }
        _getMapTouches(e2) {
          const t2 = [];
          for (const i2 of e2)
            this._el.contains(i2.target) && t2.push(i2);
          return t2;
        }
        mergeHandlerResult(e2, i2, r2, o2, a2) {
          if (!r2)
            return;
          t.e(e2, r2);
          const s2 = { handlerName: o2, originalEvent: r2.originalEvent || a2 };
          r2.zoomDelta !== undefined && (i2.zoom = s2), r2.panDelta !== undefined && (i2.drag = s2), r2.rollDelta !== undefined && (i2.roll = s2), r2.pitchDelta !== undefined && (i2.pitch = s2), r2.bearingDelta !== undefined && (i2.rotate = s2);
        }
        _applyChanges() {
          const e2 = {}, i2 = {}, r2 = {};
          for (const [o2, a2, s2] of this._changes)
            o2.panDelta && (e2.panDelta = (e2.panDelta || new t.P(0, 0))._add(o2.panDelta)), o2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + o2.zoomDelta), o2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + o2.bearingDelta), o2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + o2.pitchDelta), o2.rollDelta && (e2.rollDelta = (e2.rollDelta || 0) + o2.rollDelta), o2.around !== undefined && (e2.around = o2.around), o2.pinchAround !== undefined && (e2.pinchAround = o2.pinchAround), o2.noInertia && (e2.noInertia = o2.noInertia), t.e(i2, a2), t.e(r2, s2);
          this._updateMapTransform(e2, i2, r2), this._changes = [];
        }
        _updateMapTransform(e2, t2, i2) {
          const r2 = this._map, o2 = r2._getTransformForUpdate(), a2 = r2.terrain;
          if (!(ya(e2) || a2 && this._terrainMovement))
            return this._fireEvents(t2, i2, true);
          r2._stop(true);
          let { panDelta: s2, zoomDelta: n2, bearingDelta: l3, pitchDelta: c2, rollDelta: h2, around: u2, pinchAround: d2 } = e2;
          d2 !== undefined && (u2 = d2), u2 = u2 || r2.transform.centerPoint, a2 && !o2.isPointOnMapSurface(u2) && (u2 = o2.centerPoint);
          const _2 = { panDelta: s2, zoomDelta: n2, rollDelta: h2, pitchDelta: c2, bearingDelta: l3, around: u2 };
          this._map.cameraHelper.useGlobeControls && !o2.isPointOnMapSurface(u2) && (u2 = o2.centerPoint);
          const p2 = u2.distSqr(o2.centerPoint) < 0.01 ? o2.center : o2.screenPointToLocation(s2 ? u2.sub(s2) : u2);
          a2 ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_2, o2), this._terrainMovement || !t2.drag && !t2.zoom ? t2.drag && this._terrainMovement ? o2.setCenter(o2.screenPointToLocation(o2.centerPoint.sub(s2))) : this._map.cameraHelper.handleMapControlsPan(_2, o2, p2) : (this._terrainMovement = true, this._map._elevationFreeze = true, this._map.cameraHelper.handleMapControlsPan(_2, o2, p2))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_2, o2), this._map.cameraHelper.handleMapControlsPan(_2, o2, p2)), r2._applyUpdatedTransform(o2), this._map._update(), e2.noInertia || this._inertia.record(e2), this._fireEvents(t2, i2, true);
        }
        _fireEvents(e2, i2, r2) {
          const o2 = xa(this._eventsInProgress), a2 = xa(e2), n2 = {};
          for (const t2 in e2) {
            const { originalEvent: i3 } = e2[t2];
            this._eventsInProgress[t2] || (n2[`${t2}start`] = i3), this._eventsInProgress[t2] = e2[t2];
          }
          !o2 && a2 && this._fireEvent("movestart", a2.originalEvent);
          for (const e3 in n2)
            this._fireEvent(e3, n2[e3]);
          a2 && this._fireEvent("move", a2.originalEvent);
          for (const t2 in e2) {
            const { originalEvent: i3 } = e2[t2];
            this._fireEvent(t2, i3);
          }
          const l3 = {};
          let c2;
          for (const e3 in this._eventsInProgress) {
            const { handlerName: t2, originalEvent: r3 } = this._eventsInProgress[e3];
            this._handlersById[t2].isActive() || (delete this._eventsInProgress[e3], c2 = i2[t2] || r3, l3[`${e3}end`] = c2);
          }
          for (const e3 in l3)
            this._fireEvent(e3, l3[e3]);
          const h2 = xa(this._eventsInProgress), u2 = (o2 || a2) && !h2;
          if (u2 && this._terrainMovement) {
            this._map._elevationFreeze = false, this._terrainMovement = false;
            const e3 = this._map._getTransformForUpdate();
            this._map.getCenterClampedToGround() && e3.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e3);
          }
          if (r2 && u2) {
            this._updatingCamera = true;
            const e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e4) => e4 !== 0 && -this._bearingSnap < e4 && e4 < this._bearingSnap;
            !e3 || !e3.essential && s.prefersReducedMotion ? (this._map.fire(new t.l("moveend", { originalEvent: c2 })), i3(this._map.getBearing()) && this._map.resetNorth()) : (i3(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), e3.freezeElevation = true, this._map.easeTo(e3, { originalEvent: c2 })), this._updatingCamera = false;
          }
        }
        _fireEvent(e2, i2) {
          this._map.fire(new t.l(e2, i2 ? { originalEvent: i2 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
            delete this._frameId, this.handleEvent(new ba("renderFrame", { timeStamp: e2 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === undefined && (this._frameId = this._requestFrame());
        }
      }

      class Ta extends t.E {
        constructor(e2, t2, i2) {
          super(), this._renderFrameCallback = () => {
            const e3 = Math.min((s.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = false, this._zooming = false, this.transform = e2, this._bearingSnap = i2.bearingSnap, this.cameraHelper = t2, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        migrateProjection(e2, t2) {
          e2.apply(this.transform), this.transform = e2, this.cameraHelper = t2;
        }
        getCenter() {
          return new t.Q(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e2, t2) {
          return this.jumpTo({ center: e2 }, t2);
        }
        getCenterElevation() {
          return this.transform.elevation;
        }
        setCenterElevation(e2, t2) {
          return this.jumpTo({ elevation: e2 }, t2), this;
        }
        getCenterClampedToGround() {
          return this._centerClampedToGround;
        }
        setCenterClampedToGround(e2) {
          this._centerClampedToGround = e2;
        }
        panBy(e2, i2, r2) {
          return e2 = t.P.convert(e2).mult(-1), this.panTo(this.transform.center, t.e({ offset: e2 }, i2), r2);
        }
        panTo(e2, i2, r2) {
          return this.easeTo(t.e({ center: e2 }, i2), r2);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e2, t2) {
          return this.jumpTo({ zoom: e2 }, t2), this;
        }
        zoomTo(e2, i2, r2) {
          return this.easeTo(t.e({ zoom: e2 }, i2), r2);
        }
        zoomIn(e2, t2) {
          return this.zoomTo(this.getZoom() + 1, e2, t2), this;
        }
        zoomOut(e2, t2) {
          return this.zoomTo(this.getZoom() - 1, e2, t2), this;
        }
        getVerticalFieldOfView() {
          return this.transform.fov;
        }
        setVerticalFieldOfView(e2, i2) {
          return e2 != this.transform.fov && (this.transform.setFov(e2), this.fire(new t.l("movestart", i2)).fire(new t.l("move", i2)).fire(new t.l("moveend", i2))), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e2, t2) {
          return this.jumpTo({ bearing: e2 }, t2), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e2, t2) {
          return this.jumpTo({ padding: e2 }, t2), this;
        }
        rotateTo(e2, i2, r2) {
          return this.easeTo(t.e({ bearing: e2 }, i2), r2);
        }
        resetNorth(e2, i2) {
          return this.rotateTo(0, t.e({ duration: 1000 }, e2), i2), this;
        }
        resetNorthPitch(e2, i2) {
          return this.easeTo(t.e({ bearing: 0, pitch: 0, roll: 0, duration: 1000 }, e2), i2), this;
        }
        snapToNorth(e2, t2) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e2, t2) {
          return this.jumpTo({ pitch: e2 }, t2), this;
        }
        getRoll() {
          return this.transform.roll;
        }
        setRoll(e2, t2) {
          return this.jumpTo({ roll: e2 }, t2), this;
        }
        cameraForBounds(e2, t2) {
          e2 = V.convert(e2).adjustAntiMeridian();
          const i2 = t2 && t2.bearing || 0;
          return this._cameraForBoxAndBearing(e2.getNorthWest(), e2.getSouthEast(), i2, t2);
        }
        _cameraForBoxAndBearing(e2, i2, r2, o2) {
          const a2 = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (o2 = t.e({ padding: a2, offset: [0, 0], maxZoom: this.transform.maxZoom }, o2)).padding == "number") {
            const e3 = o2.padding;
            o2.padding = { top: e3, bottom: e3, right: e3, left: e3 };
          }
          const s2 = t.e(a2, o2.padding);
          o2.padding = s2;
          const n2 = this.transform, l3 = new V(e2, i2);
          return this.cameraHelper.cameraForBoxAndBearing(o2, s2, l3, r2, n2);
        }
        fitBounds(e2, t2, i2) {
          return this._fitInternal(this.cameraForBounds(e2, t2), t2, i2);
        }
        fitScreenCoordinates(e2, i2, r2, o2, a2) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t.P.convert(e2)), this.transform.screenPointToLocation(t.P.convert(i2)), r2, o2), o2, a2);
        }
        _fitInternal(e2, i2, r2) {
          return e2 ? (delete (i2 = t.e(e2, i2)).padding, i2.linear ? this.easeTo(i2, r2) : this.flyTo(i2, r2)) : this;
        }
        jumpTo(e2, i2) {
          this.stop();
          const r2 = this._getTransformForUpdate();
          let o2 = false, a2 = false, s2 = false;
          const n2 = r2.zoom;
          this.cameraHelper.handleJumpToCenterZoom(r2, e2);
          const l3 = r2.zoom !== n2;
          return "elevation" in e2 && r2.elevation !== +e2.elevation && r2.setElevation(+e2.elevation), "bearing" in e2 && r2.bearing !== +e2.bearing && (o2 = true, r2.setBearing(+e2.bearing)), "pitch" in e2 && r2.pitch !== +e2.pitch && (a2 = true, r2.setPitch(+e2.pitch)), "roll" in e2 && r2.roll !== +e2.roll && (s2 = true, r2.setRoll(+e2.roll)), e2.padding == null || r2.isPaddingEqual(e2.padding) || r2.setPadding(e2.padding), this._applyUpdatedTransform(r2), this.fire(new t.l("movestart", i2)).fire(new t.l("move", i2)), l3 && this.fire(new t.l("zoomstart", i2)).fire(new t.l("zoom", i2)).fire(new t.l("zoomend", i2)), o2 && this.fire(new t.l("rotatestart", i2)).fire(new t.l("rotate", i2)).fire(new t.l("rotateend", i2)), a2 && this.fire(new t.l("pitchstart", i2)).fire(new t.l("pitch", i2)).fire(new t.l("pitchend", i2)), s2 && this.fire(new t.l("rollstart", i2)).fire(new t.l("roll", i2)).fire(new t.l("rollend", i2)), this.fire(new t.l("moveend", i2));
        }
        calculateCameraOptionsFromTo(e2, i2, r2, o2 = 0) {
          const a2 = t.$.fromLngLat(e2, i2), s2 = t.$.fromLngLat(r2, o2), n2 = s2.x - a2.x, l3 = s2.y - a2.y, c2 = s2.z - a2.z, h2 = Math.hypot(n2, l3, c2);
          if (h2 === 0)
            throw new Error("Can't calculate camera options with same From and To");
          const u2 = Math.hypot(n2, l3), d2 = t.ah(this.transform.cameraToCenterDistance / h2 / this.transform.tileSize), _2 = 180 * Math.atan2(n2, -l3) / Math.PI;
          let p2 = 180 * Math.acos(u2 / h2) / Math.PI;
          return p2 = c2 < 0 ? 90 - p2 : 90 + p2, { center: s2.toLngLat(), elevation: o2, zoom: d2, pitch: p2, bearing: _2 };
        }
        calculateCameraOptionsFromCameraLngLatAltRotation(e2, t2, i2, r2, o2) {
          const a2 = this.transform.calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2);
          return { center: a2.center, elevation: a2.elevation, zoom: a2.zoom, bearing: i2, pitch: r2, roll: o2 };
        }
        easeTo(e2, i2) {
          this._stop(false, e2.easeId), ((e2 = t.e({ offset: [0, 0], duration: 500, easing: t.cf }, e2)).animate === false || !e2.essential && s.prefersReducedMotion) && (e2.duration = 0);
          const r2 = this._getTransformForUpdate(), o2 = this.getBearing(), a2 = r2.pitch, n2 = r2.roll, l3 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, o2) : o2, c2 = "pitch" in e2 ? +e2.pitch : a2, h2 = "roll" in e2 ? this._normalizeBearing(e2.roll, n2) : n2, u2 = "padding" in e2 ? e2.padding : r2.padding, d2 = t.P.convert(e2.offset);
          let _2, p2;
          e2.around && (_2 = t.Q.convert(e2.around), p2 = r2.locationToScreenPoint(_2));
          const m2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, f2 = this.cameraHelper.handleEaseTo(r2, { bearing: l3, pitch: c2, roll: h2, padding: u2, around: _2, aroundPoint: p2, offsetAsPoint: d2, offset: e2.offset, zoom: e2.zoom, center: e2.center });
          return this._rotating = this._rotating || o2 !== l3, this._pitching = this._pitching || c2 !== a2, this._rolling = this._rolling || h2 !== n2, this._padding = !r2.isPaddingEqual(u2), this._zooming = this._zooming || f2.isZooming, this._easeId = e2.easeId, this._prepareEase(i2, e2.noMoveStart, m2), this.terrain && this._prepareElevation(f2.elevationCenter), this._ease((t2) => {
            f2.easeFunc(t2), this.terrain && !e2.freezeElevation && this._updateElevation(t2), this._applyUpdatedTransform(r2), this._fireMoveEvents(i2);
          }, (t2) => {
            this.terrain && e2.freezeElevation && this._finalizeElevation(), this._afterEase(i2, t2);
          }, e2), this;
        }
        _prepareEase(e2, i2, r2 = {}) {
          this._moving = true, i2 || r2.moving || this.fire(new t.l("movestart", e2)), this._zooming && !r2.zooming && this.fire(new t.l("zoomstart", e2)), this._rotating && !r2.rotating && this.fire(new t.l("rotatestart", e2)), this._pitching && !r2.pitching && this.fire(new t.l("pitchstart", e2)), this._rolling && !r2.rolling && this.fire(new t.l("rollstart", e2));
        }
        _prepareElevation(e2) {
          this._elevationCenter = e2, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e2, this.transform.tileZoom), this._elevationFreeze = true;
        }
        _updateElevation(e2) {
          this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
          const i2 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (e2 < 1 && i2 !== this._elevationTarget) {
            const t2 = this._elevationTarget - this._elevationStart;
            this._elevationStart += e2 * (t2 - (i2 - (t2 * e2 + this._elevationStart)) / (1 - e2)), this._elevationTarget = i2;
          }
          this.transform.setElevation(t.B.number(this._elevationStart, this._elevationTarget, e2));
        }
        _finalizeElevation() {
          this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(e2) {
          if (!this.terrain && e2.elevation >= 0 && e2.pitch <= 90)
            return {};
          const t2 = e2.getCameraLngLat(), i2 = e2.getCameraAltitude(), r2 = this.terrain ? this.terrain.getElevationForLngLatZoom(t2, e2.zoom) : 0;
          if (i2 < r2) {
            const i3 = this.calculateCameraOptionsFromTo(t2, r2, e2.center, e2.elevation);
            return { pitch: i3.pitch, zoom: i3.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(e2) {
          const t2 = [];
          if (t2.push((e3) => this._elevateCameraIfInsideTerrain(e3)), this.transformCameraUpdate && t2.push((e3) => this.transformCameraUpdate(e3)), !t2.length)
            return;
          const i2 = e2.clone();
          for (const e3 of t2) {
            const t3 = i2.clone(), { center: r2, zoom: o2, roll: a2, pitch: s2, bearing: n2, elevation: l3 } = e3(t3);
            r2 && t3.setCenter(r2), l3 !== undefined && t3.setElevation(l3), o2 !== undefined && t3.setZoom(o2), a2 !== undefined && t3.setRoll(a2), s2 !== undefined && t3.setPitch(s2), n2 !== undefined && t3.setBearing(n2), i2.apply(t3);
          }
          this.transform.apply(i2);
        }
        _fireMoveEvents(e2) {
          this.fire(new t.l("move", e2)), this._zooming && this.fire(new t.l("zoom", e2)), this._rotating && this.fire(new t.l("rotate", e2)), this._pitching && this.fire(new t.l("pitch", e2)), this._rolling && this.fire(new t.l("roll", e2));
        }
        _afterEase(e2, i2) {
          if (this._easeId && i2 && this._easeId === i2)
            return;
          delete this._easeId;
          const r2 = this._zooming, o2 = this._rotating, a2 = this._pitching, s2 = this._rolling;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, r2 && this.fire(new t.l("zoomend", e2)), o2 && this.fire(new t.l("rotateend", e2)), a2 && this.fire(new t.l("pitchend", e2)), s2 && this.fire(new t.l("rollend", e2)), this.fire(new t.l("moveend", e2));
        }
        flyTo(e2, i2) {
          if (!e2.essential && s.prefersReducedMotion) {
            const r3 = t.O(e2, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
            return this.jumpTo(r3, i2);
          }
          this.stop(), e2 = t.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.cf }, e2);
          const r2 = this._getTransformForUpdate(), o2 = r2.bearing, a2 = r2.pitch, n2 = r2.roll, l3 = r2.padding, c2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, o2) : o2, h2 = "pitch" in e2 ? +e2.pitch : a2, u2 = "roll" in e2 ? this._normalizeBearing(e2.roll, n2) : n2, d2 = "padding" in e2 ? e2.padding : r2.padding, _2 = t.P.convert(e2.offset);
          let p2 = r2.centerPoint.add(_2);
          const m2 = r2.screenPointToLocation(p2), f2 = this.cameraHelper.handleFlyTo(r2, { bearing: c2, pitch: h2, roll: u2, padding: d2, locationAtOffset: m2, offsetAsPoint: _2, center: e2.center, minZoom: e2.minZoom, zoom: e2.zoom });
          let g2 = e2.curve;
          const v2 = Math.max(r2.width, r2.height), x2 = v2 / f2.scaleOfZoom, b2 = f2.pixelPathLength;
          typeof f2.scaleOfMinZoom == "number" && (g2 = Math.sqrt(v2 / f2.scaleOfMinZoom / b2 * 2));
          const y2 = g2 * g2;
          function w2(e3) {
            const t2 = (x2 * x2 - v2 * v2 + (e3 ? -1 : 1) * y2 * y2 * b2 * b2) / (2 * (e3 ? x2 : v2) * y2 * b2);
            return Math.log(Math.sqrt(t2 * t2 + 1) - t2);
          }
          function T2(e3) {
            return (Math.exp(e3) - Math.exp(-e3)) / 2;
          }
          function P2(e3) {
            return (Math.exp(e3) + Math.exp(-e3)) / 2;
          }
          const C2 = w2(false);
          let M3 = function(e3) {
            return P2(C2) / P2(C2 + g2 * e3);
          }, I2 = function(e3) {
            return v2 * ((P2(C2) * (T2(t2 = C2 + g2 * e3) / P2(t2)) - T2(C2)) / y2) / b2;
            var t2;
          }, E3 = (w2(true) - C2) / g2;
          if (Math.abs(b2) < 0.000002 || !isFinite(E3)) {
            if (Math.abs(v2 - x2) < 0.000001)
              return this.easeTo(e2, i2);
            const t2 = x2 < v2 ? -1 : 1;
            E3 = Math.abs(Math.log(x2 / v2)) / g2, I2 = () => 0, M3 = (e3) => Math.exp(t2 * g2 * e3);
          }
          return e2.duration = "duration" in e2 ? +e2.duration : 1000 * E3 / ("screenSpeed" in e2 ? +e2.screenSpeed / g2 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0), this._zooming = true, this._rotating = o2 !== c2, this._pitching = h2 !== a2, this._rolling = u2 !== n2, this._padding = !r2.isPaddingEqual(d2), this._prepareEase(i2, false), this.terrain && this._prepareElevation(f2.targetCenter), this._ease((s2) => {
            const m3 = s2 * E3, g3 = 1 / M3(m3), v3 = I2(m3);
            this._rotating && r2.setBearing(t.B.number(o2, c2, s2)), this._pitching && r2.setPitch(t.B.number(a2, h2, s2)), this._rolling && r2.setRoll(t.B.number(n2, u2, s2)), this._padding && (r2.interpolatePadding(l3, d2, s2), p2 = r2.centerPoint.add(_2)), f2.easeFunc(s2, g3, v3, p2), this.terrain && !e2.freezeElevation && this._updateElevation(s2), this._applyUpdatedTransform(r2), this._fireMoveEvents(i2);
          }, () => {
            this.terrain && e2.freezeElevation && this._finalizeElevation(), this._afterEase(i2);
          }, e2), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e2, t2) {
          var i2;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const e3 = this._onEaseEnd;
            delete this._onEaseEnd, e3.call(this, t2);
          }
          return e2 || (i2 = this.handlers) === null || i2 === undefined || i2.stop(false), this;
        }
        _ease(e2, t2, i2) {
          i2.animate === false || i2.duration === 0 ? (e2(1), t2()) : (this._easeStart = s.now(), this._easeOptions = i2, this._onEaseFrame = e2, this._onEaseEnd = t2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(e2, i2) {
          e2 = t.aL(e2, -180, 180);
          const r2 = Math.abs(e2 - i2);
          return Math.abs(e2 - 360 - i2) < r2 && (e2 -= 360), Math.abs(e2 + 360 - i2) < r2 && (e2 += 360), e2;
        }
        queryTerrainElevation(e2) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(t.Q.convert(e2), this.transform.tileZoom) : null;
        }
      }
      const Pa = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };

      class Ca {
        constructor(e2 = Pa) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (e3) => {
            !e3 || e3.sourceDataType !== "metadata" && e3.sourceDataType !== "visibility" && e3.dataType !== "style" && e3.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = e2;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e2) {
          return this._map = e2, this._compact = this.options.compact, this._container = n.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = n.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          n.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = undefined, this._compact = undefined, this._attribHTML = undefined;
        }
        _setElementTitle(e2, t2) {
          const i2 = this._map._getUIString(`AttributionControl.${t2}`);
          e2.title = i2, e2.setAttribute("aria-label", i2);
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let e2 = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = e2.concat(this.options.customAttribution.map((e3) => typeof e3 != "string" ? "" : e3)) : typeof this.options.customAttribution == "string" && e2.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const e3 = this._map.style.stylesheet;
            this.styleOwner = e3.owner, this.styleId = e3.id;
          }
          const t2 = this._map.style.sourceCaches;
          for (const i3 in t2) {
            const r2 = t2[i3];
            if (r2.used || r2.usedForTerrain) {
              const t3 = r2.getSource();
              t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
            }
          }
          e2 = e2.filter((e3) => String(e3).trim()), e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
            for (let r2 = i3 + 1;r2 < e2.length; r2++)
              if (e2[r2].indexOf(t3) >= 0)
                return false;
            return true;
          });
          const i2 = e2.join(" | ");
          i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = n.sanitize(i2), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }

      class Ma {
        constructor(e2 = {}) {
          this._updateCompact = () => {
            const e3 = this._container.children;
            if (e3.length) {
              const t2 = e3[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && t2.classList.add("maplibregl-compact") : t2.classList.remove("maplibregl-compact");
            }
          }, this.options = e2;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(e2) {
          this._map = e2, this._compact = this.options && this.options.compact, this._container = n.create("div", "maplibregl-ctrl");
          const t2 = n.create("a", "maplibregl-ctrl-logo");
          return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://maplibre.org/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          n.remove(this._container), this._map.off("resize", this._updateCompact), this._map = undefined, this._compact = undefined;
        }
      }

      class Ia {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(e2) {
          const t2 = ++this._id;
          return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
        }
        remove(e2) {
          const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
          for (const t3 of i2)
            if (t3.id === e2)
              return void (t3.cancelled = true);
        }
        run(e2 = 0) {
          if (this._currentlyRunning)
            throw new Error("Attempting to run(), but is already running.");
          const t2 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i2 of t2)
            if (!i2.cancelled && (i2.callback(e2), this._cleared))
              break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      var Ea = t.aG([{ name: "a_pos3d", type: "Int16", components: 3 }]);

      class Sa extends t.E {
        constructor(e2) {
          super(), this._lastTilesetChange = s.now(), this.sourceCache = e2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e2._source.tileSize * 2 ** this.deltaZoom, e2.usedForTerrain = true, e2.tileSize = this.tileSize;
        }
        destruct() {
          this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
        }
        update(e2, i2) {
          this.sourceCache.update(e2, i2), this._renderableTilesKeys = [];
          const r2 = {};
          for (const o2 of xe2(e2, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i2, calculateTileZoom: this.sourceCache._source.calculateTileZoom }))
            r2[o2.key] = true, this._renderableTilesKeys.push(o2.key), this._tiles[o2.key] || (o2.terrainRttPosMatrix32f = new Float64Array(16), t.bQ(o2.terrainRttPosMatrix32f, 0, t.Z, t.Z, 0, 0, 1), this._tiles[o2.key] = new ae(o2, this.tileSize), this._lastTilesetChange = s.now());
          for (const e3 in this._tiles)
            r2[e3] || delete this._tiles[e3];
        }
        freeRtt(e2) {
          for (const t2 in this._tiles) {
            const i2 = this._tiles[t2];
            (!e2 || i2.tileID.equals(e2) || i2.tileID.isChildOf(e2) || e2.isChildOf(i2.tileID)) && (i2.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((e2) => this.getTileByID(e2));
        }
        getTileByID(e2) {
          return this._tiles[e2];
        }
        getTerrainCoords(e2, t2) {
          return t2 ? this._getTerrainCoordsForTileRanges(e2, t2) : this._getTerrainCoordsForRegularTile(e2);
        }
        _getTerrainCoordsForRegularTile(e2) {
          const i2 = {};
          for (const r2 of this._renderableTilesKeys) {
            const o2 = this._tiles[r2].tileID, a2 = e2.clone(), s2 = t.b2();
            if (o2.canonical.equals(e2.canonical))
              t.bQ(s2, 0, t.Z, t.Z, 0, 0, 1);
            else if (o2.canonical.isChildOf(e2.canonical)) {
              const i3 = o2.canonical.z - e2.canonical.z, r3 = o2.canonical.x - (o2.canonical.x >> i3 << i3), a3 = o2.canonical.y - (o2.canonical.y >> i3 << i3), n2 = t.Z >> i3;
              t.bQ(s2, 0, n2, n2, 0, 0, 1), t.L(s2, s2, [-r3 * n2, -a3 * n2, 0]);
            } else {
              if (!e2.canonical.isChildOf(o2.canonical))
                continue;
              {
                const i3 = e2.canonical.z - o2.canonical.z, r3 = e2.canonical.x - (e2.canonical.x >> i3 << i3), a3 = e2.canonical.y - (e2.canonical.y >> i3 << i3), n2 = t.Z >> i3;
                t.bQ(s2, 0, t.Z, t.Z, 0, 0, 1), t.L(s2, s2, [r3 * n2, a3 * n2, 0]), t.M(s2, s2, [1 / 2 ** i3, 1 / 2 ** i3, 0]);
              }
            }
            a2.terrainRttPosMatrix32f = new Float32Array(s2), i2[r2] = a2;
          }
          return i2;
        }
        _getTerrainCoordsForTileRanges(e2, i2) {
          const r2 = {};
          for (const o2 of this._renderableTilesKeys) {
            const a2 = this._tiles[o2].tileID;
            if (!this._isWithinTileRanges(a2, i2))
              continue;
            const s2 = e2.clone(), n2 = t.b2();
            if (a2.canonical.z === e2.canonical.z) {
              const i3 = e2.canonical.x - a2.canonical.x, r3 = e2.canonical.y - a2.canonical.y;
              t.bQ(n2, 0, t.Z, t.Z, 0, 0, 1), t.L(n2, n2, [i3 * t.Z, r3 * t.Z, 0]);
            } else if (a2.canonical.z > e2.canonical.z) {
              const i3 = a2.canonical.z - e2.canonical.z, r3 = a2.canonical.x - (a2.canonical.x >> i3 << i3), o3 = a2.canonical.y - (a2.canonical.y >> i3 << i3), s3 = e2.canonical.x - (a2.canonical.x >> i3), l3 = e2.canonical.y - (a2.canonical.y >> i3), c2 = t.Z >> i3;
              t.bQ(n2, 0, c2, c2, 0, 0, 1), t.L(n2, n2, [-r3 * c2 + s3 * t.Z, -o3 * c2 + l3 * t.Z, 0]);
            } else {
              const i3 = e2.canonical.z - a2.canonical.z, r3 = e2.canonical.x - (e2.canonical.x >> i3 << i3), o3 = e2.canonical.y - (e2.canonical.y >> i3 << i3), s3 = (e2.canonical.x >> i3) - a2.canonical.x, l3 = (e2.canonical.y >> i3) - a2.canonical.y, c2 = t.Z << i3;
              t.bQ(n2, 0, c2, c2, 0, 0, 1), t.L(n2, n2, [r3 * t.Z + s3 * c2, o3 * t.Z + l3 * c2, 0]);
            }
            s2.terrainRttPosMatrix32f = new Float32Array(n2), r2[o2] = s2;
          }
          return r2;
        }
        getSourceTile(e2, t2) {
          const i2 = this.sourceCache._source;
          let r2 = e2.overscaledZ - this.deltaZoom;
          if (r2 > i2.maxzoom && (r2 = i2.maxzoom), r2 < i2.minzoom)
            return null;
          this._sourceTileCache[e2.key] || (this._sourceTileCache[e2.key] = e2.scaledTo(r2).key);
          let o2 = this.sourceCache.getTileByID(this._sourceTileCache[e2.key]);
          if ((!o2 || !o2.dem) && t2)
            for (;r2 >= i2.minzoom && (!o2 || !o2.dem); )
              o2 = this.sourceCache.getTileByID(e2.scaledTo(r2--).key);
          return o2;
        }
        anyTilesAfterTime(e2 = Date.now()) {
          return this._lastTilesetChange >= e2;
        }
        _isWithinTileRanges(e2, t2) {
          return t2[e2.canonical.z] && e2.canonical.x >= t2[e2.canonical.z].minTileX && e2.canonical.x <= t2[e2.canonical.z].maxTileX && e2.canonical.y >= t2[e2.canonical.z].minTileY && e2.canonical.y <= t2[e2.canonical.z].maxTileY;
        }
      }

      class Ra {
        constructor(e2, t2, i2) {
          this._meshCache = {}, this.painter = e2, this.sourceCache = new Sa(t2), this.options = i2, this.exaggeration = typeof i2.exaggeration == "number" ? i2.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(e2, i2, r2, o2 = t.Z) {
          var a2;
          if (!(i2 >= 0 && i2 < o2 && r2 >= 0 && r2 < o2))
            return 0;
          const s2 = this.getTerrainData(e2), n2 = (a2 = s2.tile) === null || a2 === undefined ? undefined : a2.dem;
          if (!n2)
            return 0;
          const l3 = t.cj([], [i2 / o2 * t.Z, r2 / o2 * t.Z], s2.u_terrain_matrix), c2 = [l3[0] * n2.dim, l3[1] * n2.dim], h2 = Math.floor(c2[0]), u2 = Math.floor(c2[1]), d2 = c2[0] - h2, _2 = c2[1] - u2;
          return n2.get(h2, u2) * (1 - d2) * (1 - _2) + n2.get(h2 + 1, u2) * d2 * (1 - _2) + n2.get(h2, u2 + 1) * (1 - d2) * _2 + n2.get(h2 + 1, u2 + 1) * d2 * _2;
        }
        getElevationForLngLatZoom(e2, i2) {
          if (!t.ck(i2, e2.wrap()))
            return 0;
          const { tileID: r2, mercatorX: o2, mercatorY: a2 } = this._getOverscaledTileIDFromLngLatZoom(e2, i2);
          return this.getElevation(r2, o2 % t.Z, a2 % t.Z, t.Z);
        }
        getElevation(e2, i2, r2, o2 = t.Z) {
          return this.getDEMElevation(e2, i2, r2, o2) * this.exaggeration;
        }
        getTerrainData(e2) {
          if (!this._emptyDemTexture) {
            const e3 = this.painter.context, i3 = new t.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new v(e3, i3, e3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new v(e3, new t.R({ width: 1, height: 1 }), e3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.ad([]);
          }
          const i2 = this.sourceCache.getSourceTile(e2, true);
          if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
            const e3 = this.painter.context;
            i2.demTexture = this.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: false }) : i2.demTexture = new v(e3, i2.dem.getPixels(), e3.gl.RGBA, { premultiply: false }), i2.demTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = false;
          }
          const r2 = i2 && i2 + i2.tileID.key + e2.key;
          if (r2 && !this._demMatrixCache[r2]) {
            const r3 = this.sourceCache.sourceCache._source.maxzoom;
            let o2 = e2.canonical.z - i2.tileID.canonical.z;
            e2.overscaledZ > e2.canonical.z && (e2.canonical.z >= r3 ? o2 = e2.canonical.z - r3 : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const a2 = e2.canonical.x - (e2.canonical.x >> o2 << o2), s2 = e2.canonical.y - (e2.canonical.y >> o2 << o2), n2 = t.cl(new Float64Array(16), [1 / (t.Z << o2), 1 / (t.Z << o2), 0]);
            t.L(n2, n2, [a2 * t.Z, s2 * t.Z, 0]), this._demMatrixCache[e2.key] = { matrix: n2, coord: e2 };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1, u_terrain_matrix: r2 ? this._demMatrixCache[e2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i2 && i2.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i2 };
        }
        getFramebuffer(e2) {
          const t2 = this.painter, i2 = t2.width / devicePixelRatio, r2 = t2.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === i2 && this._fbo.height === r2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new v(t2.context, { width: i2, height: r2, data: null }, t2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(t2.context.gl.NEAREST, t2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new v(t2.context, { width: i2, height: r2, data: null }, t2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(t2.context.gl.NEAREST, t2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = t2.context.createFramebuffer(i2, r2, true, false), this._fbo.depthAttachment.set(t2.context.createRenderbuffer(t2.context.gl.DEPTH_COMPONENT16, i2, r2))), this._fbo.colorAttachment.set(e2 === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const e2 = this.painter.context;
          if (this._coordsTexture)
            return this._coordsTexture;
          const i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let e3 = 0, t2 = 0;e3 < this._coordsTextureSize; e3++)
            for (let r3 = 0;r3 < this._coordsTextureSize; r3++, t2 += 4)
              i2[t2 + 0] = 255 & r3, i2[t2 + 1] = 255 & e3, i2[t2 + 2] = r3 >> 8 << 4 | e3 >> 8, i2[t2 + 3] = 0;
          const r2 = new t.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), o2 = new v(e2, r2, e2.gl.RGBA, { premultiply: false });
          return o2.bind(e2.gl.NEAREST, e2.gl.CLAMP_TO_EDGE), this._coordsTexture = o2, o2;
        }
        pointCoordinate(e2) {
          this.painter.maybeDrawDepthAndCoords(true);
          const i2 = new Uint8Array(4), r2 = this.painter.context, o2 = r2.gl, a2 = Math.round(e2.x * this.painter.pixelRatio / devicePixelRatio), s2 = Math.round(e2.y * this.painter.pixelRatio / devicePixelRatio), n2 = Math.round(this.painter.height / devicePixelRatio);
          r2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), o2.readPixels(a2, n2 - s2 - 1, 1, 1, o2.RGBA, o2.UNSIGNED_BYTE, i2), r2.bindFramebuffer.set(null);
          const l3 = i2[0] + (i2[2] >> 4 << 8), c2 = i2[1] + ((15 & i2[2]) << 8), h2 = this.coordsIndex[255 - i2[3]], u2 = h2 && this.sourceCache.getTileByID(h2);
          if (!u2)
            return null;
          const d2 = this._coordsTextureSize, _2 = (1 << u2.tileID.canonical.z) * d2;
          return new t.$((u2.tileID.canonical.x * d2 + l3) / _2 + u2.tileID.wrap, (u2.tileID.canonical.y * d2 + c2) / _2, this.getElevation(u2.tileID, l3, c2, d2));
        }
        depthAtPoint(e2) {
          const t2 = new Uint8Array(4), i2 = this.painter.context, r2 = i2.gl;
          return i2.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), r2.readPixels(e2.x, this.painter.height / devicePixelRatio - e2.y - 1, 1, 1, r2.RGBA, r2.UNSIGNED_BYTE, t2), i2.bindFramebuffer.set(null), (t2[0] / 16777216 + t2[1] / 65536 + t2[2] / 256 + t2[3]) / 256;
        }
        getTerrainMesh(e2) {
          var i2;
          const r2 = ((i2 = this.painter.style.projection) === null || i2 === undefined ? undefined : i2.transitionState) > 0, o2 = r2 && e2.canonical.y === 0, a2 = r2 && e2.canonical.y === (1 << e2.canonical.z) - 1, s2 = `m_${o2 ? "n" : ""}_${a2 ? "s" : ""}`;
          if (this._meshCache[s2])
            return this._meshCache[s2];
          const n2 = this.painter.context, l3 = new t.cm, c2 = new t.aK, h2 = this.meshSize, u2 = t.Z / h2, d2 = h2 * h2;
          for (let e3 = 0;e3 <= h2; e3++)
            for (let t2 = 0;t2 <= h2; t2++)
              l3.emplaceBack(t2 * u2, e3 * u2, 0);
          for (let e3 = 0;e3 < d2; e3 += h2 + 1)
            for (let t2 = 0;t2 < h2; t2++)
              c2.emplaceBack(t2 + e3, h2 + t2 + e3 + 1, h2 + t2 + e3 + 2), c2.emplaceBack(t2 + e3, h2 + t2 + e3 + 2, t2 + e3 + 1);
          const _2 = l3.length, p2 = _2 + (h2 + 1), m2 = (h2 + 1) * h2, f2 = o2 ? t.b9 : 0, g2 = o2 ? 0 : 1, v2 = a2 ? t.ba : t.Z, x2 = a2 ? 0 : 1;
          for (let e3 = 0;e3 <= h2; e3++)
            l3.emplaceBack(e3 * u2, f2, g2);
          for (let e3 = 0;e3 <= h2; e3++)
            l3.emplaceBack(e3 * u2, v2, x2);
          for (let e3 = 0;e3 < h2; e3++)
            c2.emplaceBack(m2 + e3, p2 + e3, p2 + e3 + 1), c2.emplaceBack(m2 + e3, p2 + e3 + 1, m2 + e3 + 1), c2.emplaceBack(0 + e3, _2 + e3 + 1, _2 + e3), c2.emplaceBack(0 + e3, 0 + e3 + 1, _2 + e3 + 1);
          const b2 = l3.length, y2 = b2 + 2 * (h2 + 1);
          for (const e3 of [0, 1])
            for (let i3 = 0;i3 <= h2; i3++)
              for (const r3 of [0, 1])
                l3.emplaceBack(e3 * t.Z, i3 * u2, r3);
          for (let e3 = 0;e3 < 2 * h2; e3 += 2)
            c2.emplaceBack(b2 + e3, b2 + e3 + 1, b2 + e3 + 3), c2.emplaceBack(b2 + e3, b2 + e3 + 3, b2 + e3 + 2), c2.emplaceBack(y2 + e3, y2 + e3 + 3, y2 + e3 + 1), c2.emplaceBack(y2 + e3, y2 + e3 + 2, y2 + e3 + 3);
          const w2 = new wt(n2.createVertexBuffer(l3, Ea.members), n2.createIndexBuffer(c2), t.aJ.simpleSegment(0, 0, l3.length, c2.length));
          return this._meshCache[s2] = w2, w2;
        }
        getMeshFrameDelta(e2) {
          return 2 * Math.PI * t.bu / Math.pow(2, Math.max(e2, 0)) / 5;
        }
        getMinTileElevationForLngLatZoom(e2, t2) {
          var i2;
          const { tileID: r2 } = this._getOverscaledTileIDFromLngLatZoom(e2, t2);
          return (i2 = this.getMinMaxElevation(r2).minElevation) !== null && i2 !== undefined ? i2 : 0;
        }
        getMinMaxElevation(e2) {
          const t2 = this.getTerrainData(e2).tile, i2 = { minElevation: null, maxElevation: null };
          return t2 && t2.dem && (i2.minElevation = t2.dem.min * this.exaggeration, i2.maxElevation = t2.dem.max * this.exaggeration), i2;
        }
        _getOverscaledTileIDFromLngLatZoom(e2, i2) {
          const r2 = t.$.fromLngLat(e2.wrap()), o2 = (1 << i2) * t.Z, a2 = r2.x * o2, s2 = r2.y * o2, n2 = Math.floor(a2 / t.Z), l3 = Math.floor(s2 / t.Z);
          return { tileID: new t.Y(i2, 0, i2, n2, l3), mercatorX: a2, mercatorY: s2 };
        }
      }

      class za {
        constructor(e2, t2, i2) {
          this._context = e2, this._size = t2, this._tileSize = i2, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const e2 of this._objects)
            e2.texture.destroy(), e2.fbo.destroy();
        }
        _createObject(e2) {
          const t2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i2 = new v(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return i2.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), t2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), t2.colorAttachment.set(i2.texture), { id: e2, fbo: t2, texture: i2, stamp: -1, inUse: false };
        }
        getObjectForId(e2) {
          return this._objects[e2];
        }
        useObject(e2) {
          e2.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((t2) => e2.id !== t2), this._recentlyUsed.push(e2.id);
        }
        stampObject(e2) {
          e2.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const e3 of this._recentlyUsed)
            if (!this._objects[e3].inUse)
              return this._objects[e3];
          if (this._objects.length >= this._size)
            throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const e2 = this._createObject(this._objects.length);
          return this._objects.push(e2), e2;
        }
        freeObject(e2) {
          e2.inUse = false;
        }
        freeAllObjects() {
          for (const e2 of this._objects)
            this.freeObject(e2);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((e2) => !e2.inUse) === false;
        }
      }
      const Da = { background: true, fill: true, line: true, raster: true, hillshade: true };

      class Aa {
        constructor(e2, t2) {
          this.painter = e2, this.terrain = t2, this.pool = new za(e2.context, 30, t2.sourceCache.tileSize * t2.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(e2) {
          return this.pool.getObjectForId(e2.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(e2, t2) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e2._order.filter((i2) => !e2._layers[i2].isHidden(t2)), this._coordsAscending = {};
          for (const t3 in e2.sourceCaches) {
            this._coordsAscending[t3] = {};
            const i2 = e2.sourceCaches[t3].getVisibleCoordinates(), r2 = e2.sourceCaches[t3].getSource(), o2 = r2 instanceof K ? r2.terrainTileRanges : null;
            for (const e3 of i2) {
              const i3 = this.terrain.sourceCache.getTerrainCoords(e3, o2);
              for (const e4 in i3)
                this._coordsAscending[t3][e4] || (this._coordsAscending[t3][e4] = []), this._coordsAscending[t3][e4].push(i3[e4]);
            }
          }
          this._coordsAscendingStr = {};
          for (const t3 of e2._order) {
            const i2 = e2._layers[t3], r2 = i2.source;
            if (Da[i2.type] && !this._coordsAscendingStr[r2]) {
              this._coordsAscendingStr[r2] = {};
              for (const e3 in this._coordsAscending[r2])
                this._coordsAscendingStr[r2][e3] = this._coordsAscending[r2][e3].map((e4) => e4.key).sort().join();
            }
          }
          for (const e3 of this._renderableTiles)
            for (const t3 in this._coordsAscendingStr) {
              const i2 = this._coordsAscendingStr[t3][e3.tileID.key];
              i2 && i2 !== e3.rttCoords[t3] && (e3.rtt = []);
            }
        }
        renderLayer(e2, i2) {
          if (e2.isHidden(this.painter.transform.zoom))
            return false;
          const r2 = Object.assign(Object.assign({}, i2), { isRenderingToTexture: true }), o2 = e2.type, a2 = this.painter, s2 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e2.id;
          if (Da[o2] && (this._prevType && Da[this._prevType] || this._stacks.push([]), this._prevType = o2, this._stacks[this._stacks.length - 1].push(e2.id), !s2))
            return true;
          if (Da[this._prevType] || Da[o2] && s2) {
            this._prevType = o2;
            const e3 = this._stacks.length - 1, i3 = this._stacks[e3] || [];
            for (const o3 of this._renderableTiles) {
              if (this.pool.isFull() && (yo2(this.painter, this.terrain, this._rttTiles, r2), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(o3), o3.rtt[e3]) {
                const t2 = this.pool.getObjectForId(o3.rtt[e3].id);
                if (t2.stamp === o3.rtt[e3].stamp) {
                  this.pool.useObject(t2);
                  continue;
                }
              }
              const s3 = this.pool.getOrCreateFreeObject();
              this.pool.useObject(s3), this.pool.stampObject(s3), o3.rtt[e3] = { id: s3.id, stamp: s3.stamp }, a2.context.bindFramebuffer.set(s3.fbo.framebuffer), a2.context.clear({ color: t.b7.transparent, stencil: 0 }), a2.currentStencilSource = undefined;
              for (let e4 = 0;e4 < i3.length; e4++) {
                const t2 = a2.style._layers[i3[e4]], n2 = t2.source ? this._coordsAscending[t2.source][o3.tileID.key] : [o3.tileID];
                a2.context.viewport.set([0, 0, s3.fbo.width, s3.fbo.height]), a2._renderTileClippingMasks(t2, n2, true), a2.renderLayer(a2, a2.style.sourceCaches[t2.source], t2, n2, r2), t2.source && (o3.rttCoords[t2.source] = this._coordsAscendingStr[t2.source][o3.tileID.key]);
              }
            }
            return yo2(this.painter, this.terrain, this._rttTiles, r2), this._rttTiles = [], this.pool.freeAllObjects(), Da[o2];
          }
          return false;
        }
      }
      const La = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, ka = i, Fa = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Pa, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: undefined }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true }, Ba = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };

      class Oa {
        constructor(e2, i2, r2 = false) {
          this.mousedown = (e3) => {
            this.startMove(e3, n.mousePos(this.element, e3)), n.addEventListener(window, "mousemove", this.mousemove), n.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (e3) => {
            this.move(e3, n.mousePos(this.element, e3));
          }, this.mouseup = (e3) => {
            this._rotatePitchHanlder.dragEnd(e3), this.offTemp();
          }, this.touchstart = (e3) => {
            e3.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = n.touchPos(this.element, e3.targetTouches)[0], this.startMove(e3, this._startPos), n.addEventListener(window, "touchmove", this.touchmove, { passive: false }), n.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (e3) => {
            e3.targetTouches.length !== 1 ? this.reset() : (this._lastPos = n.touchPos(this.element, e3.targetTouches)[0], this.move(e3, this._lastPos));
          }, this.touchend = (e3) => {
            e3.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10, this.element = i2;
          const o2 = new Ko2;
          this._rotatePitchHanlder = new Wo({ clickTolerance: 3, move: (e3, o3) => {
            const a2 = i2.getBoundingClientRect(), s2 = new t.P((a2.bottom - a2.top) / 2, (a2.right - a2.left) / 2);
            return { bearingDelta: t.ce(new t.P(e3.x, o3.y), o3, s2), pitchDelta: r2 ? -0.5 * (o3.y - e3.y) : undefined };
          }, moveStateManager: o2, enable: true, assignEvents: () => {
          } }), this.map = e2, n.addEventListener(i2, "mousedown", this.mousedown), n.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), n.addEventListener(i2, "touchcancel", this.reset);
        }
        startMove(e2, t2) {
          this._rotatePitchHanlder.dragStart(e2, t2), n.disableDrag();
        }
        move(e2, t2) {
          const i2 = this.map, { bearingDelta: r2, pitchDelta: o2 } = this._rotatePitchHanlder.dragMove(e2, t2) || {};
          r2 && i2.setBearing(i2.getBearing() + r2), o2 && i2.setPitch(i2.getPitch() + o2);
        }
        off() {
          const e2 = this.element;
          n.removeEventListener(e2, "mousedown", this.mousedown), n.removeEventListener(e2, "touchstart", this.touchstart, { passive: false }), n.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), n.removeEventListener(window, "touchend", this.touchend), n.removeEventListener(e2, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          n.enableDrag(), n.removeEventListener(window, "mousemove", this.mousemove), n.removeEventListener(window, "mouseup", this.mouseup), n.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), n.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let ja;
      function Za(e2, i2, r2, o2 = false) {
        if (o2 || !r2.getCoveringTilesDetailsProvider().allowWorldCopies())
          return e2 == null ? undefined : e2.wrap();
        const a2 = new t.Q(e2.lng, e2.lat);
        if (e2 = new t.Q(e2.lng, e2.lat), i2) {
          const o3 = new t.Q(e2.lng - 360, e2.lat), a3 = new t.Q(e2.lng + 360, e2.lat), s2 = r2.locationToScreenPoint(e2).distSqr(i2);
          r2.locationToScreenPoint(o3).distSqr(i2) < s2 ? e2 = o3 : r2.locationToScreenPoint(a3).distSqr(i2) < s2 && (e2 = a3);
        }
        for (;Math.abs(e2.lng - r2.center.lng) > 180; ) {
          const t2 = r2.locationToScreenPoint(e2);
          if (t2.x >= 0 && t2.y >= 0 && t2.x <= r2.width && t2.y <= r2.height)
            break;
          e2.lng > r2.center.lng ? e2.lng -= 360 : e2.lng += 360;
        }
        return e2.lng !== a2.lng && r2.isPointOnMapSurface(r2.locationToScreenPoint(e2)) ? e2 : a2;
      }
      const Na = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Ua(e2, t2, i2) {
        const r2 = e2.classList;
        for (const e3 in Na)
          r2.remove(`maplibregl-${i2}-anchor-${e3}`);
        r2.add(`maplibregl-${i2}-anchor-${t2}`);
      }

      class Ga extends t.E {
        constructor(e2) {
          if (super(), this._onKeyPress = (e3) => {
            const t2 = e3.code, i2 = e3.charCode || e3.keyCode;
            t2 !== "Space" && t2 !== "Enter" && i2 !== 32 && i2 !== 13 || this.togglePopup();
          }, this._onMapClick = (e3) => {
            const t2 = e3.originalEvent.target, i2 = this._element;
            this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
          }, this._update = (e3) => {
            if (!this._map)
              return;
            const t2 = this._map.loaded() && !this._map.isMoving();
            ((e3 == null ? undefined : e3.type) === "terrain" || (e3 == null ? undefined : e3.type) === "render" && !t2) && this._map.once("render", this._update), this._lngLat = Za(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
            let i2 = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? i2 = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (i2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let r2 = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? r2 = "rotateX(0deg)" : this._pitchAlignment === "map" && (r2 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e3 && e3.type !== "moveend" || (this._pos = this._pos.round()), n.setTransform(this._element, `${Na[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${r2} ${i2}`), s.frameAsync(new AbortController).then(() => {
              this._updateOpacity(e3 && e3.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (e3) => {
            if (!this._isDragging) {
              const t2 = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = e3.point.dist(this._pointerdownPos) >= t2;
            }
            this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new t.l("dragstart"))), this.fire(new t.l("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new t.l("dragend")), this._state = "inactive";
          }, this._addDragHandler = (e3) => {
            this._element.contains(e3.originalEvent.target) && (e3.preventDefault(), this._positionDelta = e3.point.sub(this._pos).add(this._offset), this._pointerdownPos = e3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = e2 && e2.anchor || "center", this._color = e2 && e2.color || "#3FB1CE", this._scale = e2 && e2.scale || 1, this._draggable = e2 && e2.draggable || false, this._clickTolerance = e2 && e2.clickTolerance || 0, this._subpixelPositioning = e2 && e2.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e2 && e2.rotation || 0, this._rotationAlignment = e2 && e2.rotationAlignment || "auto", this._pitchAlignment = e2 && e2.pitchAlignment && e2.pitchAlignment !== "auto" ? e2.pitchAlignment : this._rotationAlignment, this.setOpacity(e2 == null ? undefined : e2.opacity, e2 == null ? undefined : e2.opacityWhenCovered), e2 && e2.element)
            this._element = e2.element, this._offset = t.P.convert(e2 && e2.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = n.create("div");
            const i2 = n.createNS("http://www.w3.org/2000/svg", "svg"), r2 = 41, o2 = 27;
            i2.setAttributeNS(null, "display", "block"), i2.setAttributeNS(null, "height", `${r2}px`), i2.setAttributeNS(null, "width", `${o2}px`), i2.setAttributeNS(null, "viewBox", `0 0 ${o2} ${r2}`);
            const a2 = n.createNS("http://www.w3.org/2000/svg", "g");
            a2.setAttributeNS(null, "stroke", "none"), a2.setAttributeNS(null, "stroke-width", "1"), a2.setAttributeNS(null, "fill", "none"), a2.setAttributeNS(null, "fill-rule", "evenodd");
            const s2 = n.createNS("http://www.w3.org/2000/svg", "g");
            s2.setAttributeNS(null, "fill-rule", "nonzero");
            const l3 = n.createNS("http://www.w3.org/2000/svg", "g");
            l3.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l3.setAttributeNS(null, "fill", "#000000");
            const c2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const e3 of c2) {
              const t2 = n.createNS("http://www.w3.org/2000/svg", "ellipse");
              t2.setAttributeNS(null, "opacity", "0.04"), t2.setAttributeNS(null, "cx", "10.5"), t2.setAttributeNS(null, "cy", "5.80029008"), t2.setAttributeNS(null, "rx", e3.rx), t2.setAttributeNS(null, "ry", e3.ry), l3.appendChild(t2);
            }
            const h2 = n.createNS("http://www.w3.org/2000/svg", "g");
            h2.setAttributeNS(null, "fill", this._color);
            const u2 = n.createNS("http://www.w3.org/2000/svg", "path");
            u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h2.appendChild(u2);
            const d2 = n.createNS("http://www.w3.org/2000/svg", "g");
            d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
            const _2 = n.createNS("http://www.w3.org/2000/svg", "path");
            _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_2);
            const p2 = n.createNS("http://www.w3.org/2000/svg", "g");
            p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
            const m2 = n.createNS("http://www.w3.org/2000/svg", "g");
            m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const f2 = n.createNS("http://www.w3.org/2000/svg", "circle");
            f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
            const g2 = n.createNS("http://www.w3.org/2000/svg", "circle");
            g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g2), s2.appendChild(l3), s2.appendChild(h2), s2.appendChild(d2), s2.appendChild(p2), s2.appendChild(m2), i2.appendChild(s2), i2.setAttributeNS(null, "height", r2 * this._scale + "px"), i2.setAttributeNS(null, "width", o2 * this._scale + "px"), this._element.appendChild(i2), this._offset = t.P.convert(e2 && e2.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (e3) => {
            e3.preventDefault();
          }), this._element.addEventListener("mousedown", (e3) => {
            e3.preventDefault();
          }), Ua(this._element, this._anchor, "marker"), e2 && e2.className)
            for (const t2 of e2.className.split(" "))
              this._element.classList.add(t2);
          this._popup = null;
        }
        addTo(e2) {
          return this.remove(), this._map = e2, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e2._getUIString("Marker.Title")), e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._update), e2.on("moveend", this._update), e2.on("terrain", this._update), e2.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), n.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e2) {
          return this._lngLat = t.Q.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e2) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
            if (!("offset" in e2.options)) {
              const t2 = 38.1, i2 = 13.5, r2 = Math.abs(i2) / Math.SQRT2;
              e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [r2, -1 * (t2 - i2 + r2)], "bottom-right": [-r2, -1 * (t2 - i2 + r2)], left: [i2, -1 * (t2 - i2)], right: [-13.5, -1 * (t2 - i2)] } : this._offset;
            }
            this._popup = e2, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(e2) {
          return this._subpixelPositioning = e2, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e2 = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : e2 ? (e2.isOpen() ? e2.remove() : (e2.setLngLat(this._lngLat), e2.addTo(this._map)), this) : this;
        }
        _updateOpacity(e2 = false) {
          var i2, r2;
          const o2 = (i2 = this._map) === null || i2 === undefined ? undefined : i2.terrain, a2 = this._map.transform.isLocationOccluded(this._lngLat);
          if (!o2 || a2) {
            const e3 = a2 ? this._opacityWhenCovered : this._opacity;
            return void (this._element.style.opacity !== e3 && (this._element.style.opacity = e3));
          }
          if (e2)
            this._opacityTimeout = null;
          else {
            if (this._opacityTimeout)
              return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const s2 = this._map, n2 = s2.terrain.depthAtPoint(this._pos), l3 = s2.terrain.getElevationForLngLatZoom(this._lngLat, s2.transform.tileZoom);
          if (s2.transform.lngLatToCameraDepth(this._lngLat, l3) - n2 < 0.006)
            return void (this._element.style.opacity = this._opacity);
          const c2 = -this._offset.y / s2.transform.pixelsPerMeter, h2 = Math.sin(s2.getPitch() * Math.PI / 180) * c2, u2 = s2.terrain.depthAtPoint(new t.P(this._pos.x, this._pos.y - this._offset.y)), d2 = s2.transform.lngLatToCameraDepth(this._lngLat, l3 + h2) - u2 > 0.006;
          ((r2 = this._popup) === null || r2 === undefined ? undefined : r2.isOpen()) && d2 && this._popup.remove(), this._element.style.opacity = d2 ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(e2) {
          return this._offset = t.P.convert(e2), this._update(), this;
        }
        addClassName(e2) {
          this._element.classList.add(e2);
        }
        removeClassName(e2) {
          this._element.classList.remove(e2);
        }
        toggleClassName(e2) {
          return this._element.classList.toggle(e2);
        }
        setDraggable(e2) {
          return this._draggable = !!e2, this._map && (e2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e2) {
          return this._rotation = e2 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e2) {
          return this._rotationAlignment = e2 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(e2) {
          return this._pitchAlignment = e2 && e2 !== "auto" ? e2 : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(e2, t2) {
          return (this._opacity === undefined || e2 === undefined && t2 === undefined) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e2 !== undefined && (this._opacity = e2), t2 !== undefined && (this._opacityWhenCovered = t2), this._map && this._updateOpacity(true), this;
        }
      }
      const Va = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6000 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
      let qa = 0, Wa = false;
      const Ha = { maxWidth: 100, unit: "metric" };
      function $a(e2, t2, i2) {
        const r2 = i2 && i2.maxWidth || 100, o2 = e2._container.clientHeight / 2, a2 = e2._container.clientWidth / 2, s2 = e2.unproject([a2 - r2 / 2, o2]), n2 = e2.unproject([a2 + r2 / 2, o2]), l3 = Math.round(e2.project(n2).x - e2.project(s2).x), c2 = Math.min(r2, l3, e2._container.clientWidth), h2 = s2.distanceTo(n2);
        if (i2 && i2.unit === "imperial") {
          const i3 = 3.2808 * h2;
          i3 > 5280 ? Xa(t2, c2, i3 / 5280, e2._getUIString("ScaleControl.Miles")) : Xa(t2, c2, i3, e2._getUIString("ScaleControl.Feet"));
        } else
          i2 && i2.unit === "nautical" ? Xa(t2, c2, h2 / 1852, e2._getUIString("ScaleControl.NauticalMiles")) : h2 >= 1000 ? Xa(t2, c2, h2 / 1000, e2._getUIString("ScaleControl.Kilometers")) : Xa(t2, c2, h2, e2._getUIString("ScaleControl.Meters"));
      }
      function Xa(e2, t2, i2, r2) {
        const o2 = function(e3) {
          const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
          let i3 = e3 / t3;
          return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
            const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
            return Math.round(e4 * t4) / t4;
          }(i3), t3 * i3;
        }(i2);
        e2.style.width = t2 * (o2 / i2) + "px", e2.innerHTML = `${o2}&nbsp;${r2}`;
      }
      const Ka = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: undefined }, Qa = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function Ya(e2) {
        if (e2) {
          if (typeof e2 == "number") {
            const i2 = Math.round(Math.abs(e2) / Math.SQRT2);
            return { center: new t.P(0, 0), top: new t.P(0, e2), "top-left": new t.P(i2, i2), "top-right": new t.P(-i2, i2), bottom: new t.P(0, -e2), "bottom-left": new t.P(i2, -i2), "bottom-right": new t.P(-i2, -i2), left: new t.P(e2, 0), right: new t.P(-e2, 0) };
          }
          if (e2 instanceof t.P || Array.isArray(e2)) {
            const i2 = t.P.convert(e2);
            return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
          }
          return { center: t.P.convert(e2.center || [0, 0]), top: t.P.convert(e2.top || [0, 0]), "top-left": t.P.convert(e2["top-left"] || [0, 0]), "top-right": t.P.convert(e2["top-right"] || [0, 0]), bottom: t.P.convert(e2.bottom || [0, 0]), "bottom-left": t.P.convert(e2["bottom-left"] || [0, 0]), "bottom-right": t.P.convert(e2["bottom-right"] || [0, 0]), left: t.P.convert(e2.left || [0, 0]), right: t.P.convert(e2.right || [0, 0]) };
        }
        return Ya(new t.P(0, 0));
      }
      const Ja = i;
      e.AJAXError = t.cq, e.Event = t.l, e.Evented = t.E, e.LngLat = t.Q, e.MercatorCoordinate = t.$, e.Point = t.P, e.addProtocol = t.cr, e.config = t.a, e.removeProtocol = t.cs, e.AttributionControl = Ca, e.BoxZoomHandler = No2, e.CanvasSource = Y2, e.CooperativeGesturesHandler = va, e.DoubleClickZoomHandler = da, e.DragPanHandler = ma, e.DragRotateHandler = fa, e.EdgeInsets = It2, e.FullscreenControl = class extends t.E {
        constructor(e2 = {}) {
          super(), this._onFullscreenChange = () => {
            var e3;
            let t2 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (;(e3 = t2 == null ? undefined : t2.shadowRoot) === null || e3 === undefined ? undefined : e3.fullscreenElement; )
              t2 = t2.shadowRoot.fullscreenElement;
            t2 === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = false, e2 && e2.container && (e2.container instanceof HTMLElement ? this._container = e2.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : ("onmozfullscreenchange" in document) ? this._fullscreenchange = "mozfullscreenchange" : ("onwebkitfullscreenchange" in document) ? this._fullscreenchange = "webkitfullscreenchange" : ("onmsfullscreenchange" in document) && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(e2) {
          return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          n.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const e2 = this._fullscreenButton = n.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          n.create("span", "maplibregl-ctrl-icon", e2).setAttribute("aria-hidden", "true"), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const e2 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.title = e2;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, e.GeoJSONSource = X, e.GeolocateControl = class extends t.E {
        constructor(e2) {
          super(), this._onSuccess = (e3) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(e3))
                return this._setErrorState(), this.fire(new t.l("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = e3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e3), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.l("geolocate", e3)), this._finish();
            }
          }, this._updateCamera = (e3) => {
            const i2 = new t.Q(e3.coords.longitude, e3.coords.latitude), r2 = e3.coords.accuracy, o2 = this._map.getBearing(), a2 = t.e({ bearing: o2 }, this.options.fitBoundsOptions), s2 = V.fromLngLat(i2, r2);
            this._map.fitBounds(s2, a2, { geolocateSource: true });
          }, this._updateMarker = (e3) => {
            if (e3) {
              const i2 = new t.Q(e3.coords.longitude, e3.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (e3) => {
            if (this._map) {
              if (e3.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4), this._geolocationWatchID !== undefined && this._clearWatch();
              } else {
                if (e3.code === 3 && Wa)
                  return;
                this.options.trackUserLocation && this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.l("error", e3)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = undefined;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this._geolocateButton = n.create("button", "maplibregl-ctrl-geolocate", this._container), n.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
          }, this._finishSetupUI = (e3) => {
            if (this._map) {
              if (e3 === false) {
                t.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
              } else {
                const e4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = false, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ga({ element: this._dotElement }), this._circleElement = n.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ga({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e4) => {
                e4.geolocateSource || this._watchState !== "ACTIVE_LOCK" || e4.originalEvent && e4.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.l("trackuserlocationend")), this.fire(new t.l("userlocationlostfocus")));
              });
            }
          }, this.options = t.e({}, Va, e2);
        }
        onAdd(e2) {
          return this._map = e2, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return t._(this, arguments, undefined, function* (e3 = false) {
              if (ja !== undefined && !e3)
                return ja;
              if (window.navigator.permissions === undefined)
                return ja = !!window.navigator.geolocation, ja;
              try {
                const e4 = yield window.navigator.permissions.query({ name: "geolocation" });
                ja = e4.state !== "denied";
              } catch (e4) {
                ja = !!window.navigator.geolocation;
              }
              return ja;
            });
          }().then((e3) => this._finishSetupUI(e3)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== undefined && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = undefined), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), n.remove(this._container), this._map.off("zoom", this._onZoom), this._map = undefined, qa = 0, Wa = false;
        }
        _isOutOfMapMaxBounds(e2) {
          const t2 = this._map.getMaxBounds(), i2 = e2.coords;
          return t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const e2 = this._map.getBounds(), t2 = e2.getSouthEast(), i2 = e2.getNorthEast(), r2 = t2.distanceTo(i2), o2 = Math.ceil(this._accuracy / (r2 / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
        }
        trigger() {
          if (!this._setup)
            return t.w("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new t.l("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                qa--, Wa = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.l("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.l("trackuserlocationstart")), this.fire(new t.l("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== undefined)
              this._clearWatch();
            else if (this._geolocationWatchID === undefined) {
              let e2;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), qa++, qa > 1 ? (e2 = { maximumAge: 600000, timeout: 0 }, Wa = true) : (e2 = this.options.positionOptions, Wa = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e2);
            }
          } else
            window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = undefined, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, e.GlobeControl = class {
        constructor() {
          this._toggleProjection = () => {
            var e2;
            const t2 = (e2 = this._map.getProjection()) === null || e2 === undefined ? undefined : e2.type;
            this._map.setProjection(t2 !== "mercator" && t2 ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
          }, this._updateGlobeIcon = () => {
            var e2;
            this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((e2 = this._map.getProjection()) === null || e2 === undefined ? undefined : e2.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
          };
        }
        onAdd(e2) {
          return this._map = e2, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = n.create("button", "maplibregl-ctrl-globe", this._container), n.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
        }
        onRemove() {
          n.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = undefined;
        }
      }, e.Hash = Co2, e.ImageSource = K, e.KeyboardHandler = la, e.LngLatBounds = V, e.LogoControl = Ma, e.Map = class extends Ta {
        constructor(e2) {
          var i2, r2;
          t.cn.mark(t.co.create);
          const o2 = Object.assign(Object.assign(Object.assign({}, Fa), e2), { canvasContextAttributes: Object.assign(Object.assign({}, Fa.canvasContextAttributes), e2.canvasContextAttributes) });
          if (o2.minZoom != null && o2.maxZoom != null && o2.minZoom > o2.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (o2.minPitch != null && o2.maxPitch != null && o2.minPitch > o2.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (o2.minPitch != null && o2.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (o2.maxPitch != null && o2.maxPitch > 180)
            throw new Error("maxPitch must be less than or equal to 180");
          const a2 = new Lt2, s2 = new Ot2;
          if (o2.minZoom !== undefined && a2.setMinZoom(o2.minZoom), o2.maxZoom !== undefined && a2.setMaxZoom(o2.maxZoom), o2.minPitch !== undefined && a2.setMinPitch(o2.minPitch), o2.maxPitch !== undefined && a2.setMaxPitch(o2.maxPitch), o2.renderWorldCopies !== undefined && a2.setRenderWorldCopies(o2.renderWorldCopies), super(a2, s2, { bearingSnap: o2.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Ia, this._controls = [], this._mapId = t.a4(), this._contextLost = (e3) => {
            e3.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new t.l("webglcontextlost", { originalEvent: e3 }));
          }, this._contextRestored = (e3) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new t.l("webglcontextrestored", { originalEvent: e3 }));
          }, this._onMapScroll = (e3) => {
            if (e3.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = o2.interactive, this._maxTileCacheSize = o2.maxTileCacheSize, this._maxTileCacheZoomLevels = o2.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o2.canvasContextAttributes), this._trackResize = o2.trackResize === true, this._bearingSnap = o2.bearingSnap, this._centerClampedToGround = o2.centerClampedToGround, this._refreshExpiredTiles = o2.refreshExpiredTiles === true, this._fadeDuration = o2.fadeDuration, this._crossSourceCollisions = o2.crossSourceCollisions === true, this._collectResourceTiming = o2.collectResourceTiming === true, this._locale = Object.assign(Object.assign({}, La), o2.locale), this._clickTolerance = o2.clickTolerance, this._overridePixelRatio = o2.pixelRatio, this._maxCanvasSize = o2.maxCanvasSize, this.transformCameraUpdate = o2.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = o2.cancelPendingTileRequestsWhileZooming === true, this._imageQueueHandle = p.addThrottleControl(() => this.isMoving()), this._requestManager = new m(o2.transformRequest), typeof o2.container == "string") {
            if (this._container = document.getElementById(o2.container), !this._container)
              throw new Error(`Container '${o2.container}' not found.`);
          } else {
            if (!(o2.container instanceof HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = o2.container;
          }
          if (o2.maxBounds && this.setMaxBounds(o2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
            this.painter.terrainFacilitator.dirty = true, this._update(true);
          }), this.once("idle", () => {
            this._idleTriggered = true;
          }), typeof window != "undefined") {
            addEventListener("online", this._onWindowOnline, false);
            let e3 = false;
            const t2 = Po2((e4) => {
              this._trackResize && !this._removed && (this.resize(e4), this.redraw());
            }, 50);
            this._resizeObserver = new ResizeObserver((i3) => {
              e3 ? t2(i3) : e3 = true;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new wa(this, o2), this._hash = o2.hash && new Co2(typeof o2.hash == "string" && o2.hash || undefined).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: o2.center, elevation: o2.elevation, zoom: o2.zoom, bearing: o2.bearing, pitch: o2.pitch, roll: o2.roll }), o2.bounds && (this.resize(), this.fitBounds(o2.bounds, t.e({}, o2.fitBoundsOptions, { duration: 0 }))));
          const n2 = typeof o2.style == "string" || !(((r2 = (i2 = o2.style) === null || i2 === undefined ? undefined : i2.projection) === null || r2 === undefined ? undefined : r2.type) === "globe");
          this.resize(null, n2), this._localIdeographFontFamily = o2.localIdeographFontFamily, this._validateStyle = o2.validateStyle, o2.style && this.setStyle(o2.style, { localIdeographFontFamily: o2.localIdeographFontFamily }), o2.attributionControl && this.addControl(new Ca(typeof o2.attributionControl == "boolean" ? undefined : o2.attributionControl)), o2.maplibreLogo && this.addControl(new Ma, o2.logoPosition), this.on("style.load", () => {
            if (n2 || this._resizeTransform(), this.transform.unmodified) {
              const e3 = t.O(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
              this.jumpTo(e3);
            }
          }), this.on("data", (e3) => {
            this._update(e3.dataType === "style"), this.fire(new t.l(`${e3.dataType}data`, e3));
          }), this.on("dataloading", (e3) => {
            this.fire(new t.l(`${e3.dataType}dataloading`, e3));
          }), this.on("dataabort", (e3) => {
            this.fire(new t.l("sourcedataabort", e3));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(e2, i2) {
          if (i2 === undefined && (i2 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd)
            return this.fire(new t.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const r2 = e2.onAdd(this);
          this._controls.push(e2);
          const o2 = this._controlPositions[i2];
          return i2.indexOf("bottom") !== -1 ? o2.insertBefore(r2, o2.firstChild) : o2.appendChild(r2), this;
        }
        removeControl(e2) {
          if (!e2 || !e2.onRemove)
            return this.fire(new t.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i2 = this._controls.indexOf(e2);
          return i2 > -1 && this._controls.splice(i2, 1), e2.onRemove(this), this;
        }
        hasControl(e2) {
          return this._controls.indexOf(e2) > -1;
        }
        calculateCameraOptionsFromTo(e2, t2, i2, r2) {
          return r2 == null && this.terrain && (r2 = this.terrain.getElevationForLngLatZoom(i2, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e2, t2, i2, r2);
        }
        resize(e2, i2 = true) {
          const [r2, o2] = this._containerDimensions(), a2 = this._getClampedPixelRatio(r2, o2);
          if (this._resizeCanvas(r2, o2, a2), this.painter.resize(r2, o2, a2), this.painter.overLimit()) {
            const e3 = this.painter.context.gl;
            this._maxCanvasSize = [e3.drawingBufferWidth, e3.drawingBufferHeight];
            const t2 = this._getClampedPixelRatio(r2, o2);
            this._resizeCanvas(r2, o2, t2), this.painter.resize(r2, o2, t2);
          }
          this._resizeTransform(i2);
          const s2 = !this._moving;
          return s2 && (this.stop(), this.fire(new t.l("movestart", e2)).fire(new t.l("move", e2))), this.fire(new t.l("resize", e2)), s2 && this.fire(new t.l("moveend", e2)), this;
        }
        _resizeTransform(e2 = true) {
          var t2;
          const [i2, r2] = this._containerDimensions();
          this.transform.resize(i2, r2, e2), (t2 = this._requestedCameraState) === null || t2 === undefined || t2.resize(i2, r2, e2);
        }
        _getClampedPixelRatio(e2, t2) {
          const { 0: i2, 1: r2 } = this._maxCanvasSize, o2 = this.getPixelRatio(), a2 = e2 * o2, s2 = t2 * o2;
          return Math.min(a2 > i2 ? i2 / a2 : 1, s2 > r2 ? r2 / s2 : 1) * o2;
        }
        getPixelRatio() {
          var e2;
          return (e2 = this._overridePixelRatio) !== null && e2 !== undefined ? e2 : devicePixelRatio;
        }
        setPixelRatio(e2) {
          this._overridePixelRatio = e2, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(e2) {
          return this.transform.setMaxBounds(V.convert(e2)), this._update();
        }
        setMinZoom(e2) {
          if ((e2 = e2 == null ? -2 : e2) >= -2 && e2 <= this.transform.maxZoom)
            return this.transform.setMinZoom(e2), this._update(), this.getZoom() < e2 && this.setZoom(e2), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(e2) {
          if ((e2 = e2 == null ? 22 : e2) >= this.transform.minZoom)
            return this.transform.setMaxZoom(e2), this._update(), this.getZoom() > e2 && this.setZoom(e2), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(e2) {
          if ((e2 = e2 == null ? 0 : e2) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (e2 >= 0 && e2 <= this.transform.maxPitch)
            return this.transform.setMinPitch(e2), this._update(), this.getPitch() < e2 && this.setPitch(e2), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(e2) {
          if ((e2 = e2 == null ? 60 : e2) > 180)
            throw new Error("maxPitch must be less than or equal to 180");
          if (e2 >= this.transform.minPitch)
            return this.transform.setMaxPitch(e2), this._update(), this.getPitch() > e2 && this.setPitch(e2), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e2) {
          return this.transform.setRenderWorldCopies(e2), this._update();
        }
        project(e2) {
          return this.transform.locationToScreenPoint(t.Q.convert(e2), this.style && this.terrain);
        }
        unproject(e2) {
          return this.transform.screenPointToLocation(t.P.convert(e2), this.terrain);
        }
        isMoving() {
          var e2;
          return this._moving || ((e2 = this.handlers) === null || e2 === undefined ? undefined : e2.isMoving());
        }
        isZooming() {
          var e2;
          return this._zooming || ((e2 = this.handlers) === null || e2 === undefined ? undefined : e2.isZooming());
        }
        isRotating() {
          var e2;
          return this._rotating || ((e2 = this.handlers) === null || e2 === undefined ? undefined : e2.isRotating());
        }
        _createDelegatedListener(e2, t2, i2) {
          if (e2 === "mouseenter" || e2 === "mouseover") {
            let r2 = false;
            const o2 = (o3) => {
              const a2 = t2.filter((e3) => this.getLayer(e3)), s2 = a2.length !== 0 ? this.queryRenderedFeatures(o3.point, { layers: a2 }) : [];
              s2.length ? r2 || (r2 = true, i2.call(this, new ko2(e2, this, o3.originalEvent, { features: s2 }))) : r2 = false;
            };
            return { layers: t2, listener: i2, delegates: { mousemove: o2, mouseout: () => {
              r2 = false;
            } } };
          }
          if (e2 === "mouseleave" || e2 === "mouseout") {
            let r2 = false;
            const o2 = (o3) => {
              const a3 = t2.filter((e3) => this.getLayer(e3));
              (a3.length !== 0 ? this.queryRenderedFeatures(o3.point, { layers: a3 }) : []).length ? r2 = true : r2 && (r2 = false, i2.call(this, new ko2(e2, this, o3.originalEvent)));
            }, a2 = (t3) => {
              r2 && (r2 = false, i2.call(this, new ko2(e2, this, t3.originalEvent)));
            };
            return { layers: t2, listener: i2, delegates: { mousemove: o2, mouseout: a2 } };
          }
          {
            const r2 = (e3) => {
              const r3 = t2.filter((e4) => this.getLayer(e4)), o2 = r3.length !== 0 ? this.queryRenderedFeatures(e3.point, { layers: r3 }) : [];
              o2.length && (e3.features = o2, i2.call(this, e3), delete e3.features);
            };
            return { layers: t2, listener: i2, delegates: { [e2]: r2 } };
          }
        }
        _saveDelegatedListener(e2, t2) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(t2);
        }
        _removeDelegatedListener(e2, t2, i2) {
          if (!this._delegatedListeners || !this._delegatedListeners[e2])
            return;
          const r2 = this._delegatedListeners[e2];
          for (let e3 = 0;e3 < r2.length; e3++) {
            const o2 = r2[e3];
            if (o2.listener === i2 && o2.layers.length === t2.length && o2.layers.every((e4) => t2.includes(e4))) {
              for (const e4 in o2.delegates)
                this.off(e4, o2.delegates[e4]);
              return void r2.splice(e3, 1);
            }
          }
        }
        on(e2, t2, i2) {
          if (i2 === undefined)
            return super.on(e2, t2);
          const r2 = typeof t2 == "string" ? [t2] : t2, o2 = this._createDelegatedListener(e2, r2, i2);
          this._saveDelegatedListener(e2, o2);
          for (const e3 in o2.delegates)
            this.on(e3, o2.delegates[e3]);
          return { unsubscribe: () => {
            this._removeDelegatedListener(e2, r2, i2);
          } };
        }
        once(e2, t2, i2) {
          if (i2 === undefined)
            return super.once(e2, t2);
          const r2 = typeof t2 == "string" ? [t2] : t2, o2 = this._createDelegatedListener(e2, r2, i2);
          for (const t3 in o2.delegates) {
            const a2 = o2.delegates[t3];
            o2.delegates[t3] = (...t4) => {
              this._removeDelegatedListener(e2, r2, i2), a2(...t4);
            };
          }
          this._saveDelegatedListener(e2, o2);
          for (const e3 in o2.delegates)
            this.once(e3, o2.delegates[e3]);
          return this;
        }
        off(e2, t2, i2) {
          return i2 === undefined ? super.off(e2, t2) : (this._removeDelegatedListener(e2, typeof t2 == "string" ? [t2] : t2, i2), this);
        }
        queryRenderedFeatures(e2, i2) {
          if (!this.style)
            return [];
          let r2;
          const o2 = e2 instanceof t.P || Array.isArray(e2), a2 = o2 ? e2 : [[0, 0], [this.transform.width, this.transform.height]];
          if (i2 = i2 || (o2 ? {} : e2) || {}, a2 instanceof t.P || typeof a2[0] == "number")
            r2 = [t.P.convert(a2)];
          else {
            const e3 = t.P.convert(a2[0]), i3 = t.P.convert(a2[1]);
            r2 = [e3, new t.P(i3.x, e3.y), i3, new t.P(e3.x, i3.y), e3];
          }
          return this.style.queryRenderedFeatures(r2, i2, this.transform);
        }
        querySourceFeatures(e2, t2) {
          return this.style.querySourceFeatures(e2, t2);
        }
        setStyle(e2, i2) {
          return (i2 = t.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i2)).diff !== false && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e2, i2));
        }
        setTransformRequest(e2) {
          return this._requestManager.setTransformRequest(e2), this;
        }
        _getUIString(e2) {
          const t2 = this._locale[e2];
          if (t2 == null)
            throw new Error(`Missing UI string '${e2}'`);
          return t2;
        }
        _updateStyle(e2, t2) {
          var i2, r2;
          if (t2.transformStyle && this.style && !this.style._loaded)
            return void this.style.once("style.load", () => this._updateStyle(e2, t2));
          const o2 = this.style && t2.transformStyle ? this.style.serialize() : undefined;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!e2)), e2 ? (this.style = new bi2(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), typeof e2 == "string" ? this.style.loadURL(e2, t2, o2) : this.style.loadJSON(e2, t2, o2), this) : ((r2 = (i2 = this.style) === null || i2 === undefined ? undefined : i2.projection) === null || r2 === undefined || r2.destroy(), delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new bi2(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(e2, i2) {
          if (typeof e2 == "string") {
            const r2 = this._requestManager.transformRequest(e2, "Style");
            t.j(r2, new AbortController).then((e3) => {
              this._updateDiff(e3.data, i2);
            }).catch((e3) => {
              e3 && this.fire(new t.k(e3));
            });
          } else
            typeof e2 == "object" && this._updateDiff(e2, i2);
        }
        _updateDiff(e2, i2) {
          try {
            this.style.setState(e2, i2) && this._update(true);
          } catch (r2) {
            t.w(`Unable to perform style diff: ${r2.message || r2.error || r2}.  Rebuilding the style from scratch.`), this._updateStyle(e2, i2);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : t.w("There is no style added to the map.");
        }
        addSource(e2, t2) {
          return this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true);
        }
        isSourceLoaded(e2) {
          const i2 = this.style && this.style.sourceCaches[e2];
          if (i2 !== undefined)
            return i2.loaded();
          this.fire(new t.k(new Error(`There is no source with ID '${e2}'`)));
        }
        setTerrain(e2) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e2) {
            const i2 = this.style.sourceCaches[e2.source];
            if (!i2)
              throw new Error(`cannot load terrain, because there exists no source with ID: ${e2.source}`);
            this.terrain === null && i2.reload();
            for (const i3 in this.style._layers) {
              const r2 = this.style._layers[i3];
              r2.type === "hillshade" && r2.source === e2.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new Ra(this.painter, i2, e2), this.painter.renderToTexture = new Aa(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t2) => {
              var i3;
              t2.dataType === "style" ? this.terrain.sourceCache.freeRtt() : t2.dataType === "source" && t2.tile && (t2.sourceId !== e2.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((i3 = t2.source) === null || i3 === undefined ? undefined : i3.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(t2.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else
            this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
          return this.fire(new t.l("terrain", { terrain: e2 })), this;
        }
        getTerrain() {
          var e2, t2;
          return (t2 = (e2 = this.terrain) === null || e2 === undefined ? undefined : e2.options) !== null && t2 !== undefined ? t2 : null;
        }
        areTilesLoaded() {
          const e2 = this.style && this.style.sourceCaches;
          for (const t2 in e2) {
            const i2 = e2[t2]._tiles;
            for (const e3 in i2) {
              const t3 = i2[e3];
              if (t3.state !== "loaded" && t3.state !== "errored")
                return false;
            }
          }
          return true;
        }
        removeSource(e2) {
          return this.style.removeSource(e2), this._update(true);
        }
        getSource(e2) {
          return this.style.getSource(e2);
        }
        setSourceTileLodParams(e2, t2, i2) {
          if (i2) {
            const r2 = this.getSource(i2);
            if (!r2)
              throw new Error(`There is no source with ID "${i2}", cannot set LOD parameters`);
            r2.calculateTileZoom = fe2(Math.max(1, e2), Math.max(1, t2));
          } else
            for (const i3 in this.style.sourceCaches)
              this.style.sourceCaches[i3].getSource().calculateTileZoom = fe2(Math.max(1, e2), Math.max(1, t2));
          return this._update(true), this;
        }
        refreshTiles(e2, i2) {
          const r2 = this.style.sourceCaches[e2];
          if (!r2)
            throw new Error(`There is no source cache with ID "${e2}", cannot refresh tile`);
          i2 === undefined ? r2.reload() : r2.refreshTiles(i2.map((e3) => new t.a1(e3.z, e3.x, e3.y)));
        }
        addImage(e2, i2, r2 = {}) {
          const { pixelRatio: o2 = 1, sdf: a2 = false, stretchX: n2, stretchY: l3, content: c2, textFitWidth: h2, textFitHeight: u2 } = r2;
          if (this._lazyInitEmptyStyle(), !(i2 instanceof HTMLImageElement || t.b(i2))) {
            if (i2.width === undefined || i2.height === undefined)
              return this.fire(new t.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: r3, height: s2, data: d2 } = i2, _2 = i2;
              return this.style.addImage(e2, { data: new t.R({ width: r3, height: s2 }, new Uint8Array(d2)), pixelRatio: o2, stretchX: n2, stretchY: l3, content: c2, textFitWidth: h2, textFitHeight: u2, sdf: a2, version: 0, userImage: _2 }), _2.onAdd && _2.onAdd(this, e2), this;
            }
          }
          {
            const { width: r3, height: d2, data: _2 } = s.getImageData(i2);
            this.style.addImage(e2, { data: new t.R({ width: r3, height: d2 }, _2), pixelRatio: o2, stretchX: n2, stretchY: l3, content: c2, textFitWidth: h2, textFitHeight: u2, sdf: a2, version: 0 });
          }
        }
        updateImage(e2, i2) {
          const r2 = this.style.getImage(e2);
          if (!r2)
            return this.fire(new t.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const o2 = i2 instanceof HTMLImageElement || t.b(i2) ? s.getImageData(i2) : i2, { width: a2, height: n2, data: l3 } = o2;
          if (a2 === undefined || n2 === undefined)
            return this.fire(new t.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (a2 !== r2.data.width || n2 !== r2.data.height)
            return this.fire(new t.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const c2 = !(i2 instanceof HTMLImageElement || t.b(i2));
          return r2.data.replace(l3, c2), this.style.updateImage(e2, r2), this;
        }
        getImage(e2) {
          return this.style.getImage(e2);
        }
        hasImage(e2) {
          return e2 ? !!this.style.getImage(e2) : (this.fire(new t.k(new Error("Missing required image id"))), false);
        }
        removeImage(e2) {
          this.style.removeImage(e2);
        }
        loadImage(e2) {
          return p.getImage(this._requestManager.transformRequest(e2, "Image"), new AbortController);
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(e2, t2) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true);
        }
        moveLayer(e2, t2) {
          return this.style.moveLayer(e2, t2), this._update(true);
        }
        removeLayer(e2) {
          return this.style.removeLayer(e2), this._update(true);
        }
        getLayer(e2) {
          return this.style.getLayer(e2);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(e2, t2, i2) {
          return this.style.setLayerZoomRange(e2, t2, i2), this._update(true);
        }
        setFilter(e2, t2, i2 = {}) {
          return this.style.setFilter(e2, t2, i2), this._update(true);
        }
        getFilter(e2) {
          return this.style.getFilter(e2);
        }
        setPaintProperty(e2, t2, i2, r2 = {}) {
          return this.style.setPaintProperty(e2, t2, i2, r2), this._update(true);
        }
        getPaintProperty(e2, t2) {
          return this.style.getPaintProperty(e2, t2);
        }
        setLayoutProperty(e2, t2, i2, r2 = {}) {
          return this.style.setLayoutProperty(e2, t2, i2, r2), this._update(true);
        }
        getLayoutProperty(e2, t2) {
          return this.style.getLayoutProperty(e2, t2);
        }
        setGlyphs(e2, t2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(e2, t2), this._update(true);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(e2, t2, i2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(e2, t2, i2, (e3) => {
            e3 || this._update(true);
          }), this;
        }
        removeSprite(e2) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(e2), this._update(true);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(e2, t2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(e2, t2, (e3) => {
            e3 || this._update(true);
          }), this;
        }
        setLight(e2, t2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(e2, t2), this._update(true);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(e2, t2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSky(e2, t2), this._update(true);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(e2, t2) {
          return this.style.setFeatureState(e2, t2), this._update();
        }
        removeFeatureState(e2, t2) {
          return this.style.removeFeatureState(e2, t2), this._update();
        }
        getFeatureState(e2) {
          return this.style.getFeatureState(e2);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let e2 = 0, t2 = 0;
          return this._container && (e2 = this._container.clientWidth || 400, t2 = this._container.clientHeight || 300), [e2, t2];
        }
        _setupContainer() {
          const e2 = this._container;
          e2.classList.add("maplibregl-map");
          const t2 = this._canvasContainer = n.create("div", "maplibregl-canvas-container", e2);
          this._interactive && t2.classList.add("maplibregl-interactive"), this._canvas = n.create("canvas", "maplibregl-canvas", t2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const i2 = this._containerDimensions(), r2 = this._getClampedPixelRatio(i2[0], i2[1]);
          this._resizeCanvas(i2[0], i2[1], r2);
          const o2 = this._controlContainer = n.create("div", "maplibregl-control-container", e2), a2 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
            a2[e3] = n.create("div", `maplibregl-ctrl-${e3} `, o2);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(e2, t2, i2) {
          this._canvas.width = Math.floor(i2 * e2), this._canvas.height = Math.floor(i2 * t2), this._canvas.style.width = `${e2}px`, this._canvas.style.height = `${t2}px`;
        }
        _setupPainter() {
          const e2 = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
          let t2 = null;
          this._canvas.addEventListener("webglcontextcreationerror", (i3) => {
            t2 = { requestedAttributes: e2 }, i3 && (t2.statusMessage = i3.statusMessage, t2.type = i3.type);
          }, { once: true });
          let i2 = null;
          if (i2 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e2) : this._canvas.getContext("webgl2", e2) || this._canvas.getContext("webgl", e2), !i2) {
            const e3 = "Failed to initialize WebGL";
            throw t2 ? (t2.message = e3, new Error(JSON.stringify(t2))) : new Error(e3);
          }
          this.painter = new To2(i2, this.transform), l2.testSupport(i2);
        }
        migrateProjection(e2, i2) {
          super.migrateProjection(e2, i2), this.painter.transform = e2, this.fire(new t.l("projectiontransition", { newProjection: this.style.projection.name }));
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(e2) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e2) {
          return this._update(), this._renderTaskQueue.add(e2);
        }
        _cancelRenderFrame(e2) {
          this._renderTaskQueue.remove(e2);
        }
        _render(e2) {
          var i2, r2, o2, a2, n2;
          const l3 = this._idleTriggered ? this._fadeDuration : 0, c2 = ((i2 = this.style.projection) === null || i2 === undefined ? undefined : i2.transitionState) > 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), this._removed)
            return;
          let h2 = false;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const e3 = this.transform.zoom, i3 = s.now();
            this.style.zoomHistory.update(e3, i3);
            const r3 = new t.C(e3, { now: i3, fadeDuration: l3, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), o3 = r3.crossFadingFactor();
            o3 === 1 && o3 === this._crossFadingFactor || (h2 = true, this._crossFadingFactor = o3), this.style.update(r3);
          }
          const u2 = ((r2 = this.style.projection) === null || r2 === undefined ? undefined : r2.transitionState) > 0 !== c2;
          (o2 = this.style.projection) === null || o2 === undefined || o2.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((a2 = this.style.projection) === null || a2 === undefined ? undefined : a2.transitionState, (n2 = this.style.projection) === null || n2 === undefined ? undefined : n2.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u2) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, l3, this._crossSourceCollisions, u2), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: l3, showPadding: this.showPadding }), this.fire(new t.l("render")), this.loaded() && !this._loaded && (this._loaded = true, t.cn.mark(t.co.load), this.fire(new t.l("load"))), this.style && (this.style.hasTransitions() || h2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const d2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return d2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.l("idle")), !this._loaded || this._fullyLoaded || d2 || (this._fullyLoaded = true, t.cn.mark(t.co.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var e2;
          this._hash && this._hash.remove();
          for (const e3 of this._controls)
            e3.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window != "undefined" && removeEventListener("online", this._onWindowOnline, false), p.removeThrottleControl(this._imageQueueHandle), (e2 = this._resizeObserver) === null || e2 === undefined || e2.disconnect();
          const i2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          (i2 == null ? undefined : i2.loseContext) && i2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), n.remove(this._canvasContainer), n.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), t.cn.clearMetrics(), this._removed = true, this.fire(new t.l("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController, s.frame(this._frameRequest, (e2) => {
            t.cn.frame(e2), this._frameRequest = null;
            try {
              this._render(e2);
            } catch (e3) {
              if (!t.cp(e3) && !function(e4) {
                return e4.message === Ur2;
              }(e3))
                throw e3;
            }
          }, () => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e2) {
          this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e2) {
          this._showPadding !== e2 && (this._showPadding = e2, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e2) {
          this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e2) {
          this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e2) {
          this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e2) {
          this._vertices = e2, this._update();
        }
        get version() {
          return ka;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
        getProjection() {
          return this.style.getProjection();
        }
        setProjection(e2) {
          return this._lazyInitEmptyStyle(), this.style.setProjection(e2), this._update(true);
        }
      }, e.MapMouseEvent = ko2, e.MapTouchEvent = Fo2, e.MapWheelEvent = Bo2, e.Marker = Ga, e.NavigationControl = class {
        constructor(e2) {
          this._updateZoomButtons = () => {
            const e3 = this._map.getZoom(), t2 = e3 === this._map.getMaxZoom(), i2 = e3 === this._map.getMinZoom();
            this._zoomInButton.disabled = t2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", t2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
          }, this._rotateCompassArrow = () => {
            this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
          }, this._setButtonTitle = (e3, t2) => {
            const i2 = this._map._getUIString(`NavigationControl.${t2}`);
            e3.title = i2, e3.setAttribute("aria-label", i2);
          }, this.options = t.e({}, Ba, e2), this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e3) => this._map.zoomIn({}, { originalEvent: e3 })), n.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e3) => this._map.zoomOut({}, { originalEvent: e3 })), n.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e3) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e3 }) : this._map.resetNorth({}, { originalEvent: e3 });
          }), this._compassIcon = n.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(e2) {
          return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Oa(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          n.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(e2, t2) {
          const i2 = n.create("button", e2, this._container);
          return i2.type = "button", i2.addEventListener("click", t2), i2;
        }
      }, e.Popup = class extends t.E {
        constructor(e2) {
          super(), this._updateOpacity = () => {
            this.options.locationOccludedOpacity !== undefined && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : undefined);
          }, this.remove = () => (this._content && n.remove(this._content), this._container && (n.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t.l("close"))), this), this._onMouseUp = (e3) => {
            this._update(e3.point);
          }, this._onMouseMove = (e3) => {
            this._update(e3.point);
          }, this._onDrag = (e3) => {
            this._update(e3.point);
          }, this._update = (e3) => {
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
              return;
            if (!this._container) {
              if (this._container = n.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = n.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                for (const e4 of this.options.className.split(" "))
                  this._container.classList.add(e4);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Za(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e3)
              return;
            const t2 = this._flatPos = this._pos = this._trackPointer && e3 ? e3 : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && e3 ? e3 : this._map.transform.locationToScreenPoint(this._lngLat));
            let i2 = this.options.anchor;
            const r2 = Ya(this.options.offset);
            if (!i2) {
              const e4 = this._container.offsetWidth, o3 = this._container.offsetHeight;
              let a2;
              a2 = t2.y + r2.bottom.y < o3 ? ["top"] : t2.y > this._map.transform.height - o3 ? ["bottom"] : [], t2.x < e4 / 2 ? a2.push("left") : t2.x > this._map.transform.width - e4 / 2 && a2.push("right"), i2 = a2.length === 0 ? "bottom" : a2.join("-");
            }
            let o2 = t2.add(r2[i2]);
            this.options.subpixelPositioning || (o2 = o2.round()), n.setTransform(this._container, `${Na[i2]} translate(${o2.x}px,${o2.y}px)`), Ua(this._container, i2, "popup"), this._updateOpacity();
          }, this._onClose = () => {
            this.remove();
          }, this.options = t.e(Object.create(Ka), e2);
        }
        addTo(e2) {
          return this._map && this.remove(), this._map = e2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.l("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e2) {
          return this._lngLat = t.Q.convert(e2), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(e2) {
          return this.setDOMContent(document.createTextNode(e2));
        }
        setHTML(e2) {
          const t2 = document.createDocumentFragment(), i2 = document.createElement("body");
          let r2;
          for (i2.innerHTML = e2;r2 = i2.firstChild, r2; )
            t2.appendChild(r2);
          return this.setDOMContent(t2);
        }
        getMaxWidth() {
          var e2;
          return (e2 = this._container) === null || e2 === undefined ? undefined : e2.style.maxWidth;
        }
        setMaxWidth(e2) {
          return this.options.maxWidth = e2, this._update(), this;
        }
        setDOMContent(e2) {
          if (this._content)
            for (;this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = n.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(e2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(e2) {
          return this._container && this._container.classList.add(e2), this;
        }
        removeClassName(e2) {
          return this._container && this._container.classList.remove(e2), this;
        }
        setOffset(e2) {
          return this.options.offset = e2, this._update(), this;
        }
        toggleClassName(e2) {
          if (this._container)
            return this._container.classList.toggle(e2);
        }
        setSubpixelPositioning(e2) {
          this.options.subpixelPositioning = e2;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = n.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const e2 = this._container.querySelector(Qa);
          e2 && e2.focus();
        }
      }, e.RasterDEMTileSource = $2, e.RasterTileSource = H, e.ScaleControl = class {
        constructor(e2) {
          this._onMove = () => {
            $a(this._map, this._container, this.options);
          }, this.setUnit = (e3) => {
            this.options.unit = e3, $a(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, Ha), e2);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(e2) {
          return this._map = e2, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          n.remove(this._container), this._map.off("move", this._onMove), this._map = undefined;
        }
      }, e.ScrollZoomHandler = ua, e.Style = bi2, e.TerrainControl = class {
        constructor(e2) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = e2;
        }
        onAdd(e2) {
          return this._map = e2, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = n.create("button", "maplibregl-ctrl-terrain", this._container), n.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          n.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = undefined;
        }
      }, e.TwoFingersTouchPitchHandler = sa, e.TwoFingersTouchRotateHandler = oa, e.TwoFingersTouchZoomHandler = ia, e.TwoFingersTouchZoomRotateHandler = ga, e.VectorTileSource = W2, e.VideoSource = Q2, e.addSourceType = (e2, i2) => t._(undefined, undefined, undefined, function* () {
        if (ee2(e2))
          throw new Error(`A source type called "${e2}" already exists.`);
        ((e3, t2) => {
          J2[e3] = t2;
        })(e2, i2);
      }), e.clearPrewarmedResources = function() {
        const e2 = L;
        e2 && (e2.isPreloaded() && e2.numActive() === 1 ? (e2.release(z2), L = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, e.createTileMesh = Xt2, e.getMaxParallelImageRequests = function() {
        return t.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, e.getRTLTextPluginStatus = function() {
        return oe().getRTLTextPluginStatus();
      }, e.getVersion = function() {
        return Ja;
      }, e.getWorkerCount = function() {
        return D2.workerCount;
      }, e.getWorkerUrl = function() {
        return t.a.WORKER_URL;
      }, e.importScriptInWorkers = function(e2) {
        return O().broadcast("IS", e2);
      }, e.prewarm = function() {
        F2().acquire(z2);
      }, e.setMaxParallelImageRequests = function(e2) {
        t.a.MAX_PARALLEL_IMAGE_REQUESTS = e2;
      }, e.setRTLTextPlugin = function(e2, t2) {
        return oe().setRTLTextPlugin(e2, t2);
      }, e.setWorkerCount = function(e2) {
        D2.workerCount = e2;
      }, e.setWorkerUrl = function(e2) {
        t.a.WORKER_URL = e2;
      };
    });
    var maplibregl$1 = maplibregl;
    return maplibregl$1;
  });
});

// ../../lib/ima.js
function useTags() {
  const is_static = typeof window === "undefined";
  return is_static ? new Proxy({}, { get: static_tag_generator }) : new Proxy({}, { get: tag_generator });
}
if (typeof window === "undefined") {
  global.document = {
    createElement: () => ({}),
    createTextNode: () => ({}),
    createComment: () => ({})
  };
  console.warn("Trying to use client-side tags on server.");
}
var tag_generator = (_, name) => (...args) => {
  let props_obj = {};
  let children = args;
  if (args.length > 0) {
    const first_arg = args[0];
    if (typeof first_arg === "string" || typeof first_arg === "number" || first_arg instanceof HTMLElement || typeof first_arg === "function") {
      children = args;
    } else if (Object.getPrototypeOf(first_arg ?? 0) === Object.prototype) {
      const [props_arg, ...rest_args] = args;
      const { is, ...rest_props } = props_arg;
      props_obj = rest_props;
      children = rest_args;
    }
  }
  const element = document.createElement(name);
  for (const [attr_key, value] of Object.entries(props_obj)) {
    if (attr_key.startsWith("on") && typeof value === "function") {
      const event_name = attr_key.substring(2).toLowerCase();
      element.addEventListener(event_name, value);
      continue;
    }
    if (typeof value === "function" && !attr_key.startsWith("on")) {
      setup_reactive_attr(element, attr_key, value);
      continue;
    }
    if (value === true) {
      element.setAttribute(attr_key, "");
    } else if (value !== false && value != null) {
      element.setAttribute(attr_key, String(value));
    }
  }
  for (const child of children.flat(Infinity)) {
    if (child != null) {
      if (child instanceof Node) {
        element.appendChild(child);
      } else if (typeof child === "function") {
        const reactive_node = setup_reactive_node(child);
        element.appendChild(reactive_node);
      } else {
        element.appendChild(document.createTextNode(String(child)));
      }
    }
  }
  return element;
};
var tags = new Proxy({}, { get: tag_generator });
var reactive_markers = [];
var reactive_callbacks = [];
var reactive_prev_values = [];
var reactive_count = { value: 0 };
var reactive_attr_elements = [];
var reactive_attr_names = [];
var reactive_attr_callbacks = [];
var reactive_attr_prev_values = [];
var reactive_attr_count = { value: 0 };
var animation_frame_requested = false;
var frame_time = 0;
function update_reactive_components() {
  animation_frame_requested = false;
  const start_time = performance.now();
  for (let i = 0;i < reactive_attr_count.value; i++) {
    const element = reactive_attr_elements[i];
    const attr_name = reactive_attr_names[i];
    const callback = reactive_attr_callbacks[i];
    if (!element.isConnected)
      continue;
    const new_value = callback();
    if (new_value !== reactive_attr_prev_values[i]) {
      if (new_value === true) {
        element.setAttribute(attr_name, "");
      } else if (new_value === false || new_value == null) {
        element.removeAttribute(attr_name);
      } else {
        element.setAttribute(attr_name, String(new_value));
      }
      reactive_attr_prev_values[i] = new_value;
    }
  }
  for (let i = 0;i < reactive_count.value; i++) {
    const marker = reactive_markers[i];
    const callback = reactive_callbacks[i];
    if (!marker.isConnected)
      continue;
    const new_value = callback();
    const current_node = marker.previousSibling;
    if (!current_node)
      continue;
    let needs_update = false;
    if (new_value instanceof Node) {
      if (current_node instanceof HTMLElement && new_value instanceof HTMLElement) {
        if (current_node.outerHTML !== new_value.outerHTML) {
          needs_update = true;
        }
      } else {
        needs_update = true;
      }
    } else {
      const new_text = String(new_value ?? "");
      if (current_node.nodeType === Node.TEXT_NODE) {
        needs_update = current_node.textContent !== new_text;
      } else {
        needs_update = true;
      }
    }
    if (needs_update) {
      let new_node;
      if (new_value instanceof Node) {
        new_node = new_value;
      } else {
        new_node = document.createTextNode(String(new_value ?? ""));
      }
      current_node.replaceWith(new_node);
    }
  }
  frame_time = performance.now() - start_time;
  if (reactive_count.value > 0 || reactive_attr_count.value > 0) {
    animation_frame();
  }
}
function animation_frame() {
  if (!animation_frame_requested && (reactive_count.value > 0 || reactive_attr_count.value > 0)) {
    animation_frame_requested = true;
    requestAnimationFrame(update_reactive_components);
  }
}
function setup_reactive_node(callback) {
  const node_index = reactive_count.value++;
  const marker = document.createComment(`reactive-${node_index}`);
  const initial_value = callback();
  let initial_node;
  if (initial_value instanceof Node) {
    initial_node = initial_value;
  } else {
    initial_node = document.createTextNode(String(initial_value ?? ""));
  }
  const fragment = document.createDocumentFragment();
  fragment.appendChild(initial_node);
  fragment.appendChild(marker);
  reactive_markers[node_index] = marker;
  reactive_callbacks[node_index] = callback;
  reactive_prev_values[node_index] = initial_node;
  animation_frame();
  return fragment;
}
function setup_reactive_attr(element, attr_name, callback) {
  const attr_index = reactive_attr_count.value++;
  const initial_value = callback();
  if (initial_value === true) {
    element.setAttribute(attr_name, "");
  } else if (initial_value !== false && initial_value != null) {
    element.setAttribute(attr_name, String(initial_value));
  }
  reactive_attr_elements[attr_index] = element;
  reactive_attr_names[attr_index] = attr_name;
  reactive_attr_callbacks[attr_index] = callback;
  reactive_attr_prev_values[attr_index] = initial_value;
  animation_frame();
}
var static_tag_generator = (_, name) => (...args) => {
  let props_obj = {};
  let children = args;
  if (args.length > 0) {
    const first_arg = args[0];
    if (typeof first_arg === "string" || typeof first_arg === "number" || typeof first_arg === "function") {
      children = args;
    } else if (Object.getPrototypeOf(first_arg ?? 0) === Object.prototype) {
      const [props_arg, ...rest_args] = args;
      const { is, ...rest_props } = props_arg;
      props_obj = rest_props;
      children = rest_args;
    }
  }
  let html = `<${name}`;
  for (const [key, value] of Object.entries(props_obj)) {
    if (key.startsWith("on") || typeof value === "function") {
      continue;
    }
    const attr_key = key === "className" ? "class" : key;
    if (value === true) {
      html += ` ${attr_key}`;
    } else if (value !== false && value != null) {
      const escaped_value = String(value).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      html += ` ${attr_key}="${escaped_value}"`;
    }
  }
  const void_elements = new Set([
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  if (void_elements.has(name)) {
    return html + "/>";
  }
  html += ">";
  for (const child of children.flat(Infinity)) {
    if (child != null) {
      if (typeof child === "function") {
        html += String(child());
      } else {
        html += String(child);
      }
    }
  }
  return html + `</${name}>`;
};
var staticTags = new Proxy({}, { get: static_tag_generator });

// ../../lib/utils.js
function GlobalStyleSheet(styles) {
  const sheet = createStylesheet("global_styles");
  const cleaned_css = styles.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\s+/g, " ").trim();
  let rules = [];
  let current_rule = "";
  let brace_count = 0;
  for (let i = 0;i < cleaned_css.length; i++) {
    const char = cleaned_css[i];
    current_rule += char;
    if (char === "{") {
      brace_count++;
    } else if (char === "}") {
      brace_count--;
      if (brace_count === 0) {
        rules.push(current_rule.trim());
        current_rule = "";
      }
    }
  }
  for (const rule of rules) {
    try {
      sheet.insertRule(rule, sheet.cssRules.length);
    } catch (error) {
      console.error(`Failed to insert CSS rule: ${rule}`, error);
    }
  }
}
function createStylesheet(id) {
  let sheet = document.adoptedStyleSheets.find((sheet2) => sheet2.id === id);
  if (!sheet) {
    sheet = new CSSStyleSheet;
    sheet.id = id;
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];
  }
  return sheet;
}
function finish(time = 0) {
  return new Promise((resolve) => setTimeout(resolve, time));
}
function css(strings, ...values) {
  return strings.reduce((result, str, i) => result + str + (i < values.length ? values[i] : ""), "");
}

// ../../lib/tw.js
var qt = "4.1.7";
var Pe = 92;
var Be = 47;
var qe = 42;
var Po = 34;
var Oo = 39;
var _o = 58;
var He = 59;
var ie = 10;
var Ge = 13;
var Oe = 32;
var Ye = 9;
var Ht = 123;
var bt = 125;
var At = 40;
var Gt = 41;
var zo = 91;
var Ko = 93;
var Yt = 45;
var yt = 64;
var Uo = 33;
function $e(t, r) {
  let o = r?.from ? { file: r.from, code: t } : null;
  t[0] === "\uFEFF" && (t = " " + t.slice(1));
  let e = [], i = [], s = [], a = null, f = null, u = "", c = "", g = 0, d;
  for (let m = 0;m < t.length; m++) {
    let v = t.charCodeAt(m);
    if (!(v === Ge && (d = t.charCodeAt(m + 1), d === ie)))
      if (v === Pe)
        u === "" && (g = m), u += t.slice(m, m + 2), m += 1;
      else if (v === Be && t.charCodeAt(m + 1) === qe) {
        let k = m;
        for (let y = m + 2;y < t.length; y++)
          if (d = t.charCodeAt(y), d === Pe)
            y += 1;
          else if (d === qe && t.charCodeAt(y + 1) === Be) {
            m = y + 1;
            break;
          }
        let x = t.slice(k, m + 1);
        if (x.charCodeAt(2) === Uo) {
          let y = Je(x.slice(2, -2));
          i.push(y), o && (y.src = [o, k, m + 1], y.dst = [o, k, m + 1]);
        }
      } else if (v === Oo || v === Po) {
        let k = m;
        for (let x = m + 1;x < t.length; x++)
          if (d = t.charCodeAt(x), d === Pe)
            x += 1;
          else if (d === v) {
            m = x;
            break;
          } else {
            if (d === He && (t.charCodeAt(x + 1) === ie || t.charCodeAt(x + 1) === Ge && t.charCodeAt(x + 2) === ie))
              throw new Error(`Unterminated string: ${t.slice(k, x + 1) + String.fromCharCode(v)}`);
            if (d === ie || d === Ge && t.charCodeAt(x + 1) === ie)
              throw new Error(`Unterminated string: ${t.slice(k, x) + String.fromCharCode(v)}`);
          }
        u += t.slice(k, m + 1);
      } else {
        if ((v === Oe || v === ie || v === Ye) && (d = t.charCodeAt(m + 1)) && (d === Oe || d === ie || d === Ye || d === Ge && (d = t.charCodeAt(m + 2)) && d == ie))
          continue;
        if (v === ie) {
          if (u.length === 0)
            continue;
          d = u.charCodeAt(u.length - 1), d !== Oe && d !== ie && d !== Ye && (u += " ");
        } else if (v === Yt && t.charCodeAt(m + 1) === Yt && u.length === 0) {
          let k = "", x = m, y = -1;
          for (let b = m + 2;b < t.length; b++)
            if (d = t.charCodeAt(b), d === Pe)
              b += 1;
            else if (d === Be && t.charCodeAt(b + 1) === qe) {
              for (let V = b + 2;V < t.length; V++)
                if (d = t.charCodeAt(V), d === Pe)
                  V += 1;
                else if (d === qe && t.charCodeAt(V + 1) === Be) {
                  b = V + 1;
                  break;
                }
            } else if (y === -1 && d === _o)
              y = u.length + b - x;
            else if (d === He && k.length === 0) {
              u += t.slice(x, b), m = b;
              break;
            } else if (d === At)
              k += ")";
            else if (d === zo)
              k += "]";
            else if (d === Ht)
              k += "}";
            else if ((d === bt || t.length - 1 === b) && k.length === 0) {
              m = b - 1, u += t.slice(x, b);
              break;
            } else
              (d === Gt || d === Ko || d === bt) && k.length > 0 && t[b] === k[k.length - 1] && (k = k.slice(0, -1));
          let N = xt(u, y);
          if (!N)
            throw new Error("Invalid custom property, expected a value");
          o && (N.src = [o, x, m], N.dst = [o, x, m]), a ? a.nodes.push(N) : e.push(N), u = "";
        } else if (v === He && u.charCodeAt(0) === yt)
          f = _e(u), o && (f.src = [o, g, m], f.dst = [o, g, m]), a ? a.nodes.push(f) : e.push(f), u = "", f = null;
        else if (v === He && c[c.length - 1] !== ")") {
          let k = xt(u);
          if (!k)
            throw u.length === 0 ? new Error("Unexpected semicolon") : new Error(`Invalid declaration: \`${u.trim()}\``);
          o && (k.src = [o, g, m], k.dst = [o, g, m]), a ? a.nodes.push(k) : e.push(k), u = "";
        } else if (v === Ht && c[c.length - 1] !== ")")
          c += "}", f = G(u.trim()), o && (f.src = [o, g, m], f.dst = [o, g, m]), a && a.nodes.push(f), s.push(a), a = f, u = "", f = null;
        else if (v === bt && c[c.length - 1] !== ")") {
          if (c === "")
            throw new Error("Missing opening {");
          if (c = c.slice(0, -1), u.length > 0)
            if (u.charCodeAt(0) === yt)
              f = _e(u), o && (f.src = [o, g, m], f.dst = [o, g, m]), a ? a.nodes.push(f) : e.push(f), u = "", f = null;
            else {
              let x = u.indexOf(":");
              if (a) {
                let y = xt(u, x);
                if (!y)
                  throw new Error(`Invalid declaration: \`${u.trim()}\``);
                o && (y.src = [o, g, m], y.dst = [o, g, m]), a.nodes.push(y);
              }
            }
          let k = s.pop() ?? null;
          k === null && a && e.push(a), a = k, u = "", f = null;
        } else if (v === At)
          c += ")", u += "(";
        else if (v === Gt) {
          if (c[c.length - 1] !== ")")
            throw new Error("Missing opening (");
          c = c.slice(0, -1), u += ")";
        } else {
          if (u.length === 0 && (v === Oe || v === ie || v === Ye))
            continue;
          u === "" && (g = m), u += String.fromCharCode(v);
        }
      }
  }
  if (u.charCodeAt(0) === yt) {
    let m = _e(u);
    o && (m.src = [o, g, t.length], m.dst = [o, g, t.length]), e.push(m);
  }
  if (c.length > 0 && a) {
    if (a.kind === "rule")
      throw new Error(`Missing closing } at ${a.selector}`);
    if (a.kind === "at-rule")
      throw new Error(`Missing closing } at ${a.name} ${a.params}`);
  }
  return i.length > 0 ? i.concat(e) : e;
}
function _e(t, r = []) {
  let o = t, e = "";
  for (let i = 5;i < t.length; i++) {
    let s = t.charCodeAt(i);
    if (s === Oe || s === At) {
      o = t.slice(0, i), e = t.slice(i);
      break;
    }
  }
  return F(o.trim(), e.trim(), r);
}
function xt(t, r = t.indexOf(":")) {
  if (r === -1)
    return null;
  let o = t.indexOf("!important", r + 1);
  return l(t.slice(0, r).trim(), t.slice(r + 1, o === -1 ? t.length : o).trim(), o !== -1);
}
function me(t) {
  if (arguments.length === 0)
    throw new TypeError("`CSS.escape` requires an argument.");
  let r = String(t), o = r.length, e = -1, i, s = "", a = r.charCodeAt(0);
  if (o === 1 && a === 45)
    return "\\" + r;
  for (;++e < o; ) {
    if (i = r.charCodeAt(e), i === 0) {
      s += "�";
      continue;
    }
    if (i >= 1 && i <= 31 || i === 127 || e === 0 && i >= 48 && i <= 57 || e === 1 && i >= 48 && i <= 57 && a === 45) {
      s += "\\" + i.toString(16) + " ";
      continue;
    }
    if (i >= 128 || i === 45 || i === 95 || i >= 48 && i <= 57 || i >= 65 && i <= 90 || i >= 97 && i <= 122) {
      s += r.charAt(e);
      continue;
    }
    s += "\\" + r.charAt(e);
  }
  return s;
}
function ve(t) {
  return t.replace(/\\([\dA-Fa-f]{1,6}[\t\n\f\r ]?|[\S\s])/g, (r) => r.length > 2 ? String.fromCodePoint(Number.parseInt(r.slice(1).trim(), 16)) : r[1]);
}
var Qt = new Map([["--font", ["--font-weight", "--font-size"]], ["--inset", ["--inset-shadow", "--inset-ring"]], ["--text", ["--text-color", "--text-decoration-color", "--text-decoration-thickness", "--text-indent", "--text-shadow", "--text-underline-offset"]]]);
function Jt(t, r) {
  return (Qt.get(r) ?? []).some((o) => t === o || t.startsWith(`${o}-`));
}
var Qe = class {
  constructor(r = new Map, o = new Set([])) {
    this.values = r;
    this.keyframes = o;
  }
  prefix = null;
  add(r, o, e = 0, i) {
    if (r.endsWith("-*")) {
      if (o !== "initial")
        throw new Error(`Invalid theme value \`${o}\` for namespace \`${r}\``);
      r === "--*" ? this.values.clear() : this.clearNamespace(r.slice(0, -2), 0);
    }
    if (e & 4) {
      let s = this.values.get(r);
      if (s && !(s.options & 4))
        return;
    }
    o === "initial" ? this.values.delete(r) : this.values.set(r, { value: o, options: e, src: i });
  }
  keysInNamespaces(r) {
    let o = [];
    for (let e of r) {
      let i = `${e}-`;
      for (let s of this.values.keys())
        s.startsWith(i) && s.indexOf("--", 2) === -1 && (Jt(s, e) || o.push(s.slice(i.length)));
    }
    return o;
  }
  get(r) {
    for (let o of r) {
      let e = this.values.get(o);
      if (e)
        return e.value;
    }
    return null;
  }
  hasDefault(r) {
    return (this.getOptions(r) & 4) === 4;
  }
  getOptions(r) {
    return r = ve(this.#r(r)), this.values.get(r)?.options ?? 0;
  }
  entries() {
    return this.prefix ? Array.from(this.values, (r) => (r[0] = this.prefixKey(r[0]), r)) : this.values.entries();
  }
  prefixKey(r) {
    return this.prefix ? `--${this.prefix}-${r.slice(2)}` : r;
  }
  #r(r) {
    return this.prefix ? `--${r.slice(3 + this.prefix.length)}` : r;
  }
  clearNamespace(r, o) {
    let e = Qt.get(r) ?? [];
    e:
      for (let i of this.values.keys())
        if (i.startsWith(r)) {
          if (o !== 0 && (this.getOptions(i) & o) !== o)
            continue;
          for (let s of e)
            if (i.startsWith(s))
              continue e;
          this.values.delete(i);
        }
  }
  #e(r, o) {
    for (let e of o) {
      let i = r !== null ? `${e}-${r}` : e;
      if (!this.values.has(i))
        if (r !== null && r.includes(".")) {
          if (i = `${e}-${r.replaceAll(".", "_")}`, !this.values.has(i))
            continue;
        } else
          continue;
      if (!Jt(i, e))
        return i;
    }
    return null;
  }
  #t(r) {
    let o = this.values.get(r);
    if (!o)
      return null;
    let e = null;
    return o.options & 2 && (e = o.value), `var(${me(this.prefixKey(r))}${e ? `, ${e}` : ""})`;
  }
  markUsedVariable(r) {
    let o = ve(this.#r(r)), e = this.values.get(o);
    if (!e)
      return false;
    let i = e.options & 16;
    return e.options |= 16, !i;
  }
  resolve(r, o, e = 0) {
    let i = this.#e(r, o);
    if (!i)
      return null;
    let s = this.values.get(i);
    return (e | s.options) & 1 ? s.value : this.#t(i);
  }
  resolveValue(r, o) {
    let e = this.#e(r, o);
    return e ? this.values.get(e).value : null;
  }
  resolveWith(r, o, e = []) {
    let i = this.#e(r, o);
    if (!i)
      return null;
    let s = {};
    for (let f of e) {
      let u = `${i}${f}`, c = this.values.get(u);
      c && (c.options & 1 ? s[f] = c.value : s[f] = this.#t(u));
    }
    let a = this.values.get(i);
    return a.options & 1 ? [a.value, s] : [this.#t(i), s];
  }
  namespace(r) {
    let o = new Map, e = `${r}-`;
    for (let [i, s] of this.values)
      i === r ? o.set(null, s.value) : i.startsWith(`${e}-`) ? o.set(i.slice(r.length), s.value) : i.startsWith(e) && o.set(i.slice(e.length), s.value);
    return o;
  }
  addKeyframes(r) {
    this.keyframes.add(r);
  }
  getKeyframes() {
    return Array.from(this.keyframes);
  }
};
var W = class extends Map {
  constructor(o) {
    super();
    this.factory = o;
  }
  get(o) {
    let e = super.get(o);
    return e === undefined && (e = this.factory(o, this), this.set(o, e)), e;
  }
};
function $t(t) {
  return { kind: "word", value: t };
}
function Do(t, r) {
  return { kind: "function", value: t, nodes: r };
}
function jo(t) {
  return { kind: "separator", value: t };
}
function ee(t, r, o = null) {
  for (let e = 0;e < t.length; e++) {
    let i = t[e], s = false, a = 0, f = r(i, { parent: o, replaceWith(u) {
      s || (s = true, Array.isArray(u) ? u.length === 0 ? (t.splice(e, 1), a = 0) : u.length === 1 ? (t[e] = u[0], a = 1) : (t.splice(e, 1, ...u), a = u.length) : t[e] = u);
    } }) ?? 0;
    if (s) {
      f === 0 ? e-- : e += a - 1;
      continue;
    }
    if (f === 2)
      return 2;
    if (f !== 1 && i.kind === "function" && ee(i.nodes, r, i) === 2)
      return 2;
  }
}
function J(t) {
  let r = "";
  for (let o of t)
    switch (o.kind) {
      case "word":
      case "separator": {
        r += o.value;
        break;
      }
      case "function":
        r += o.value + "(" + J(o.nodes) + ")";
    }
  return r;
}
var Zt = 92;
var Lo = 41;
var Xt = 58;
var er = 44;
var Io = 34;
var tr = 61;
var rr = 62;
var or = 60;
var ir = 10;
var Fo = 40;
var Mo = 39;
var nr = 47;
var lr = 32;
var ar = 9;
function B(t) {
  t = t.replaceAll(`\r
`, `
`);
  let r = [], o = [], e = null, i = "", s;
  for (let a = 0;a < t.length; a++) {
    let f = t.charCodeAt(a);
    switch (f) {
      case Zt: {
        i += t[a] + t[a + 1], a++;
        break;
      }
      case Xt:
      case er:
      case tr:
      case rr:
      case or:
      case ir:
      case nr:
      case lr:
      case ar: {
        if (i.length > 0) {
          let d = $t(i);
          e ? e.nodes.push(d) : r.push(d), i = "";
        }
        let u = a, c = a + 1;
        for (;c < t.length && (s = t.charCodeAt(c), !(s !== Xt && s !== er && s !== tr && s !== rr && s !== or && s !== ir && s !== nr && s !== lr && s !== ar)); c++)
          ;
        a = c - 1;
        let g = jo(t.slice(u, c));
        e ? e.nodes.push(g) : r.push(g);
        break;
      }
      case Mo:
      case Io: {
        let u = a;
        for (let c = a + 1;c < t.length; c++)
          if (s = t.charCodeAt(c), s === Zt)
            c += 1;
          else if (s === f) {
            a = c;
            break;
          }
        i += t.slice(u, a + 1);
        break;
      }
      case Fo: {
        let u = Do(i, []);
        i = "", e ? e.nodes.push(u) : r.push(u), o.push(u), e = u;
        break;
      }
      case Lo: {
        let u = o.pop();
        if (i.length > 0) {
          let c = $t(i);
          u.nodes.push(c), i = "";
        }
        o.length > 0 ? e = o[o.length - 1] : e = null;
        break;
      }
      default:
        i += String.fromCharCode(f);
    }
  }
  return i.length > 0 && r.push($t(i)), r;
}
function Ze(t) {
  let r = [];
  return ee(B(t), (o) => {
    if (!(o.kind !== "function" || o.value !== "var"))
      return ee(o.nodes, (e) => {
        e.kind !== "word" || e.value[0] !== "-" || e.value[1] !== "-" || r.push(e.value);
      }), 1;
  }), r;
}
var Bo = 64;
function M(t, r = []) {
  return { kind: "rule", selector: t, nodes: r };
}
function F(t, r = "", o = []) {
  return { kind: "at-rule", name: t, params: r, nodes: o };
}
function G(t, r = []) {
  return t.charCodeAt(0) === Bo ? _e(t, r) : M(t, r);
}
function l(t, r, o = false) {
  return { kind: "declaration", property: t, value: r, important: o };
}
function Je(t) {
  return { kind: "comment", value: t };
}
function se(t, r) {
  return { kind: "context", context: t, nodes: r };
}
function j(t) {
  return { kind: "at-root", nodes: t };
}
function D(t, r, o = [], e = {}) {
  for (let i = 0;i < t.length; i++) {
    let s = t[i], a = o[o.length - 1] ?? null;
    if (s.kind === "context") {
      if (D(s.nodes, r, o, { ...e, ...s.context }) === 2)
        return 2;
      continue;
    }
    o.push(s);
    let f = false, u = 0, c = r(s, { parent: a, context: e, path: o, replaceWith(g) {
      f || (f = true, Array.isArray(g) ? g.length === 0 ? (t.splice(i, 1), u = 0) : g.length === 1 ? (t[i] = g[0], u = 1) : (t.splice(i, 1, ...g), u = g.length) : (t[i] = g, u = 1));
    } }) ?? 0;
    if (o.pop(), f) {
      c === 0 ? i-- : i += u - 1;
      continue;
    }
    if (c === 2)
      return 2;
    if (c !== 1 && "nodes" in s) {
      o.push(s);
      let g = D(s.nodes, r, o, e);
      if (o.pop(), g === 2)
        return 2;
    }
  }
}
function Xe(t, r, o = [], e = {}) {
  for (let i = 0;i < t.length; i++) {
    let s = t[i], a = o[o.length - 1] ?? null;
    if (s.kind === "rule" || s.kind === "at-rule")
      o.push(s), Xe(s.nodes, r, o, e), o.pop();
    else if (s.kind === "context") {
      Xe(s.nodes, r, o, { ...e, ...s.context });
      continue;
    }
    o.push(s), r(s, { parent: a, context: e, path: o, replaceWith(f) {
      Array.isArray(f) ? f.length === 0 ? t.splice(i, 1) : f.length === 1 ? t[i] = f[0] : t.splice(i, 1, ...f) : t[i] = f, i += f.length - 1;
    } }), o.pop();
  }
}
function be(t, r, o = 3) {
  let e = [], i = new Set, s = new W(() => new Set), a = new W(() => new Set), f = new Set, u = new Set, c = [], g = [], d = new W(() => new Set);
  function m(k, x, y = {}, N = 0) {
    if (k.kind === "declaration") {
      if (k.property === "--tw-sort" || k.value === undefined || k.value === null)
        return;
      if (y.theme && k.property[0] === "-" && k.property[1] === "-") {
        if (k.value === "initial") {
          k.value = undefined;
          return;
        }
        y.keyframes || s.get(x).add(k);
      }
      if (k.value.includes("var("))
        if (y.theme && k.property[0] === "-" && k.property[1] === "-")
          for (let b of Ze(k.value))
            d.get(b).add(k.property);
        else
          r.trackUsedVariables(k.value);
      if (k.property === "animation")
        for (let b of sr(k.value))
          u.add(b);
      o & 2 && k.value.includes("color-mix(") && a.get(x).add(k), x.push(k);
    } else if (k.kind === "rule")
      if (k.selector === "&")
        for (let b of k.nodes) {
          let V = [];
          m(b, V, y, N + 1), V.length > 0 && x.push(...V);
        }
      else {
        let b = { ...k, nodes: [] };
        for (let V of k.nodes)
          m(V, b.nodes, y, N + 1);
        b.nodes.length > 0 && x.push(b);
      }
    else if (k.kind === "at-rule" && k.name === "@property" && N === 0) {
      if (i.has(k.params))
        return;
      if (o & 1) {
        let V = k.params, R = null, U = false;
        for (let L of k.nodes)
          L.kind === "declaration" && (L.property === "initial-value" ? R = L.value : L.property === "inherits" && (U = L.value === "true"));
        let _ = l(V, R ?? "initial");
        _.src = k.src, U ? c.push(_) : g.push(_);
      }
      i.add(k.params);
      let b = { ...k, nodes: [] };
      for (let V of k.nodes)
        m(V, b.nodes, y, N + 1);
      x.push(b);
    } else if (k.kind === "at-rule") {
      k.name === "@keyframes" && (y = { ...y, keyframes: true });
      let b = { ...k, nodes: [] };
      for (let V of k.nodes)
        m(V, b.nodes, y, N + 1);
      k.name === "@keyframes" && y.theme && f.add(b), (b.nodes.length > 0 || b.name === "@layer" || b.name === "@charset" || b.name === "@custom-media" || b.name === "@namespace" || b.name === "@import") && x.push(b);
    } else if (k.kind === "at-root")
      for (let b of k.nodes) {
        let V = [];
        m(b, V, y, 0);
        for (let R of V)
          e.push(R);
      }
    else if (k.kind === "context") {
      if (k.context.reference)
        return;
      for (let b of k.nodes)
        m(b, x, { ...y, ...k.context }, N);
    } else
      k.kind === "comment" && x.push(k);
  }
  let v = [];
  for (let k of t)
    m(k, v, {}, 0);
  e:
    for (let [k, x] of s)
      for (let y of x) {
        if (ur(y.property, r.theme, d)) {
          if (y.property.startsWith(r.theme.prefixKey("--animate-")))
            for (let V of sr(y.value))
              u.add(V);
          continue;
        }
        let b = k.indexOf(y);
        if (k.splice(b, 1), k.length === 0) {
          let V = qo(v, (R) => R.kind === "rule" && R.nodes === k);
          if (!V || V.length === 0)
            continue e;
          V.unshift({ kind: "at-root", nodes: v });
          do {
            let R = V.pop();
            if (!R)
              break;
            let U = V[V.length - 1];
            if (!U || U.kind !== "at-root" && U.kind !== "at-rule")
              break;
            let _ = U.nodes.indexOf(R);
            if (_ === -1)
              break;
            U.nodes.splice(_, 1);
          } while (true);
          continue e;
        }
      }
  for (let k of f)
    if (!u.has(k.params)) {
      let x = e.indexOf(k);
      e.splice(x, 1);
    }
  if (v = v.concat(e), o & 2)
    for (let [k, x] of a)
      for (let y of x) {
        let N = k.indexOf(y);
        if (N === -1 || y.value == null)
          continue;
        let b = B(y.value), V = false;
        if (ee(b, (_, { replaceWith: L }) => {
          if (_.kind !== "function" || _.value !== "color-mix")
            return;
          let O = false, H = false;
          if (ee(_.nodes, (I, { replaceWith: q }) => {
            if (I.kind == "word" && I.value.toLowerCase() === "currentcolor") {
              H = true, V = true;
              return;
            }
            let X = I, oe = null, n = new Set;
            do {
              if (X.kind !== "function" || X.value !== "var")
                return;
              let p = X.nodes[0];
              if (!p || p.kind !== "word")
                return;
              let h = p.value;
              if (n.has(h)) {
                O = true;
                return;
              }
              if (n.add(h), V = true, oe = r.theme.resolveValue(null, [p.value]), !oe) {
                O = true;
                return;
              }
              if (oe.toLowerCase() === "currentcolor") {
                H = true;
                return;
              }
              oe.startsWith("var(") ? X = B(oe)[0] : X = null;
            } while (X);
            q({ kind: "word", value: oe });
          }), O || H) {
            let I = _.nodes.findIndex((X) => X.kind === "separator" && X.value.trim().includes(","));
            if (I === -1)
              return;
            let q = _.nodes.length > I ? _.nodes[I + 1] : null;
            if (!q)
              return;
            L(q);
          } else if (V) {
            let I = _.nodes[2];
            I.kind === "word" && (I.value === "oklab" || I.value === "oklch" || I.value === "lab" || I.value === "lch") && (I.value = "srgb");
          }
        }), !V)
          continue;
        let R = { ...y, value: J(b) }, U = G("@supports (color: color-mix(in lab, red, red))", [y]);
        U.src = y.src, k.splice(N, 1, R, U);
      }
  if (o & 1) {
    let k = [];
    if (c.length > 0) {
      let x = G(":root, :host", c);
      x.src = c[0].src, k.push(x);
    }
    if (g.length > 0) {
      let x = G("*, ::before, ::after, ::backdrop", g);
      x.src = g[0].src, k.push(x);
    }
    if (k.length > 0) {
      let x = v.findIndex((b) => !(b.kind === "comment" || b.kind === "at-rule" && (b.name === "@charset" || b.name === "@import"))), y = F("@layer", "properties", []);
      y.src = k[0].src, v.splice(x < 0 ? v.length : x, 0, y);
      let N = G("@layer properties", [F("@supports", "((-webkit-hyphens: none) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color:rgb(from red r g b))))", k)]);
      N.src = k[0].src, N.nodes[0].src = k[0].src, v.push(N);
    }
  }
  return v;
}
function ne(t, r) {
  let o = 0, e = { file: null, code: "" };
  function i(a, f = 0) {
    let u = "", c = "  ".repeat(f);
    if (a.kind === "declaration") {
      if (u += `${c}${a.property}: ${a.value}${a.important ? " !important" : ""};
`, r) {
        o += c.length;
        let g = o;
        o += a.property.length, o += 2, o += a.value?.length ?? 0, a.important && (o += 11);
        let d = o;
        o += 2, a.dst = [e, g, d];
      }
    } else if (a.kind === "rule") {
      if (u += `${c}${a.selector} {
`, r) {
        o += c.length;
        let g = o;
        o += a.selector.length, o += 1;
        let d = o;
        a.dst = [e, g, d], o += 2;
      }
      for (let g of a.nodes)
        u += i(g, f + 1);
      u += `${c}}
`, r && (o += c.length, o += 2);
    } else if (a.kind === "at-rule") {
      if (a.nodes.length === 0) {
        let g = `${c}${a.name} ${a.params};
`;
        if (r) {
          o += c.length;
          let d = o;
          o += a.name.length, o += 1, o += a.params.length;
          let m = o;
          o += 2, a.dst = [e, d, m];
        }
        return g;
      }
      if (u += `${c}${a.name}${a.params ? ` ${a.params} ` : " "}{
`, r) {
        o += c.length;
        let g = o;
        o += a.name.length, a.params && (o += 1, o += a.params.length), o += 1;
        let d = o;
        a.dst = [e, g, d], o += 2;
      }
      for (let g of a.nodes)
        u += i(g, f + 1);
      u += `${c}}
`, r && (o += c.length, o += 2);
    } else if (a.kind === "comment") {
      if (u += `${c}/*${a.value}*/
`, r) {
        o += c.length;
        let g = o;
        o += 2 + a.value.length + 2;
        let d = o;
        a.dst = [e, g, d], o += 1;
      }
    } else if (a.kind === "context" || a.kind === "at-root")
      return "";
    return u;
  }
  let s = "";
  for (let a of t)
    s += i(a, 0);
  return e.code = s, s;
}
function qo(t, r) {
  let o = [];
  return D(t, (e, { path: i }) => {
    if (r(e))
      return o = [...i], 2;
  }), o;
}
function ur(t, r, o, e = new Set) {
  if (e.has(t) || (e.add(t), r.getOptions(t) & 24))
    return true;
  {
    let s = o.get(t) ?? [];
    for (let a of s)
      if (ur(a, r, o, e))
        return true;
  }
  return false;
}
function sr(t) {
  return t.split(/[\s,]+/);
}
var St = ["calc", "min", "max", "clamp", "mod", "rem", "sin", "cos", "tan", "asin", "acos", "atan", "atan2", "pow", "sqrt", "hypot", "log", "exp", "round"];
var tt = ["anchor-size"];
var cr = new RegExp(`(${tt.join("|")})\\(`, "g");
function ze(t) {
  return t.indexOf("(") !== -1 && St.some((r) => t.includes(`${r}(`));
}
function fr(t) {
  if (!St.some((i) => t.includes(i)))
    return t;
  let r = false;
  tt.some((i) => t.includes(i)) && (cr.lastIndex = 0, t = t.replace(cr, (i, s) => (r = true, `$${tt.indexOf(s)}$(`)));
  let o = "", e = [];
  for (let i = 0;i < t.length; i++) {
    let s = t[i];
    if (s === "(") {
      o += s;
      let a = i;
      for (let u = i - 1;u >= 0; u--) {
        let c = t.charCodeAt(u);
        if (c >= 48 && c <= 57)
          a = u;
        else if (c >= 97 && c <= 122)
          a = u;
        else
          break;
      }
      let f = t.slice(a, i);
      if (St.includes(f)) {
        e.unshift(true);
        continue;
      } else if (e[0] && f === "") {
        e.unshift(true);
        continue;
      }
      e.unshift(false);
      continue;
    } else if (s === ")")
      o += s, e.shift();
    else if (s === "," && e[0]) {
      o += ", ";
      continue;
    } else {
      if (s === " " && e[0] && o[o.length - 1] === " ")
        continue;
      if ((s === "+" || s === "*" || s === "/" || s === "-") && e[0]) {
        let a = o.trimEnd(), f = a[a.length - 1];
        if (f === "+" || f === "*" || f === "/" || f === "-") {
          o += s;
          continue;
        } else if (f === "(" || f === ",") {
          o += s;
          continue;
        } else
          t[i - 1] === " " ? o += `${s} ` : o += ` ${s} `;
      } else if (e[0] && t.startsWith("to-zero", i)) {
        let a = i;
        i += 7, o += t.slice(a, i + 1);
      } else
        o += s;
    }
  }
  return r ? o.replace(/\$(\d+)\$/g, (i, s) => tt[s] ?? i) : o;
}
function ge(t) {
  if (t.indexOf("(") === -1)
    return Se(t);
  let r = B(t);
  return Nt(r), t = J(r), t = fr(t), t;
}
function Se(t, r = false) {
  let o = "";
  for (let e = 0;e < t.length; e++) {
    let i = t[e];
    i === "\\" && t[e + 1] === "_" ? (o += "_", e += 1) : i === "_" && !r ? o += " " : o += i;
  }
  return o;
}
function Nt(t) {
  for (let r of t)
    switch (r.kind) {
      case "function": {
        if (r.value === "url" || r.value.endsWith("_url")) {
          r.value = Se(r.value);
          break;
        }
        if (r.value === "var" || r.value.endsWith("_var") || r.value === "theme" || r.value.endsWith("_theme")) {
          r.value = Se(r.value);
          for (let o = 0;o < r.nodes.length; o++) {
            if (o == 0 && r.nodes[o].kind === "word") {
              r.nodes[o].value = Se(r.nodes[o].value, true);
              continue;
            }
            Nt([r.nodes[o]]);
          }
          break;
        }
        r.value = Se(r.value), Nt(r.nodes);
        break;
      }
      case "separator":
      case "word": {
        r.value = Se(r.value);
        break;
      }
      default:
        Go(r);
    }
}
function Go(t) {
  throw new Error(`Unexpected value: ${t}`);
}
var Vt = new Uint8Array(256);
function fe(t) {
  let r = 0, o = t.length;
  for (let e = 0;e < o; e++) {
    let i = t.charCodeAt(e);
    switch (i) {
      case 92:
        e += 1;
        break;
      case 39:
      case 34:
        for (;++e < o; ) {
          let s = t.charCodeAt(e);
          if (s === 92) {
            e += 1;
            continue;
          }
          if (s === i)
            break;
        }
        break;
      case 40:
        Vt[r] = 41, r++;
        break;
      case 91:
        Vt[r] = 93, r++;
        break;
      case 123:
        break;
      case 93:
      case 125:
      case 41:
        if (r === 0)
          return false;
        r > 0 && i === Vt[r - 1] && r--;
        break;
      case 59:
        if (r === 0)
          return false;
        break;
    }
  }
  return true;
}
var rt = new Uint8Array(256);
function z(t, r) {
  let o = 0, e = [], i = 0, s = t.length, a = r.charCodeAt(0);
  for (let f = 0;f < s; f++) {
    let u = t.charCodeAt(f);
    if (o === 0 && u === a) {
      e.push(t.slice(i, f)), i = f + 1;
      continue;
    }
    switch (u) {
      case 92:
        f += 1;
        break;
      case 39:
      case 34:
        for (;++f < s; ) {
          let c = t.charCodeAt(f);
          if (c === 92) {
            f += 1;
            continue;
          }
          if (c === u)
            break;
        }
        break;
      case 40:
        rt[o] = 41, o++;
        break;
      case 91:
        rt[o] = 93, o++;
        break;
      case 123:
        rt[o] = 125, o++;
        break;
      case 93:
      case 125:
      case 41:
        o > 0 && u === rt[o - 1] && o--;
        break;
    }
  }
  return e.push(t.slice(i)), e;
}
var Yo = 58;
var pr = 45;
var dr = 97;
var mr = 122;
function* gr(t, r) {
  let o = z(t, ":");
  if (r.theme.prefix) {
    if (o.length === 1 || o[0] !== r.theme.prefix)
      return null;
    o.shift();
  }
  let e = o.pop(), i = [];
  for (let d = o.length - 1;d >= 0; --d) {
    let m = r.parseVariant(o[d]);
    if (m === null)
      return;
    i.push(m);
  }
  let s = false;
  e[e.length - 1] === "!" ? (s = true, e = e.slice(0, -1)) : e[0] === "!" && (s = true, e = e.slice(1)), r.utilities.has(e, "static") && !e.includes("[") && (yield { kind: "static", root: e, variants: i, important: s, raw: t });
  let [a, f = null, u] = z(e, "/");
  if (u)
    return;
  let c = f === null ? null : Tt(f);
  if (f !== null && c === null)
    return;
  if (a[0] === "[") {
    if (a[a.length - 1] !== "]")
      return;
    let d = a.charCodeAt(1);
    if (d !== pr && !(d >= dr && d <= mr))
      return;
    a = a.slice(1, -1);
    let m = a.indexOf(":");
    if (m === -1 || m === 0 || m === a.length - 1)
      return;
    let v = a.slice(0, m), k = ge(a.slice(m + 1));
    if (!fe(k))
      return;
    yield { kind: "arbitrary", property: v, value: k, modifier: c, variants: i, important: s, raw: t };
    return;
  }
  let g;
  if (a[a.length - 1] === "]") {
    let d = a.indexOf("-[");
    if (d === -1)
      return;
    let m = a.slice(0, d);
    if (!r.utilities.has(m, "functional"))
      return;
    let v = a.slice(d + 1);
    g = [[m, v]];
  } else if (a[a.length - 1] === ")") {
    let d = a.indexOf("-(");
    if (d === -1)
      return;
    let m = a.slice(0, d);
    if (!r.utilities.has(m, "functional"))
      return;
    let v = a.slice(d + 2, -1), k = z(v, ":"), x = null;
    if (k.length === 2 && (x = k[0], v = k[1]), v[0] !== "-" || v[1] !== "-" || !fe(v))
      return;
    g = [[m, x === null ? `[var(${v})]` : `[${x}:var(${v})]`]];
  } else
    g = kr(a, (d) => r.utilities.has(d, "functional"));
  for (let [d, m] of g) {
    let v = { kind: "functional", root: d, modifier: c, value: null, variants: i, important: s, raw: t };
    if (m === null) {
      yield v;
      continue;
    }
    {
      let k = m.indexOf("[");
      if (k !== -1) {
        if (m[m.length - 1] !== "]")
          return;
        let y = ge(m.slice(k + 1, -1));
        if (!fe(y))
          continue;
        let N = "";
        for (let b = 0;b < y.length; b++) {
          let V = y.charCodeAt(b);
          if (V === Yo) {
            N = y.slice(0, b), y = y.slice(b + 1);
            break;
          }
          if (!(V === pr || V >= dr && V <= mr))
            break;
        }
        if (y.length === 0 || y.trim().length === 0)
          continue;
        v.value = { kind: "arbitrary", dataType: N || null, value: y };
      } else {
        let y = f === null || v.modifier?.kind === "arbitrary" ? null : `${m}/${f}`;
        v.value = { kind: "named", value: m, fraction: y };
      }
    }
    yield v;
  }
}
function Tt(t) {
  if (t[0] === "[" && t[t.length - 1] === "]") {
    let r = ge(t.slice(1, -1));
    return !fe(r) || r.length === 0 || r.trim().length === 0 ? null : { kind: "arbitrary", value: r };
  }
  return t[0] === "(" && t[t.length - 1] === ")" ? (t = t.slice(1, -1), t[0] !== "-" || t[1] !== "-" || !fe(t) ? null : (t = `var(${t})`, { kind: "arbitrary", value: ge(t) })) : { kind: "named", value: t };
}
function hr(t, r) {
  if (t[0] === "[" && t[t.length - 1] === "]") {
    if (t[1] === "@" && t.includes("&"))
      return null;
    let o = ge(t.slice(1, -1));
    if (!fe(o) || o.length === 0 || o.trim().length === 0)
      return null;
    let e = o[0] === ">" || o[0] === "+" || o[0] === "~";
    return !e && o[0] !== "@" && !o.includes("&") && (o = `&:is(${o})`), { kind: "arbitrary", selector: o, relative: e };
  }
  {
    let [o, e = null, i] = z(t, "/");
    if (i)
      return null;
    let s = kr(o, (a) => r.variants.has(a));
    for (let [a, f] of s)
      switch (r.variants.kind(a)) {
        case "static":
          return f !== null || e !== null ? null : { kind: "static", root: a };
        case "functional": {
          let u = e === null ? null : Tt(e);
          if (e !== null && u === null)
            return null;
          if (f === null)
            return { kind: "functional", root: a, modifier: u, value: null };
          if (f[f.length - 1] === "]") {
            if (f[0] !== "[")
              continue;
            let c = ge(f.slice(1, -1));
            return !fe(c) || c.length === 0 || c.trim().length === 0 ? null : { kind: "functional", root: a, modifier: u, value: { kind: "arbitrary", value: c } };
          }
          if (f[f.length - 1] === ")") {
            if (f[0] !== "(")
              continue;
            let c = ge(f.slice(1, -1));
            return !fe(c) || c.length === 0 || c.trim().length === 0 || c[0] !== "-" || c[1] !== "-" ? null : { kind: "functional", root: a, modifier: u, value: { kind: "arbitrary", value: `var(${c})` } };
          }
          return { kind: "functional", root: a, modifier: u, value: { kind: "named", value: f } };
        }
        case "compound": {
          if (f === null)
            return null;
          let u = r.parseVariant(f);
          if (u === null || !r.variants.compoundsWith(a, u))
            return null;
          let c = e === null ? null : Tt(e);
          return e !== null && c === null ? null : { kind: "compound", root: a, modifier: c, variant: u };
        }
      }
  }
  return null;
}
function* kr(t, r) {
  r(t) && (yield [t, null]);
  let o = t.lastIndexOf("-");
  for (;o > 0; ) {
    let e = t.slice(0, o);
    if (r(e)) {
      let i = [e, t.slice(o + 1)];
      if (i[1] === "")
        break;
      yield i;
    }
    o = t.lastIndexOf("-", o - 1);
  }
  t[0] === "@" && r("@") && (yield ["@", t.slice(1)]);
}
function vr(t, r) {
  let o = [];
  for (let i of r.variants)
    o.unshift(ot(i));
  t.theme.prefix && o.unshift(t.theme.prefix);
  let e = "";
  if (r.kind === "static" && (e += r.root), r.kind === "functional" && (e += r.root, r.value))
    if (r.value.kind === "arbitrary") {
      if (r.value !== null) {
        let i = Rt(r.value.value), s = i ? r.value.value.slice(4, -1) : r.value.value, [a, f] = i ? ["(", ")"] : ["[", "]"];
        r.value.dataType ? e += `-${a}${r.value.dataType}:${Ne(s)}${f}` : e += `-${a}${Ne(s)}${f}`;
      }
    } else
      r.value.kind === "named" && (e += `-${r.value.value}`);
  return r.kind === "arbitrary" && (e += `[${r.property}:${Ne(r.value)}]`), (r.kind === "arbitrary" || r.kind === "functional") && (e += wr(r.modifier)), r.important && (e += "!"), o.push(e), o.join(":");
}
function wr(t) {
  if (t === null)
    return "";
  let r = Rt(t.value), o = r ? t.value.slice(4, -1) : t.value, [e, i] = r ? ["(", ")"] : ["[", "]"];
  return t.kind === "arbitrary" ? `/${e}${Ne(o)}${i}` : t.kind === "named" ? `/${t.value}` : "";
}
function ot(t) {
  if (t.kind === "static")
    return t.root;
  if (t.kind === "arbitrary")
    return `[${Ne(Zo(t.selector))}]`;
  let r = "";
  if (t.kind === "functional") {
    r += t.root;
    let o = t.root !== "@";
    if (t.value)
      if (t.value.kind === "arbitrary") {
        let e = Rt(t.value.value), i = e ? t.value.value.slice(4, -1) : t.value.value, [s, a] = e ? ["(", ")"] : ["[", "]"];
        r += `${o ? "-" : ""}${s}${Ne(i)}${a}`;
      } else
        t.value.kind === "named" && (r += `${o ? "-" : ""}${t.value.value}`);
  }
  return t.kind === "compound" && (r += t.root, r += "-", r += ot(t.variant)), (t.kind === "functional" || t.kind === "compound") && (r += wr(t.modifier)), r;
}
var Jo = new W((t) => {
  let r = B(t), o = new Set;
  return ee(r, (e, { parent: i }) => {
    let s = i === null ? r : i.nodes ?? [];
    if (e.kind === "word" && (e.value === "+" || e.value === "-" || e.value === "*" || e.value === "/")) {
      let a = s.indexOf(e) ?? -1;
      if (a === -1)
        return;
      let f = s[a - 1];
      if (f?.kind !== "separator" || f.value !== " ")
        return;
      let u = s[a + 1];
      if (u?.kind !== "separator" || u.value !== " ")
        return;
      o.add(f), o.add(u);
    } else
      e.kind === "separator" && e.value.trim() === "/" ? e.value = "/" : e.kind === "separator" && e.value.length > 0 && e.value.trim() === "" ? (s[0] === e || s[s.length - 1] === e) && o.add(e) : e.kind === "separator" && e.value.trim() === "," && (e.value = ",");
  }), o.size > 0 && ee(r, (e, { replaceWith: i }) => {
    o.has(e) && (o.delete(e), i([]));
  }), Et(r), J(r);
});
function Ne(t) {
  return Jo.get(t);
}
var Qo = new W((t) => {
  let r = B(t);
  return r.length === 3 && r[0].kind === "word" && r[0].value === "&" && r[1].kind === "separator" && r[1].value === ":" && r[2].kind === "function" && r[2].value === "is" ? J(r[2].nodes) : t;
});
function Zo(t) {
  return Qo.get(t);
}
function Et(t) {
  for (let r of t)
    switch (r.kind) {
      case "function": {
        if (r.value === "url" || r.value.endsWith("_url")) {
          r.value = Ke(r.value);
          break;
        }
        if (r.value === "var" || r.value.endsWith("_var") || r.value === "theme" || r.value.endsWith("_theme")) {
          r.value = Ke(r.value);
          for (let o = 0;o < r.nodes.length; o++)
            Et([r.nodes[o]]);
          break;
        }
        r.value = Ke(r.value), Et(r.nodes);
        break;
      }
      case "separator":
        r.value = Ke(r.value);
        break;
      case "word": {
        (r.value[0] !== "-" || r.value[1] !== "-") && (r.value = Ke(r.value));
        break;
      }
      default:
        ei(r);
    }
}
var Xo = new W((t) => {
  let r = B(t);
  return r.length === 1 && r[0].kind === "function" && r[0].value === "var";
});
function Rt(t) {
  return Xo.get(t);
}
function ei(t) {
  throw new Error(`Unexpected value: ${t}`);
}
function Ke(t) {
  return t.replaceAll("_", String.raw`\_`).replaceAll(" ", "_");
}
function ye(t, r, o) {
  if (t === r)
    return 0;
  let e = t.indexOf("("), i = r.indexOf("("), s = e === -1 ? t.replace(/[\d.]+/g, "") : t.slice(0, e), a = i === -1 ? r.replace(/[\d.]+/g, "") : r.slice(0, i), f = (s === a ? 0 : s < a ? -1 : 1) || (o === "asc" ? parseInt(t) - parseInt(r) : parseInt(r) - parseInt(t));
  return Number.isNaN(f) ? t < r ? -1 : 1 : f;
}
var ti = new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "green", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", "transparent", "currentcolor", "canvas", "canvastext", "linktext", "visitedtext", "activetext", "buttonface", "buttontext", "buttonborder", "field", "fieldtext", "highlight", "highlighttext", "selecteditem", "selecteditemtext", "mark", "marktext", "graytext", "accentcolor", "accentcolortext"]);
var ri = /^(rgba?|hsla?|hwb|color|(ok)?(lab|lch)|light-dark|color-mix)\(/i;
function br(t) {
  return t.charCodeAt(0) === 35 || ri.test(t) || ti.has(t.toLowerCase());
}
var oi = { color: br, length: it, percentage: Pt, ratio: hi, number: xr, integer: E, url: yr, position: wi, "bg-size": bi, "line-width": ni, image: si, "family-name": ci, "generic-name": ui, "absolute-size": fi, "relative-size": pi, angle: Ai, vector: $i };
function Y(t, r) {
  if (t.startsWith("var("))
    return null;
  for (let o of r)
    if (oi[o]?.(t))
      return o;
  return null;
}
var ii = /^url\(.*\)$/;
function yr(t) {
  return ii.test(t);
}
function ni(t) {
  return z(t, " ").every((r) => it(r) || xr(r) || r === "thin" || r === "medium" || r === "thick");
}
var li = /^(?:element|image|cross-fade|image-set)\(/;
var ai = /^(repeating-)?(conic|linear|radial)-gradient\(/;
function si(t) {
  let r = 0;
  for (let o of z(t, ","))
    if (!o.startsWith("var(")) {
      if (yr(o)) {
        r += 1;
        continue;
      }
      if (ai.test(o)) {
        r += 1;
        continue;
      }
      if (li.test(o)) {
        r += 1;
        continue;
      }
      return false;
    }
  return r > 0;
}
function ui(t) {
  return t === "serif" || t === "sans-serif" || t === "monospace" || t === "cursive" || t === "fantasy" || t === "system-ui" || t === "ui-serif" || t === "ui-sans-serif" || t === "ui-monospace" || t === "ui-rounded" || t === "math" || t === "emoji" || t === "fangsong";
}
function ci(t) {
  let r = 0;
  for (let o of z(t, ",")) {
    let e = o.charCodeAt(0);
    if (e >= 48 && e <= 57)
      return false;
    o.startsWith("var(") || (r += 1);
  }
  return r > 0;
}
function fi(t) {
  return t === "xx-small" || t === "x-small" || t === "small" || t === "medium" || t === "large" || t === "x-large" || t === "xx-large" || t === "xxx-large";
}
function pi(t) {
  return t === "larger" || t === "smaller";
}
var pe = /[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/;
var di = new RegExp(`^${pe.source}$`);
function xr(t) {
  return di.test(t) || ze(t);
}
var mi = new RegExp(`^${pe.source}%$`);
function Pt(t) {
  return mi.test(t) || ze(t);
}
var gi = new RegExp(`^${pe.source}s*/s*${pe.source}$`);
function hi(t) {
  return gi.test(t) || ze(t);
}
var ki = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"];
var vi = new RegExp(`^${pe.source}(${ki.join("|")})$`);
function it(t) {
  return vi.test(t) || ze(t);
}
function wi(t) {
  let r = 0;
  for (let o of z(t, " ")) {
    if (o === "center" || o === "top" || o === "right" || o === "bottom" || o === "left") {
      r += 1;
      continue;
    }
    if (!o.startsWith("var(")) {
      if (it(o) || Pt(o)) {
        r += 1;
        continue;
      }
      return false;
    }
  }
  return r > 0;
}
function bi(t) {
  let r = 0;
  for (let o of z(t, ",")) {
    if (o === "cover" || o === "contain") {
      r += 1;
      continue;
    }
    let e = z(o, " ");
    if (e.length !== 1 && e.length !== 2)
      return false;
    if (e.every((i) => i === "auto" || it(i) || Pt(i))) {
      r += 1;
      continue;
    }
  }
  return r > 0;
}
var yi = ["deg", "rad", "grad", "turn"];
var xi = new RegExp(`^${pe.source}(${yi.join("|")})$`);
function Ai(t) {
  return xi.test(t);
}
var Ci = new RegExp(`^${pe.source} +${pe.source} +${pe.source}$`);
function $i(t) {
  return Ci.test(t);
}
function E(t) {
  let r = Number(t);
  return Number.isInteger(r) && r >= 0 && String(r) === String(t);
}
function Ot(t) {
  let r = Number(t);
  return Number.isInteger(r) && r > 0 && String(r) === String(t);
}
function xe(t) {
  return Ar(t, 0.25);
}
function nt(t) {
  return Ar(t, 0.25);
}
function Ar(t, r) {
  let o = Number(t);
  return o >= 0 && o % r === 0 && String(o) === String(t);
}
var Si = new Set(["inset", "inherit", "initial", "revert", "unset"]);
var Cr = /^-?(\d+|\.\d+)(.*?)$/g;
function Ue(t, r) {
  return z(t, ",").map((e) => {
    e = e.trim();
    let i = z(e, " ").filter((c) => c.trim() !== ""), s = null, a = null, f = null;
    for (let c of i)
      Si.has(c) || (Cr.test(c) ? (a === null ? a = c : f === null && (f = c), Cr.lastIndex = 0) : s === null && (s = c));
    if (a === null || f === null)
      return e;
    let u = r(s ?? "currentcolor");
    return s !== null ? e.replace(s, u) : `${e} ${u}`;
  }).join(", ");
}
var Ni = /^-?[a-z][a-zA-Z0-9/%._-]*$/;
var Vi = /^-?[a-z][a-zA-Z0-9/%._-]*-\*$/;
var at = ["0", "0.5", "1", "1.5", "2", "2.5", "3", "3.5", "4", "5", "6", "7", "8", "9", "10", "11", "12", "14", "16", "20", "24", "28", "32", "36", "40", "44", "48", "52", "56", "60", "64", "72", "80", "96"];
var _t = class {
  utilities = new W(() => []);
  completions = new Map;
  static(r, o) {
    this.utilities.get(r).push({ kind: "static", compileFn: o });
  }
  functional(r, o, e) {
    this.utilities.get(r).push({ kind: "functional", compileFn: o, options: e });
  }
  has(r, o) {
    return this.utilities.has(r) && this.utilities.get(r).some((e) => e.kind === o);
  }
  get(r) {
    return this.utilities.has(r) ? this.utilities.get(r) : [];
  }
  getCompletions(r) {
    return this.completions.get(r)?.() ?? [];
  }
  suggest(r, o) {
    this.completions.set(r, o);
  }
  keys(r) {
    let o = [];
    for (let [e, i] of this.utilities.entries())
      for (let s of i)
        if (s.kind === r) {
          o.push(e);
          break;
        }
    return o;
  }
};
function $(t, r, o) {
  return F("@property", t, [l("syntax", o ? `"${o}"` : '"*"'), l("inherits", "false"), ...r ? [l("initial-value", r)] : []]);
}
function Q(t, r) {
  if (r === null)
    return t;
  let o = Number(r);
  return Number.isNaN(o) || (r = `${o * 100}%`), r === "100%" ? t : `color-mix(in oklab, ${t} ${r}, transparent)`;
}
function Sr(t, r) {
  let o = Number(r);
  return Number.isNaN(o) || (r = `${o * 100}%`), `oklab(from ${t} l a b / ${r})`;
}
function Z(t, r, o) {
  if (!r)
    return t;
  if (r.kind === "arbitrary")
    return Q(t, r.value);
  let e = o.resolve(r.value, ["--opacity"]);
  return e ? Q(t, e) : nt(r.value) ? Q(t, `${r.value}%`) : null;
}
function te(t, r, o) {
  let e = null;
  switch (t.value.value) {
    case "inherit": {
      e = "inherit";
      break;
    }
    case "transparent": {
      e = "transparent";
      break;
    }
    case "current": {
      e = "currentcolor";
      break;
    }
    default: {
      e = r.resolve(t.value.value, o);
      break;
    }
  }
  return e ? Z(e, t.modifier, r) : null;
}
var Nr = /(\d+)_(\d+)/g;
function Vr(t) {
  let r = new _t;
  function o(n, p) {
    function* h(w) {
      for (let C of t.keysInNamespaces(w))
        yield C.replace(Nr, (P, S, T) => `${S}.${T}`);
    }
    let A = ["1/2", "1/3", "2/3", "1/4", "2/4", "3/4", "1/5", "2/5", "3/5", "4/5", "1/6", "2/6", "3/6", "4/6", "5/6", "1/12", "2/12", "3/12", "4/12", "5/12", "6/12", "7/12", "8/12", "9/12", "10/12", "11/12"];
    r.suggest(n, () => {
      let w = [];
      for (let C of p()) {
        if (typeof C == "string") {
          w.push({ values: [C], modifiers: [] });
          continue;
        }
        let P = [...C.values ?? [], ...h(C.valueThemeKeys ?? [])], S = [...C.modifiers ?? [], ...h(C.modifierThemeKeys ?? [])];
        C.supportsFractions && P.push(...A), C.hasDefaultValue && P.unshift(null), w.push({ supportsNegative: C.supportsNegative, values: P, modifiers: S });
      }
      return w;
    });
  }
  function e(n, p) {
    r.static(n, () => p.map((h) => typeof h == "function" ? h() : l(h[0], h[1])));
  }
  function i(n, p) {
    function h({ negative: A }) {
      return (w) => {
        let C = null, P = null;
        if (w.value)
          if (w.value.kind === "arbitrary") {
            if (w.modifier)
              return;
            C = w.value.value, P = w.value.dataType;
          } else {
            if (C = t.resolve(w.value.fraction ?? w.value.value, p.themeKeys ?? []), C === null && p.supportsFractions && w.value.fraction) {
              let [S, T] = z(w.value.fraction, "/");
              if (!E(S) || !E(T))
                return;
              C = `calc(${w.value.fraction} * 100%)`;
            }
            if (C === null && A && p.handleNegativeBareValue) {
              if (C = p.handleNegativeBareValue(w.value), !C?.includes("/") && w.modifier)
                return;
              if (C !== null)
                return p.handle(C, null);
            }
            if (C === null && p.handleBareValue && (C = p.handleBareValue(w.value), !C?.includes("/") && w.modifier))
              return;
          }
        else {
          if (w.modifier)
            return;
          C = p.defaultValue !== undefined ? p.defaultValue : t.resolve(null, p.themeKeys ?? []);
        }
        if (C !== null)
          return p.handle(A ? `calc(${C} * -1)` : C, P);
      };
    }
    p.supportsNegative && r.functional(`-${n}`, h({ negative: true })), r.functional(n, h({ negative: false })), o(n, () => [{ supportsNegative: p.supportsNegative, valueThemeKeys: p.themeKeys ?? [], hasDefaultValue: p.defaultValue !== undefined && p.defaultValue !== null, supportsFractions: p.supportsFractions }]);
  }
  function s(n, p) {
    r.functional(n, (h) => {
      if (!h.value)
        return;
      let A = null;
      if (h.value.kind === "arbitrary" ? (A = h.value.value, A = Z(A, h.modifier, t)) : A = te(h, t, p.themeKeys), A !== null)
        return p.handle(A);
    }), o(n, () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: p.themeKeys, modifiers: Array.from({ length: 21 }, (h, A) => `${A * 5}`) }]);
  }
  function a(n, p, h, { supportsNegative: A = false, supportsFractions: w = false } = {}) {
    A && r.static(`-${n}-px`, () => h("-1px")), r.static(`${n}-px`, () => h("1px")), i(n, { themeKeys: p, supportsFractions: w, supportsNegative: A, defaultValue: null, handleBareValue: ({ value: C }) => {
      let P = t.resolve(null, ["--spacing"]);
      return !P || !xe(C) ? null : `calc(${P} * ${C})`;
    }, handleNegativeBareValue: ({ value: C }) => {
      let P = t.resolve(null, ["--spacing"]);
      return !P || !xe(C) ? null : `calc(${P} * -${C})`;
    }, handle: h }), o(n, () => [{ values: t.get(["--spacing"]) ? at : [], supportsNegative: A, supportsFractions: w, valueThemeKeys: p }]);
  }
  e("sr-only", [["position", "absolute"], ["width", "1px"], ["height", "1px"], ["padding", "0"], ["margin", "-1px"], ["overflow", "hidden"], ["clip", "rect(0, 0, 0, 0)"], ["white-space", "nowrap"], ["border-width", "0"]]), e("not-sr-only", [["position", "static"], ["width", "auto"], ["height", "auto"], ["padding", "0"], ["margin", "0"], ["overflow", "visible"], ["clip", "auto"], ["white-space", "normal"]]), e("pointer-events-none", [["pointer-events", "none"]]), e("pointer-events-auto", [["pointer-events", "auto"]]), e("visible", [["visibility", "visible"]]), e("invisible", [["visibility", "hidden"]]), e("collapse", [["visibility", "collapse"]]), e("static", [["position", "static"]]), e("fixed", [["position", "fixed"]]), e("absolute", [["position", "absolute"]]), e("relative", [["position", "relative"]]), e("sticky", [["position", "sticky"]]);
  for (let [n, p] of [["inset", "inset"], ["inset-x", "inset-inline"], ["inset-y", "inset-block"], ["start", "inset-inline-start"], ["end", "inset-inline-end"], ["top", "top"], ["right", "right"], ["bottom", "bottom"], ["left", "left"]])
    e(`${n}-auto`, [[p, "auto"]]), e(`${n}-full`, [[p, "100%"]]), e(`-${n}-full`, [[p, "-100%"]]), a(n, ["--inset", "--spacing"], (h) => [l(p, h)], { supportsNegative: true, supportsFractions: true });
  e("isolate", [["isolation", "isolate"]]), e("isolation-auto", [["isolation", "auto"]]), e("z-auto", [["z-index", "auto"]]), i("z", { supportsNegative: true, handleBareValue: ({ value: n }) => E(n) ? n : null, themeKeys: ["--z-index"], handle: (n) => [l("z-index", n)] }), o("z", () => [{ supportsNegative: true, values: ["0", "10", "20", "30", "40", "50"], valueThemeKeys: ["--z-index"] }]), e("order-first", [["order", "-9999"]]), e("order-last", [["order", "9999"]]), e("order-none", [["order", "0"]]), i("order", { supportsNegative: true, handleBareValue: ({ value: n }) => E(n) ? n : null, themeKeys: ["--order"], handle: (n) => [l("order", n)] }), o("order", () => [{ supportsNegative: true, values: Array.from({ length: 12 }, (n, p) => `${p + 1}`), valueThemeKeys: ["--order"] }]), e("col-auto", [["grid-column", "auto"]]), i("col", { supportsNegative: true, handleBareValue: ({ value: n }) => E(n) ? n : null, themeKeys: ["--grid-column"], handle: (n) => [l("grid-column", n)] }), e("col-span-full", [["grid-column", "1 / -1"]]), i("col-span", { handleBareValue: ({ value: n }) => E(n) ? n : null, handle: (n) => [l("grid-column", `span ${n} / span ${n}`)] }), e("col-start-auto", [["grid-column-start", "auto"]]), i("col-start", { supportsNegative: true, handleBareValue: ({ value: n }) => E(n) ? n : null, themeKeys: ["--grid-column-start"], handle: (n) => [l("grid-column-start", n)] }), e("col-end-auto", [["grid-column-end", "auto"]]), i("col-end", { supportsNegative: true, handleBareValue: ({ value: n }) => E(n) ? n : null, themeKeys: ["--grid-column-end"], handle: (n) => [l("grid-column-end", n)] }), o("col-span", () => [{ values: Array.from({ length: 12 }, (n, p) => `${p + 1}`), valueThemeKeys: [] }]), o("col-start", () => [{ supportsNegative: true, values: Array.from({ length: 13 }, (n, p) => `${p + 1}`), valueThemeKeys: ["--grid-column-start"] }]), o("col-end", () => [{ supportsNegative: true, values: Array.from({ length: 13 }, (n, p) => `${p + 1}`), valueThemeKeys: ["--grid-column-end"] }]), e("row-auto", [["grid-row", "auto"]]), i("row", { supportsNegative: true, handleBareValue: ({ value: n }) => E(n) ? n : null, themeKeys: ["--grid-row"], handle: (n) => [l("grid-row", n)] }), e("row-span-full", [["grid-row", "1 / -1"]]), i("row-span", { themeKeys: [], handleBareValue: ({ value: n }) => E(n) ? n : null, handle: (n) => [l("grid-row", `span ${n} / span ${n}`)] }), e("row-start-auto", [["grid-row-start", "auto"]]), i("row-start", { supportsNegative: true, handleBareValue: ({ value: n }) => E(n) ? n : null, themeKeys: ["--grid-row-start"], handle: (n) => [l("grid-row-start", n)] }), e("row-end-auto", [["grid-row-end", "auto"]]), i("row-end", { supportsNegative: true, handleBareValue: ({ value: n }) => E(n) ? n : null, themeKeys: ["--grid-row-end"], handle: (n) => [l("grid-row-end", n)] }), o("row-span", () => [{ values: Array.from({ length: 12 }, (n, p) => `${p + 1}`), valueThemeKeys: [] }]), o("row-start", () => [{ supportsNegative: true, values: Array.from({ length: 13 }, (n, p) => `${p + 1}`), valueThemeKeys: ["--grid-row-start"] }]), o("row-end", () => [{ supportsNegative: true, values: Array.from({ length: 13 }, (n, p) => `${p + 1}`), valueThemeKeys: ["--grid-row-end"] }]), e("float-start", [["float", "inline-start"]]), e("float-end", [["float", "inline-end"]]), e("float-right", [["float", "right"]]), e("float-left", [["float", "left"]]), e("float-none", [["float", "none"]]), e("clear-start", [["clear", "inline-start"]]), e("clear-end", [["clear", "inline-end"]]), e("clear-right", [["clear", "right"]]), e("clear-left", [["clear", "left"]]), e("clear-both", [["clear", "both"]]), e("clear-none", [["clear", "none"]]);
  for (let [n, p] of [["m", "margin"], ["mx", "margin-inline"], ["my", "margin-block"], ["ms", "margin-inline-start"], ["me", "margin-inline-end"], ["mt", "margin-top"], ["mr", "margin-right"], ["mb", "margin-bottom"], ["ml", "margin-left"]])
    e(`${n}-auto`, [[p, "auto"]]), a(n, ["--margin", "--spacing"], (h) => [l(p, h)], { supportsNegative: true });
  e("box-border", [["box-sizing", "border-box"]]), e("box-content", [["box-sizing", "content-box"]]), e("line-clamp-none", [["overflow", "visible"], ["display", "block"], ["-webkit-box-orient", "horizontal"], ["-webkit-line-clamp", "unset"]]), i("line-clamp", { themeKeys: ["--line-clamp"], handleBareValue: ({ value: n }) => E(n) ? n : null, handle: (n) => [l("overflow", "hidden"), l("display", "-webkit-box"), l("-webkit-box-orient", "vertical"), l("-webkit-line-clamp", n)] }), o("line-clamp", () => [{ values: ["1", "2", "3", "4", "5", "6"], valueThemeKeys: ["--line-clamp"] }]), e("block", [["display", "block"]]), e("inline-block", [["display", "inline-block"]]), e("inline", [["display", "inline"]]), e("hidden", [["display", "none"]]), e("inline-flex", [["display", "inline-flex"]]), e("table", [["display", "table"]]), e("inline-table", [["display", "inline-table"]]), e("table-caption", [["display", "table-caption"]]), e("table-cell", [["display", "table-cell"]]), e("table-column", [["display", "table-column"]]), e("table-column-group", [["display", "table-column-group"]]), e("table-footer-group", [["display", "table-footer-group"]]), e("table-header-group", [["display", "table-header-group"]]), e("table-row-group", [["display", "table-row-group"]]), e("table-row", [["display", "table-row"]]), e("flow-root", [["display", "flow-root"]]), e("flex", [["display", "flex"]]), e("grid", [["display", "grid"]]), e("inline-grid", [["display", "inline-grid"]]), e("contents", [["display", "contents"]]), e("list-item", [["display", "list-item"]]), e("field-sizing-content", [["field-sizing", "content"]]), e("field-sizing-fixed", [["field-sizing", "fixed"]]), e("aspect-auto", [["aspect-ratio", "auto"]]), e("aspect-square", [["aspect-ratio", "1 / 1"]]), i("aspect", { themeKeys: ["--aspect"], handleBareValue: ({ fraction: n }) => {
    if (n === null)
      return null;
    let [p, h] = z(n, "/");
    return !E(p) || !E(h) ? null : n;
  }, handle: (n) => [l("aspect-ratio", n)] });
  for (let [n, p] of [["full", "100%"], ["svw", "100svw"], ["lvw", "100lvw"], ["dvw", "100dvw"], ["svh", "100svh"], ["lvh", "100lvh"], ["dvh", "100dvh"], ["min", "min-content"], ["max", "max-content"], ["fit", "fit-content"]])
    e(`size-${n}`, [["--tw-sort", "size"], ["width", p], ["height", p]]), e(`w-${n}`, [["width", p]]), e(`h-${n}`, [["height", p]]), e(`min-w-${n}`, [["min-width", p]]), e(`min-h-${n}`, [["min-height", p]]), e(`max-w-${n}`, [["max-width", p]]), e(`max-h-${n}`, [["max-height", p]]);
  e("size-auto", [["--tw-sort", "size"], ["width", "auto"], ["height", "auto"]]), e("w-auto", [["width", "auto"]]), e("h-auto", [["height", "auto"]]), e("min-w-auto", [["min-width", "auto"]]), e("min-h-auto", [["min-height", "auto"]]), e("h-lh", [["height", "1lh"]]), e("min-h-lh", [["min-height", "1lh"]]), e("max-h-lh", [["max-height", "1lh"]]), e("w-screen", [["width", "100vw"]]), e("min-w-screen", [["min-width", "100vw"]]), e("max-w-screen", [["max-width", "100vw"]]), e("h-screen", [["height", "100vh"]]), e("min-h-screen", [["min-height", "100vh"]]), e("max-h-screen", [["max-height", "100vh"]]), e("max-w-none", [["max-width", "none"]]), e("max-h-none", [["max-height", "none"]]), a("size", ["--size", "--spacing"], (n) => [l("--tw-sort", "size"), l("width", n), l("height", n)], { supportsFractions: true });
  for (let [n, p, h] of [["w", ["--width", "--spacing", "--container"], "width"], ["min-w", ["--min-width", "--spacing", "--container"], "min-width"], ["max-w", ["--max-width", "--spacing", "--container"], "max-width"], ["h", ["--height", "--spacing"], "height"], ["min-h", ["--min-height", "--height", "--spacing"], "min-height"], ["max-h", ["--max-height", "--height", "--spacing"], "max-height"]])
    a(n, p, (A) => [l(h, A)], { supportsFractions: true });
  r.static("container", () => {
    let n = [...t.namespace("--breakpoint").values()];
    n.sort((h, A) => ye(h, A, "asc"));
    let p = [l("--tw-sort", "--tw-container-component"), l("width", "100%")];
    for (let h of n)
      p.push(F("@media", `(width >= ${h})`, [l("max-width", h)]));
    return p;
  }), e("flex-auto", [["flex", "auto"]]), e("flex-initial", [["flex", "0 auto"]]), e("flex-none", [["flex", "none"]]), r.functional("flex", (n) => {
    if (n.value) {
      if (n.value.kind === "arbitrary")
        return n.modifier ? undefined : [l("flex", n.value.value)];
      if (n.value.fraction) {
        let [p, h] = z(n.value.fraction, "/");
        return !E(p) || !E(h) ? undefined : [l("flex", `calc(${n.value.fraction} * 100%)`)];
      }
      if (E(n.value.value))
        return n.modifier ? undefined : [l("flex", n.value.value)];
    }
  }), o("flex", () => [{ supportsFractions: true }]), i("shrink", { defaultValue: "1", handleBareValue: ({ value: n }) => E(n) ? n : null, handle: (n) => [l("flex-shrink", n)] }), i("grow", { defaultValue: "1", handleBareValue: ({ value: n }) => E(n) ? n : null, handle: (n) => [l("flex-grow", n)] }), o("shrink", () => [{ values: ["0"], valueThemeKeys: [], hasDefaultValue: true }]), o("grow", () => [{ values: ["0"], valueThemeKeys: [], hasDefaultValue: true }]), e("basis-auto", [["flex-basis", "auto"]]), e("basis-full", [["flex-basis", "100%"]]), a("basis", ["--flex-basis", "--spacing", "--container"], (n) => [l("flex-basis", n)], { supportsFractions: true }), e("table-auto", [["table-layout", "auto"]]), e("table-fixed", [["table-layout", "fixed"]]), e("caption-top", [["caption-side", "top"]]), e("caption-bottom", [["caption-side", "bottom"]]), e("border-collapse", [["border-collapse", "collapse"]]), e("border-separate", [["border-collapse", "separate"]]);
  let f = () => j([$("--tw-border-spacing-x", "0", "<length>"), $("--tw-border-spacing-y", "0", "<length>")]);
  a("border-spacing", ["--border-spacing", "--spacing"], (n) => [f(), l("--tw-border-spacing-x", n), l("--tw-border-spacing-y", n), l("border-spacing", "var(--tw-border-spacing-x) var(--tw-border-spacing-y)")]), a("border-spacing-x", ["--border-spacing", "--spacing"], (n) => [f(), l("--tw-border-spacing-x", n), l("border-spacing", "var(--tw-border-spacing-x) var(--tw-border-spacing-y)")]), a("border-spacing-y", ["--border-spacing", "--spacing"], (n) => [f(), l("--tw-border-spacing-y", n), l("border-spacing", "var(--tw-border-spacing-x) var(--tw-border-spacing-y)")]), e("origin-center", [["transform-origin", "center"]]), e("origin-top", [["transform-origin", "top"]]), e("origin-top-right", [["transform-origin", "top right"]]), e("origin-right", [["transform-origin", "right"]]), e("origin-bottom-right", [["transform-origin", "bottom right"]]), e("origin-bottom", [["transform-origin", "bottom"]]), e("origin-bottom-left", [["transform-origin", "bottom left"]]), e("origin-left", [["transform-origin", "left"]]), e("origin-top-left", [["transform-origin", "top left"]]), i("origin", { themeKeys: ["--transform-origin"], handle: (n) => [l("transform-origin", n)] }), e("perspective-origin-center", [["perspective-origin", "center"]]), e("perspective-origin-top", [["perspective-origin", "top"]]), e("perspective-origin-top-right", [["perspective-origin", "top right"]]), e("perspective-origin-right", [["perspective-origin", "right"]]), e("perspective-origin-bottom-right", [["perspective-origin", "bottom right"]]), e("perspective-origin-bottom", [["perspective-origin", "bottom"]]), e("perspective-origin-bottom-left", [["perspective-origin", "bottom left"]]), e("perspective-origin-left", [["perspective-origin", "left"]]), e("perspective-origin-top-left", [["perspective-origin", "top left"]]), i("perspective-origin", { themeKeys: ["--perspective-origin"], handle: (n) => [l("perspective-origin", n)] }), e("perspective-none", [["perspective", "none"]]), i("perspective", { themeKeys: ["--perspective"], handle: (n) => [l("perspective", n)] });
  let u = () => j([$("--tw-translate-x", "0"), $("--tw-translate-y", "0"), $("--tw-translate-z", "0")]);
  e("translate-none", [["translate", "none"]]), e("-translate-full", [u, ["--tw-translate-x", "-100%"], ["--tw-translate-y", "-100%"], ["translate", "var(--tw-translate-x) var(--tw-translate-y)"]]), e("translate-full", [u, ["--tw-translate-x", "100%"], ["--tw-translate-y", "100%"], ["translate", "var(--tw-translate-x) var(--tw-translate-y)"]]), a("translate", ["--translate", "--spacing"], (n) => [u(), l("--tw-translate-x", n), l("--tw-translate-y", n), l("translate", "var(--tw-translate-x) var(--tw-translate-y)")], { supportsNegative: true, supportsFractions: true });
  for (let n of ["x", "y"])
    e(`-translate-${n}-full`, [u, [`--tw-translate-${n}`, "-100%"], ["translate", "var(--tw-translate-x) var(--tw-translate-y)"]]), e(`translate-${n}-full`, [u, [`--tw-translate-${n}`, "100%"], ["translate", "var(--tw-translate-x) var(--tw-translate-y)"]]), a(`translate-${n}`, ["--translate", "--spacing"], (p) => [u(), l(`--tw-translate-${n}`, p), l("translate", "var(--tw-translate-x) var(--tw-translate-y)")], { supportsNegative: true, supportsFractions: true });
  a("translate-z", ["--translate", "--spacing"], (n) => [u(), l("--tw-translate-z", n), l("translate", "var(--tw-translate-x) var(--tw-translate-y) var(--tw-translate-z)")], { supportsNegative: true }), e("translate-3d", [u, ["translate", "var(--tw-translate-x) var(--tw-translate-y) var(--tw-translate-z)"]]);
  let c = () => j([$("--tw-scale-x", "1"), $("--tw-scale-y", "1"), $("--tw-scale-z", "1")]);
  e("scale-none", [["scale", "none"]]);
  function g({ negative: n }) {
    return (p) => {
      if (!p.value || p.modifier)
        return;
      let h;
      return p.value.kind === "arbitrary" ? (h = p.value.value, h = n ? `calc(${h} * -1)` : h, [l("scale", h)]) : (h = t.resolve(p.value.value, ["--scale"]), !h && E(p.value.value) && (h = `${p.value.value}%`), h ? (h = n ? `calc(${h} * -1)` : h, [c(), l("--tw-scale-x", h), l("--tw-scale-y", h), l("--tw-scale-z", h), l("scale", "var(--tw-scale-x) var(--tw-scale-y)")]) : undefined);
    };
  }
  r.functional("-scale", g({ negative: true })), r.functional("scale", g({ negative: false })), o("scale", () => [{ supportsNegative: true, values: ["0", "50", "75", "90", "95", "100", "105", "110", "125", "150", "200"], valueThemeKeys: ["--scale"] }]);
  for (let n of ["x", "y", "z"])
    i(`scale-${n}`, { supportsNegative: true, themeKeys: ["--scale"], handleBareValue: ({ value: p }) => E(p) ? `${p}%` : null, handle: (p) => [c(), l(`--tw-scale-${n}`, p), l("scale", `var(--tw-scale-x) var(--tw-scale-y)${n === "z" ? " var(--tw-scale-z)" : ""}`)] }), o(`scale-${n}`, () => [{ supportsNegative: true, values: ["0", "50", "75", "90", "95", "100", "105", "110", "125", "150", "200"], valueThemeKeys: ["--scale"] }]);
  e("scale-3d", [c, ["scale", "var(--tw-scale-x) var(--tw-scale-y) var(--tw-scale-z)"]]), e("rotate-none", [["rotate", "none"]]);
  function d({ negative: n }) {
    return (p) => {
      if (!p.value || p.modifier)
        return;
      let h;
      if (p.value.kind === "arbitrary") {
        h = p.value.value;
        let A = p.value.dataType ?? Y(h, ["angle", "vector"]);
        if (A === "vector")
          return [l("rotate", `${h} var(--tw-rotate)`)];
        if (A !== "angle")
          return [l("rotate", n ? `calc(${h} * -1)` : h)];
      } else if (h = t.resolve(p.value.value, ["--rotate"]), !h && E(p.value.value) && (h = `${p.value.value}deg`), !h)
        return;
      return [l("rotate", n ? `calc(${h} * -1)` : h)];
    };
  }
  r.functional("-rotate", d({ negative: true })), r.functional("rotate", d({ negative: false })), o("rotate", () => [{ supportsNegative: true, values: ["0", "1", "2", "3", "6", "12", "45", "90", "180"], valueThemeKeys: ["--rotate"] }]);
  {
    let n = ["var(--tw-rotate-x,)", "var(--tw-rotate-y,)", "var(--tw-rotate-z,)", "var(--tw-skew-x,)", "var(--tw-skew-y,)"].join(" "), p = () => j([$("--tw-rotate-x"), $("--tw-rotate-y"), $("--tw-rotate-z"), $("--tw-skew-x"), $("--tw-skew-y")]);
    for (let h of ["x", "y", "z"])
      i(`rotate-${h}`, { supportsNegative: true, themeKeys: ["--rotate"], handleBareValue: ({ value: A }) => E(A) ? `${A}deg` : null, handle: (A) => [p(), l(`--tw-rotate-${h}`, `rotate${h.toUpperCase()}(${A})`), l("transform", n)] }), o(`rotate-${h}`, () => [{ supportsNegative: true, values: ["0", "1", "2", "3", "6", "12", "45", "90", "180"], valueThemeKeys: ["--rotate"] }]);
    i("skew", { supportsNegative: true, themeKeys: ["--skew"], handleBareValue: ({ value: h }) => E(h) ? `${h}deg` : null, handle: (h) => [p(), l("--tw-skew-x", `skewX(${h})`), l("--tw-skew-y", `skewY(${h})`), l("transform", n)] }), i("skew-x", { supportsNegative: true, themeKeys: ["--skew"], handleBareValue: ({ value: h }) => E(h) ? `${h}deg` : null, handle: (h) => [p(), l("--tw-skew-x", `skewX(${h})`), l("transform", n)] }), i("skew-y", { supportsNegative: true, themeKeys: ["--skew"], handleBareValue: ({ value: h }) => E(h) ? `${h}deg` : null, handle: (h) => [p(), l("--tw-skew-y", `skewY(${h})`), l("transform", n)] }), o("skew", () => [{ supportsNegative: true, values: ["0", "1", "2", "3", "6", "12"], valueThemeKeys: ["--skew"] }]), o("skew-x", () => [{ supportsNegative: true, values: ["0", "1", "2", "3", "6", "12"], valueThemeKeys: ["--skew"] }]), o("skew-y", () => [{ supportsNegative: true, values: ["0", "1", "2", "3", "6", "12"], valueThemeKeys: ["--skew"] }]), r.functional("transform", (h) => {
      if (h.modifier)
        return;
      let A = null;
      if (h.value ? h.value.kind === "arbitrary" && (A = h.value.value) : A = n, A !== null)
        return [p(), l("transform", A)];
    }), o("transform", () => [{ hasDefaultValue: true }]), e("transform-cpu", [["transform", n]]), e("transform-gpu", [["transform", `translateZ(0) ${n}`]]), e("transform-none", [["transform", "none"]]);
  }
  e("transform-flat", [["transform-style", "flat"]]), e("transform-3d", [["transform-style", "preserve-3d"]]), e("transform-content", [["transform-box", "content-box"]]), e("transform-border", [["transform-box", "border-box"]]), e("transform-fill", [["transform-box", "fill-box"]]), e("transform-stroke", [["transform-box", "stroke-box"]]), e("transform-view", [["transform-box", "view-box"]]), e("backface-visible", [["backface-visibility", "visible"]]), e("backface-hidden", [["backface-visibility", "hidden"]]);
  for (let n of ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"])
    e(`cursor-${n}`, [["cursor", n]]);
  i("cursor", { themeKeys: ["--cursor"], handle: (n) => [l("cursor", n)] });
  for (let n of ["auto", "none", "manipulation"])
    e(`touch-${n}`, [["touch-action", n]]);
  let m = () => j([$("--tw-pan-x"), $("--tw-pan-y"), $("--tw-pinch-zoom")]);
  for (let n of ["x", "left", "right"])
    e(`touch-pan-${n}`, [m, ["--tw-pan-x", `pan-${n}`], ["touch-action", "var(--tw-pan-x,) var(--tw-pan-y,) var(--tw-pinch-zoom,)"]]);
  for (let n of ["y", "up", "down"])
    e(`touch-pan-${n}`, [m, ["--tw-pan-y", `pan-${n}`], ["touch-action", "var(--tw-pan-x,) var(--tw-pan-y,) var(--tw-pinch-zoom,)"]]);
  e("touch-pinch-zoom", [m, ["--tw-pinch-zoom", "pinch-zoom"], ["touch-action", "var(--tw-pan-x,) var(--tw-pan-y,) var(--tw-pinch-zoom,)"]]);
  for (let n of ["none", "text", "all", "auto"])
    e(`select-${n}`, [["-webkit-user-select", n], ["user-select", n]]);
  e("resize-none", [["resize", "none"]]), e("resize-x", [["resize", "horizontal"]]), e("resize-y", [["resize", "vertical"]]), e("resize", [["resize", "both"]]), e("snap-none", [["scroll-snap-type", "none"]]);
  let v = () => j([$("--tw-scroll-snap-strictness", "proximity", "*")]);
  for (let n of ["x", "y", "both"])
    e(`snap-${n}`, [v, ["scroll-snap-type", `${n} var(--tw-scroll-snap-strictness)`]]);
  e("snap-mandatory", [v, ["--tw-scroll-snap-strictness", "mandatory"]]), e("snap-proximity", [v, ["--tw-scroll-snap-strictness", "proximity"]]), e("snap-align-none", [["scroll-snap-align", "none"]]), e("snap-start", [["scroll-snap-align", "start"]]), e("snap-end", [["scroll-snap-align", "end"]]), e("snap-center", [["scroll-snap-align", "center"]]), e("snap-normal", [["scroll-snap-stop", "normal"]]), e("snap-always", [["scroll-snap-stop", "always"]]);
  for (let [n, p] of [["scroll-m", "scroll-margin"], ["scroll-mx", "scroll-margin-inline"], ["scroll-my", "scroll-margin-block"], ["scroll-ms", "scroll-margin-inline-start"], ["scroll-me", "scroll-margin-inline-end"], ["scroll-mt", "scroll-margin-top"], ["scroll-mr", "scroll-margin-right"], ["scroll-mb", "scroll-margin-bottom"], ["scroll-ml", "scroll-margin-left"]])
    a(n, ["--scroll-margin", "--spacing"], (h) => [l(p, h)], { supportsNegative: true });
  for (let [n, p] of [["scroll-p", "scroll-padding"], ["scroll-px", "scroll-padding-inline"], ["scroll-py", "scroll-padding-block"], ["scroll-ps", "scroll-padding-inline-start"], ["scroll-pe", "scroll-padding-inline-end"], ["scroll-pt", "scroll-padding-top"], ["scroll-pr", "scroll-padding-right"], ["scroll-pb", "scroll-padding-bottom"], ["scroll-pl", "scroll-padding-left"]])
    a(n, ["--scroll-padding", "--spacing"], (h) => [l(p, h)]);
  e("list-inside", [["list-style-position", "inside"]]), e("list-outside", [["list-style-position", "outside"]]), e("list-none", [["list-style-type", "none"]]), e("list-disc", [["list-style-type", "disc"]]), e("list-decimal", [["list-style-type", "decimal"]]), i("list", { themeKeys: ["--list-style-type"], handle: (n) => [l("list-style-type", n)] }), e("list-image-none", [["list-style-image", "none"]]), i("list-image", { themeKeys: ["--list-style-image"], handle: (n) => [l("list-style-image", n)] }), e("appearance-none", [["appearance", "none"]]), e("appearance-auto", [["appearance", "auto"]]), e("scheme-normal", [["color-scheme", "normal"]]), e("scheme-dark", [["color-scheme", "dark"]]), e("scheme-light", [["color-scheme", "light"]]), e("scheme-light-dark", [["color-scheme", "light dark"]]), e("scheme-only-dark", [["color-scheme", "only dark"]]), e("scheme-only-light", [["color-scheme", "only light"]]), e("columns-auto", [["columns", "auto"]]), i("columns", { themeKeys: ["--columns", "--container"], handleBareValue: ({ value: n }) => E(n) ? n : null, handle: (n) => [l("columns", n)] }), o("columns", () => [{ values: Array.from({ length: 12 }, (n, p) => `${p + 1}`), valueThemeKeys: ["--columns", "--container"] }]);
  for (let n of ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"])
    e(`break-before-${n}`, [["break-before", n]]);
  for (let n of ["auto", "avoid", "avoid-page", "avoid-column"])
    e(`break-inside-${n}`, [["break-inside", n]]);
  for (let n of ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"])
    e(`break-after-${n}`, [["break-after", n]]);
  e("grid-flow-row", [["grid-auto-flow", "row"]]), e("grid-flow-col", [["grid-auto-flow", "column"]]), e("grid-flow-dense", [["grid-auto-flow", "dense"]]), e("grid-flow-row-dense", [["grid-auto-flow", "row dense"]]), e("grid-flow-col-dense", [["grid-auto-flow", "column dense"]]), e("auto-cols-auto", [["grid-auto-columns", "auto"]]), e("auto-cols-min", [["grid-auto-columns", "min-content"]]), e("auto-cols-max", [["grid-auto-columns", "max-content"]]), e("auto-cols-fr", [["grid-auto-columns", "minmax(0, 1fr)"]]), i("auto-cols", { themeKeys: ["--grid-auto-columns"], handle: (n) => [l("grid-auto-columns", n)] }), e("auto-rows-auto", [["grid-auto-rows", "auto"]]), e("auto-rows-min", [["grid-auto-rows", "min-content"]]), e("auto-rows-max", [["grid-auto-rows", "max-content"]]), e("auto-rows-fr", [["grid-auto-rows", "minmax(0, 1fr)"]]), i("auto-rows", { themeKeys: ["--grid-auto-rows"], handle: (n) => [l("grid-auto-rows", n)] }), e("grid-cols-none", [["grid-template-columns", "none"]]), e("grid-cols-subgrid", [["grid-template-columns", "subgrid"]]), i("grid-cols", { themeKeys: ["--grid-template-columns"], handleBareValue: ({ value: n }) => Ot(n) ? `repeat(${n}, minmax(0, 1fr))` : null, handle: (n) => [l("grid-template-columns", n)] }), e("grid-rows-none", [["grid-template-rows", "none"]]), e("grid-rows-subgrid", [["grid-template-rows", "subgrid"]]), i("grid-rows", { themeKeys: ["--grid-template-rows"], handleBareValue: ({ value: n }) => Ot(n) ? `repeat(${n}, minmax(0, 1fr))` : null, handle: (n) => [l("grid-template-rows", n)] }), o("grid-cols", () => [{ values: Array.from({ length: 12 }, (n, p) => `${p + 1}`), valueThemeKeys: ["--grid-template-columns"] }]), o("grid-rows", () => [{ values: Array.from({ length: 12 }, (n, p) => `${p + 1}`), valueThemeKeys: ["--grid-template-rows"] }]), e("flex-row", [["flex-direction", "row"]]), e("flex-row-reverse", [["flex-direction", "row-reverse"]]), e("flex-col", [["flex-direction", "column"]]), e("flex-col-reverse", [["flex-direction", "column-reverse"]]), e("flex-wrap", [["flex-wrap", "wrap"]]), e("flex-nowrap", [["flex-wrap", "nowrap"]]), e("flex-wrap-reverse", [["flex-wrap", "wrap-reverse"]]), e("place-content-center", [["place-content", "center"]]), e("place-content-start", [["place-content", "start"]]), e("place-content-end", [["place-content", "end"]]), e("place-content-center-safe", [["place-content", "safe center"]]), e("place-content-end-safe", [["place-content", "safe end"]]), e("place-content-between", [["place-content", "space-between"]]), e("place-content-around", [["place-content", "space-around"]]), e("place-content-evenly", [["place-content", "space-evenly"]]), e("place-content-baseline", [["place-content", "baseline"]]), e("place-content-stretch", [["place-content", "stretch"]]), e("place-items-center", [["place-items", "center"]]), e("place-items-start", [["place-items", "start"]]), e("place-items-end", [["place-items", "end"]]), e("place-items-center-safe", [["place-items", "safe center"]]), e("place-items-end-safe", [["place-items", "safe end"]]), e("place-items-baseline", [["place-items", "baseline"]]), e("place-items-stretch", [["place-items", "stretch"]]), e("content-normal", [["align-content", "normal"]]), e("content-center", [["align-content", "center"]]), e("content-start", [["align-content", "flex-start"]]), e("content-end", [["align-content", "flex-end"]]), e("content-center-safe", [["align-content", "safe center"]]), e("content-end-safe", [["align-content", "safe flex-end"]]), e("content-between", [["align-content", "space-between"]]), e("content-around", [["align-content", "space-around"]]), e("content-evenly", [["align-content", "space-evenly"]]), e("content-baseline", [["align-content", "baseline"]]), e("content-stretch", [["align-content", "stretch"]]), e("items-center", [["align-items", "center"]]), e("items-start", [["align-items", "flex-start"]]), e("items-end", [["align-items", "flex-end"]]), e("items-center-safe", [["align-items", "safe center"]]), e("items-end-safe", [["align-items", "safe flex-end"]]), e("items-baseline", [["align-items", "baseline"]]), e("items-baseline-last", [["align-items", "last baseline"]]), e("items-stretch", [["align-items", "stretch"]]), e("justify-normal", [["justify-content", "normal"]]), e("justify-center", [["justify-content", "center"]]), e("justify-start", [["justify-content", "flex-start"]]), e("justify-end", [["justify-content", "flex-end"]]), e("justify-center-safe", [["justify-content", "safe center"]]), e("justify-end-safe", [["justify-content", "safe flex-end"]]), e("justify-between", [["justify-content", "space-between"]]), e("justify-around", [["justify-content", "space-around"]]), e("justify-evenly", [["justify-content", "space-evenly"]]), e("justify-baseline", [["justify-content", "baseline"]]), e("justify-stretch", [["justify-content", "stretch"]]), e("justify-items-normal", [["justify-items", "normal"]]), e("justify-items-center", [["justify-items", "center"]]), e("justify-items-start", [["justify-items", "start"]]), e("justify-items-end", [["justify-items", "end"]]), e("justify-items-center-safe", [["justify-items", "safe center"]]), e("justify-items-end-safe", [["justify-items", "safe end"]]), e("justify-items-stretch", [["justify-items", "stretch"]]), a("gap", ["--gap", "--spacing"], (n) => [l("gap", n)]), a("gap-x", ["--gap", "--spacing"], (n) => [l("column-gap", n)]), a("gap-y", ["--gap", "--spacing"], (n) => [l("row-gap", n)]), a("space-x", ["--space", "--spacing"], (n) => [j([$("--tw-space-x-reverse", "0")]), M(":where(& > :not(:last-child))", [l("--tw-sort", "row-gap"), l("--tw-space-x-reverse", "0"), l("margin-inline-start", `calc(${n} * var(--tw-space-x-reverse))`), l("margin-inline-end", `calc(${n} * calc(1 - var(--tw-space-x-reverse)))`)])], { supportsNegative: true }), a("space-y", ["--space", "--spacing"], (n) => [j([$("--tw-space-y-reverse", "0")]), M(":where(& > :not(:last-child))", [l("--tw-sort", "column-gap"), l("--tw-space-y-reverse", "0"), l("margin-block-start", `calc(${n} * var(--tw-space-y-reverse))`), l("margin-block-end", `calc(${n} * calc(1 - var(--tw-space-y-reverse)))`)])], { supportsNegative: true }), e("space-x-reverse", [() => j([$("--tw-space-x-reverse", "0")]), () => M(":where(& > :not(:last-child))", [l("--tw-sort", "row-gap"), l("--tw-space-x-reverse", "1")])]), e("space-y-reverse", [() => j([$("--tw-space-y-reverse", "0")]), () => M(":where(& > :not(:last-child))", [l("--tw-sort", "column-gap"), l("--tw-space-y-reverse", "1")])]), e("accent-auto", [["accent-color", "auto"]]), s("accent", { themeKeys: ["--accent-color", "--color"], handle: (n) => [l("accent-color", n)] }), s("caret", { themeKeys: ["--caret-color", "--color"], handle: (n) => [l("caret-color", n)] }), s("divide", { themeKeys: ["--divide-color", "--color"], handle: (n) => [M(":where(& > :not(:last-child))", [l("--tw-sort", "divide-color"), l("border-color", n)])] }), e("place-self-auto", [["place-self", "auto"]]), e("place-self-start", [["place-self", "start"]]), e("place-self-end", [["place-self", "end"]]), e("place-self-center", [["place-self", "center"]]), e("place-self-end-safe", [["place-self", "safe end"]]), e("place-self-center-safe", [["place-self", "safe center"]]), e("place-self-stretch", [["place-self", "stretch"]]), e("self-auto", [["align-self", "auto"]]), e("self-start", [["align-self", "flex-start"]]), e("self-end", [["align-self", "flex-end"]]), e("self-center", [["align-self", "center"]]), e("self-end-safe", [["align-self", "safe flex-end"]]), e("self-center-safe", [["align-self", "safe center"]]), e("self-stretch", [["align-self", "stretch"]]), e("self-baseline", [["align-self", "baseline"]]), e("self-baseline-last", [["align-self", "last baseline"]]), e("justify-self-auto", [["justify-self", "auto"]]), e("justify-self-start", [["justify-self", "flex-start"]]), e("justify-self-end", [["justify-self", "flex-end"]]), e("justify-self-center", [["justify-self", "center"]]), e("justify-self-end-safe", [["justify-self", "safe flex-end"]]), e("justify-self-center-safe", [["justify-self", "safe center"]]), e("justify-self-stretch", [["justify-self", "stretch"]]);
  for (let n of ["auto", "hidden", "clip", "visible", "scroll"])
    e(`overflow-${n}`, [["overflow", n]]), e(`overflow-x-${n}`, [["overflow-x", n]]), e(`overflow-y-${n}`, [["overflow-y", n]]);
  for (let n of ["auto", "contain", "none"])
    e(`overscroll-${n}`, [["overscroll-behavior", n]]), e(`overscroll-x-${n}`, [["overscroll-behavior-x", n]]), e(`overscroll-y-${n}`, [["overscroll-behavior-y", n]]);
  e("scroll-auto", [["scroll-behavior", "auto"]]), e("scroll-smooth", [["scroll-behavior", "smooth"]]), e("truncate", [["overflow", "hidden"], ["text-overflow", "ellipsis"], ["white-space", "nowrap"]]), e("text-ellipsis", [["text-overflow", "ellipsis"]]), e("text-clip", [["text-overflow", "clip"]]), e("hyphens-none", [["-webkit-hyphens", "none"], ["hyphens", "none"]]), e("hyphens-manual", [["-webkit-hyphens", "manual"], ["hyphens", "manual"]]), e("hyphens-auto", [["-webkit-hyphens", "auto"], ["hyphens", "auto"]]), e("whitespace-normal", [["white-space", "normal"]]), e("whitespace-nowrap", [["white-space", "nowrap"]]), e("whitespace-pre", [["white-space", "pre"]]), e("whitespace-pre-line", [["white-space", "pre-line"]]), e("whitespace-pre-wrap", [["white-space", "pre-wrap"]]), e("whitespace-break-spaces", [["white-space", "break-spaces"]]), e("text-wrap", [["text-wrap", "wrap"]]), e("text-nowrap", [["text-wrap", "nowrap"]]), e("text-balance", [["text-wrap", "balance"]]), e("text-pretty", [["text-wrap", "pretty"]]), e("break-normal", [["overflow-wrap", "normal"], ["word-break", "normal"]]), e("break-words", [["overflow-wrap", "break-word"]]), e("break-all", [["word-break", "break-all"]]), e("break-keep", [["word-break", "keep-all"]]), e("wrap-anywhere", [["overflow-wrap", "anywhere"]]), e("wrap-break-word", [["overflow-wrap", "break-word"]]), e("wrap-normal", [["overflow-wrap", "normal"]]);
  for (let [n, p] of [["rounded", ["border-radius"]], ["rounded-s", ["border-start-start-radius", "border-end-start-radius"]], ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]], ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]], ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]], ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]], ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]], ["rounded-ss", ["border-start-start-radius"]], ["rounded-se", ["border-start-end-radius"]], ["rounded-ee", ["border-end-end-radius"]], ["rounded-es", ["border-end-start-radius"]], ["rounded-tl", ["border-top-left-radius"]], ["rounded-tr", ["border-top-right-radius"]], ["rounded-br", ["border-bottom-right-radius"]], ["rounded-bl", ["border-bottom-left-radius"]]])
    e(`${n}-none`, p.map((h) => [h, "0"])), e(`${n}-full`, p.map((h) => [h, "calc(infinity * 1px)"])), i(n, { themeKeys: ["--radius"], handle: (h) => p.map((A) => l(A, h)) });
  e("border-solid", [["--tw-border-style", "solid"], ["border-style", "solid"]]), e("border-dashed", [["--tw-border-style", "dashed"], ["border-style", "dashed"]]), e("border-dotted", [["--tw-border-style", "dotted"], ["border-style", "dotted"]]), e("border-double", [["--tw-border-style", "double"], ["border-style", "double"]]), e("border-hidden", [["--tw-border-style", "hidden"], ["border-style", "hidden"]]), e("border-none", [["--tw-border-style", "none"], ["border-style", "none"]]);
  {
    let p = function(h, A) {
      r.functional(h, (w) => {
        if (!w.value) {
          if (w.modifier)
            return;
          let C = t.get(["--default-border-width"]) ?? "1px", P = A.width(C);
          return P ? [n(), ...P] : undefined;
        }
        if (w.value.kind === "arbitrary") {
          let C = w.value.value;
          switch (w.value.dataType ?? Y(C, ["color", "line-width", "length"])) {
            case "line-width":
            case "length": {
              if (w.modifier)
                return;
              let S = A.width(C);
              return S ? [n(), ...S] : undefined;
            }
            default:
              return C = Z(C, w.modifier, t), C === null ? undefined : A.color(C);
          }
        }
        {
          let C = te(w, t, ["--border-color", "--color"]);
          if (C)
            return A.color(C);
        }
        {
          if (w.modifier)
            return;
          let C = t.resolve(w.value.value, ["--border-width"]);
          if (C) {
            let P = A.width(C);
            return P ? [n(), ...P] : undefined;
          }
          if (E(w.value.value)) {
            let P = A.width(`${w.value.value}px`);
            return P ? [n(), ...P] : undefined;
          }
        }
      }), o(h, () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--border-color", "--color"], modifiers: Array.from({ length: 21 }, (w, C) => `${C * 5}`), hasDefaultValue: true }, { values: ["0", "2", "4", "8"], valueThemeKeys: ["--border-width"] }]);
    };
    var O = p;
    let n = () => j([$("--tw-border-style", "solid")]);
    p("border", { width: (h) => [l("border-style", "var(--tw-border-style)"), l("border-width", h)], color: (h) => [l("border-color", h)] }), p("border-x", { width: (h) => [l("border-inline-style", "var(--tw-border-style)"), l("border-inline-width", h)], color: (h) => [l("border-inline-color", h)] }), p("border-y", { width: (h) => [l("border-block-style", "var(--tw-border-style)"), l("border-block-width", h)], color: (h) => [l("border-block-color", h)] }), p("border-s", { width: (h) => [l("border-inline-start-style", "var(--tw-border-style)"), l("border-inline-start-width", h)], color: (h) => [l("border-inline-start-color", h)] }), p("border-e", { width: (h) => [l("border-inline-end-style", "var(--tw-border-style)"), l("border-inline-end-width", h)], color: (h) => [l("border-inline-end-color", h)] }), p("border-t", { width: (h) => [l("border-top-style", "var(--tw-border-style)"), l("border-top-width", h)], color: (h) => [l("border-top-color", h)] }), p("border-r", { width: (h) => [l("border-right-style", "var(--tw-border-style)"), l("border-right-width", h)], color: (h) => [l("border-right-color", h)] }), p("border-b", { width: (h) => [l("border-bottom-style", "var(--tw-border-style)"), l("border-bottom-width", h)], color: (h) => [l("border-bottom-color", h)] }), p("border-l", { width: (h) => [l("border-left-style", "var(--tw-border-style)"), l("border-left-width", h)], color: (h) => [l("border-left-color", h)] }), i("divide-x", { defaultValue: t.get(["--default-border-width"]) ?? "1px", themeKeys: ["--divide-width", "--border-width"], handleBareValue: ({ value: h }) => E(h) ? `${h}px` : null, handle: (h) => [j([$("--tw-divide-x-reverse", "0")]), M(":where(& > :not(:last-child))", [l("--tw-sort", "divide-x-width"), n(), l("--tw-divide-x-reverse", "0"), l("border-inline-style", "var(--tw-border-style)"), l("border-inline-start-width", `calc(${h} * var(--tw-divide-x-reverse))`), l("border-inline-end-width", `calc(${h} * calc(1 - var(--tw-divide-x-reverse)))`)])] }), i("divide-y", { defaultValue: t.get(["--default-border-width"]) ?? "1px", themeKeys: ["--divide-width", "--border-width"], handleBareValue: ({ value: h }) => E(h) ? `${h}px` : null, handle: (h) => [j([$("--tw-divide-y-reverse", "0")]), M(":where(& > :not(:last-child))", [l("--tw-sort", "divide-y-width"), n(), l("--tw-divide-y-reverse", "0"), l("border-bottom-style", "var(--tw-border-style)"), l("border-top-style", "var(--tw-border-style)"), l("border-top-width", `calc(${h} * var(--tw-divide-y-reverse))`), l("border-bottom-width", `calc(${h} * calc(1 - var(--tw-divide-y-reverse)))`)])] }), o("divide-x", () => [{ values: ["0", "2", "4", "8"], valueThemeKeys: ["--divide-width", "--border-width"], hasDefaultValue: true }]), o("divide-y", () => [{ values: ["0", "2", "4", "8"], valueThemeKeys: ["--divide-width", "--border-width"], hasDefaultValue: true }]), e("divide-x-reverse", [() => j([$("--tw-divide-x-reverse", "0")]), () => M(":where(& > :not(:last-child))", [l("--tw-divide-x-reverse", "1")])]), e("divide-y-reverse", [() => j([$("--tw-divide-y-reverse", "0")]), () => M(":where(& > :not(:last-child))", [l("--tw-divide-y-reverse", "1")])]);
    for (let h of ["solid", "dashed", "dotted", "double", "none"])
      e(`divide-${h}`, [() => M(":where(& > :not(:last-child))", [l("--tw-sort", "divide-style"), l("--tw-border-style", h), l("border-style", h)])]);
  }
  e("bg-auto", [["background-size", "auto"]]), e("bg-cover", [["background-size", "cover"]]), e("bg-contain", [["background-size", "contain"]]), i("bg-size", { handle(n) {
    if (n)
      return [l("background-size", n)];
  } }), e("bg-fixed", [["background-attachment", "fixed"]]), e("bg-local", [["background-attachment", "local"]]), e("bg-scroll", [["background-attachment", "scroll"]]), e("bg-top", [["background-position", "top"]]), e("bg-top-left", [["background-position", "left top"]]), e("bg-top-right", [["background-position", "right top"]]), e("bg-bottom", [["background-position", "bottom"]]), e("bg-bottom-left", [["background-position", "left bottom"]]), e("bg-bottom-right", [["background-position", "right bottom"]]), e("bg-left", [["background-position", "left"]]), e("bg-right", [["background-position", "right"]]), e("bg-center", [["background-position", "center"]]), i("bg-position", { handle(n) {
    if (n)
      return [l("background-position", n)];
  } }), e("bg-repeat", [["background-repeat", "repeat"]]), e("bg-no-repeat", [["background-repeat", "no-repeat"]]), e("bg-repeat-x", [["background-repeat", "repeat-x"]]), e("bg-repeat-y", [["background-repeat", "repeat-y"]]), e("bg-repeat-round", [["background-repeat", "round"]]), e("bg-repeat-space", [["background-repeat", "space"]]), e("bg-none", [["background-image", "none"]]);
  {
    let h = function(C) {
      let P = "in oklab";
      if (C?.kind === "named")
        switch (C.value) {
          case "longer":
          case "shorter":
          case "increasing":
          case "decreasing":
            P = `in oklch ${C.value} hue`;
            break;
          default:
            P = `in ${C.value}`;
        }
      else
        C?.kind === "arbitrary" && (P = C.value);
      return P;
    }, A = function({ negative: C }) {
      return (P) => {
        if (!P.value)
          return;
        if (P.value.kind === "arbitrary") {
          if (P.modifier)
            return;
          let K = P.value.value;
          switch (P.value.dataType ?? Y(K, ["angle"])) {
            case "angle":
              return K = C ? `calc(${K} * -1)` : `${K}`, [l("--tw-gradient-position", K), l("background-image", `linear-gradient(var(--tw-gradient-stops,${K}))`)];
            default:
              return C ? undefined : [l("--tw-gradient-position", K), l("background-image", `linear-gradient(var(--tw-gradient-stops,${K}))`)];
          }
        }
        let S = P.value.value;
        if (!C && p.has(S))
          S = p.get(S);
        else if (E(S))
          S = C ? `calc(${S}deg * -1)` : `${S}deg`;
        else
          return;
        let T = h(P.modifier);
        return [l("--tw-gradient-position", `${S}`), G("@supports (background-image: linear-gradient(in lab, red, red))", [l("--tw-gradient-position", `${S} ${T}`)]), l("background-image", "linear-gradient(var(--tw-gradient-stops))")];
      };
    }, w = function({ negative: C }) {
      return (P) => {
        if (P.value?.kind === "arbitrary") {
          if (P.modifier)
            return;
          let K = P.value.value;
          return [l("--tw-gradient-position", K), l("background-image", `conic-gradient(var(--tw-gradient-stops,${K}))`)];
        }
        let S = h(P.modifier);
        if (!P.value)
          return [l("--tw-gradient-position", S), l("background-image", "conic-gradient(var(--tw-gradient-stops))")];
        let T = P.value.value;
        if (E(T))
          return T = C ? `calc(${T}deg * -1)` : `${T}deg`, [l("--tw-gradient-position", `from ${T} ${S}`), l("background-image", "conic-gradient(var(--tw-gradient-stops))")];
      };
    };
    var H = h, I = A, q = w;
    let n = ["oklab", "oklch", "srgb", "hsl", "longer", "shorter", "increasing", "decreasing"], p = new Map([["to-t", "to top"], ["to-tr", "to top right"], ["to-r", "to right"], ["to-br", "to bottom right"], ["to-b", "to bottom"], ["to-bl", "to bottom left"], ["to-l", "to left"], ["to-tl", "to top left"]]);
    r.functional("-bg-linear", A({ negative: true })), r.functional("bg-linear", A({ negative: false })), o("bg-linear", () => [{ values: [...p.keys()], modifiers: n }, { values: ["0", "30", "60", "90", "120", "150", "180", "210", "240", "270", "300", "330"], supportsNegative: true, modifiers: n }]), r.functional("-bg-conic", w({ negative: true })), r.functional("bg-conic", w({ negative: false })), o("bg-conic", () => [{ hasDefaultValue: true, modifiers: n }, { values: ["0", "30", "60", "90", "120", "150", "180", "210", "240", "270", "300", "330"], supportsNegative: true, modifiers: n }]), r.functional("bg-radial", (C) => {
      if (!C.value) {
        let P = h(C.modifier);
        return [l("--tw-gradient-position", P), l("background-image", "radial-gradient(var(--tw-gradient-stops))")];
      }
      if (C.value.kind === "arbitrary") {
        if (C.modifier)
          return;
        let P = C.value.value;
        return [l("--tw-gradient-position", P), l("background-image", `radial-gradient(var(--tw-gradient-stops,${P}))`)];
      }
    }), o("bg-radial", () => [{ hasDefaultValue: true, modifiers: n }]);
  }
  r.functional("bg", (n) => {
    if (n.value) {
      if (n.value.kind === "arbitrary") {
        let p = n.value.value;
        switch (n.value.dataType ?? Y(p, ["image", "color", "percentage", "position", "bg-size", "length", "url"])) {
          case "percentage":
          case "position":
            return n.modifier ? undefined : [l("background-position", p)];
          case "bg-size":
          case "length":
          case "size":
            return n.modifier ? undefined : [l("background-size", p)];
          case "image":
          case "url":
            return n.modifier ? undefined : [l("background-image", p)];
          default:
            return p = Z(p, n.modifier, t), p === null ? undefined : [l("background-color", p)];
        }
      }
      {
        let p = te(n, t, ["--background-color", "--color"]);
        if (p)
          return [l("background-color", p)];
      }
      {
        if (n.modifier)
          return;
        let p = t.resolve(n.value.value, ["--background-image"]);
        if (p)
          return [l("background-image", p)];
      }
    }
  }), o("bg", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--background-color", "--color"], modifiers: Array.from({ length: 21 }, (n, p) => `${p * 5}`) }, { values: [], valueThemeKeys: ["--background-image"] }]);
  let k = () => j([$("--tw-gradient-position"), $("--tw-gradient-from", "#0000", "<color>"), $("--tw-gradient-via", "#0000", "<color>"), $("--tw-gradient-to", "#0000", "<color>"), $("--tw-gradient-stops"), $("--tw-gradient-via-stops"), $("--tw-gradient-from-position", "0%", "<length-percentage>"), $("--tw-gradient-via-position", "50%", "<length-percentage>"), $("--tw-gradient-to-position", "100%", "<length-percentage>")]);
  function x(n, p) {
    r.functional(n, (h) => {
      if (h.value) {
        if (h.value.kind === "arbitrary") {
          let A = h.value.value;
          switch (h.value.dataType ?? Y(A, ["color", "length", "percentage"])) {
            case "length":
            case "percentage":
              return h.modifier ? undefined : p.position(A);
            default:
              return A = Z(A, h.modifier, t), A === null ? undefined : p.color(A);
          }
        }
        {
          let A = te(h, t, ["--background-color", "--color"]);
          if (A)
            return p.color(A);
        }
        {
          if (h.modifier)
            return;
          let A = t.resolve(h.value.value, ["--gradient-color-stop-positions"]);
          if (A)
            return p.position(A);
          if (h.value.value[h.value.value.length - 1] === "%" && E(h.value.value.slice(0, -1)))
            return p.position(h.value.value);
        }
      }
    }), o(n, () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--background-color", "--color"], modifiers: Array.from({ length: 21 }, (h, A) => `${A * 5}`) }, { values: Array.from({ length: 21 }, (h, A) => `${A * 5}%`), valueThemeKeys: ["--gradient-color-stop-positions"] }]);
  }
  x("from", { color: (n) => [k(), l("--tw-sort", "--tw-gradient-from"), l("--tw-gradient-from", n), l("--tw-gradient-stops", "var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position))")], position: (n) => [k(), l("--tw-gradient-from-position", n)] }), e("via-none", [["--tw-gradient-via-stops", "initial"]]), x("via", { color: (n) => [k(), l("--tw-sort", "--tw-gradient-via"), l("--tw-gradient-via", n), l("--tw-gradient-via-stops", "var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-via) var(--tw-gradient-via-position), var(--tw-gradient-to) var(--tw-gradient-to-position)"), l("--tw-gradient-stops", "var(--tw-gradient-via-stops)")], position: (n) => [k(), l("--tw-gradient-via-position", n)] }), x("to", { color: (n) => [k(), l("--tw-sort", "--tw-gradient-to"), l("--tw-gradient-to", n), l("--tw-gradient-stops", "var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position))")], position: (n) => [k(), l("--tw-gradient-to-position", n)] }), e("mask-none", [["mask-image", "none"]]), r.functional("mask", (n) => {
    if (!n.value || n.modifier || n.value.kind !== "arbitrary")
      return;
    let p = n.value.value;
    switch (n.value.dataType ?? Y(p, ["image", "percentage", "position", "bg-size", "length", "url"])) {
      case "percentage":
      case "position":
        return n.modifier ? undefined : [l("mask-position", p)];
      case "bg-size":
      case "length":
      case "size":
        return [l("mask-size", p)];
      case "image":
      case "url":
      default:
        return [l("mask-image", p)];
    }
  }), e("mask-add", [["mask-composite", "add"]]), e("mask-subtract", [["mask-composite", "subtract"]]), e("mask-intersect", [["mask-composite", "intersect"]]), e("mask-exclude", [["mask-composite", "exclude"]]), e("mask-alpha", [["mask-mode", "alpha"]]), e("mask-luminance", [["mask-mode", "luminance"]]), e("mask-match", [["mask-mode", "match-source"]]), e("mask-type-alpha", [["mask-type", "alpha"]]), e("mask-type-luminance", [["mask-type", "luminance"]]), e("mask-auto", [["mask-size", "auto"]]), e("mask-cover", [["mask-size", "cover"]]), e("mask-contain", [["mask-size", "contain"]]), i("mask-size", { handle(n) {
    if (n)
      return [l("mask-size", n)];
  } }), e("mask-top", [["mask-position", "top"]]), e("mask-top-left", [["mask-position", "left top"]]), e("mask-top-right", [["mask-position", "right top"]]), e("mask-bottom", [["mask-position", "bottom"]]), e("mask-bottom-left", [["mask-position", "left bottom"]]), e("mask-bottom-right", [["mask-position", "right bottom"]]), e("mask-left", [["mask-position", "left"]]), e("mask-right", [["mask-position", "right"]]), e("mask-center", [["mask-position", "center"]]), i("mask-position", { handle(n) {
    if (n)
      return [l("mask-position", n)];
  } }), e("mask-repeat", [["mask-repeat", "repeat"]]), e("mask-no-repeat", [["mask-repeat", "no-repeat"]]), e("mask-repeat-x", [["mask-repeat", "repeat-x"]]), e("mask-repeat-y", [["mask-repeat", "repeat-y"]]), e("mask-repeat-round", [["mask-repeat", "round"]]), e("mask-repeat-space", [["mask-repeat", "space"]]), e("mask-clip-border", [["mask-clip", "border-box"]]), e("mask-clip-padding", [["mask-clip", "padding-box"]]), e("mask-clip-content", [["mask-clip", "content-box"]]), e("mask-clip-fill", [["mask-clip", "fill-box"]]), e("mask-clip-stroke", [["mask-clip", "stroke-box"]]), e("mask-clip-view", [["mask-clip", "view-box"]]), e("mask-no-clip", [["mask-clip", "no-clip"]]), e("mask-origin-border", [["mask-origin", "border-box"]]), e("mask-origin-padding", [["mask-origin", "padding-box"]]), e("mask-origin-content", [["mask-origin", "content-box"]]), e("mask-origin-fill", [["mask-origin", "fill-box"]]), e("mask-origin-stroke", [["mask-origin", "stroke-box"]]), e("mask-origin-view", [["mask-origin", "view-box"]]);
  let y = () => j([$("--tw-mask-linear", "linear-gradient(#fff, #fff)"), $("--tw-mask-radial", "linear-gradient(#fff, #fff)"), $("--tw-mask-conic", "linear-gradient(#fff, #fff)")]);
  function N(n, p) {
    r.functional(n, (h) => {
      if (h.value) {
        if (h.value.kind === "arbitrary") {
          let A = h.value.value;
          switch (h.value.dataType ?? Y(A, ["length", "percentage", "color"])) {
            case "color":
              return A = Z(A, h.modifier, t), A === null ? undefined : p.color(A);
            case "percentage":
              return h.modifier || !E(A.slice(0, -1)) ? undefined : p.position(A);
            default:
              return h.modifier ? undefined : p.position(A);
          }
        }
        {
          let A = te(h, t, ["--background-color", "--color"]);
          if (A)
            return p.color(A);
        }
        {
          if (h.modifier)
            return;
          let A = Y(h.value.value, ["number", "percentage"]);
          if (!A)
            return;
          switch (A) {
            case "number": {
              let w = t.resolve(null, ["--spacing"]);
              return !w || !xe(h.value.value) ? undefined : p.position(`calc(${w} * ${h.value.value})`);
            }
            case "percentage":
              return E(h.value.value.slice(0, -1)) ? p.position(h.value.value) : undefined;
            default:
              return;
          }
        }
      }
    }), o(n, () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--background-color", "--color"], modifiers: Array.from({ length: 21 }, (h, A) => `${A * 5}`) }, { values: Array.from({ length: 21 }, (h, A) => `${A * 5}%`), valueThemeKeys: ["--gradient-color-stop-positions"] }]), o(n, () => [{ values: Array.from({ length: 21 }, (h, A) => `${A * 5}%`) }, { values: t.get(["--spacing"]) ? at : [] }, { values: ["current", "inherit", "transparent"], valueThemeKeys: ["--background-color", "--color"], modifiers: Array.from({ length: 21 }, (h, A) => `${A * 5}`) }]);
  }
  let b = () => j([$("--tw-mask-left", "linear-gradient(#fff, #fff)"), $("--tw-mask-right", "linear-gradient(#fff, #fff)"), $("--tw-mask-bottom", "linear-gradient(#fff, #fff)"), $("--tw-mask-top", "linear-gradient(#fff, #fff)")]);
  function V(n, p, h) {
    N(n, { color(A) {
      let w = [y(), b(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-linear", "var(--tw-mask-left), var(--tw-mask-right), var(--tw-mask-bottom), var(--tw-mask-top)")];
      for (let C of ["top", "right", "bottom", "left"])
        h[C] && (w.push(l(`--tw-mask-${C}`, `linear-gradient(to ${C}, var(--tw-mask-${C}-from-color) var(--tw-mask-${C}-from-position), var(--tw-mask-${C}-to-color) var(--tw-mask-${C}-to-position))`)), w.push(j([$(`--tw-mask-${C}-from-position`, "0%"), $(`--tw-mask-${C}-to-position`, "100%"), $(`--tw-mask-${C}-from-color`, "black"), $(`--tw-mask-${C}-to-color`, "transparent")])), w.push(l(`--tw-mask-${C}-${p}-color`, A)));
      return w;
    }, position(A) {
      let w = [y(), b(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-linear", "var(--tw-mask-left), var(--tw-mask-right), var(--tw-mask-bottom), var(--tw-mask-top)")];
      for (let C of ["top", "right", "bottom", "left"])
        h[C] && (w.push(l(`--tw-mask-${C}`, `linear-gradient(to ${C}, var(--tw-mask-${C}-from-color) var(--tw-mask-${C}-from-position), var(--tw-mask-${C}-to-color) var(--tw-mask-${C}-to-position))`)), w.push(j([$(`--tw-mask-${C}-from-position`, "0%"), $(`--tw-mask-${C}-to-position`, "100%"), $(`--tw-mask-${C}-from-color`, "black"), $(`--tw-mask-${C}-to-color`, "transparent")])), w.push(l(`--tw-mask-${C}-${p}-position`, A)));
      return w;
    } });
  }
  V("mask-x-from", "from", { top: false, right: true, bottom: false, left: true }), V("mask-x-to", "to", { top: false, right: true, bottom: false, left: true }), V("mask-y-from", "from", { top: true, right: false, bottom: true, left: false }), V("mask-y-to", "to", { top: true, right: false, bottom: true, left: false }), V("mask-t-from", "from", { top: true, right: false, bottom: false, left: false }), V("mask-t-to", "to", { top: true, right: false, bottom: false, left: false }), V("mask-r-from", "from", { top: false, right: true, bottom: false, left: false }), V("mask-r-to", "to", { top: false, right: true, bottom: false, left: false }), V("mask-b-from", "from", { top: false, right: false, bottom: true, left: false }), V("mask-b-to", "to", { top: false, right: false, bottom: true, left: false }), V("mask-l-from", "from", { top: false, right: false, bottom: false, left: true }), V("mask-l-to", "to", { top: false, right: false, bottom: false, left: true });
  let R = () => j([$("--tw-mask-linear-position", "0deg"), $("--tw-mask-linear-from-position", "0%"), $("--tw-mask-linear-to-position", "100%"), $("--tw-mask-linear-from-color", "black"), $("--tw-mask-linear-to-color", "transparent")]);
  i("mask-linear", { defaultValue: null, supportsNegative: true, supportsFractions: false, handleBareValue(n) {
    return E(n.value) ? `calc(1deg * ${n.value})` : null;
  }, handleNegativeBareValue(n) {
    return E(n.value) ? `calc(1deg * -${n.value})` : null;
  }, handle: (n) => [y(), R(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-linear", "linear-gradient(var(--tw-mask-linear-stops, var(--tw-mask-linear-position)))"), l("--tw-mask-linear-position", n)] }), o("mask-linear", () => [{ supportsNegative: true, values: ["0", "1", "2", "3", "6", "12", "45", "90", "180"] }]), N("mask-linear-from", { color: (n) => [y(), R(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-linear-stops", "var(--tw-mask-linear-position), var(--tw-mask-linear-from-color) var(--tw-mask-linear-from-position), var(--tw-mask-linear-to-color) var(--tw-mask-linear-to-position)"), l("--tw-mask-linear", "linear-gradient(var(--tw-mask-linear-stops))"), l("--tw-mask-linear-from-color", n)], position: (n) => [y(), R(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-linear-stops", "var(--tw-mask-linear-position), var(--tw-mask-linear-from-color) var(--tw-mask-linear-from-position), var(--tw-mask-linear-to-color) var(--tw-mask-linear-to-position)"), l("--tw-mask-linear", "linear-gradient(var(--tw-mask-linear-stops))"), l("--tw-mask-linear-from-position", n)] }), N("mask-linear-to", { color: (n) => [y(), R(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-linear-stops", "var(--tw-mask-linear-position), var(--tw-mask-linear-from-color) var(--tw-mask-linear-from-position), var(--tw-mask-linear-to-color) var(--tw-mask-linear-to-position)"), l("--tw-mask-linear", "linear-gradient(var(--tw-mask-linear-stops))"), l("--tw-mask-linear-to-color", n)], position: (n) => [y(), R(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-linear-stops", "var(--tw-mask-linear-position), var(--tw-mask-linear-from-color) var(--tw-mask-linear-from-position), var(--tw-mask-linear-to-color) var(--tw-mask-linear-to-position)"), l("--tw-mask-linear", "linear-gradient(var(--tw-mask-linear-stops))"), l("--tw-mask-linear-to-position", n)] });
  let U = () => j([$("--tw-mask-radial-from-position", "0%"), $("--tw-mask-radial-to-position", "100%"), $("--tw-mask-radial-from-color", "black"), $("--tw-mask-radial-to-color", "transparent"), $("--tw-mask-radial-shape", "ellipse"), $("--tw-mask-radial-size", "farthest-corner"), $("--tw-mask-radial-position", "center")]);
  e("mask-circle", [["--tw-mask-radial-shape", "circle"]]), e("mask-ellipse", [["--tw-mask-radial-shape", "ellipse"]]), e("mask-radial-closest-side", [["--tw-mask-radial-size", "closest-side"]]), e("mask-radial-farthest-side", [["--tw-mask-radial-size", "farthest-side"]]), e("mask-radial-closest-corner", [["--tw-mask-radial-size", "closest-corner"]]), e("mask-radial-farthest-corner", [["--tw-mask-radial-size", "farthest-corner"]]), e("mask-radial-at-top", [["--tw-mask-radial-position", "top"]]), e("mask-radial-at-top-left", [["--tw-mask-radial-position", "top left"]]), e("mask-radial-at-top-right", [["--tw-mask-radial-position", "top right"]]), e("mask-radial-at-bottom", [["--tw-mask-radial-position", "bottom"]]), e("mask-radial-at-bottom-left", [["--tw-mask-radial-position", "bottom left"]]), e("mask-radial-at-bottom-right", [["--tw-mask-radial-position", "bottom right"]]), e("mask-radial-at-left", [["--tw-mask-radial-position", "left"]]), e("mask-radial-at-right", [["--tw-mask-radial-position", "right"]]), e("mask-radial-at-center", [["--tw-mask-radial-position", "center"]]), i("mask-radial-at", { defaultValue: null, supportsNegative: false, supportsFractions: false, handle: (n) => [l("--tw-mask-radial-position", n)] }), i("mask-radial", { defaultValue: null, supportsNegative: false, supportsFractions: false, handle: (n) => [y(), U(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-radial", "radial-gradient(var(--tw-mask-radial-stops, var(--tw-mask-radial-size)))"), l("--tw-mask-radial-size", n)] }), N("mask-radial-from", { color: (n) => [y(), U(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-radial-stops", "var(--tw-mask-radial-shape) var(--tw-mask-radial-size) at var(--tw-mask-radial-position), var(--tw-mask-radial-from-color) var(--tw-mask-radial-from-position), var(--tw-mask-radial-to-color) var(--tw-mask-radial-to-position)"), l("--tw-mask-radial", "radial-gradient(var(--tw-mask-radial-stops))"), l("--tw-mask-radial-from-color", n)], position: (n) => [y(), U(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-radial-stops", "var(--tw-mask-radial-shape) var(--tw-mask-radial-size) at var(--tw-mask-radial-position), var(--tw-mask-radial-from-color) var(--tw-mask-radial-from-position), var(--tw-mask-radial-to-color) var(--tw-mask-radial-to-position)"), l("--tw-mask-radial", "radial-gradient(var(--tw-mask-radial-stops))"), l("--tw-mask-radial-from-position", n)] }), N("mask-radial-to", { color: (n) => [y(), U(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-radial-stops", "var(--tw-mask-radial-shape) var(--tw-mask-radial-size) at var(--tw-mask-radial-position), var(--tw-mask-radial-from-color) var(--tw-mask-radial-from-position), var(--tw-mask-radial-to-color) var(--tw-mask-radial-to-position)"), l("--tw-mask-radial", "radial-gradient(var(--tw-mask-radial-stops))"), l("--tw-mask-radial-to-color", n)], position: (n) => [y(), U(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-radial-stops", "var(--tw-mask-radial-shape) var(--tw-mask-radial-size) at var(--tw-mask-radial-position), var(--tw-mask-radial-from-color) var(--tw-mask-radial-from-position), var(--tw-mask-radial-to-color) var(--tw-mask-radial-to-position)"), l("--tw-mask-radial", "radial-gradient(var(--tw-mask-radial-stops))"), l("--tw-mask-radial-to-position", n)] });
  let _ = () => j([$("--tw-mask-conic-position", "0deg"), $("--tw-mask-conic-from-position", "0%"), $("--tw-mask-conic-to-position", "100%"), $("--tw-mask-conic-from-color", "black"), $("--tw-mask-conic-to-color", "transparent")]);
  i("mask-conic", { defaultValue: null, supportsNegative: true, supportsFractions: false, handleBareValue(n) {
    return E(n.value) ? `calc(1deg * ${n.value})` : null;
  }, handleNegativeBareValue(n) {
    return E(n.value) ? `calc(1deg * -${n.value})` : null;
  }, handle: (n) => [y(), _(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-conic", "conic-gradient(var(--tw-mask-conic-stops, var(--tw-mask-conic-position)))"), l("--tw-mask-conic-position", n)] }), o("mask-conic", () => [{ supportsNegative: true, values: ["0", "1", "2", "3", "6", "12", "45", "90", "180"] }]), N("mask-conic-from", { color: (n) => [y(), _(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-conic-stops", "from var(--tw-mask-conic-position), var(--tw-mask-conic-from-color) var(--tw-mask-conic-from-position), var(--tw-mask-conic-to-color) var(--tw-mask-conic-to-position)"), l("--tw-mask-conic", "conic-gradient(var(--tw-mask-conic-stops))"), l("--tw-mask-conic-from-color", n)], position: (n) => [y(), _(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-conic-stops", "from var(--tw-mask-conic-position), var(--tw-mask-conic-from-color) var(--tw-mask-conic-from-position), var(--tw-mask-conic-to-color) var(--tw-mask-conic-to-position)"), l("--tw-mask-conic", "conic-gradient(var(--tw-mask-conic-stops))"), l("--tw-mask-conic-from-position", n)] }), N("mask-conic-to", { color: (n) => [y(), _(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-conic-stops", "from var(--tw-mask-conic-position), var(--tw-mask-conic-from-color) var(--tw-mask-conic-from-position), var(--tw-mask-conic-to-color) var(--tw-mask-conic-to-position)"), l("--tw-mask-conic", "conic-gradient(var(--tw-mask-conic-stops))"), l("--tw-mask-conic-to-color", n)], position: (n) => [y(), _(), l("mask-image", "var(--tw-mask-linear), var(--tw-mask-radial), var(--tw-mask-conic)"), l("mask-composite", "intersect"), l("--tw-mask-conic-stops", "from var(--tw-mask-conic-position), var(--tw-mask-conic-from-color) var(--tw-mask-conic-from-position), var(--tw-mask-conic-to-color) var(--tw-mask-conic-to-position)"), l("--tw-mask-conic", "conic-gradient(var(--tw-mask-conic-stops))"), l("--tw-mask-conic-to-position", n)] }), e("box-decoration-slice", [["-webkit-box-decoration-break", "slice"], ["box-decoration-break", "slice"]]), e("box-decoration-clone", [["-webkit-box-decoration-break", "clone"], ["box-decoration-break", "clone"]]), e("bg-clip-text", [["background-clip", "text"]]), e("bg-clip-border", [["background-clip", "border-box"]]), e("bg-clip-padding", [["background-clip", "padding-box"]]), e("bg-clip-content", [["background-clip", "content-box"]]), e("bg-origin-border", [["background-origin", "border-box"]]), e("bg-origin-padding", [["background-origin", "padding-box"]]), e("bg-origin-content", [["background-origin", "content-box"]]);
  for (let n of ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"])
    e(`bg-blend-${n}`, [["background-blend-mode", n]]), e(`mix-blend-${n}`, [["mix-blend-mode", n]]);
  e("mix-blend-plus-darker", [["mix-blend-mode", "plus-darker"]]), e("mix-blend-plus-lighter", [["mix-blend-mode", "plus-lighter"]]), e("fill-none", [["fill", "none"]]), r.functional("fill", (n) => {
    if (!n.value)
      return;
    if (n.value.kind === "arbitrary") {
      let h = Z(n.value.value, n.modifier, t);
      return h === null ? undefined : [l("fill", h)];
    }
    let p = te(n, t, ["--fill", "--color"]);
    if (p)
      return [l("fill", p)];
  }), o("fill", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--fill", "--color"], modifiers: Array.from({ length: 21 }, (n, p) => `${p * 5}`) }]), e("stroke-none", [["stroke", "none"]]), r.functional("stroke", (n) => {
    if (n.value) {
      if (n.value.kind === "arbitrary") {
        let p = n.value.value;
        switch (n.value.dataType ?? Y(p, ["color", "number", "length", "percentage"])) {
          case "number":
          case "length":
          case "percentage":
            return n.modifier ? undefined : [l("stroke-width", p)];
          default:
            return p = Z(n.value.value, n.modifier, t), p === null ? undefined : [l("stroke", p)];
        }
      }
      {
        let p = te(n, t, ["--stroke", "--color"]);
        if (p)
          return [l("stroke", p)];
      }
      {
        let p = t.resolve(n.value.value, ["--stroke-width"]);
        if (p)
          return [l("stroke-width", p)];
        if (E(n.value.value))
          return [l("stroke-width", n.value.value)];
      }
    }
  }), o("stroke", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--stroke", "--color"], modifiers: Array.from({ length: 21 }, (n, p) => `${p * 5}`) }, { values: ["0", "1", "2", "3"], valueThemeKeys: ["--stroke-width"] }]), e("object-contain", [["object-fit", "contain"]]), e("object-cover", [["object-fit", "cover"]]), e("object-fill", [["object-fit", "fill"]]), e("object-none", [["object-fit", "none"]]), e("object-scale-down", [["object-fit", "scale-down"]]), e("object-top", [["object-position", "top"]]), e("object-top-left", [["object-position", "left top"]]), e("object-top-right", [["object-position", "right top"]]), e("object-bottom", [["object-position", "bottom"]]), e("object-bottom-left", [["object-position", "left bottom"]]), e("object-bottom-right", [["object-position", "right bottom"]]), e("object-left", [["object-position", "left"]]), e("object-right", [["object-position", "right"]]), e("object-center", [["object-position", "center"]]), i("object", { themeKeys: ["--object-position"], handle: (n) => [l("object-position", n)] });
  for (let [n, p] of [["p", "padding"], ["px", "padding-inline"], ["py", "padding-block"], ["ps", "padding-inline-start"], ["pe", "padding-inline-end"], ["pt", "padding-top"], ["pr", "padding-right"], ["pb", "padding-bottom"], ["pl", "padding-left"]])
    a(n, ["--padding", "--spacing"], (h) => [l(p, h)]);
  e("text-left", [["text-align", "left"]]), e("text-center", [["text-align", "center"]]), e("text-right", [["text-align", "right"]]), e("text-justify", [["text-align", "justify"]]), e("text-start", [["text-align", "start"]]), e("text-end", [["text-align", "end"]]), a("indent", ["--text-indent", "--spacing"], (n) => [l("text-indent", n)], { supportsNegative: true }), e("align-baseline", [["vertical-align", "baseline"]]), e("align-top", [["vertical-align", "top"]]), e("align-middle", [["vertical-align", "middle"]]), e("align-bottom", [["vertical-align", "bottom"]]), e("align-text-top", [["vertical-align", "text-top"]]), e("align-text-bottom", [["vertical-align", "text-bottom"]]), e("align-sub", [["vertical-align", "sub"]]), e("align-super", [["vertical-align", "super"]]), i("align", { themeKeys: [], handle: (n) => [l("vertical-align", n)] }), r.functional("font", (n) => {
    if (!(!n.value || n.modifier)) {
      if (n.value.kind === "arbitrary") {
        let p = n.value.value;
        switch (n.value.dataType ?? Y(p, ["number", "generic-name", "family-name"])) {
          case "generic-name":
          case "family-name":
            return [l("font-family", p)];
          default:
            return [j([$("--tw-font-weight")]), l("--tw-font-weight", p), l("font-weight", p)];
        }
      }
      {
        let p = t.resolveWith(n.value.value, ["--font"], ["--font-feature-settings", "--font-variation-settings"]);
        if (p) {
          let [h, A = {}] = p;
          return [l("font-family", h), l("font-feature-settings", A["--font-feature-settings"]), l("font-variation-settings", A["--font-variation-settings"])];
        }
      }
      {
        let p = t.resolve(n.value.value, ["--font-weight"]);
        if (p)
          return [j([$("--tw-font-weight")]), l("--tw-font-weight", p), l("font-weight", p)];
      }
    }
  }), o("font", () => [{ values: [], valueThemeKeys: ["--font"] }, { values: [], valueThemeKeys: ["--font-weight"] }]), e("uppercase", [["text-transform", "uppercase"]]), e("lowercase", [["text-transform", "lowercase"]]), e("capitalize", [["text-transform", "capitalize"]]), e("normal-case", [["text-transform", "none"]]), e("italic", [["font-style", "italic"]]), e("not-italic", [["font-style", "normal"]]), e("underline", [["text-decoration-line", "underline"]]), e("overline", [["text-decoration-line", "overline"]]), e("line-through", [["text-decoration-line", "line-through"]]), e("no-underline", [["text-decoration-line", "none"]]), e("font-stretch-normal", [["font-stretch", "normal"]]), e("font-stretch-ultra-condensed", [["font-stretch", "ultra-condensed"]]), e("font-stretch-extra-condensed", [["font-stretch", "extra-condensed"]]), e("font-stretch-condensed", [["font-stretch", "condensed"]]), e("font-stretch-semi-condensed", [["font-stretch", "semi-condensed"]]), e("font-stretch-semi-expanded", [["font-stretch", "semi-expanded"]]), e("font-stretch-expanded", [["font-stretch", "expanded"]]), e("font-stretch-extra-expanded", [["font-stretch", "extra-expanded"]]), e("font-stretch-ultra-expanded", [["font-stretch", "ultra-expanded"]]), i("font-stretch", { handleBareValue: ({ value: n }) => {
    if (!n.endsWith("%"))
      return null;
    let p = Number(n.slice(0, -1));
    return !E(p) || Number.isNaN(p) || p < 50 || p > 200 ? null : n;
  }, handle: (n) => [l("font-stretch", n)] }), o("font-stretch", () => [{ values: ["50%", "75%", "90%", "95%", "100%", "105%", "110%", "125%", "150%", "200%"] }]), s("placeholder", { themeKeys: ["--background-color", "--color"], handle: (n) => [M("&::placeholder", [l("--tw-sort", "placeholder-color"), l("color", n)])] }), e("decoration-solid", [["text-decoration-style", "solid"]]), e("decoration-double", [["text-decoration-style", "double"]]), e("decoration-dotted", [["text-decoration-style", "dotted"]]), e("decoration-dashed", [["text-decoration-style", "dashed"]]), e("decoration-wavy", [["text-decoration-style", "wavy"]]), e("decoration-auto", [["text-decoration-thickness", "auto"]]), e("decoration-from-font", [["text-decoration-thickness", "from-font"]]), r.functional("decoration", (n) => {
    if (n.value) {
      if (n.value.kind === "arbitrary") {
        let p = n.value.value;
        switch (n.value.dataType ?? Y(p, ["color", "length", "percentage"])) {
          case "length":
          case "percentage":
            return n.modifier ? undefined : [l("text-decoration-thickness", p)];
          default:
            return p = Z(p, n.modifier, t), p === null ? undefined : [l("text-decoration-color", p)];
        }
      }
      {
        let p = t.resolve(n.value.value, ["--text-decoration-thickness"]);
        if (p)
          return n.modifier ? undefined : [l("text-decoration-thickness", p)];
        if (E(n.value.value))
          return n.modifier ? undefined : [l("text-decoration-thickness", `${n.value.value}px`)];
      }
      {
        let p = te(n, t, ["--text-decoration-color", "--color"]);
        if (p)
          return [l("text-decoration-color", p)];
      }
    }
  }), o("decoration", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--text-decoration-color", "--color"], modifiers: Array.from({ length: 21 }, (n, p) => `${p * 5}`) }, { values: ["0", "1", "2"], valueThemeKeys: ["--text-decoration-thickness"] }]), e("animate-none", [["animation", "none"]]), i("animate", { themeKeys: ["--animate"], handle: (n) => [l("animation", n)] });
  {
    let n = ["var(--tw-blur,)", "var(--tw-brightness,)", "var(--tw-contrast,)", "var(--tw-grayscale,)", "var(--tw-hue-rotate,)", "var(--tw-invert,)", "var(--tw-saturate,)", "var(--tw-sepia,)", "var(--tw-drop-shadow,)"].join(" "), p = ["var(--tw-backdrop-blur,)", "var(--tw-backdrop-brightness,)", "var(--tw-backdrop-contrast,)", "var(--tw-backdrop-grayscale,)", "var(--tw-backdrop-hue-rotate,)", "var(--tw-backdrop-invert,)", "var(--tw-backdrop-opacity,)", "var(--tw-backdrop-saturate,)", "var(--tw-backdrop-sepia,)"].join(" "), h = () => j([$("--tw-blur"), $("--tw-brightness"), $("--tw-contrast"), $("--tw-grayscale"), $("--tw-hue-rotate"), $("--tw-invert"), $("--tw-opacity"), $("--tw-saturate"), $("--tw-sepia"), $("--tw-drop-shadow"), $("--tw-drop-shadow-color"), $("--tw-drop-shadow-alpha", "100%", "<percentage>"), $("--tw-drop-shadow-size")]), A = () => j([$("--tw-backdrop-blur"), $("--tw-backdrop-brightness"), $("--tw-backdrop-contrast"), $("--tw-backdrop-grayscale"), $("--tw-backdrop-hue-rotate"), $("--tw-backdrop-invert"), $("--tw-backdrop-opacity"), $("--tw-backdrop-saturate"), $("--tw-backdrop-sepia")]);
    r.functional("filter", (w) => {
      if (!w.modifier) {
        if (w.value === null)
          return [h(), l("filter", n)];
        if (w.value.kind === "arbitrary")
          return [l("filter", w.value.value)];
        switch (w.value.value) {
          case "none":
            return [l("filter", "none")];
        }
      }
    }), r.functional("backdrop-filter", (w) => {
      if (!w.modifier) {
        if (w.value === null)
          return [A(), l("-webkit-backdrop-filter", p), l("backdrop-filter", p)];
        if (w.value.kind === "arbitrary")
          return [l("-webkit-backdrop-filter", w.value.value), l("backdrop-filter", w.value.value)];
        switch (w.value.value) {
          case "none":
            return [l("-webkit-backdrop-filter", "none"), l("backdrop-filter", "none")];
        }
      }
    }), i("blur", { themeKeys: ["--blur"], handle: (w) => [h(), l("--tw-blur", `blur(${w})`), l("filter", n)] }), e("blur-none", [h, ["--tw-blur", " "], ["filter", n]]), i("backdrop-blur", { themeKeys: ["--backdrop-blur", "--blur"], handle: (w) => [A(), l("--tw-backdrop-blur", `blur(${w})`), l("-webkit-backdrop-filter", p), l("backdrop-filter", p)] }), e("backdrop-blur-none", [A, ["--tw-backdrop-blur", " "], ["-webkit-backdrop-filter", p], ["backdrop-filter", p]]), i("brightness", { themeKeys: ["--brightness"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, handle: (w) => [h(), l("--tw-brightness", `brightness(${w})`), l("filter", n)] }), i("backdrop-brightness", { themeKeys: ["--backdrop-brightness", "--brightness"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, handle: (w) => [A(), l("--tw-backdrop-brightness", `brightness(${w})`), l("-webkit-backdrop-filter", p), l("backdrop-filter", p)] }), o("brightness", () => [{ values: ["0", "50", "75", "90", "95", "100", "105", "110", "125", "150", "200"], valueThemeKeys: ["--brightness"] }]), o("backdrop-brightness", () => [{ values: ["0", "50", "75", "90", "95", "100", "105", "110", "125", "150", "200"], valueThemeKeys: ["--backdrop-brightness", "--brightness"] }]), i("contrast", { themeKeys: ["--contrast"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, handle: (w) => [h(), l("--tw-contrast", `contrast(${w})`), l("filter", n)] }), i("backdrop-contrast", { themeKeys: ["--backdrop-contrast", "--contrast"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, handle: (w) => [A(), l("--tw-backdrop-contrast", `contrast(${w})`), l("-webkit-backdrop-filter", p), l("backdrop-filter", p)] }), o("contrast", () => [{ values: ["0", "50", "75", "100", "125", "150", "200"], valueThemeKeys: ["--contrast"] }]), o("backdrop-contrast", () => [{ values: ["0", "50", "75", "100", "125", "150", "200"], valueThemeKeys: ["--backdrop-contrast", "--contrast"] }]), i("grayscale", { themeKeys: ["--grayscale"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, defaultValue: "100%", handle: (w) => [h(), l("--tw-grayscale", `grayscale(${w})`), l("filter", n)] }), i("backdrop-grayscale", { themeKeys: ["--backdrop-grayscale", "--grayscale"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, defaultValue: "100%", handle: (w) => [A(), l("--tw-backdrop-grayscale", `grayscale(${w})`), l("-webkit-backdrop-filter", p), l("backdrop-filter", p)] }), o("grayscale", () => [{ values: ["0", "25", "50", "75", "100"], valueThemeKeys: ["--grayscale"], hasDefaultValue: true }]), o("backdrop-grayscale", () => [{ values: ["0", "25", "50", "75", "100"], valueThemeKeys: ["--backdrop-grayscale", "--grayscale"], hasDefaultValue: true }]), i("hue-rotate", { supportsNegative: true, themeKeys: ["--hue-rotate"], handleBareValue: ({ value: w }) => E(w) ? `${w}deg` : null, handle: (w) => [h(), l("--tw-hue-rotate", `hue-rotate(${w})`), l("filter", n)] }), i("backdrop-hue-rotate", { supportsNegative: true, themeKeys: ["--backdrop-hue-rotate", "--hue-rotate"], handleBareValue: ({ value: w }) => E(w) ? `${w}deg` : null, handle: (w) => [A(), l("--tw-backdrop-hue-rotate", `hue-rotate(${w})`), l("-webkit-backdrop-filter", p), l("backdrop-filter", p)] }), o("hue-rotate", () => [{ values: ["0", "15", "30", "60", "90", "180"], valueThemeKeys: ["--hue-rotate"] }]), o("backdrop-hue-rotate", () => [{ values: ["0", "15", "30", "60", "90", "180"], valueThemeKeys: ["--backdrop-hue-rotate", "--hue-rotate"] }]), i("invert", { themeKeys: ["--invert"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, defaultValue: "100%", handle: (w) => [h(), l("--tw-invert", `invert(${w})`), l("filter", n)] }), i("backdrop-invert", { themeKeys: ["--backdrop-invert", "--invert"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, defaultValue: "100%", handle: (w) => [A(), l("--tw-backdrop-invert", `invert(${w})`), l("-webkit-backdrop-filter", p), l("backdrop-filter", p)] }), o("invert", () => [{ values: ["0", "25", "50", "75", "100"], valueThemeKeys: ["--invert"], hasDefaultValue: true }]), o("backdrop-invert", () => [{ values: ["0", "25", "50", "75", "100"], valueThemeKeys: ["--backdrop-invert", "--invert"], hasDefaultValue: true }]), i("saturate", { themeKeys: ["--saturate"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, handle: (w) => [h(), l("--tw-saturate", `saturate(${w})`), l("filter", n)] }), i("backdrop-saturate", { themeKeys: ["--backdrop-saturate", "--saturate"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, handle: (w) => [A(), l("--tw-backdrop-saturate", `saturate(${w})`), l("-webkit-backdrop-filter", p), l("backdrop-filter", p)] }), o("saturate", () => [{ values: ["0", "50", "100", "150", "200"], valueThemeKeys: ["--saturate"] }]), o("backdrop-saturate", () => [{ values: ["0", "50", "100", "150", "200"], valueThemeKeys: ["--backdrop-saturate", "--saturate"] }]), i("sepia", { themeKeys: ["--sepia"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, defaultValue: "100%", handle: (w) => [h(), l("--tw-sepia", `sepia(${w})`), l("filter", n)] }), i("backdrop-sepia", { themeKeys: ["--backdrop-sepia", "--sepia"], handleBareValue: ({ value: w }) => E(w) ? `${w}%` : null, defaultValue: "100%", handle: (w) => [A(), l("--tw-backdrop-sepia", `sepia(${w})`), l("-webkit-backdrop-filter", p), l("backdrop-filter", p)] }), o("sepia", () => [{ values: ["0", "50", "100"], valueThemeKeys: ["--sepia"], hasDefaultValue: true }]), o("backdrop-sepia", () => [{ values: ["0", "50", "100"], valueThemeKeys: ["--backdrop-sepia", "--sepia"], hasDefaultValue: true }]), e("drop-shadow-none", [h, ["--tw-drop-shadow", " "], ["filter", n]]), r.functional("drop-shadow", (w) => {
      let C;
      if (w.modifier && (w.modifier.kind === "arbitrary" ? C = w.modifier.value : E(w.modifier.value) && (C = `${w.modifier.value}%`)), !w.value) {
        let P = t.get(["--drop-shadow"]), S = t.resolve(null, ["--drop-shadow"]);
        return P === null || S === null ? undefined : [h(), l("--tw-drop-shadow-alpha", C), ...lt("--tw-drop-shadow-size", P, C, (T) => `var(--tw-drop-shadow-color, ${T})`), l("--tw-drop-shadow", z(S, ",").map((T) => `drop-shadow(${T})`).join(" ")), l("filter", n)];
      }
      if (w.value.kind === "arbitrary") {
        let P = w.value.value;
        switch (w.value.dataType ?? Y(P, ["color"])) {
          case "color":
            return P = Z(P, w.modifier, t), P === null ? undefined : [h(), l("--tw-drop-shadow-color", Q(P, "var(--tw-drop-shadow-alpha)")), l("--tw-drop-shadow", "var(--tw-drop-shadow-size)")];
          default:
            return w.modifier && !C ? undefined : [h(), l("--tw-drop-shadow-alpha", C), ...lt("--tw-drop-shadow-size", P, C, (T) => `var(--tw-drop-shadow-color, ${T})`), l("--tw-drop-shadow", "var(--tw-drop-shadow-size)"), l("filter", n)];
        }
      }
      {
        let P = t.get([`--drop-shadow-${w.value.value}`]), S = t.resolve(w.value.value, ["--drop-shadow"]);
        if (P && S)
          return w.modifier && !C ? undefined : C ? [h(), l("--tw-drop-shadow-alpha", C), ...lt("--tw-drop-shadow-size", P, C, (T) => `var(--tw-drop-shadow-color, ${T})`), l("--tw-drop-shadow", "var(--tw-drop-shadow-size)"), l("filter", n)] : [h(), l("--tw-drop-shadow-alpha", C), ...lt("--tw-drop-shadow-size", P, C, (T) => `var(--tw-drop-shadow-color, ${T})`), l("--tw-drop-shadow", z(S, ",").map((T) => `drop-shadow(${T})`).join(" ")), l("filter", n)];
      }
      {
        let P = te(w, t, ["--drop-shadow-color", "--color"]);
        if (P)
          return P === "inherit" ? [h(), l("--tw-drop-shadow-color", "inherit"), l("--tw-drop-shadow", "var(--tw-drop-shadow-size)")] : [h(), l("--tw-drop-shadow-color", Q(P, "var(--tw-drop-shadow-alpha)")), l("--tw-drop-shadow", "var(--tw-drop-shadow-size)")];
      }
    }), o("drop-shadow", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--drop-shadow-color", "--color"], modifiers: Array.from({ length: 21 }, (w, C) => `${C * 5}`) }, { valueThemeKeys: ["--drop-shadow"] }]), i("backdrop-opacity", { themeKeys: ["--backdrop-opacity", "--opacity"], handleBareValue: ({ value: w }) => nt(w) ? `${w}%` : null, handle: (w) => [A(), l("--tw-backdrop-opacity", `opacity(${w})`), l("-webkit-backdrop-filter", p), l("backdrop-filter", p)] }), o("backdrop-opacity", () => [{ values: Array.from({ length: 21 }, (w, C) => `${C * 5}`), valueThemeKeys: ["--backdrop-opacity", "--opacity"] }]);
  }
  {
    let n = `var(--tw-ease, ${t.resolve(null, ["--default-transition-timing-function"]) ?? "ease"})`, p = `var(--tw-duration, ${t.resolve(null, ["--default-transition-duration"]) ?? "0s"})`;
    e("transition-none", [["transition-property", "none"]]), e("transition-all", [["transition-property", "all"], ["transition-timing-function", n], ["transition-duration", p]]), e("transition-colors", [["transition-property", "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to"], ["transition-timing-function", n], ["transition-duration", p]]), e("transition-opacity", [["transition-property", "opacity"], ["transition-timing-function", n], ["transition-duration", p]]), e("transition-shadow", [["transition-property", "box-shadow"], ["transition-timing-function", n], ["transition-duration", p]]), e("transition-transform", [["transition-property", "transform, translate, scale, rotate"], ["transition-timing-function", n], ["transition-duration", p]]), i("transition", { defaultValue: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, -webkit-backdrop-filter, backdrop-filter, display, visibility, content-visibility, overlay, pointer-events", themeKeys: ["--transition-property"], handle: (h) => [l("transition-property", h), l("transition-timing-function", n), l("transition-duration", p)] }), e("transition-discrete", [["transition-behavior", "allow-discrete"]]), e("transition-normal", [["transition-behavior", "normal"]]), i("delay", { handleBareValue: ({ value: h }) => E(h) ? `${h}ms` : null, themeKeys: ["--transition-delay"], handle: (h) => [l("transition-delay", h)] });
    {
      let h = () => j([$("--tw-duration")]);
      e("duration-initial", [h, ["--tw-duration", "initial"]]), r.functional("duration", (A) => {
        if (A.modifier || !A.value)
          return;
        let w = null;
        if (A.value.kind === "arbitrary" ? w = A.value.value : (w = t.resolve(A.value.fraction ?? A.value.value, ["--transition-duration"]), w === null && E(A.value.value) && (w = `${A.value.value}ms`)), w !== null)
          return [h(), l("--tw-duration", w), l("transition-duration", w)];
      });
    }
    o("delay", () => [{ values: ["75", "100", "150", "200", "300", "500", "700", "1000"], valueThemeKeys: ["--transition-delay"] }]), o("duration", () => [{ values: ["75", "100", "150", "200", "300", "500", "700", "1000"], valueThemeKeys: ["--transition-duration"] }]);
  }
  {
    let n = () => j([$("--tw-ease")]);
    e("ease-initial", [n, ["--tw-ease", "initial"]]), e("ease-linear", [n, ["--tw-ease", "linear"], ["transition-timing-function", "linear"]]), i("ease", { themeKeys: ["--ease"], handle: (p) => [n(), l("--tw-ease", p), l("transition-timing-function", p)] });
  }
  e("will-change-auto", [["will-change", "auto"]]), e("will-change-scroll", [["will-change", "scroll-position"]]), e("will-change-contents", [["will-change", "contents"]]), e("will-change-transform", [["will-change", "transform"]]), i("will-change", { themeKeys: [], handle: (n) => [l("will-change", n)] }), e("content-none", [["--tw-content", "none"], ["content", "none"]]), i("content", { themeKeys: [], handle: (n) => [j([$("--tw-content", '""')]), l("--tw-content", n), l("content", "var(--tw-content)")] });
  {
    let n = "var(--tw-contain-size,) var(--tw-contain-layout,) var(--tw-contain-paint,) var(--tw-contain-style,)", p = () => j([$("--tw-contain-size"), $("--tw-contain-layout"), $("--tw-contain-paint"), $("--tw-contain-style")]);
    e("contain-none", [["contain", "none"]]), e("contain-content", [["contain", "content"]]), e("contain-strict", [["contain", "strict"]]), e("contain-size", [p, ["--tw-contain-size", "size"], ["contain", n]]), e("contain-inline-size", [p, ["--tw-contain-size", "inline-size"], ["contain", n]]), e("contain-layout", [p, ["--tw-contain-layout", "layout"], ["contain", n]]), e("contain-paint", [p, ["--tw-contain-paint", "paint"], ["contain", n]]), e("contain-style", [p, ["--tw-contain-style", "style"], ["contain", n]]), i("contain", { themeKeys: [], handle: (h) => [l("contain", h)] });
  }
  e("forced-color-adjust-none", [["forced-color-adjust", "none"]]), e("forced-color-adjust-auto", [["forced-color-adjust", "auto"]]), e("leading-none", [() => j([$("--tw-leading")]), ["--tw-leading", "1"], ["line-height", "1"]]), a("leading", ["--leading", "--spacing"], (n) => [j([$("--tw-leading")]), l("--tw-leading", n), l("line-height", n)]), i("tracking", { supportsNegative: true, themeKeys: ["--tracking"], handle: (n) => [j([$("--tw-tracking")]), l("--tw-tracking", n), l("letter-spacing", n)] }), e("antialiased", [["-webkit-font-smoothing", "antialiased"], ["-moz-osx-font-smoothing", "grayscale"]]), e("subpixel-antialiased", [["-webkit-font-smoothing", "auto"], ["-moz-osx-font-smoothing", "auto"]]);
  {
    let n = "var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,)", p = () => j([$("--tw-ordinal"), $("--tw-slashed-zero"), $("--tw-numeric-figure"), $("--tw-numeric-spacing"), $("--tw-numeric-fraction")]);
    e("normal-nums", [["font-variant-numeric", "normal"]]), e("ordinal", [p, ["--tw-ordinal", "ordinal"], ["font-variant-numeric", n]]), e("slashed-zero", [p, ["--tw-slashed-zero", "slashed-zero"], ["font-variant-numeric", n]]), e("lining-nums", [p, ["--tw-numeric-figure", "lining-nums"], ["font-variant-numeric", n]]), e("oldstyle-nums", [p, ["--tw-numeric-figure", "oldstyle-nums"], ["font-variant-numeric", n]]), e("proportional-nums", [p, ["--tw-numeric-spacing", "proportional-nums"], ["font-variant-numeric", n]]), e("tabular-nums", [p, ["--tw-numeric-spacing", "tabular-nums"], ["font-variant-numeric", n]]), e("diagonal-fractions", [p, ["--tw-numeric-fraction", "diagonal-fractions"], ["font-variant-numeric", n]]), e("stacked-fractions", [p, ["--tw-numeric-fraction", "stacked-fractions"], ["font-variant-numeric", n]]);
  }
  {
    let n = () => j([$("--tw-outline-style", "solid")]);
    r.static("outline-hidden", () => [l("--tw-outline-style", "none"), l("outline-style", "none"), F("@media", "(forced-colors: active)", [l("outline", "2px solid transparent"), l("outline-offset", "2px")])]), e("outline-none", [["--tw-outline-style", "none"], ["outline-style", "none"]]), e("outline-solid", [["--tw-outline-style", "solid"], ["outline-style", "solid"]]), e("outline-dashed", [["--tw-outline-style", "dashed"], ["outline-style", "dashed"]]), e("outline-dotted", [["--tw-outline-style", "dotted"], ["outline-style", "dotted"]]), e("outline-double", [["--tw-outline-style", "double"], ["outline-style", "double"]]), r.functional("outline", (p) => {
      if (p.value === null) {
        if (p.modifier)
          return;
        let h = t.get(["--default-outline-width"]) ?? "1px";
        return [n(), l("outline-style", "var(--tw-outline-style)"), l("outline-width", h)];
      }
      if (p.value.kind === "arbitrary") {
        let h = p.value.value;
        switch (p.value.dataType ?? Y(h, ["color", "length", "number", "percentage"])) {
          case "length":
          case "number":
          case "percentage":
            return p.modifier ? undefined : [n(), l("outline-style", "var(--tw-outline-style)"), l("outline-width", h)];
          default:
            return h = Z(h, p.modifier, t), h === null ? undefined : [l("outline-color", h)];
        }
      }
      {
        let h = te(p, t, ["--outline-color", "--color"]);
        if (h)
          return [l("outline-color", h)];
      }
      {
        if (p.modifier)
          return;
        let h = t.resolve(p.value.value, ["--outline-width"]);
        if (h)
          return [n(), l("outline-style", "var(--tw-outline-style)"), l("outline-width", h)];
        if (E(p.value.value))
          return [n(), l("outline-style", "var(--tw-outline-style)"), l("outline-width", `${p.value.value}px`)];
      }
    }), o("outline", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--outline-color", "--color"], modifiers: Array.from({ length: 21 }, (p, h) => `${h * 5}`), hasDefaultValue: true }, { values: ["0", "1", "2", "4", "8"], valueThemeKeys: ["--outline-width"] }]), i("outline-offset", { supportsNegative: true, themeKeys: ["--outline-offset"], handleBareValue: ({ value: p }) => E(p) ? `${p}px` : null, handle: (p) => [l("outline-offset", p)] }), o("outline-offset", () => [{ supportsNegative: true, values: ["0", "1", "2", "4", "8"], valueThemeKeys: ["--outline-offset"] }]);
  }
  i("opacity", { themeKeys: ["--opacity"], handleBareValue: ({ value: n }) => nt(n) ? `${n}%` : null, handle: (n) => [l("opacity", n)] }), o("opacity", () => [{ values: Array.from({ length: 21 }, (n, p) => `${p * 5}`), valueThemeKeys: ["--opacity"] }]), e("underline-offset-auto", [["text-underline-offset", "auto"]]), i("underline-offset", { supportsNegative: true, themeKeys: ["--text-underline-offset"], handleBareValue: ({ value: n }) => E(n) ? `${n}px` : null, handle: (n) => [l("text-underline-offset", n)] }), o("underline-offset", () => [{ supportsNegative: true, values: ["0", "1", "2", "4", "8"], valueThemeKeys: ["--text-underline-offset"] }]), r.functional("text", (n) => {
    if (n.value) {
      if (n.value.kind === "arbitrary") {
        let p = n.value.value;
        switch (n.value.dataType ?? Y(p, ["color", "length", "percentage", "absolute-size", "relative-size"])) {
          case "size":
          case "length":
          case "percentage":
          case "absolute-size":
          case "relative-size": {
            if (n.modifier) {
              let A = n.modifier.kind === "arbitrary" ? n.modifier.value : t.resolve(n.modifier.value, ["--leading"]);
              if (!A && xe(n.modifier.value)) {
                let w = t.resolve(null, ["--spacing"]);
                if (!w)
                  return null;
                A = `calc(${w} * ${n.modifier.value})`;
              }
              return !A && n.modifier.value === "none" && (A = "1"), A ? [l("font-size", p), l("line-height", A)] : null;
            }
            return [l("font-size", p)];
          }
          default:
            return p = Z(p, n.modifier, t), p === null ? undefined : [l("color", p)];
        }
      }
      {
        let p = te(n, t, ["--text-color", "--color"]);
        if (p)
          return [l("color", p)];
      }
      {
        let p = t.resolveWith(n.value.value, ["--text"], ["--line-height", "--letter-spacing", "--font-weight"]);
        if (p) {
          let [h, A = {}] = Array.isArray(p) ? p : [p];
          if (n.modifier) {
            let w = n.modifier.kind === "arbitrary" ? n.modifier.value : t.resolve(n.modifier.value, ["--leading"]);
            if (!w && xe(n.modifier.value)) {
              let P = t.resolve(null, ["--spacing"]);
              if (!P)
                return null;
              w = `calc(${P} * ${n.modifier.value})`;
            }
            if (!w && n.modifier.value === "none" && (w = "1"), !w)
              return null;
            let C = [l("font-size", h)];
            return w && C.push(l("line-height", w)), C;
          }
          return typeof A == "string" ? [l("font-size", h), l("line-height", A)] : [l("font-size", h), l("line-height", A["--line-height"] ? `var(--tw-leading, ${A["--line-height"]})` : undefined), l("letter-spacing", A["--letter-spacing"] ? `var(--tw-tracking, ${A["--letter-spacing"]})` : undefined), l("font-weight", A["--font-weight"] ? `var(--tw-font-weight, ${A["--font-weight"]})` : undefined)];
        }
      }
    }
  }), o("text", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--text-color", "--color"], modifiers: Array.from({ length: 21 }, (n, p) => `${p * 5}`) }, { values: [], valueThemeKeys: ["--text"], modifiers: [], modifierThemeKeys: ["--leading"] }]);
  let L = () => j([$("--tw-text-shadow-color"), $("--tw-text-shadow-alpha", "100%", "<percentage>")]);
  e("text-shadow-initial", [L, ["--tw-text-shadow-color", "initial"]]), r.functional("text-shadow", (n) => {
    let p;
    if (n.modifier && (n.modifier.kind === "arbitrary" ? p = n.modifier.value : E(n.modifier.value) && (p = `${n.modifier.value}%`)), !n.value) {
      let h = t.get(["--text-shadow"]);
      return h === null ? undefined : [L(), l("--tw-text-shadow-alpha", p), ...de("text-shadow", h, p, (A) => `var(--tw-text-shadow-color, ${A})`)];
    }
    if (n.value.kind === "arbitrary") {
      let h = n.value.value;
      switch (n.value.dataType ?? Y(h, ["color"])) {
        case "color":
          return h = Z(h, n.modifier, t), h === null ? undefined : [L(), l("--tw-text-shadow-color", Q(h, "var(--tw-text-shadow-alpha)"))];
        default:
          return [L(), l("--tw-text-shadow-alpha", p), ...de("text-shadow", h, p, (w) => `var(--tw-text-shadow-color, ${w})`)];
      }
    }
    switch (n.value.value) {
      case "none":
        return n.modifier ? undefined : [L(), l("text-shadow", "none")];
      case "inherit":
        return n.modifier ? undefined : [L(), l("--tw-text-shadow-color", "inherit")];
    }
    {
      let h = t.get([`--text-shadow-${n.value.value}`]);
      if (h)
        return [L(), l("--tw-text-shadow-alpha", p), ...de("text-shadow", h, p, (A) => `var(--tw-text-shadow-color, ${A})`)];
    }
    {
      let h = te(n, t, ["--text-shadow-color", "--color"]);
      if (h)
        return [L(), l("--tw-text-shadow-color", Q(h, "var(--tw-text-shadow-alpha)"))];
    }
  }), o("text-shadow", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--text-shadow-color", "--color"], modifiers: Array.from({ length: 21 }, (n, p) => `${p * 5}`) }, { values: ["none"] }, { valueThemeKeys: ["--text-shadow"], modifiers: Array.from({ length: 21 }, (n, p) => `${p * 5}`), hasDefaultValue: t.get(["--text-shadow"]) !== null }]);
  {
    let w = function(S) {
      return `var(--tw-ring-inset,) 0 0 0 calc(${S} + var(--tw-ring-offset-width)) var(--tw-ring-color, ${A})`;
    }, C = function(S) {
      return `inset 0 0 0 ${S} var(--tw-inset-ring-color, currentcolor)`;
    };
    var X = w, oe = C;
    let n = ["var(--tw-inset-shadow)", "var(--tw-inset-ring-shadow)", "var(--tw-ring-offset-shadow)", "var(--tw-ring-shadow)", "var(--tw-shadow)"].join(", "), p = "0 0 #0000", h = () => j([$("--tw-shadow", p), $("--tw-shadow-color"), $("--tw-shadow-alpha", "100%", "<percentage>"), $("--tw-inset-shadow", p), $("--tw-inset-shadow-color"), $("--tw-inset-shadow-alpha", "100%", "<percentage>"), $("--tw-ring-color"), $("--tw-ring-shadow", p), $("--tw-inset-ring-color"), $("--tw-inset-ring-shadow", p), $("--tw-ring-inset"), $("--tw-ring-offset-width", "0px", "<length>"), $("--tw-ring-offset-color", "#fff"), $("--tw-ring-offset-shadow", p)]);
    e("shadow-initial", [h, ["--tw-shadow-color", "initial"]]), r.functional("shadow", (S) => {
      let T;
      if (S.modifier && (S.modifier.kind === "arbitrary" ? T = S.modifier.value : E(S.modifier.value) && (T = `${S.modifier.value}%`)), !S.value) {
        let K = t.get(["--shadow"]);
        return K === null ? undefined : [h(), l("--tw-shadow-alpha", T), ...de("--tw-shadow", K, T, (ae) => `var(--tw-shadow-color, ${ae})`), l("box-shadow", n)];
      }
      if (S.value.kind === "arbitrary") {
        let K = S.value.value;
        switch (S.value.dataType ?? Y(K, ["color"])) {
          case "color":
            return K = Z(K, S.modifier, t), K === null ? undefined : [h(), l("--tw-shadow-color", Q(K, "var(--tw-shadow-alpha)"))];
          default:
            return [h(), l("--tw-shadow-alpha", T), ...de("--tw-shadow", K, T, (wt) => `var(--tw-shadow-color, ${wt})`), l("box-shadow", n)];
        }
      }
      switch (S.value.value) {
        case "none":
          return S.modifier ? undefined : [h(), l("--tw-shadow", p), l("box-shadow", n)];
        case "inherit":
          return S.modifier ? undefined : [h(), l("--tw-shadow-color", "inherit")];
      }
      {
        let K = t.get([`--shadow-${S.value.value}`]);
        if (K)
          return [h(), l("--tw-shadow-alpha", T), ...de("--tw-shadow", K, T, (ae) => `var(--tw-shadow-color, ${ae})`), l("box-shadow", n)];
      }
      {
        let K = te(S, t, ["--box-shadow-color", "--color"]);
        if (K)
          return [h(), l("--tw-shadow-color", Q(K, "var(--tw-shadow-alpha)"))];
      }
    }), o("shadow", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--box-shadow-color", "--color"], modifiers: Array.from({ length: 21 }, (S, T) => `${T * 5}`) }, { values: ["none"] }, { valueThemeKeys: ["--shadow"], modifiers: Array.from({ length: 21 }, (S, T) => `${T * 5}`), hasDefaultValue: t.get(["--shadow"]) !== null }]), e("inset-shadow-initial", [h, ["--tw-inset-shadow-color", "initial"]]), r.functional("inset-shadow", (S) => {
      let T;
      if (S.modifier && (S.modifier.kind === "arbitrary" ? T = S.modifier.value : E(S.modifier.value) && (T = `${S.modifier.value}%`)), !S.value) {
        let K = t.get(["--inset-shadow"]);
        return K === null ? undefined : [h(), l("--tw-inset-shadow-alpha", T), ...de("--tw-inset-shadow", K, T, (ae) => `var(--tw-inset-shadow-color, ${ae})`), l("box-shadow", n)];
      }
      if (S.value.kind === "arbitrary") {
        let K = S.value.value;
        switch (S.value.dataType ?? Y(K, ["color"])) {
          case "color":
            return K = Z(K, S.modifier, t), K === null ? undefined : [h(), l("--tw-inset-shadow-color", Q(K, "var(--tw-inset-shadow-alpha)"))];
          default:
            return [h(), l("--tw-inset-shadow-alpha", T), ...de("--tw-inset-shadow", K, T, (wt) => `var(--tw-inset-shadow-color, ${wt})`, "inset "), l("box-shadow", n)];
        }
      }
      switch (S.value.value) {
        case "none":
          return S.modifier ? undefined : [h(), l("--tw-inset-shadow", p), l("box-shadow", n)];
        case "inherit":
          return S.modifier ? undefined : [h(), l("--tw-inset-shadow-color", "inherit")];
      }
      {
        let K = t.get([`--inset-shadow-${S.value.value}`]);
        if (K)
          return [h(), l("--tw-inset-shadow-alpha", T), ...de("--tw-inset-shadow", K, T, (ae) => `var(--tw-inset-shadow-color, ${ae})`), l("box-shadow", n)];
      }
      {
        let K = te(S, t, ["--box-shadow-color", "--color"]);
        if (K)
          return [h(), l("--tw-inset-shadow-color", Q(K, "var(--tw-inset-shadow-alpha)"))];
      }
    }), o("inset-shadow", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--box-shadow-color", "--color"], modifiers: Array.from({ length: 21 }, (S, T) => `${T * 5}`) }, { values: ["none"] }, { valueThemeKeys: ["--inset-shadow"], modifiers: Array.from({ length: 21 }, (S, T) => `${T * 5}`), hasDefaultValue: t.get(["--inset-shadow"]) !== null }]), e("ring-inset", [h, ["--tw-ring-inset", "inset"]]);
    let A = t.get(["--default-ring-color"]) ?? "currentcolor";
    r.functional("ring", (S) => {
      if (!S.value) {
        if (S.modifier)
          return;
        let T = t.get(["--default-ring-width"]) ?? "1px";
        return [h(), l("--tw-ring-shadow", w(T)), l("box-shadow", n)];
      }
      if (S.value.kind === "arbitrary") {
        let T = S.value.value;
        switch (S.value.dataType ?? Y(T, ["color", "length"])) {
          case "length":
            return S.modifier ? undefined : [h(), l("--tw-ring-shadow", w(T)), l("box-shadow", n)];
          default:
            return T = Z(T, S.modifier, t), T === null ? undefined : [l("--tw-ring-color", T)];
        }
      }
      {
        let T = te(S, t, ["--ring-color", "--color"]);
        if (T)
          return [l("--tw-ring-color", T)];
      }
      {
        if (S.modifier)
          return;
        let T = t.resolve(S.value.value, ["--ring-width"]);
        if (T === null && E(S.value.value) && (T = `${S.value.value}px`), T)
          return [h(), l("--tw-ring-shadow", w(T)), l("box-shadow", n)];
      }
    }), o("ring", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--ring-color", "--color"], modifiers: Array.from({ length: 21 }, (S, T) => `${T * 5}`) }, { values: ["0", "1", "2", "4", "8"], valueThemeKeys: ["--ring-width"], hasDefaultValue: true }]), r.functional("inset-ring", (S) => {
      if (!S.value)
        return S.modifier ? undefined : [h(), l("--tw-inset-ring-shadow", C("1px")), l("box-shadow", n)];
      if (S.value.kind === "arbitrary") {
        let T = S.value.value;
        switch (S.value.dataType ?? Y(T, ["color", "length"])) {
          case "length":
            return S.modifier ? undefined : [h(), l("--tw-inset-ring-shadow", C(T)), l("box-shadow", n)];
          default:
            return T = Z(T, S.modifier, t), T === null ? undefined : [l("--tw-inset-ring-color", T)];
        }
      }
      {
        let T = te(S, t, ["--ring-color", "--color"]);
        if (T)
          return [l("--tw-inset-ring-color", T)];
      }
      {
        if (S.modifier)
          return;
        let T = t.resolve(S.value.value, ["--ring-width"]);
        if (T === null && E(S.value.value) && (T = `${S.value.value}px`), T)
          return [h(), l("--tw-inset-ring-shadow", C(T)), l("box-shadow", n)];
      }
    }), o("inset-ring", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--ring-color", "--color"], modifiers: Array.from({ length: 21 }, (S, T) => `${T * 5}`) }, { values: ["0", "1", "2", "4", "8"], valueThemeKeys: ["--ring-width"], hasDefaultValue: true }]);
    let P = "var(--tw-ring-inset,) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)";
    r.functional("ring-offset", (S) => {
      if (S.value) {
        if (S.value.kind === "arbitrary") {
          let T = S.value.value;
          switch (S.value.dataType ?? Y(T, ["color", "length"])) {
            case "length":
              return S.modifier ? undefined : [l("--tw-ring-offset-width", T), l("--tw-ring-offset-shadow", P)];
            default:
              return T = Z(T, S.modifier, t), T === null ? undefined : [l("--tw-ring-offset-color", T)];
          }
        }
        {
          let T = t.resolve(S.value.value, ["--ring-offset-width"]);
          if (T)
            return S.modifier ? undefined : [l("--tw-ring-offset-width", T), l("--tw-ring-offset-shadow", P)];
          if (E(S.value.value))
            return S.modifier ? undefined : [l("--tw-ring-offset-width", `${S.value.value}px`), l("--tw-ring-offset-shadow", P)];
        }
        {
          let T = te(S, t, ["--ring-offset-color", "--color"]);
          if (T)
            return [l("--tw-ring-offset-color", T)];
        }
      }
    });
  }
  return o("ring-offset", () => [{ values: ["current", "inherit", "transparent"], valueThemeKeys: ["--ring-offset-color", "--color"], modifiers: Array.from({ length: 21 }, (n, p) => `${p * 5}`) }, { values: ["0", "1", "2", "4", "8"], valueThemeKeys: ["--ring-offset-width"] }]), r.functional("@container", (n) => {
    let p = null;
    if (n.value === null ? p = "inline-size" : n.value.kind === "arbitrary" ? p = n.value.value : n.value.kind === "named" && n.value.value === "normal" && (p = "normal"), p !== null)
      return n.modifier ? [l("container-type", p), l("container-name", n.modifier.value)] : [l("container-type", p)];
  }), o("@container", () => [{ values: ["normal"], valueThemeKeys: [], hasDefaultValue: true }]), r;
}
var zt = ["number", "integer", "ratio", "percentage"];
function Tr(t) {
  let r = t.params;
  return Vi.test(r) ? (o) => {
    let e = { "--value": { usedSpacingInteger: false, usedSpacingNumber: false, themeKeys: new Set, literals: new Set }, "--modifier": { usedSpacingInteger: false, usedSpacingNumber: false, themeKeys: new Set, literals: new Set } };
    D(t.nodes, (i) => {
      if (i.kind !== "declaration" || !i.value || !i.value.includes("--value(") && !i.value.includes("--modifier("))
        return;
      let s = B(i.value);
      ee(s, (a) => {
        if (a.kind !== "function")
          return;
        if (a.value === "--spacing" && !(e["--modifier"].usedSpacingNumber && e["--value"].usedSpacingNumber))
          return ee(a.nodes, (u) => {
            if (u.kind !== "function" || u.value !== "--value" && u.value !== "--modifier")
              return;
            let c = u.value;
            for (let g of u.nodes)
              if (g.kind === "word") {
                if (g.value === "integer")
                  e[c].usedSpacingInteger ||= true;
                else if (g.value === "number" && (e[c].usedSpacingNumber ||= true, e["--modifier"].usedSpacingNumber && e["--value"].usedSpacingNumber))
                  return 2;
              }
          }), 0;
        if (a.value !== "--value" && a.value !== "--modifier")
          return;
        let f = z(J(a.nodes), ",");
        for (let [u, c] of f.entries())
          c = c.replace(/\\\*/g, "*"), c = c.replace(/--(.*?)\s--(.*?)/g, "--$1-*--$2"), c = c.replace(/\s+/g, ""), c = c.replace(/(-\*){2,}/g, "-*"), c[0] === "-" && c[1] === "-" && !c.includes("-*") && (c += "-*"), f[u] = c;
        a.nodes = B(f.join(","));
        for (let u of a.nodes)
          if (u.kind === "word" && (u.value[0] === '"' || u.value[0] === "'") && u.value[0] === u.value[u.value.length - 1]) {
            let c = u.value.slice(1, -1);
            e[a.value].literals.add(c);
          } else if (u.kind === "word" && u.value[0] === "-" && u.value[1] === "-") {
            let c = u.value.replace(/-\*.*$/g, "");
            e[a.value].themeKeys.add(c);
          } else if (u.kind === "word" && !(u.value[0] === "[" && u.value[u.value.length - 1] === "]") && !zt.includes(u.value)) {
            console.warn(`Unsupported bare value data type: "${u.value}".
Only valid data types are: ${zt.map((x) => `"${x}"`).join(", ")}.
`);
            let c = u.value, g = structuredClone(a), d = "¶";
            ee(g.nodes, (x, { replaceWith: y }) => {
              x.kind === "word" && x.value === c && y({ kind: "word", value: d });
            });
            let m = "^".repeat(J([u]).length), v = J([g]).indexOf(d), k = ["```css", J([a]), " ".repeat(v) + m, "```"].join(`
`);
            console.warn(k);
          }
      }), i.value = J(s);
    }), o.utilities.functional(r.slice(0, -2), (i) => {
      let s = structuredClone(t), a = i.value, f = i.modifier;
      if (a === null)
        return;
      let u = false, c = false, g = false, d = false, m = new Map, v = false;
      if (D([s], (k, { parent: x, replaceWith: y }) => {
        if (x?.kind !== "rule" && x?.kind !== "at-rule" || k.kind !== "declaration" || !k.value)
          return;
        let N = B(k.value);
        (ee(N, (V, { replaceWith: R }) => {
          if (V.kind === "function") {
            if (V.value === "--value") {
              u = true;
              let U = $r(a, V, o);
              return U ? (c = true, U.ratio ? v = true : m.set(k, x), R(U.nodes), 1) : (u ||= false, y([]), 2);
            } else if (V.value === "--modifier") {
              if (f === null)
                return y([]), 2;
              g = true;
              let U = $r(f, V, o);
              return U ? (d = true, R(U.nodes), 1) : (g ||= false, y([]), 2);
            }
          }
        }) ?? 0) === 0 && (k.value = J(N));
      }), u && !c || g && !d || v && d || f && !v && !d)
        return null;
      if (v)
        for (let [k, x] of m) {
          let y = x.nodes.indexOf(k);
          y !== -1 && x.nodes.splice(y, 1);
        }
      return s.nodes;
    }), o.utilities.suggest(r.slice(0, -2), () => {
      let i = [], s = [];
      for (let [a, { literals: f, usedSpacingNumber: u, usedSpacingInteger: c, themeKeys: g }] of [[i, e["--value"]], [s, e["--modifier"]]]) {
        for (let d of f)
          a.push(d);
        if (u)
          a.push(...at);
        else if (c)
          for (let d of at)
            E(d) && a.push(d);
        for (let d of o.theme.keysInNamespaces(g))
          a.push(d.replace(Nr, (m, v, k) => `${v}.${k}`));
      }
      return [{ values: i, modifiers: s }];
    });
  } : Ni.test(r) ? (o) => {
    o.utilities.static(r, () => structuredClone(t.nodes));
  } : null;
}
function $r(t, r, o) {
  for (let e of r.nodes) {
    if (t.kind === "named" && e.kind === "word" && (e.value[0] === "'" || e.value[0] === '"') && e.value[e.value.length - 1] === e.value[0] && e.value.slice(1, -1) === t.value)
      return { nodes: B(t.value) };
    if (t.kind === "named" && e.kind === "word" && e.value[0] === "-" && e.value[1] === "-") {
      let i = e.value;
      if (i.endsWith("-*")) {
        i = i.slice(0, -2);
        let s = o.theme.resolve(t.value, [i]);
        if (s)
          return { nodes: B(s) };
      } else {
        let s = i.split("-*");
        if (s.length <= 1)
          continue;
        let a = [s.shift()], f = o.theme.resolveWith(t.value, a, s);
        if (f) {
          let [, u = {}] = f;
          {
            let c = u[s.pop()];
            if (c)
              return { nodes: B(c) };
          }
        }
      }
    } else if (t.kind === "named" && e.kind === "word") {
      if (!zt.includes(e.value))
        continue;
      let i = e.value === "ratio" && "fraction" in t ? t.fraction : t.value;
      if (!i)
        continue;
      let s = Y(i, [e.value]);
      if (s === null)
        continue;
      if (s === "ratio") {
        let [a, f] = z(i, "/");
        if (!E(a) || !E(f))
          continue;
      } else {
        if (s === "number" && !xe(i))
          continue;
        if (s === "percentage" && !E(i.slice(0, -1)))
          continue;
      }
      return { nodes: B(i), ratio: s === "ratio" };
    } else if (t.kind === "arbitrary" && e.kind === "word" && e.value[0] === "[" && e.value[e.value.length - 1] === "]") {
      let i = e.value.slice(1, -1);
      if (i === "*")
        return { nodes: B(t.value) };
      if ("dataType" in t && t.dataType && t.dataType !== i)
        continue;
      if ("dataType" in t && t.dataType)
        return { nodes: B(t.value) };
      if (Y(t.value, [i]) !== null)
        return { nodes: B(t.value) };
    }
  }
}
function de(t, r, o, e, i = "") {
  let s = false, a = Ue(r, (u) => o == null ? e(u) : u.startsWith("current") ? e(Q(u, o)) : ((u.startsWith("var(") || o.startsWith("var(")) && (s = true), e(Sr(u, o))));
  function f(u) {
    return i ? z(u, ",").map((c) => i + c).join(",") : u;
  }
  return s ? [l(t, f(Ue(r, e))), G("@supports (color: lab(from red l a b))", [l(t, f(a))])] : [l(t, f(a))];
}
function lt(t, r, o, e, i = "") {
  let s = false, a = z(r, ",").map((f) => Ue(f, (u) => o == null ? e(u) : u.startsWith("current") ? e(Q(u, o)) : ((u.startsWith("var(") || o.startsWith("var(")) && (s = true), e(Sr(u, o))))).map((f) => `drop-shadow(${f})`).join(" ");
  return s ? [l(t, i + z(r, ",").map((f) => `drop-shadow(${Ue(f, e)})`).join(" ")), G("@supports (color: lab(from red l a b))", [l(t, i + a)])] : [l(t, i + a)];
}
var Kt = { "--alpha": Ti, "--spacing": Ei, "--theme": Ri, theme: Pi };
function Ti(t, r, o, ...e) {
  let [i, s] = z(o, "/").map((a) => a.trim());
  if (!i || !s)
    throw new Error(`The --alpha(…) function requires a color and an alpha value, e.g.: \`--alpha(${i || "var(--my-color)"} / ${s || "50%"})\``);
  if (e.length > 0)
    throw new Error(`The --alpha(…) function only accepts one argument, e.g.: \`--alpha(${i || "var(--my-color)"} / ${s || "50%"})\``);
  return Q(i, s);
}
function Ei(t, r, o, ...e) {
  if (!o)
    throw new Error("The --spacing(…) function requires an argument, but received none.");
  if (e.length > 0)
    throw new Error(`The --spacing(…) function only accepts a single argument, but received ${e.length + 1}.`);
  let i = t.theme.resolve(null, ["--spacing"]);
  if (!i)
    throw new Error("The --spacing(…) function requires that the `--spacing` theme variable exists, but it was not found.");
  return `calc(${i} * ${o})`;
}
function Ri(t, r, o, ...e) {
  if (!o.startsWith("--"))
    throw new Error("The --theme(…) function can only be used with CSS variables from your theme.");
  let i = false;
  o.endsWith(" inline") && (i = true, o = o.slice(0, -7)), r.kind === "at-rule" && (i = true);
  let s = t.resolveThemeValue(o, i);
  if (!s) {
    if (e.length > 0)
      return e.join(", ");
    throw new Error(`Could not resolve value for theme function: \`theme(${o})\`. Consider checking if the variable name is correct or provide a fallback value to silence this error.`);
  }
  if (e.length === 0)
    return s;
  let a = e.join(", ");
  if (a === "initial")
    return s;
  if (s === "initial")
    return a;
  if (s.startsWith("var(") || s.startsWith("theme(") || s.startsWith("--theme(")) {
    let f = B(s);
    return _i(f, a), J(f);
  }
  return s;
}
function Pi(t, r, o, ...e) {
  o = Oi(o);
  let i = t.resolveThemeValue(o);
  if (!i && e.length > 0)
    return e.join(", ");
  if (!i)
    throw new Error(`Could not resolve value for theme function: \`theme(${o})\`. Consider checking if the path is correct or provide a fallback value to silence this error.`);
  return i;
}
var Er = new RegExp(Object.keys(Kt).map((t) => `${t}\\(`).join("|"));
function Ve(t, r) {
  let o = 0;
  return D(t, (e) => {
    if (e.kind === "declaration" && e.value && Er.test(e.value)) {
      o |= 8, e.value = Rr(e.value, e, r);
      return;
    }
    e.kind === "at-rule" && (e.name === "@media" || e.name === "@custom-media" || e.name === "@container" || e.name === "@supports") && Er.test(e.params) && (o |= 8, e.params = Rr(e.params, e, r));
  }), o;
}
function Rr(t, r, o) {
  let e = B(t);
  return ee(e, (i, { replaceWith: s }) => {
    if (i.kind === "function" && i.value in Kt) {
      let a = z(J(i.nodes).trim(), ",").map((u) => u.trim()), f = Kt[i.value](o, r, ...a);
      return s(B(f));
    }
  }), J(e);
}
function Oi(t) {
  if (t[0] !== "'" && t[0] !== '"')
    return t;
  let r = "", o = t[0];
  for (let e = 1;e < t.length - 1; e++) {
    let i = t[e], s = t[e + 1];
    i === "\\" && (s === o || s === "\\") ? (r += s, e++) : r += i;
  }
  return r;
}
function _i(t, r) {
  ee(t, (o) => {
    if (o.kind === "function" && !(o.value !== "var" && o.value !== "theme" && o.value !== "--theme"))
      if (o.nodes.length === 1)
        o.nodes.push({ kind: "word", value: `, ${r}` });
      else {
        let e = o.nodes[o.nodes.length - 1];
        e.kind === "word" && e.value === "initial" && (e.value = r);
      }
  });
}
function st(t, r) {
  let o = t.length, e = r.length, i = o < e ? o : e;
  for (let s = 0;s < i; s++) {
    let a = t.charCodeAt(s), f = r.charCodeAt(s);
    if (a >= 48 && a <= 57 && f >= 48 && f <= 57) {
      let u = s, c = s + 1, g = s, d = s + 1;
      for (a = t.charCodeAt(c);a >= 48 && a <= 57; )
        a = t.charCodeAt(++c);
      for (f = r.charCodeAt(d);f >= 48 && f <= 57; )
        f = r.charCodeAt(++d);
      let m = t.slice(u, c), v = r.slice(g, d), k = Number(m) - Number(v);
      if (k)
        return k;
      if (m < v)
        return -1;
      if (m > v)
        return 1;
      continue;
    }
    if (a !== f)
      return a - f;
  }
  return t.length - r.length;
}
var zi = /^\d+\/\d+$/;
function Pr(t) {
  let r = new W((i) => ({ name: i, utility: i, fraction: false, modifiers: [] }));
  for (let i of t.utilities.keys("static")) {
    let s = r.get(i);
    s.fraction = false, s.modifiers = [];
  }
  for (let i of t.utilities.keys("functional")) {
    let s = t.utilities.getCompletions(i);
    for (let a of s)
      for (let f of a.values) {
        let u = f !== null && zi.test(f), c = f === null ? i : `${i}-${f}`, g = r.get(c);
        if (g.utility = i, g.fraction ||= u, g.modifiers.push(...a.modifiers), a.supportsNegative) {
          let d = r.get(`-${c}`);
          d.utility = `-${i}`, d.fraction ||= u, d.modifiers.push(...a.modifiers);
        }
      }
  }
  if (r.size === 0)
    return [];
  let o = Array.from(r.values());
  return o.sort((i, s) => st(i.name, s.name)), Ki(o);
}
function Ki(t) {
  let r = [], o = null, e = new Map, i = new W(() => []);
  for (let a of t) {
    let { utility: f, fraction: u } = a;
    o || (o = { utility: f, items: [] }, e.set(f, o)), f !== o.utility && (r.push(o), o = { utility: f, items: [] }, e.set(f, o)), u ? i.get(f).push(a) : o.items.push(a);
  }
  o && r[r.length - 1] !== o && r.push(o);
  for (let [a, f] of i) {
    let u = e.get(a);
    u && u.items.push(...f);
  }
  let s = [];
  for (let a of r)
    for (let f of a.items)
      s.push([f.name, { modifiers: f.modifiers }]);
  return s;
}
function Or(t) {
  let r = [];
  for (let [e, i] of t.variants.entries()) {
    let f = function({ value: u, modifier: c } = {}) {
      let g = e;
      u && (g += s ? `-${u}` : u), c && (g += `/${c}`);
      let d = t.parseVariant(g);
      if (!d)
        return [];
      let m = M(".__placeholder__", []);
      if (Te(m, d, t.variants) === null)
        return [];
      let v = [];
      return Xe(m.nodes, (k, { path: x }) => {
        if (k.kind !== "rule" && k.kind !== "at-rule" || k.nodes.length > 0)
          return;
        x.sort((b, V) => {
          let R = b.kind === "at-rule", U = V.kind === "at-rule";
          return R && !U ? -1 : !R && U ? 1 : 0;
        });
        let y = x.flatMap((b) => b.kind === "rule" ? b.selector === "&" ? [] : [b.selector] : b.kind === "at-rule" ? [`${b.name} ${b.params}`] : []), N = "";
        for (let b = y.length - 1;b >= 0; b--)
          N = N === "" ? y[b] : `${y[b]} { ${N} }`;
        v.push(N);
      }), v;
    };
    var o = f;
    if (i.kind === "arbitrary")
      continue;
    let s = e !== "@", a = t.variants.getCompletions(e);
    switch (i.kind) {
      case "static": {
        r.push({ name: e, values: a, isArbitrary: false, hasDash: s, selectors: f });
        break;
      }
      case "functional": {
        r.push({ name: e, values: a, isArbitrary: true, hasDash: s, selectors: f });
        break;
      }
      case "compound": {
        r.push({ name: e, values: a, isArbitrary: true, hasDash: s, selectors: f });
        break;
      }
    }
  }
  return r;
}
function _r(t, r) {
  let { astNodes: o, nodeSorting: e } = he(Array.from(r), t), i = new Map(r.map((a) => [a, null])), s = 0n;
  for (let a of o) {
    let f = e.get(a)?.candidate;
    f && i.set(f, i.get(f) ?? s++);
  }
  return r.map((a) => [a, i.get(a) ?? null]);
}
var ut = /^@?[a-zA-Z0-9_-]*$/;
var Dt = class {
  compareFns = new Map;
  variants = new Map;
  completions = new Map;
  groupOrder = null;
  lastOrder = 0;
  static(r, o, { compounds: e, order: i } = {}) {
    this.set(r, { kind: "static", applyFn: o, compoundsWith: 0, compounds: e ?? 2, order: i });
  }
  fromAst(r, o) {
    let e = [];
    D(o, (i) => {
      i.kind === "rule" ? e.push(i.selector) : i.kind === "at-rule" && i.name !== "@slot" && e.push(`${i.name} ${i.params}`);
    }), this.static(r, (i) => {
      let s = structuredClone(o);
      jt(s, i.nodes), i.nodes = s;
    }, { compounds: Ae(e) });
  }
  functional(r, o, { compounds: e, order: i } = {}) {
    this.set(r, { kind: "functional", applyFn: o, compoundsWith: 0, compounds: e ?? 2, order: i });
  }
  compound(r, o, e, { compounds: i, order: s } = {}) {
    this.set(r, { kind: "compound", applyFn: e, compoundsWith: o, compounds: i ?? 2, order: s });
  }
  group(r, o) {
    this.groupOrder = this.nextOrder(), o && this.compareFns.set(this.groupOrder, o), r(), this.groupOrder = null;
  }
  has(r) {
    return this.variants.has(r);
  }
  get(r) {
    return this.variants.get(r);
  }
  kind(r) {
    return this.variants.get(r)?.kind;
  }
  compoundsWith(r, o) {
    let e = this.variants.get(r), i = typeof o == "string" ? this.variants.get(o) : o.kind === "arbitrary" ? { compounds: Ae([o.selector]) } : this.variants.get(o.root);
    return !(!e || !i || e.kind !== "compound" || i.compounds === 0 || e.compoundsWith === 0 || (e.compoundsWith & i.compounds) === 0);
  }
  suggest(r, o) {
    this.completions.set(r, o);
  }
  getCompletions(r) {
    return this.completions.get(r)?.() ?? [];
  }
  compare(r, o) {
    if (r === o)
      return 0;
    if (r === null)
      return -1;
    if (o === null)
      return 1;
    if (r.kind === "arbitrary" && o.kind === "arbitrary")
      return r.selector < o.selector ? -1 : 1;
    if (r.kind === "arbitrary")
      return 1;
    if (o.kind === "arbitrary")
      return -1;
    let e = this.variants.get(r.root).order, i = this.variants.get(o.root).order, s = e - i;
    if (s !== 0)
      return s;
    if (r.kind === "compound" && o.kind === "compound") {
      let c = this.compare(r.variant, o.variant);
      return c !== 0 ? c : r.modifier && o.modifier ? r.modifier.value < o.modifier.value ? -1 : 1 : r.modifier ? 1 : o.modifier ? -1 : 0;
    }
    let a = this.compareFns.get(e);
    if (a !== undefined)
      return a(r, o);
    if (r.root !== o.root)
      return r.root < o.root ? -1 : 1;
    let f = r.value, u = o.value;
    return f === null ? -1 : u === null || f.kind === "arbitrary" && u.kind !== "arbitrary" ? 1 : f.kind !== "arbitrary" && u.kind === "arbitrary" || f.value < u.value ? -1 : 1;
  }
  keys() {
    return this.variants.keys();
  }
  entries() {
    return this.variants.entries();
  }
  set(r, { kind: o, applyFn: e, compounds: i, compoundsWith: s, order: a }) {
    let f = this.variants.get(r);
    f ? Object.assign(f, { kind: o, applyFn: e, compounds: i }) : (a === undefined && (this.lastOrder = this.nextOrder(), a = this.lastOrder), this.variants.set(r, { kind: o, applyFn: e, order: a, compoundsWith: s, compounds: i }));
  }
  nextOrder() {
    return this.groupOrder ?? this.lastOrder + 1;
  }
};
function Ae(t) {
  let r = 0;
  for (let o of t) {
    if (o[0] === "@") {
      if (!o.startsWith("@media") && !o.startsWith("@supports") && !o.startsWith("@container"))
        return 0;
      r |= 1;
      continue;
    }
    if (o.includes("::"))
      return 0;
    r |= 2;
  }
  return r;
}
function Kr(t) {
  let r = new Dt;
  function o(c, g, { compounds: d } = {}) {
    d = d ?? Ae(g), r.static(c, (m) => {
      m.nodes = g.map((v) => G(v, m.nodes));
    }, { compounds: d });
  }
  o("*", [":is(& > *)"], { compounds: 0 }), o("**", [":is(& *)"], { compounds: 0 });
  function e(c, g) {
    return g.map((d) => {
      d = d.trim();
      let m = z(d, " ");
      return m[0] === "not" ? m.slice(1).join(" ") : c === "@container" ? m[0][0] === "(" ? `not ${d}` : m[1] === "not" ? `${m[0]} ${m.slice(2).join(" ")}` : `${m[0]} not ${m.slice(1).join(" ")}` : `not ${d}`;
    });
  }
  let i = ["@media", "@supports", "@container"];
  function s(c) {
    for (let g of i) {
      if (g !== c.name)
        continue;
      let d = z(c.params, ",");
      return d.length > 1 ? null : (d = e(c.name, d), F(c.name, d.join(", ")));
    }
    return null;
  }
  function a(c) {
    return c.includes("::") ? null : `&:not(${z(c, ",").map((d) => (d = d.replaceAll("&", "*"), d)).join(", ")})`;
  }
  r.compound("not", 3, (c, g) => {
    if (g.variant.kind === "arbitrary" && g.variant.relative || g.modifier)
      return null;
    let d = false;
    if (D([c], (m, { path: v }) => {
      if (m.kind !== "rule" && m.kind !== "at-rule")
        return 0;
      if (m.nodes.length > 0)
        return 0;
      let k = [], x = [];
      for (let N of v)
        N.kind === "at-rule" ? k.push(N) : N.kind === "rule" && x.push(N);
      if (k.length > 1)
        return 2;
      if (x.length > 1)
        return 2;
      let y = [];
      for (let N of x) {
        let b = a(N.selector);
        if (!b)
          return d = false, 2;
        y.push(M(b, []));
      }
      for (let N of k) {
        let b = s(N);
        if (!b)
          return d = false, 2;
        y.push(b);
      }
      return Object.assign(c, M("&", y)), d = true, 1;
    }), c.kind === "rule" && c.selector === "&" && c.nodes.length === 1 && Object.assign(c, c.nodes[0]), !d)
      return null;
  }), r.suggest("not", () => Array.from(r.keys()).filter((c) => r.compoundsWith("not", c))), r.compound("group", 2, (c, g) => {
    if (g.variant.kind === "arbitrary" && g.variant.relative)
      return null;
    let d = g.modifier ? `:where(.${t.prefix ? `${t.prefix}\\:` : ""}group\\/${g.modifier.value})` : `:where(.${t.prefix ? `${t.prefix}\\:` : ""}group)`, m = false;
    if (D([c], (v, { path: k }) => {
      if (v.kind !== "rule")
        return 0;
      for (let y of k.slice(0, -1))
        if (y.kind === "rule")
          return m = false, 2;
      let x = v.selector.replaceAll("&", d);
      z(x, ",").length > 1 && (x = `:is(${x})`), v.selector = `&:is(${x} *)`, m = true;
    }), !m)
      return null;
  }), r.suggest("group", () => Array.from(r.keys()).filter((c) => r.compoundsWith("group", c))), r.compound("peer", 2, (c, g) => {
    if (g.variant.kind === "arbitrary" && g.variant.relative)
      return null;
    let d = g.modifier ? `:where(.${t.prefix ? `${t.prefix}\\:` : ""}peer\\/${g.modifier.value})` : `:where(.${t.prefix ? `${t.prefix}\\:` : ""}peer)`, m = false;
    if (D([c], (v, { path: k }) => {
      if (v.kind !== "rule")
        return 0;
      for (let y of k.slice(0, -1))
        if (y.kind === "rule")
          return m = false, 2;
      let x = v.selector.replaceAll("&", d);
      z(x, ",").length > 1 && (x = `:is(${x})`), v.selector = `&:is(${x} ~ *)`, m = true;
    }), !m)
      return null;
  }), r.suggest("peer", () => Array.from(r.keys()).filter((c) => r.compoundsWith("peer", c))), o("first-letter", ["&::first-letter"]), o("first-line", ["&::first-line"]), o("marker", ["& *::marker", "&::marker", "& *::-webkit-details-marker", "&::-webkit-details-marker"]), o("selection", ["& *::selection", "&::selection"]), o("file", ["&::file-selector-button"]), o("placeholder", ["&::placeholder"]), o("backdrop", ["&::backdrop"]), o("details-content", ["&::details-content"]);
  {
    let c = function() {
      return j([F("@property", "--tw-content", [l("syntax", '"*"'), l("initial-value", '""'), l("inherits", "false")])]);
    };
    var f = c;
    r.static("before", (g) => {
      g.nodes = [M("&::before", [c(), l("content", "var(--tw-content)"), ...g.nodes])];
    }, { compounds: 0 }), r.static("after", (g) => {
      g.nodes = [M("&::after", [c(), l("content", "var(--tw-content)"), ...g.nodes])];
    }, { compounds: 0 });
  }
  o("first", ["&:first-child"]), o("last", ["&:last-child"]), o("only", ["&:only-child"]), o("odd", ["&:nth-child(odd)"]), o("even", ["&:nth-child(even)"]), o("first-of-type", ["&:first-of-type"]), o("last-of-type", ["&:last-of-type"]), o("only-of-type", ["&:only-of-type"]), o("visited", ["&:visited"]), o("target", ["&:target"]), o("open", ["&:is([open], :popover-open, :open)"]), o("default", ["&:default"]), o("checked", ["&:checked"]), o("indeterminate", ["&:indeterminate"]), o("placeholder-shown", ["&:placeholder-shown"]), o("autofill", ["&:autofill"]), o("optional", ["&:optional"]), o("required", ["&:required"]), o("valid", ["&:valid"]), o("invalid", ["&:invalid"]), o("user-valid", ["&:user-valid"]), o("user-invalid", ["&:user-invalid"]), o("in-range", ["&:in-range"]), o("out-of-range", ["&:out-of-range"]), o("read-only", ["&:read-only"]), o("empty", ["&:empty"]), o("focus-within", ["&:focus-within"]), r.static("hover", (c) => {
    c.nodes = [M("&:hover", [F("@media", "(hover: hover)", c.nodes)])];
  }), o("focus", ["&:focus"]), o("focus-visible", ["&:focus-visible"]), o("active", ["&:active"]), o("enabled", ["&:enabled"]), o("disabled", ["&:disabled"]), o("inert", ["&:is([inert], [inert] *)"]), r.compound("in", 2, (c, g) => {
    if (g.modifier)
      return null;
    let d = false;
    if (D([c], (m, { path: v }) => {
      if (m.kind !== "rule")
        return 0;
      for (let k of v.slice(0, -1))
        if (k.kind === "rule")
          return d = false, 2;
      m.selector = `:where(${m.selector.replaceAll("&", "*")}) &`, d = true;
    }), !d)
      return null;
  }), r.suggest("in", () => Array.from(r.keys()).filter((c) => r.compoundsWith("in", c))), r.compound("has", 2, (c, g) => {
    if (g.modifier)
      return null;
    let d = false;
    if (D([c], (m, { path: v }) => {
      if (m.kind !== "rule")
        return 0;
      for (let k of v.slice(0, -1))
        if (k.kind === "rule")
          return d = false, 2;
      m.selector = `&:has(${m.selector.replaceAll("&", "*")})`, d = true;
    }), !d)
      return null;
  }), r.suggest("has", () => Array.from(r.keys()).filter((c) => r.compoundsWith("has", c))), r.functional("aria", (c, g) => {
    if (!g.value || g.modifier)
      return null;
    g.value.kind === "arbitrary" ? c.nodes = [M(`&[aria-${zr(g.value.value)}]`, c.nodes)] : c.nodes = [M(`&[aria-${g.value.value}="true"]`, c.nodes)];
  }), r.suggest("aria", () => ["busy", "checked", "disabled", "expanded", "hidden", "pressed", "readonly", "required", "selected"]), r.functional("data", (c, g) => {
    if (!g.value || g.modifier)
      return null;
    c.nodes = [M(`&[data-${zr(g.value.value)}]`, c.nodes)];
  }), r.functional("nth", (c, g) => {
    if (!g.value || g.modifier || g.value.kind === "named" && !E(g.value.value))
      return null;
    c.nodes = [M(`&:nth-child(${g.value.value})`, c.nodes)];
  }), r.functional("nth-last", (c, g) => {
    if (!g.value || g.modifier || g.value.kind === "named" && !E(g.value.value))
      return null;
    c.nodes = [M(`&:nth-last-child(${g.value.value})`, c.nodes)];
  }), r.functional("nth-of-type", (c, g) => {
    if (!g.value || g.modifier || g.value.kind === "named" && !E(g.value.value))
      return null;
    c.nodes = [M(`&:nth-of-type(${g.value.value})`, c.nodes)];
  }), r.functional("nth-last-of-type", (c, g) => {
    if (!g.value || g.modifier || g.value.kind === "named" && !E(g.value.value))
      return null;
    c.nodes = [M(`&:nth-last-of-type(${g.value.value})`, c.nodes)];
  }), r.functional("supports", (c, g) => {
    if (!g.value || g.modifier)
      return null;
    let d = g.value.value;
    if (d === null)
      return null;
    if (/^[\w-]*\s*\(/.test(d)) {
      let m = d.replace(/\b(and|or|not)\b/g, " $1 ");
      c.nodes = [F("@supports", m, c.nodes)];
      return;
    }
    d.includes(":") || (d = `${d}: var(--tw)`), (d[0] !== "(" || d[d.length - 1] !== ")") && (d = `(${d})`), c.nodes = [F("@supports", d, c.nodes)];
  }, { compounds: 1 }), o("motion-safe", ["@media (prefers-reduced-motion: no-preference)"]), o("motion-reduce", ["@media (prefers-reduced-motion: reduce)"]), o("contrast-more", ["@media (prefers-contrast: more)"]), o("contrast-less", ["@media (prefers-contrast: less)"]);
  {
    let c = function(g, d, m, v) {
      if (g === d)
        return 0;
      let k = v.get(g);
      if (k === null)
        return m === "asc" ? -1 : 1;
      let x = v.get(d);
      return x === null ? m === "asc" ? 1 : -1 : ye(k, x, m);
    };
    var u = c;
    {
      let g = t.namespace("--breakpoint"), d = new W((m) => {
        switch (m.kind) {
          case "static":
            return t.resolveValue(m.root, ["--breakpoint"]) ?? null;
          case "functional": {
            if (!m.value || m.modifier)
              return null;
            let v = null;
            return m.value.kind === "arbitrary" ? v = m.value.value : m.value.kind === "named" && (v = t.resolveValue(m.value.value, ["--breakpoint"])), !v || v.includes("var(") ? null : v;
          }
          case "arbitrary":
          case "compound":
            return null;
        }
      });
      r.group(() => {
        r.functional("max", (m, v) => {
          if (v.modifier)
            return null;
          let k = d.get(v);
          if (k === null)
            return null;
          m.nodes = [F("@media", `(width < ${k})`, m.nodes)];
        }, { compounds: 1 });
      }, (m, v) => c(m, v, "desc", d)), r.suggest("max", () => Array.from(g.keys()).filter((m) => m !== null)), r.group(() => {
        for (let [m, v] of t.namespace("--breakpoint"))
          m !== null && r.static(m, (k) => {
            k.nodes = [F("@media", `(width >= ${v})`, k.nodes)];
          }, { compounds: 1 });
        r.functional("min", (m, v) => {
          if (v.modifier)
            return null;
          let k = d.get(v);
          if (k === null)
            return null;
          m.nodes = [F("@media", `(width >= ${k})`, m.nodes)];
        }, { compounds: 1 });
      }, (m, v) => c(m, v, "asc", d)), r.suggest("min", () => Array.from(g.keys()).filter((m) => m !== null));
    }
    {
      let g = t.namespace("--container"), d = new W((m) => {
        switch (m.kind) {
          case "functional": {
            if (m.value === null)
              return null;
            let v = null;
            return m.value.kind === "arbitrary" ? v = m.value.value : m.value.kind === "named" && (v = t.resolveValue(m.value.value, ["--container"])), !v || v.includes("var(") ? null : v;
          }
          case "static":
          case "arbitrary":
          case "compound":
            return null;
        }
      });
      r.group(() => {
        r.functional("@max", (m, v) => {
          let k = d.get(v);
          if (k === null)
            return null;
          m.nodes = [F("@container", v.modifier ? `${v.modifier.value} (width < ${k})` : `(width < ${k})`, m.nodes)];
        }, { compounds: 1 });
      }, (m, v) => c(m, v, "desc", d)), r.suggest("@max", () => Array.from(g.keys()).filter((m) => m !== null)), r.group(() => {
        r.functional("@", (m, v) => {
          let k = d.get(v);
          if (k === null)
            return null;
          m.nodes = [F("@container", v.modifier ? `${v.modifier.value} (width >= ${k})` : `(width >= ${k})`, m.nodes)];
        }, { compounds: 1 }), r.functional("@min", (m, v) => {
          let k = d.get(v);
          if (k === null)
            return null;
          m.nodes = [F("@container", v.modifier ? `${v.modifier.value} (width >= ${k})` : `(width >= ${k})`, m.nodes)];
        }, { compounds: 1 });
      }, (m, v) => c(m, v, "asc", d)), r.suggest("@min", () => Array.from(g.keys()).filter((m) => m !== null)), r.suggest("@", () => Array.from(g.keys()).filter((m) => m !== null));
    }
  }
  return o("portrait", ["@media (orientation: portrait)"]), o("landscape", ["@media (orientation: landscape)"]), o("ltr", ['&:where(:dir(ltr), [dir="ltr"], [dir="ltr"] *)']), o("rtl", ['&:where(:dir(rtl), [dir="rtl"], [dir="rtl"] *)']), o("dark", ["@media (prefers-color-scheme: dark)"]), o("starting", ["@starting-style"]), o("print", ["@media print"]), o("forced-colors", ["@media (forced-colors: active)"]), o("inverted-colors", ["@media (inverted-colors: inverted)"]), o("pointer-none", ["@media (pointer: none)"]), o("pointer-coarse", ["@media (pointer: coarse)"]), o("pointer-fine", ["@media (pointer: fine)"]), o("any-pointer-none", ["@media (any-pointer: none)"]), o("any-pointer-coarse", ["@media (any-pointer: coarse)"]), o("any-pointer-fine", ["@media (any-pointer: fine)"]), o("noscript", ["@media (scripting: none)"]), r;
}
function zr(t) {
  if (t.includes("=")) {
    let [r, ...o] = z(t, "="), e = o.join("=").trim();
    if (e[0] === "'" || e[0] === '"')
      return t;
    if (e.length > 1) {
      let i = e[e.length - 1];
      if (e[e.length - 2] === " " && (i === "i" || i === "I" || i === "s" || i === "S"))
        return `${r}="${e.slice(0, -2)}" ${i}`;
    }
    return `${r}="${e}"`;
  }
  return t;
}
function jt(t, r) {
  D(t, (o, { replaceWith: e }) => {
    if (o.kind === "at-rule" && o.name === "@slot")
      e(r);
    else if (o.kind === "at-rule" && (o.name === "@keyframes" || o.name === "@property"))
      return Object.assign(o, j([F(o.name, o.params, o.nodes)])), 1;
  });
}
function Ur(t) {
  let r = Vr(t), o = Kr(t), e = new W((u) => hr(u, f)), i = new W((u) => Array.from(gr(u, f))), s = new W((u) => {
    let c = Dr(u, f);
    try {
      Ve(c.map(({ node: g }) => g), f);
    } catch {
      return [];
    }
    return c;
  }), a = new W((u) => {
    for (let c of Ze(u))
      t.markUsedVariable(c);
  }), f = { theme: t, utilities: r, variants: o, invalidCandidates: new Set, important: false, candidatesToCss(u) {
    let c = [];
    for (let g of u) {
      let d = false, { astNodes: m } = he([g], this, { onInvalidCandidate() {
        d = true;
      } });
      m = be(m, f, 0), m.length === 0 || d ? c.push(null) : c.push(ne(m));
    }
    return c;
  }, getClassOrder(u) {
    return _r(this, u);
  }, getClassList() {
    return Pr(this);
  }, getVariants() {
    return Or(this);
  }, parseCandidate(u) {
    return i.get(u);
  }, parseVariant(u) {
    return e.get(u);
  }, compileAstNodes(u) {
    return s.get(u);
  }, printCandidate(u) {
    return vr(f, u);
  }, printVariant(u) {
    return ot(u);
  }, getVariantOrder() {
    let u = Array.from(e.values());
    u.sort((m, v) => this.variants.compare(m, v));
    let c = new Map, g, d = 0;
    for (let m of u)
      m !== null && (g !== undefined && this.variants.compare(g, m) !== 0 && d++, c.set(m, d), g = m);
    return c;
  }, resolveThemeValue(u, c = true) {
    let g = u.lastIndexOf("/"), d = null;
    g !== -1 && (d = u.slice(g + 1).trim(), u = u.slice(0, g).trim());
    let m = t.resolve(null, [u], c ? 1 : 0) ?? undefined;
    return d && m ? Q(m, d) : m;
  }, trackUsedVariables(u) {
    a.get(u);
  } };
  return f;
}
var Lt = ["container-type", "pointer-events", "visibility", "position", "inset", "inset-inline", "inset-block", "inset-inline-start", "inset-inline-end", "top", "right", "bottom", "left", "isolation", "z-index", "order", "grid-column", "grid-column-start", "grid-column-end", "grid-row", "grid-row-start", "grid-row-end", "float", "clear", "--tw-container-component", "margin", "margin-inline", "margin-block", "margin-inline-start", "margin-inline-end", "margin-top", "margin-right", "margin-bottom", "margin-left", "box-sizing", "display", "field-sizing", "aspect-ratio", "height", "max-height", "min-height", "width", "max-width", "min-width", "flex", "flex-shrink", "flex-grow", "flex-basis", "table-layout", "caption-side", "border-collapse", "border-spacing", "transform-origin", "translate", "--tw-translate-x", "--tw-translate-y", "--tw-translate-z", "scale", "--tw-scale-x", "--tw-scale-y", "--tw-scale-z", "rotate", "--tw-rotate-x", "--tw-rotate-y", "--tw-rotate-z", "--tw-skew-x", "--tw-skew-y", "transform", "animation", "cursor", "touch-action", "--tw-pan-x", "--tw-pan-y", "--tw-pinch-zoom", "resize", "scroll-snap-type", "--tw-scroll-snap-strictness", "scroll-snap-align", "scroll-snap-stop", "scroll-margin", "scroll-margin-inline", "scroll-margin-block", "scroll-margin-inline-start", "scroll-margin-inline-end", "scroll-margin-top", "scroll-margin-right", "scroll-margin-bottom", "scroll-margin-left", "scroll-padding", "scroll-padding-inline", "scroll-padding-block", "scroll-padding-inline-start", "scroll-padding-inline-end", "scroll-padding-top", "scroll-padding-right", "scroll-padding-bottom", "scroll-padding-left", "list-style-position", "list-style-type", "list-style-image", "appearance", "columns", "break-before", "break-inside", "break-after", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-template-columns", "grid-template-rows", "flex-direction", "flex-wrap", "place-content", "place-items", "align-content", "align-items", "justify-content", "justify-items", "gap", "column-gap", "row-gap", "--tw-space-x-reverse", "--tw-space-y-reverse", "divide-x-width", "divide-y-width", "--tw-divide-y-reverse", "divide-style", "divide-color", "place-self", "align-self", "justify-self", "overflow", "overflow-x", "overflow-y", "overscroll-behavior", "overscroll-behavior-x", "overscroll-behavior-y", "scroll-behavior", "border-radius", "border-start-radius", "border-end-radius", "border-top-radius", "border-right-radius", "border-bottom-radius", "border-left-radius", "border-start-start-radius", "border-start-end-radius", "border-end-end-radius", "border-end-start-radius", "border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius", "border-width", "border-inline-width", "border-block-width", "border-inline-start-width", "border-inline-end-width", "border-top-width", "border-right-width", "border-bottom-width", "border-left-width", "border-style", "border-inline-style", "border-block-style", "border-inline-start-style", "border-inline-end-style", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-color", "border-inline-color", "border-block-color", "border-inline-start-color", "border-inline-end-color", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "background-color", "background-image", "--tw-gradient-position", "--tw-gradient-stops", "--tw-gradient-via-stops", "--tw-gradient-from", "--tw-gradient-from-position", "--tw-gradient-via", "--tw-gradient-via-position", "--tw-gradient-to", "--tw-gradient-to-position", "mask-image", "--tw-mask-top", "--tw-mask-top-from-color", "--tw-mask-top-from-position", "--tw-mask-top-to-color", "--tw-mask-top-to-position", "--tw-mask-right", "--tw-mask-right-from-color", "--tw-mask-right-from-position", "--tw-mask-right-to-color", "--tw-mask-right-to-position", "--tw-mask-bottom", "--tw-mask-bottom-from-color", "--tw-mask-bottom-from-position", "--tw-mask-bottom-to-color", "--tw-mask-bottom-to-position", "--tw-mask-left", "--tw-mask-left-from-color", "--tw-mask-left-from-position", "--tw-mask-left-to-color", "--tw-mask-left-to-position", "--tw-mask-linear", "--tw-mask-linear-position", "--tw-mask-linear-from-color", "--tw-mask-linear-from-position", "--tw-mask-linear-to-color", "--tw-mask-linear-to-position", "--tw-mask-radial", "--tw-mask-radial-shape", "--tw-mask-radial-size", "--tw-mask-radial-position", "--tw-mask-radial-from-color", "--tw-mask-radial-from-position", "--tw-mask-radial-to-color", "--tw-mask-radial-to-position", "--tw-mask-conic", "--tw-mask-conic-position", "--tw-mask-conic-from-color", "--tw-mask-conic-from-position", "--tw-mask-conic-to-color", "--tw-mask-conic-to-position", "box-decoration-break", "background-size", "background-attachment", "background-clip", "background-position", "background-repeat", "background-origin", "mask-composite", "mask-mode", "mask-type", "mask-size", "mask-clip", "mask-position", "mask-repeat", "mask-origin", "fill", "stroke", "stroke-width", "object-fit", "object-position", "padding", "padding-inline", "padding-block", "padding-inline-start", "padding-inline-end", "padding-top", "padding-right", "padding-bottom", "padding-left", "text-align", "text-indent", "vertical-align", "font-family", "font-size", "line-height", "font-weight", "letter-spacing", "text-wrap", "overflow-wrap", "word-break", "text-overflow", "hyphens", "white-space", "color", "text-transform", "font-style", "font-stretch", "font-variant-numeric", "text-decoration-line", "text-decoration-color", "text-decoration-style", "text-decoration-thickness", "text-underline-offset", "-webkit-font-smoothing", "placeholder-color", "caret-color", "accent-color", "color-scheme", "opacity", "background-blend-mode", "mix-blend-mode", "box-shadow", "--tw-shadow", "--tw-shadow-color", "--tw-ring-shadow", "--tw-ring-color", "--tw-inset-shadow", "--tw-inset-shadow-color", "--tw-inset-ring-shadow", "--tw-inset-ring-color", "--tw-ring-offset-width", "--tw-ring-offset-color", "outline", "outline-width", "outline-offset", "outline-color", "--tw-blur", "--tw-brightness", "--tw-contrast", "--tw-drop-shadow", "--tw-grayscale", "--tw-hue-rotate", "--tw-invert", "--tw-saturate", "--tw-sepia", "filter", "--tw-backdrop-blur", "--tw-backdrop-brightness", "--tw-backdrop-contrast", "--tw-backdrop-grayscale", "--tw-backdrop-hue-rotate", "--tw-backdrop-invert", "--tw-backdrop-opacity", "--tw-backdrop-saturate", "--tw-backdrop-sepia", "backdrop-filter", "transition-property", "transition-behavior", "transition-delay", "transition-duration", "transition-timing-function", "will-change", "contain", "content", "forced-color-adjust"];
function he(t, r, { onInvalidCandidate: o } = {}) {
  let e = new Map, i = [], s = new Map;
  for (let f of t) {
    if (r.invalidCandidates.has(f)) {
      o?.(f);
      continue;
    }
    let u = r.parseCandidate(f);
    if (u.length === 0) {
      o?.(f);
      continue;
    }
    s.set(f, u);
  }
  let a = r.getVariantOrder();
  for (let [f, u] of s) {
    let c = false;
    for (let g of u) {
      let d = r.compileAstNodes(g);
      if (d.length !== 0) {
        c = true;
        for (let { node: m, propertySort: v } of d) {
          let k = 0n;
          for (let x of g.variants)
            k |= 1n << BigInt(a.get(x));
          e.set(m, { properties: v, variants: k, candidate: f }), i.push(m);
        }
      }
    }
    c || o?.(f);
  }
  return i.sort((f, u) => {
    let c = e.get(f), g = e.get(u);
    if (c.variants - g.variants !== 0n)
      return Number(c.variants - g.variants);
    let d = 0;
    for (;d < c.properties.order.length && d < g.properties.order.length && c.properties.order[d] === g.properties.order[d]; )
      d += 1;
    return (c.properties.order[d] ?? 1 / 0) - (g.properties.order[d] ?? 1 / 0) || g.properties.count - c.properties.count || st(c.candidate, g.candidate);
  }), { astNodes: i, nodeSorting: e };
}
function Dr(t, r) {
  let o = Ui(t, r);
  if (o.length === 0)
    return [];
  let e = [], i = `.${me(t.raw)}`;
  for (let s of o) {
    let a = Di(s);
    (t.important || r.important) && Lr(s);
    let f = { kind: "rule", selector: i, nodes: s };
    for (let u of t.variants)
      if (Te(f, u, r.variants) === null)
        return [];
    e.push({ node: f, propertySort: a });
  }
  return e;
}
function Te(t, r, o, e = 0) {
  if (r.kind === "arbitrary") {
    if (r.relative && e === 0)
      return null;
    t.nodes = [G(r.selector, t.nodes)];
    return;
  }
  let { applyFn: i } = o.get(r.root);
  if (r.kind === "compound") {
    let a = F("@slot");
    if (Te(a, r.variant, o, e + 1) === null || r.root === "not" && a.nodes.length > 1)
      return null;
    for (let u of a.nodes)
      if (u.kind !== "rule" && u.kind !== "at-rule" || i(u, r) === null)
        return null;
    D(a.nodes, (u) => {
      if ((u.kind === "rule" || u.kind === "at-rule") && u.nodes.length <= 0)
        return u.nodes = t.nodes, 1;
    }), t.nodes = a.nodes;
    return;
  }
  if (i(t, r) === null)
    return null;
}
function jr(t) {
  let r = t.options?.types ?? [];
  return r.length > 1 && r.includes("any");
}
function Ui(t, r) {
  if (t.kind === "arbitrary") {
    let a = t.value;
    return t.modifier && (a = Z(a, t.modifier, r.theme)), a === null ? [] : [[l(t.property, a)]];
  }
  let o = r.utilities.get(t.root) ?? [], e = [], i = o.filter((a) => !jr(a));
  for (let a of i) {
    if (a.kind !== t.kind)
      continue;
    let f = a.compileFn(t);
    if (f !== undefined) {
      if (f === null)
        return e;
      e.push(f);
    }
  }
  if (e.length > 0)
    return e;
  let s = o.filter((a) => jr(a));
  for (let a of s) {
    if (a.kind !== t.kind)
      continue;
    let f = a.compileFn(t);
    if (f !== undefined) {
      if (f === null)
        return e;
      e.push(f);
    }
  }
  return e;
}
function Lr(t) {
  for (let r of t)
    r.kind !== "at-root" && (r.kind === "declaration" ? r.important = true : (r.kind === "rule" || r.kind === "at-rule") && Lr(r.nodes));
}
function Di(t) {
  let r = new Set, o = 0, e = t.slice(), i = false;
  for (;e.length > 0; ) {
    let s = e.shift();
    if (s.kind === "declaration") {
      if (s.value === undefined || (o++, i))
        continue;
      if (s.property === "--tw-sort") {
        let f = Lt.indexOf(s.value ?? "");
        if (f !== -1) {
          r.add(f), i = true;
          continue;
        }
      }
      let a = Lt.indexOf(s.property);
      a !== -1 && r.add(a);
    } else if (s.kind === "rule" || s.kind === "at-rule")
      for (let a of s.nodes)
        e.push(a);
  }
  return { order: Array.from(r).sort((s, a) => s - a), count: o };
}
function je(t, r) {
  let o = 0, e = G("&", t), i = new Set, s = new W(() => new Set), a = new W(() => new Set);
  D([e], (d, { parent: m, path: v }) => {
    if (d.kind === "at-rule") {
      if (d.name === "@keyframes")
        return D(d.nodes, (k) => {
          if (k.kind === "at-rule" && k.name === "@apply")
            throw new Error("You cannot use `@apply` inside `@keyframes`.");
        }), 1;
      if (d.name === "@utility") {
        let k = d.params.replace(/-\*$/, "");
        a.get(k).add(d), D(d.nodes, (x) => {
          if (!(x.kind !== "at-rule" || x.name !== "@apply")) {
            i.add(d);
            for (let y of Ir(x, r))
              s.get(d).add(y);
          }
        });
        return;
      }
      if (d.name === "@apply") {
        if (m === null)
          return;
        o |= 1, i.add(m);
        for (let k of Ir(d, r))
          for (let x of v)
            x !== d && i.has(x) && s.get(x).add(k);
      }
    }
  });
  let f = new Set, u = [], c = new Set;
  function g(d, m = []) {
    if (!f.has(d)) {
      if (c.has(d)) {
        let v = m[(m.indexOf(d) + 1) % m.length];
        throw d.kind === "at-rule" && d.name === "@utility" && v.kind === "at-rule" && v.name === "@utility" && D(d.nodes, (k) => {
          if (k.kind !== "at-rule" || k.name !== "@apply")
            return;
          let x = k.params.split(/\s+/g);
          for (let y of x)
            for (let N of r.parseCandidate(y))
              switch (N.kind) {
                case "arbitrary":
                  break;
                case "static":
                case "functional":
                  if (v.params.replace(/-\*$/, "") === N.root)
                    throw new Error(`You cannot \`@apply\` the \`${y}\` utility here because it creates a circular dependency.`);
                  break;
                default:
              }
        }), new Error(`Circular dependency detected:

${ne([d])}
Relies on:

${ne([v])}`);
      }
      c.add(d);
      for (let v of s.get(d))
        for (let k of a.get(v))
          m.push(d), g(k, m), m.pop();
      f.add(d), c.delete(d), u.push(d);
    }
  }
  for (let d of i)
    g(d);
  for (let d of u)
    "nodes" in d && D(d.nodes, (m, { replaceWith: v }) => {
      if (m.kind !== "at-rule" || m.name !== "@apply")
        return;
      let k = m.params.split(/(\s+)/g), x = {}, y = 0;
      for (let [N, b] of k.entries())
        N % 2 === 0 && (x[b] = y), y += b.length;
      {
        let N = Object.keys(x), b = he(N, r, { onInvalidCandidate: (_) => {
          throw new Error(`Cannot apply unknown utility class: ${_}`);
        } }), V = m.src, R = b.astNodes.map((_) => {
          let L = b.nodeSorting.get(_)?.candidate, O = L ? x[L] : undefined;
          if (_ = structuredClone(_), !V || !L || O === undefined)
            return D([_], (I) => {
              I.src = V;
            }), _;
          let H = [V[0], V[1], V[2]];
          return H[1] += 7 + O, H[2] = H[1] + L.length, D([_], (I) => {
            I.src = H;
          }), _;
        }), U = [];
        for (let _ of R)
          if (_.kind === "rule")
            for (let L of _.nodes)
              U.push(L);
          else
            U.push(_);
        v(U);
      }
    });
  return o;
}
function* Ir(t, r) {
  for (let o of t.params.split(/\s+/g))
    for (let e of r.parseCandidate(o))
      switch (e.kind) {
        case "arbitrary":
          break;
        case "static":
        case "functional":
          yield e.root;
          break;
        default:
      }
}
async function It(t, r, o, e = 0, i = false) {
  let s = 0, a = [];
  return D(t, (f, { replaceWith: u }) => {
    if (f.kind === "at-rule" && (f.name === "@import" || f.name === "@reference")) {
      let c = ji(B(f.params));
      if (c === null)
        return;
      f.name === "@reference" && (c.media = "reference"), s |= 2;
      let { uri: g, layer: d, media: m, supports: v } = c;
      if (g.startsWith("data:") || g.startsWith("http://") || g.startsWith("https://"))
        return;
      let k = se({}, []);
      return a.push((async () => {
        if (e > 100)
          throw new Error(`Exceeded maximum recursion depth while resolving \`${g}\` in \`${r}\`)`);
        let x = await o(g, r), y = $e(x.content, { from: i ? x.path : undefined });
        await It(y, x.base, o, e + 1, i), k.nodes = Li(f, [se({ base: x.base }, y)], d, m, v);
      })()), u(k), 1;
    }
  }), a.length > 0 && await Promise.all(a), s;
}
function ji(t) {
  let r, o = null, e = null, i = null;
  for (let s = 0;s < t.length; s++) {
    let a = t[s];
    if (a.kind !== "separator") {
      if (a.kind === "word" && !r) {
        if (!a.value || a.value[0] !== '"' && a.value[0] !== "'")
          return null;
        r = a.value.slice(1, -1);
        continue;
      }
      if (a.kind === "function" && a.value.toLowerCase() === "url" || !r)
        return null;
      if ((a.kind === "word" || a.kind === "function") && a.value.toLowerCase() === "layer") {
        if (o)
          return null;
        if (i)
          throw new Error("`layer(…)` in an `@import` should come before any other functions or conditions");
        "nodes" in a ? o = J(a.nodes) : o = "";
        continue;
      }
      if (a.kind === "function" && a.value.toLowerCase() === "supports") {
        if (i)
          return null;
        i = J(a.nodes);
        continue;
      }
      e = J(t.slice(s));
      break;
    }
  }
  return r ? { uri: r, layer: o, media: e, supports: i } : null;
}
function Li(t, r, o, e, i) {
  let s = r;
  if (o !== null) {
    let a = F("@layer", o, s);
    a.src = t.src, s = [a];
  }
  if (e !== null) {
    let a = F("@media", e, s);
    a.src = t.src, s = [a];
  }
  if (i !== null) {
    let a = F("@supports", i[0] === "(" ? i : `(${i})`, s);
    a.src = t.src, s = [a];
  }
  return s;
}
function Ee(t, r = null) {
  return Array.isArray(t) && t.length === 2 && typeof t[1] == "object" && typeof t[1] !== null ? r ? t[1][r] ?? null : t[0] : Array.isArray(t) && r === null ? t.join(", ") : typeof t == "string" && r === null ? t : null;
}
function Fr(t, { theme: r }, o) {
  for (let e of o) {
    let i = ct([e]);
    i && t.theme.clearNamespace(`--${i}`, 4);
  }
  for (let [e, i] of Ii(r)) {
    if (typeof i != "string" && typeof i != "number")
      continue;
    if (typeof i == "string" && (i = i.replace(/<alpha-value>/g, "1")), e[0] === "opacity" && (typeof i == "number" || typeof i == "string")) {
      let a = typeof i == "string" ? parseFloat(i) : i;
      a >= 0 && a <= 1 && (i = a * 100 + "%");
    }
    let s = ct(e);
    s && t.theme.add(`--${s}`, "" + i, 7);
  }
  if (Object.hasOwn(r, "fontFamily")) {
    let e = 5;
    {
      let i = Ee(r.fontFamily.sans);
      i && t.theme.hasDefault("--font-sans") && (t.theme.add("--default-font-family", i, e), t.theme.add("--default-font-feature-settings", Ee(r.fontFamily.sans, "fontFeatureSettings") ?? "normal", e), t.theme.add("--default-font-variation-settings", Ee(r.fontFamily.sans, "fontVariationSettings") ?? "normal", e));
    }
    {
      let i = Ee(r.fontFamily.mono);
      i && t.theme.hasDefault("--font-mono") && (t.theme.add("--default-mono-font-family", i, e), t.theme.add("--default-mono-font-feature-settings", Ee(r.fontFamily.mono, "fontFeatureSettings") ?? "normal", e), t.theme.add("--default-mono-font-variation-settings", Ee(r.fontFamily.mono, "fontVariationSettings") ?? "normal", e));
    }
  }
  return r;
}
function Ii(t) {
  let r = [];
  return Mr(t, [], (o, e) => {
    if (Mi(o))
      return r.push([e, o]), 1;
    if (Wi(o)) {
      r.push([e, o[0]]);
      for (let i of Reflect.ownKeys(o[1]))
        r.push([[...e, `-${i}`], o[1][i]]);
      return 1;
    }
    if (Array.isArray(o) && o.every((i) => typeof i == "string"))
      return e[0] === "fontSize" ? (r.push([e, o[0]]), o.length >= 2 && r.push([[...e, "-line-height"], o[1]])) : r.push([e, o.join(", ")]), 1;
  }), r;
}
var Fi = /^[a-zA-Z0-9-_%/\.]+$/;
function ct(t) {
  if (t[0] === "container")
    return null;
  t = structuredClone(t), t[0] === "animation" && (t[0] = "animate"), t[0] === "aspectRatio" && (t[0] = "aspect"), t[0] === "borderRadius" && (t[0] = "radius"), t[0] === "boxShadow" && (t[0] = "shadow"), t[0] === "colors" && (t[0] = "color"), t[0] === "containers" && (t[0] = "container"), t[0] === "fontFamily" && (t[0] = "font"), t[0] === "fontSize" && (t[0] = "text"), t[0] === "letterSpacing" && (t[0] = "tracking"), t[0] === "lineHeight" && (t[0] = "leading"), t[0] === "maxWidth" && (t[0] = "container"), t[0] === "screens" && (t[0] = "breakpoint"), t[0] === "transitionTimingFunction" && (t[0] = "ease");
  for (let r of t)
    if (!Fi.test(r))
      return null;
  return t.map((r, o, e) => r === "1" && o !== e.length - 1 ? "" : r).map((r) => r.replaceAll(".", "_").replace(/([a-z])([A-Z])/g, (o, e, i) => `${e}-${i.toLowerCase()}`)).filter((r, o) => r !== "DEFAULT" || o !== t.length - 1).join("-");
}
function Mi(t) {
  return typeof t == "number" || typeof t == "string";
}
function Wi(t) {
  if (!Array.isArray(t) || t.length !== 2 || typeof t[0] != "string" && typeof t[0] != "number" || t[1] === undefined || t[1] === null || typeof t[1] != "object")
    return false;
  for (let r of Reflect.ownKeys(t[1]))
    if (typeof r != "string" || typeof t[1][r] != "string" && typeof t[1][r] != "number")
      return false;
  return true;
}
function Mr(t, r = [], o) {
  for (let e of Reflect.ownKeys(t)) {
    let i = t[e];
    if (i == null)
      continue;
    let s = [...r, e], a = o(i, s) ?? 0;
    if (a !== 1) {
      if (a === 2)
        return 2;
      if (!(!Array.isArray(i) && typeof i != "object") && Mr(i, s, o) === 2)
        return 2;
    }
  }
}
function ft(t) {
  let r = [];
  for (let o of z(t, ".")) {
    if (!o.includes("[")) {
      r.push(o);
      continue;
    }
    let e = 0;
    for (;; ) {
      let i = o.indexOf("[", e), s = o.indexOf("]", i);
      if (i === -1 || s === -1)
        break;
      i > e && r.push(o.slice(e, i)), r.push(o.slice(i + 1, s)), e = s + 1;
    }
    e <= o.length - 1 && r.push(o.slice(e));
  }
  return r;
}
function Re(t) {
  if (Object.prototype.toString.call(t) !== "[object Object]")
    return false;
  let r = Object.getPrototypeOf(t);
  return r === null || Object.getPrototypeOf(r) === null;
}
function Le(t, r, o, e = []) {
  for (let i of r)
    if (i != null)
      for (let s of Reflect.ownKeys(i)) {
        e.push(s);
        let a = o(t[s], i[s], e);
        a !== undefined ? t[s] = a : !Re(t[s]) || !Re(i[s]) ? t[s] = i[s] : t[s] = Le({}, [t[s], i[s]], o, e), e.pop();
      }
  return t;
}
function pt(t, r, o) {
  return function(i, s) {
    let a = i.lastIndexOf("/"), f = null;
    a !== -1 && (f = i.slice(a + 1).trim(), i = i.slice(0, a).trim());
    let u = (() => {
      let c = ft(i), [g, d] = Bi(t.theme, c), m = o(Wr(r() ?? {}, c) ?? null);
      if (typeof m == "string" && (m = m.replace("<alpha-value>", "1")), typeof g != "object")
        return typeof d != "object" && d & 4 ? m ?? g : g;
      if (m !== null && typeof m == "object" && !Array.isArray(m)) {
        let v = Le({}, [m], (k, x) => x);
        if (g === null && Object.hasOwn(m, "__CSS_VALUES__")) {
          let k = {};
          for (let x in m.__CSS_VALUES__)
            k[x] = m[x], delete v[x];
          g = k;
        }
        for (let k in g)
          k !== "__CSS_VALUES__" && (m?.__CSS_VALUES__?.[k] & 4 && Wr(v, k.split("-")) !== undefined || (v[ve(k)] = g[k]));
        return v;
      }
      if (Array.isArray(g) && Array.isArray(d) && Array.isArray(m)) {
        let v = g[0], k = g[1];
        d[0] & 4 && (v = m[0] ?? v);
        for (let x of Object.keys(k))
          d[1][x] & 4 && (k[x] = m[1][x] ?? k[x]);
        return [v, k];
      }
      return g ?? m;
    })();
    return f && typeof u == "string" && (u = Q(u, f)), u ?? s;
  };
}
function Bi(t, r) {
  if (r.length === 1 && r[0].startsWith("--"))
    return [t.get([r[0]]), t.getOptions(r[0])];
  let o = ct(r), e = new Map, i = new W(() => new Map), s = t.namespace(`--${o}`);
  if (s.size === 0)
    return [null, 0];
  let a = new Map;
  for (let [g, d] of s) {
    if (!g || !g.includes("--")) {
      e.set(g, d), a.set(g, t.getOptions(g ? `--${o}-${g}` : `--${o}`));
      continue;
    }
    let m = g.indexOf("--"), v = g.slice(0, m), k = g.slice(m + 2);
    k = k.replace(/-([a-z])/g, (x, y) => y.toUpperCase()), i.get(v === "" ? null : v).set(k, [d, t.getOptions(`--${o}${g}`)]);
  }
  let f = t.getOptions(`--${o}`);
  for (let [g, d] of i) {
    let m = e.get(g);
    if (typeof m != "string")
      continue;
    let v = {}, k = {};
    for (let [x, [y, N]] of d)
      v[x] = y, k[x] = N;
    e.set(g, [m, v]), a.set(g, [f, k]);
  }
  let u = {}, c = {};
  for (let [g, d] of e)
    Br(u, [g ?? "DEFAULT"], d);
  for (let [g, d] of a)
    Br(c, [g ?? "DEFAULT"], d);
  return r[r.length - 1] === "DEFAULT" ? [u?.DEFAULT ?? null, c.DEFAULT ?? 0] : ("DEFAULT" in u) && Object.keys(u).length === 1 ? [u.DEFAULT, c.DEFAULT ?? 0] : (u.__CSS_VALUES__ = c, [u, c]);
}
function Wr(t, r) {
  for (let o = 0;o < r.length; ++o) {
    let e = r[o];
    if (t?.[e] === undefined) {
      if (r[o + 1] === undefined)
        return;
      r[o + 1] = `${e}-${r[o + 1]}`;
      continue;
    }
    t = t[e];
  }
  return t;
}
function Br(t, r, o) {
  for (let e of r.slice(0, -1))
    t[e] === undefined && (t[e] = {}), t = t[e];
  t[r[r.length - 1]] = o;
}
function qi(t) {
  return { kind: "combinator", value: t };
}
function Hi(t, r) {
  return { kind: "function", value: t, nodes: r };
}
function Ie(t) {
  return { kind: "selector", value: t };
}
function Gi(t) {
  return { kind: "separator", value: t };
}
function Yi(t) {
  return { kind: "value", value: t };
}
function Fe(t, r, o = null) {
  for (let e = 0;e < t.length; e++) {
    let i = t[e], s = false, a = 0, f = r(i, { parent: o, replaceWith(u) {
      s || (s = true, Array.isArray(u) ? u.length === 0 ? (t.splice(e, 1), a = 0) : u.length === 1 ? (t[e] = u[0], a = 1) : (t.splice(e, 1, ...u), a = u.length) : (t[e] = u, a = 1));
    } }) ?? 0;
    if (s) {
      f === 0 ? e-- : e += a - 1;
      continue;
    }
    if (f === 2)
      return 2;
    if (f !== 1 && i.kind === "function" && Fe(i.nodes, r, i) === 2)
      return 2;
  }
}
function Me(t) {
  let r = "";
  for (let o of t)
    switch (o.kind) {
      case "combinator":
      case "selector":
      case "separator":
      case "value": {
        r += o.value;
        break;
      }
      case "function":
        r += o.value + "(" + Me(o.nodes) + ")";
    }
  return r;
}
var qr = 92;
var Ji = 93;
var Hr = 41;
var Qi = 58;
var Gr = 44;
var Zi = 34;
var Xi = 46;
var Yr = 62;
var Jr = 10;
var en = 35;
var Qr = 91;
var Zr = 40;
var Xr = 43;
var tn = 39;
var eo = 32;
var to = 9;
var ro = 126;
function dt(t) {
  t = t.replaceAll(`\r
`, `
`);
  let r = [], o = [], e = null, i = "", s;
  for (let a = 0;a < t.length; a++) {
    let f = t.charCodeAt(a);
    switch (f) {
      case Gr:
      case Yr:
      case Jr:
      case eo:
      case Xr:
      case to:
      case ro: {
        if (i.length > 0) {
          let m = Ie(i);
          e ? e.nodes.push(m) : r.push(m), i = "";
        }
        let u = a, c = a + 1;
        for (;c < t.length && (s = t.charCodeAt(c), !(s !== Gr && s !== Yr && s !== Jr && s !== eo && s !== Xr && s !== to && s !== ro)); c++)
          ;
        a = c - 1;
        let g = t.slice(u, c), d = g.trim() === "," ? Gi(g) : qi(g);
        e ? e.nodes.push(d) : r.push(d);
        break;
      }
      case Zr: {
        let u = Hi(i, []);
        if (i = "", u.value !== ":not" && u.value !== ":where" && u.value !== ":has" && u.value !== ":is") {
          let c = a + 1, g = 0;
          for (let m = a + 1;m < t.length; m++) {
            if (s = t.charCodeAt(m), s === Zr) {
              g++;
              continue;
            }
            if (s === Hr) {
              if (g === 0) {
                a = m;
                break;
              }
              g--;
            }
          }
          let d = a;
          u.nodes.push(Yi(t.slice(c, d))), i = "", a = d, e ? e.nodes.push(u) : r.push(u);
          break;
        }
        e ? e.nodes.push(u) : r.push(u), o.push(u), e = u;
        break;
      }
      case Hr: {
        let u = o.pop();
        if (i.length > 0) {
          let c = Ie(i);
          u.nodes.push(c), i = "";
        }
        o.length > 0 ? e = o[o.length - 1] : e = null;
        break;
      }
      case Xi:
      case Qi:
      case en: {
        if (i.length > 0) {
          let u = Ie(i);
          e ? e.nodes.push(u) : r.push(u);
        }
        i = String.fromCharCode(f);
        break;
      }
      case Qr: {
        if (i.length > 0) {
          let g = Ie(i);
          e ? e.nodes.push(g) : r.push(g);
        }
        i = "";
        let u = a, c = 0;
        for (let g = a + 1;g < t.length; g++) {
          if (s = t.charCodeAt(g), s === Qr) {
            c++;
            continue;
          }
          if (s === Ji) {
            if (c === 0) {
              a = g;
              break;
            }
            c--;
          }
        }
        i += t.slice(u, a + 1);
        break;
      }
      case tn:
      case Zi: {
        let u = a;
        for (let c = a + 1;c < t.length; c++)
          if (s = t.charCodeAt(c), s === qr)
            c += 1;
          else if (s === f) {
            a = c;
            break;
          }
        i += t.slice(u, a + 1);
        break;
      }
      case qr: {
        let u = t.charCodeAt(a + 1);
        i += String.fromCharCode(f) + String.fromCharCode(u), a += 1;
        break;
      }
      default:
        i += String.fromCharCode(f);
    }
  }
  return i.length > 0 && r.push(Ie(i)), r;
}
var oo = /^[a-z@][a-zA-Z0-9/%._-]*$/;
function Ft({ designSystem: t, ast: r, resolvedConfig: o, featuresRef: e, referenceMode: i }) {
  let s = { addBase(a) {
    if (i)
      return;
    let f = ue(a);
    e.current |= Ve(f, t), r.push(F("@layer", "base", f));
  }, addVariant(a, f) {
    if (!ut.test(a))
      throw new Error(`\`addVariant('${a}')\` defines an invalid variant name. Variants should only contain alphanumeric, dashes or underscore characters.`);
    if (typeof f == "string") {
      if (f.includes(":merge("))
        return;
    } else if (Array.isArray(f)) {
      if (f.some((c) => c.includes(":merge(")))
        return;
    } else if (typeof f == "object") {
      let c = function(g, d) {
        return Object.entries(g).some(([m, v]) => m.includes(d) || typeof v == "object" && c(v, d));
      };
      var u = c;
      if (c(f, ":merge("))
        return;
    }
    typeof f == "string" || Array.isArray(f) ? t.variants.static(a, (c) => {
      c.nodes = io(f, c.nodes);
    }, { compounds: Ae(typeof f == "string" ? [f] : f) }) : typeof f == "object" && t.variants.fromAst(a, ue(f));
  }, matchVariant(a, f, u) {
    function c(d, m, v) {
      let k = f(d, { modifier: m?.value ?? null });
      return io(k, v);
    }
    try {
      let d = f("a", { modifier: null });
      if (typeof d == "string" && d.includes(":merge("))
        return;
      if (Array.isArray(d) && d.some((m) => m.includes(":merge(")))
        return;
    } catch {
    }
    let g = Object.keys(u?.values ?? {});
    t.variants.group(() => {
      t.variants.functional(a, (d, m) => {
        if (!m.value) {
          if (u?.values && "DEFAULT" in u.values) {
            d.nodes = c(u.values.DEFAULT, m.modifier, d.nodes);
            return;
          }
          return null;
        }
        if (m.value.kind === "arbitrary")
          d.nodes = c(m.value.value, m.modifier, d.nodes);
        else if (m.value.kind === "named" && u?.values) {
          let v = u.values[m.value.value];
          if (typeof v != "string")
            return;
          d.nodes = c(v, m.modifier, d.nodes);
        }
      });
    }, (d, m) => {
      if (d.kind !== "functional" || m.kind !== "functional")
        return 0;
      let v = d.value ? d.value.value : "DEFAULT", k = m.value ? m.value.value : "DEFAULT", x = u?.values?.[v] ?? v, y = u?.values?.[k] ?? k;
      if (u && typeof u.sort == "function")
        return u.sort({ value: x, modifier: d.modifier?.value ?? null }, { value: y, modifier: m.modifier?.value ?? null });
      let N = g.indexOf(v), b = g.indexOf(k);
      return N = N === -1 ? g.length : N, b = b === -1 ? g.length : b, N !== b ? N - b : x < y ? -1 : 1;
    });
  }, addUtilities(a) {
    a = Array.isArray(a) ? a : [a];
    let f = a.flatMap((c) => Object.entries(c));
    f = f.flatMap(([c, g]) => z(c, ",").map((d) => [d.trim(), g]));
    let u = new W(() => []);
    for (let [c, g] of f) {
      if (c.startsWith("@keyframes ")) {
        i || r.push(G(c, ue(g)));
        continue;
      }
      let d = dt(c), m = false;
      if (Fe(d, (v) => {
        if (v.kind === "selector" && v.value[0] === "." && oo.test(v.value.slice(1))) {
          let k = v.value;
          v.value = "&";
          let x = Me(d), y = k.slice(1), N = x === "&" ? ue(g) : [G(x, ue(g))];
          u.get(y).push(...N), m = true, v.value = k;
          return;
        }
        if (v.kind === "function" && v.value === ":not")
          return 1;
      }), !m)
        throw new Error(`\`addUtilities({ '${c}' : … })\` defines an invalid utility selector. Utilities must be a single class name and start with a lowercase letter, eg. \`.scrollbar-none\`.`);
    }
    for (let [c, g] of u)
      t.theme.prefix && D(g, (d) => {
        if (d.kind === "rule") {
          let m = dt(d.selector);
          Fe(m, (v) => {
            v.kind === "selector" && v.value[0] === "." && (v.value = `.${t.theme.prefix}\\:${v.value.slice(1)}`);
          }), d.selector = Me(m);
        }
      }), t.utilities.static(c, (d) => {
        let m = structuredClone(g);
        return no(m, c, d.raw), e.current |= je(m, t), m;
      });
  }, matchUtilities(a, f) {
    let u = f?.type ? Array.isArray(f?.type) ? f.type : [f.type] : ["any"];
    for (let [g, d] of Object.entries(a)) {
      let m = function({ negative: v }) {
        return (k) => {
          if (k.value?.kind === "arbitrary" && u.length > 0 && !u.includes("any") && (k.value.dataType && !u.includes(k.value.dataType) || !k.value.dataType && !Y(k.value.value, u)))
            return;
          let x = u.includes("color"), y = null, N = false;
          {
            let R = f?.values ?? {};
            x && (R = Object.assign({ inherit: "inherit", transparent: "transparent", current: "currentcolor" }, R)), k.value ? k.value.kind === "arbitrary" ? y = k.value.value : k.value.fraction && R[k.value.fraction] ? (y = R[k.value.fraction], N = true) : R[k.value.value] ? y = R[k.value.value] : R.__BARE_VALUE__ && (y = R.__BARE_VALUE__(k.value) ?? null, N = (k.value.fraction !== null && y?.includes("/")) ?? false) : y = R.DEFAULT ?? null;
          }
          if (y === null)
            return;
          let b;
          {
            let R = f?.modifiers ?? null;
            k.modifier ? R === "any" || k.modifier.kind === "arbitrary" ? b = k.modifier.value : R?.[k.modifier.value] ? b = R[k.modifier.value] : x && !Number.isNaN(Number(k.modifier.value)) ? b = `${k.modifier.value}%` : b = null : b = null;
          }
          if (k.modifier && b === null && !N)
            return k.value?.kind === "arbitrary" ? null : undefined;
          x && b !== null && (y = Q(y, b)), v && (y = `calc(${y} * -1)`);
          let V = ue(d(y, { modifier: b }));
          return no(V, g, k.raw), e.current |= je(V, t), V;
        };
      };
      var c = m;
      if (!oo.test(g))
        throw new Error(`\`matchUtilities({ '${g}' : … })\` defines an invalid utility name. Utilities should be alphanumeric and start with a lowercase letter, eg. \`scrollbar\`.`);
      f?.supportsNegativeValues && t.utilities.functional(`-${g}`, m({ negative: true }), { types: u }), t.utilities.functional(g, m({ negative: false }), { types: u }), t.utilities.suggest(g, () => {
        let v = f?.values ?? {}, k = new Set(Object.keys(v));
        k.delete("__BARE_VALUE__"), k.has("DEFAULT") && (k.delete("DEFAULT"), k.add(null));
        let x = f?.modifiers ?? {}, y = x === "any" ? [] : Object.keys(x);
        return [{ supportsNegative: f?.supportsNegativeValues ?? false, values: Array.from(k), modifiers: y }];
      });
    }
  }, addComponents(a, f) {
    this.addUtilities(a, f);
  }, matchComponents(a, f) {
    this.matchUtilities(a, f);
  }, theme: pt(t, () => o.theme ?? {}, (a) => a), prefix(a) {
    return a;
  }, config(a, f) {
    let u = o;
    if (!a)
      return u;
    let c = ft(a);
    for (let g = 0;g < c.length; ++g) {
      let d = c[g];
      if (u[d] === undefined)
        return f;
      u = u[d];
    }
    return u ?? f;
  } };
  return s.addComponents = s.addComponents.bind(s), s.matchComponents = s.matchComponents.bind(s), s;
}
function ue(t) {
  let r = [];
  t = Array.isArray(t) ? t : [t];
  let o = t.flatMap((e) => Object.entries(e));
  for (let [e, i] of o)
    if (typeof i != "object") {
      if (!e.startsWith("--")) {
        if (i === "@slot") {
          r.push(G(e, [F("@slot")]));
          continue;
        }
        e = e.replace(/([A-Z])/g, "-$1").toLowerCase();
      }
      r.push(l(e, String(i)));
    } else if (Array.isArray(i))
      for (let s of i)
        typeof s == "string" ? r.push(l(e, s)) : r.push(G(e, ue(s)));
    else
      i !== null && r.push(G(e, ue(i)));
  return r;
}
function io(t, r) {
  return (typeof t == "string" ? [t] : t).flatMap((e) => {
    if (e.trim().endsWith("}")) {
      let i = e.replace("}", "{@slot}}"), s = $e(i);
      return jt(s, r), s;
    } else
      return G(e, r);
  });
}
function no(t, r, o) {
  D(t, (e) => {
    if (e.kind === "rule") {
      let i = dt(e.selector);
      Fe(i, (s) => {
        s.kind === "selector" && s.value === `.${r}` && (s.value = `.${me(o)}`);
      }), e.selector = Me(i);
    }
  });
}
function lo(t, r, o) {
  for (let e of on(r))
    t.theme.addKeyframes(e);
}
function on(t) {
  let r = [];
  if ("keyframes" in t.theme)
    for (let [o, e] of Object.entries(t.theme.keyframes))
      r.push(F("@keyframes", o, ue(e)));
  return r;
}
var mt = { inherit: "inherit", current: "currentcolor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "oklch(98.4% 0.003 247.858)", 100: "oklch(96.8% 0.007 247.896)", 200: "oklch(92.9% 0.013 255.508)", 300: "oklch(86.9% 0.022 252.894)", 400: "oklch(70.4% 0.04 256.788)", 500: "oklch(55.4% 0.046 257.417)", 600: "oklch(44.6% 0.043 257.281)", 700: "oklch(37.2% 0.044 257.287)", 800: "oklch(27.9% 0.041 260.031)", 900: "oklch(20.8% 0.042 265.755)", 950: "oklch(12.9% 0.042 264.695)" }, gray: { 50: "oklch(98.5% 0.002 247.839)", 100: "oklch(96.7% 0.003 264.542)", 200: "oklch(92.8% 0.006 264.531)", 300: "oklch(87.2% 0.01 258.338)", 400: "oklch(70.7% 0.022 261.325)", 500: "oklch(55.1% 0.027 264.364)", 600: "oklch(44.6% 0.03 256.802)", 700: "oklch(37.3% 0.034 259.733)", 800: "oklch(27.8% 0.033 256.848)", 900: "oklch(21% 0.034 264.665)", 950: "oklch(13% 0.028 261.692)" }, zinc: { 50: "oklch(98.5% 0 0)", 100: "oklch(96.7% 0.001 286.375)", 200: "oklch(92% 0.004 286.32)", 300: "oklch(87.1% 0.006 286.286)", 400: "oklch(70.5% 0.015 286.067)", 500: "oklch(55.2% 0.016 285.938)", 600: "oklch(44.2% 0.017 285.786)", 700: "oklch(37% 0.013 285.805)", 800: "oklch(27.4% 0.006 286.033)", 900: "oklch(21% 0.006 285.885)", 950: "oklch(14.1% 0.005 285.823)" }, neutral: { 50: "oklch(98.5% 0 0)", 100: "oklch(97% 0 0)", 200: "oklch(92.2% 0 0)", 300: "oklch(87% 0 0)", 400: "oklch(70.8% 0 0)", 500: "oklch(55.6% 0 0)", 600: "oklch(43.9% 0 0)", 700: "oklch(37.1% 0 0)", 800: "oklch(26.9% 0 0)", 900: "oklch(20.5% 0 0)", 950: "oklch(14.5% 0 0)" }, stone: { 50: "oklch(98.5% 0.001 106.423)", 100: "oklch(97% 0.001 106.424)", 200: "oklch(92.3% 0.003 48.717)", 300: "oklch(86.9% 0.005 56.366)", 400: "oklch(70.9% 0.01 56.259)", 500: "oklch(55.3% 0.013 58.071)", 600: "oklch(44.4% 0.011 73.639)", 700: "oklch(37.4% 0.01 67.558)", 800: "oklch(26.8% 0.007 34.298)", 900: "oklch(21.6% 0.006 56.043)", 950: "oklch(14.7% 0.004 49.25)" }, red: { 50: "oklch(97.1% 0.013 17.38)", 100: "oklch(93.6% 0.032 17.717)", 200: "oklch(88.5% 0.062 18.334)", 300: "oklch(80.8% 0.114 19.571)", 400: "oklch(70.4% 0.191 22.216)", 500: "oklch(63.7% 0.237 25.331)", 600: "oklch(57.7% 0.245 27.325)", 700: "oklch(50.5% 0.213 27.518)", 800: "oklch(44.4% 0.177 26.899)", 900: "oklch(39.6% 0.141 25.723)", 950: "oklch(25.8% 0.092 26.042)" }, orange: { 50: "oklch(98% 0.016 73.684)", 100: "oklch(95.4% 0.038 75.164)", 200: "oklch(90.1% 0.076 70.697)", 300: "oklch(83.7% 0.128 66.29)", 400: "oklch(75% 0.183 55.934)", 500: "oklch(70.5% 0.213 47.604)", 600: "oklch(64.6% 0.222 41.116)", 700: "oklch(55.3% 0.195 38.402)", 800: "oklch(47% 0.157 37.304)", 900: "oklch(40.8% 0.123 38.172)", 950: "oklch(26.6% 0.079 36.259)" }, amber: { 50: "oklch(98.7% 0.022 95.277)", 100: "oklch(96.2% 0.059 95.617)", 200: "oklch(92.4% 0.12 95.746)", 300: "oklch(87.9% 0.169 91.605)", 400: "oklch(82.8% 0.189 84.429)", 500: "oklch(76.9% 0.188 70.08)", 600: "oklch(66.6% 0.179 58.318)", 700: "oklch(55.5% 0.163 48.998)", 800: "oklch(47.3% 0.137 46.201)", 900: "oklch(41.4% 0.112 45.904)", 950: "oklch(27.9% 0.077 45.635)" }, yellow: { 50: "oklch(98.7% 0.026 102.212)", 100: "oklch(97.3% 0.071 103.193)", 200: "oklch(94.5% 0.129 101.54)", 300: "oklch(90.5% 0.182 98.111)", 400: "oklch(85.2% 0.199 91.936)", 500: "oklch(79.5% 0.184 86.047)", 600: "oklch(68.1% 0.162 75.834)", 700: "oklch(55.4% 0.135 66.442)", 800: "oklch(47.6% 0.114 61.907)", 900: "oklch(42.1% 0.095 57.708)", 950: "oklch(28.6% 0.066 53.813)" }, lime: { 50: "oklch(98.6% 0.031 120.757)", 100: "oklch(96.7% 0.067 122.328)", 200: "oklch(93.8% 0.127 124.321)", 300: "oklch(89.7% 0.196 126.665)", 400: "oklch(84.1% 0.238 128.85)", 500: "oklch(76.8% 0.233 130.85)", 600: "oklch(64.8% 0.2 131.684)", 700: "oklch(53.2% 0.157 131.589)", 800: "oklch(45.3% 0.124 130.933)", 900: "oklch(40.5% 0.101 131.063)", 950: "oklch(27.4% 0.072 132.109)" }, green: { 50: "oklch(98.2% 0.018 155.826)", 100: "oklch(96.2% 0.044 156.743)", 200: "oklch(92.5% 0.084 155.995)", 300: "oklch(87.1% 0.15 154.449)", 400: "oklch(79.2% 0.209 151.711)", 500: "oklch(72.3% 0.219 149.579)", 600: "oklch(62.7% 0.194 149.214)", 700: "oklch(52.7% 0.154 150.069)", 800: "oklch(44.8% 0.119 151.328)", 900: "oklch(39.3% 0.095 152.535)", 950: "oklch(26.6% 0.065 152.934)" }, emerald: { 50: "oklch(97.9% 0.021 166.113)", 100: "oklch(95% 0.052 163.051)", 200: "oklch(90.5% 0.093 164.15)", 300: "oklch(84.5% 0.143 164.978)", 400: "oklch(76.5% 0.177 163.223)", 500: "oklch(69.6% 0.17 162.48)", 600: "oklch(59.6% 0.145 163.225)", 700: "oklch(50.8% 0.118 165.612)", 800: "oklch(43.2% 0.095 166.913)", 900: "oklch(37.8% 0.077 168.94)", 950: "oklch(26.2% 0.051 172.552)" }, teal: { 50: "oklch(98.4% 0.014 180.72)", 100: "oklch(95.3% 0.051 180.801)", 200: "oklch(91% 0.096 180.426)", 300: "oklch(85.5% 0.138 181.071)", 400: "oklch(77.7% 0.152 181.912)", 500: "oklch(70.4% 0.14 182.503)", 600: "oklch(60% 0.118 184.704)", 700: "oklch(51.1% 0.096 186.391)", 800: "oklch(43.7% 0.078 188.216)", 900: "oklch(38.6% 0.063 188.416)", 950: "oklch(27.7% 0.046 192.524)" }, cyan: { 50: "oklch(98.4% 0.019 200.873)", 100: "oklch(95.6% 0.045 203.388)", 200: "oklch(91.7% 0.08 205.041)", 300: "oklch(86.5% 0.127 207.078)", 400: "oklch(78.9% 0.154 211.53)", 500: "oklch(71.5% 0.143 215.221)", 600: "oklch(60.9% 0.126 221.723)", 700: "oklch(52% 0.105 223.128)", 800: "oklch(45% 0.085 224.283)", 900: "oklch(39.8% 0.07 227.392)", 950: "oklch(30.2% 0.056 229.695)" }, sky: { 50: "oklch(97.7% 0.013 236.62)", 100: "oklch(95.1% 0.026 236.824)", 200: "oklch(90.1% 0.058 230.902)", 300: "oklch(82.8% 0.111 230.318)", 400: "oklch(74.6% 0.16 232.661)", 500: "oklch(68.5% 0.169 237.323)", 600: "oklch(58.8% 0.158 241.966)", 700: "oklch(50% 0.134 242.749)", 800: "oklch(44.3% 0.11 240.79)", 900: "oklch(39.1% 0.09 240.876)", 950: "oklch(29.3% 0.066 243.157)" }, blue: { 50: "oklch(97% 0.014 254.604)", 100: "oklch(93.2% 0.032 255.585)", 200: "oklch(88.2% 0.059 254.128)", 300: "oklch(80.9% 0.105 251.813)", 400: "oklch(70.7% 0.165 254.624)", 500: "oklch(62.3% 0.214 259.815)", 600: "oklch(54.6% 0.245 262.881)", 700: "oklch(48.8% 0.243 264.376)", 800: "oklch(42.4% 0.199 265.638)", 900: "oklch(37.9% 0.146 265.522)", 950: "oklch(28.2% 0.091 267.935)" }, indigo: { 50: "oklch(96.2% 0.018 272.314)", 100: "oklch(93% 0.034 272.788)", 200: "oklch(87% 0.065 274.039)", 300: "oklch(78.5% 0.115 274.713)", 400: "oklch(67.3% 0.182 276.935)", 500: "oklch(58.5% 0.233 277.117)", 600: "oklch(51.1% 0.262 276.966)", 700: "oklch(45.7% 0.24 277.023)", 800: "oklch(39.8% 0.195 277.366)", 900: "oklch(35.9% 0.144 278.697)", 950: "oklch(25.7% 0.09 281.288)" }, violet: { 50: "oklch(96.9% 0.016 293.756)", 100: "oklch(94.3% 0.029 294.588)", 200: "oklch(89.4% 0.057 293.283)", 300: "oklch(81.1% 0.111 293.571)", 400: "oklch(70.2% 0.183 293.541)", 500: "oklch(60.6% 0.25 292.717)", 600: "oklch(54.1% 0.281 293.009)", 700: "oklch(49.1% 0.27 292.581)", 800: "oklch(43.2% 0.232 292.759)", 900: "oklch(38% 0.189 293.745)", 950: "oklch(28.3% 0.141 291.089)" }, purple: { 50: "oklch(97.7% 0.014 308.299)", 100: "oklch(94.6% 0.033 307.174)", 200: "oklch(90.2% 0.063 306.703)", 300: "oklch(82.7% 0.119 306.383)", 400: "oklch(71.4% 0.203 305.504)", 500: "oklch(62.7% 0.265 303.9)", 600: "oklch(55.8% 0.288 302.321)", 700: "oklch(49.6% 0.265 301.924)", 800: "oklch(43.8% 0.218 303.724)", 900: "oklch(38.1% 0.176 304.987)", 950: "oklch(29.1% 0.149 302.717)" }, fuchsia: { 50: "oklch(97.7% 0.017 320.058)", 100: "oklch(95.2% 0.037 318.852)", 200: "oklch(90.3% 0.076 319.62)", 300: "oklch(83.3% 0.145 321.434)", 400: "oklch(74% 0.238 322.16)", 500: "oklch(66.7% 0.295 322.15)", 600: "oklch(59.1% 0.293 322.896)", 700: "oklch(51.8% 0.253 323.949)", 800: "oklch(45.2% 0.211 324.591)", 900: "oklch(40.1% 0.17 325.612)", 950: "oklch(29.3% 0.136 325.661)" }, pink: { 50: "oklch(97.1% 0.014 343.198)", 100: "oklch(94.8% 0.028 342.258)", 200: "oklch(89.9% 0.061 343.231)", 300: "oklch(82.3% 0.12 346.018)", 400: "oklch(71.8% 0.202 349.761)", 500: "oklch(65.6% 0.241 354.308)", 600: "oklch(59.2% 0.249 0.584)", 700: "oklch(52.5% 0.223 3.958)", 800: "oklch(45.9% 0.187 3.815)", 900: "oklch(40.8% 0.153 2.432)", 950: "oklch(28.4% 0.109 3.907)" }, rose: { 50: "oklch(96.9% 0.015 12.422)", 100: "oklch(94.1% 0.03 12.58)", 200: "oklch(89.2% 0.058 10.001)", 300: "oklch(81% 0.117 11.638)", 400: "oklch(71.2% 0.194 13.428)", 500: "oklch(64.5% 0.246 16.439)", 600: "oklch(58.6% 0.253 17.585)", 700: "oklch(51.4% 0.222 16.935)", 800: "oklch(45.5% 0.188 13.697)", 900: "oklch(41% 0.159 10.272)", 950: "oklch(27.1% 0.105 12.094)" } };
function Ce(t) {
  return { __BARE_VALUE__: t };
}
var le = Ce((t) => {
  if (E(t.value))
    return t.value;
});
var re = Ce((t) => {
  if (E(t.value))
    return `${t.value}%`;
});
var ke = Ce((t) => {
  if (E(t.value))
    return `${t.value}px`;
});
var ao = Ce((t) => {
  if (E(t.value))
    return `${t.value}ms`;
});
var gt = Ce((t) => {
  if (E(t.value))
    return `${t.value}deg`;
});
var nn = Ce((t) => {
  if (t.fraction === null)
    return;
  let [r, o] = z(t.fraction, "/");
  if (!(!E(r) || !E(o)))
    return t.fraction;
});
var so = Ce((t) => {
  if (E(Number(t.value)))
    return `repeat(${t.value}, minmax(0, 1fr))`;
});
var uo = { accentColor: ({ theme: t }) => t("colors"), animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite", pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", bounce: "bounce 1s infinite" }, aria: { busy: 'busy="true"', checked: 'checked="true"', disabled: 'disabled="true"', expanded: 'expanded="true"', hidden: 'hidden="true"', pressed: 'pressed="true"', readonly: 'readonly="true"', required: 'required="true"', selected: 'selected="true"' }, aspectRatio: { auto: "auto", square: "1 / 1", video: "16 / 9", ...nn }, backdropBlur: ({ theme: t }) => t("blur"), backdropBrightness: ({ theme: t }) => ({ ...t("brightness"), ...re }), backdropContrast: ({ theme: t }) => ({ ...t("contrast"), ...re }), backdropGrayscale: ({ theme: t }) => ({ ...t("grayscale"), ...re }), backdropHueRotate: ({ theme: t }) => ({ ...t("hueRotate"), ...gt }), backdropInvert: ({ theme: t }) => ({ ...t("invert"), ...re }), backdropOpacity: ({ theme: t }) => ({ ...t("opacity"), ...re }), backdropSaturate: ({ theme: t }) => ({ ...t("saturate"), ...re }), backdropSepia: ({ theme: t }) => ({ ...t("sepia"), ...re }), backgroundColor: ({ theme: t }) => t("colors"), backgroundImage: { none: "none", "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))", "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))", "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))", "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))", "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))", "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))", "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))", "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))" }, backgroundOpacity: ({ theme: t }) => t("opacity"), backgroundPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { 0: "0", none: "", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, borderColor: ({ theme: t }) => ({ DEFAULT: "currentcolor", ...t("colors") }), borderOpacity: ({ theme: t }) => t("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", full: "9999px" }, borderSpacing: ({ theme: t }) => t("spacing"), borderWidth: { DEFAULT: "1px", 0: "0px", 2: "2px", 4: "4px", 8: "8px", ...ke }, boxShadow: { sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)", DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)", md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)", lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)", xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)", "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)", inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)", none: "none" }, boxShadowColor: ({ theme: t }) => t("colors"), brightness: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", 200: "2", ...re }, caretColor: ({ theme: t }) => t("colors"), colors: () => ({ ...mt }), columns: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", ...le }, container: {}, content: { none: "none" }, contrast: { 0: "0", 50: ".5", 75: ".75", 100: "1", 125: "1.25", 150: "1.5", 200: "2", ...re }, cursor: { auto: "auto", default: "default", pointer: "pointer", wait: "wait", text: "text", move: "move", help: "help", "not-allowed": "not-allowed", none: "none", "context-menu": "context-menu", progress: "progress", cell: "cell", crosshair: "crosshair", "vertical-text": "vertical-text", alias: "alias", copy: "copy", "no-drop": "no-drop", grab: "grab", grabbing: "grabbing", "all-scroll": "all-scroll", "col-resize": "col-resize", "row-resize": "row-resize", "n-resize": "n-resize", "e-resize": "e-resize", "s-resize": "s-resize", "w-resize": "w-resize", "ne-resize": "ne-resize", "nw-resize": "nw-resize", "se-resize": "se-resize", "sw-resize": "sw-resize", "ew-resize": "ew-resize", "ns-resize": "ns-resize", "nesw-resize": "nesw-resize", "nwse-resize": "nwse-resize", "zoom-in": "zoom-in", "zoom-out": "zoom-out" }, divideColor: ({ theme: t }) => t("borderColor"), divideOpacity: ({ theme: t }) => t("borderOpacity"), divideWidth: ({ theme: t }) => ({ ...t("borderWidth"), ...ke }), dropShadow: { sm: "0 1px 1px rgb(0 0 0 / 0.05)", DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"], md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"], lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"], xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"], "2xl": "0 25px 25px rgb(0 0 0 / 0.15)", none: "0 0 #0000" }, fill: ({ theme: t }) => t("colors"), flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: t }) => ({ auto: "auto", "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", ...t("spacing") }), flexGrow: { 0: "0", DEFAULT: "1", ...le }, flexShrink: { 0: "0", DEFAULT: "1", ...le }, fontFamily: { sans: ["ui-sans-serif", "system-ui", "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'], serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"], mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"] }, fontSize: { xs: ["0.75rem", { lineHeight: "1rem" }], sm: ["0.875rem", { lineHeight: "1.25rem" }], base: ["1rem", { lineHeight: "1.5rem" }], lg: ["1.125rem", { lineHeight: "1.75rem" }], xl: ["1.25rem", { lineHeight: "1.75rem" }], "2xl": ["1.5rem", { lineHeight: "2rem" }], "3xl": ["1.875rem", { lineHeight: "2.25rem" }], "4xl": ["2.25rem", { lineHeight: "2.5rem" }], "5xl": ["3rem", { lineHeight: "1" }], "6xl": ["3.75rem", { lineHeight: "1" }], "7xl": ["4.5rem", { lineHeight: "1" }], "8xl": ["6rem", { lineHeight: "1" }], "9xl": ["8rem", { lineHeight: "1" }] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: ({ theme: t }) => t("spacing"), gradientColorStops: ({ theme: t }) => t("colors"), gradientColorStopPositions: { "0%": "0%", "5%": "5%", "10%": "10%", "15%": "15%", "20%": "20%", "25%": "25%", "30%": "30%", "35%": "35%", "40%": "40%", "45%": "45%", "50%": "50%", "55%": "55%", "60%": "60%", "65%": "65%", "70%": "70%", "75%": "75%", "80%": "80%", "85%": "85%", "90%": "90%", "95%": "95%", "100%": "100%", ...re }, grayscale: { 0: "0", DEFAULT: "100%", ...re }, gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridColumn: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridColumnEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13", ...le }, gridColumnStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13", ...le }, gridRow: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridRowEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13", ...le }, gridRowStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13", ...le }, gridTemplateColumns: { none: "none", subgrid: "subgrid", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))", ...so }, gridTemplateRows: { none: "none", subgrid: "subgrid", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))", ...so }, height: ({ theme: t }) => ({ auto: "auto", "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", full: "100%", screen: "100vh", svh: "100svh", lvh: "100lvh", dvh: "100dvh", min: "min-content", max: "max-content", fit: "fit-content", ...t("spacing") }), hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg", ...gt }, inset: ({ theme: t }) => ({ auto: "auto", "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%", ...t("spacing") }), invert: { 0: "0", DEFAULT: "100%", ...re }, keyframes: { spin: { to: { transform: "rotate(360deg)" } }, ping: { "75%, 100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2", 3: ".75rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem" }, listStyleType: { none: "none", disc: "disc", decimal: "decimal" }, listStyleImage: { none: "none" }, margin: ({ theme: t }) => ({ auto: "auto", ...t("spacing") }), lineClamp: { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", ...le }, maxHeight: ({ theme: t }) => ({ none: "none", full: "100%", screen: "100vh", svh: "100svh", lvh: "100lvh", dvh: "100dvh", min: "min-content", max: "max-content", fit: "fit-content", ...t("spacing") }), maxWidth: ({ theme: t }) => ({ none: "none", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch", ...t("spacing") }), minHeight: ({ theme: t }) => ({ full: "100%", screen: "100vh", svh: "100svh", lvh: "100lvh", dvh: "100dvh", min: "min-content", max: "max-content", fit: "fit-content", ...t("spacing") }), minWidth: ({ theme: t }) => ({ full: "100%", min: "min-content", max: "max-content", fit: "fit-content", ...t("spacing") }), objectPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, opacity: { 0: "0", 5: "0.05", 10: "0.1", 15: "0.15", 20: "0.2", 25: "0.25", 30: "0.3", 35: "0.35", 40: "0.4", 45: "0.45", 50: "0.5", 55: "0.55", 60: "0.6", 65: "0.65", 70: "0.7", 75: "0.75", 80: "0.8", 85: "0.85", 90: "0.9", 95: "0.95", 100: "1", ...re }, order: { first: "-9999", last: "9999", none: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", ...le }, outlineColor: ({ theme: t }) => t("colors"), outlineOffset: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px", ...ke }, outlineWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px", ...ke }, padding: ({ theme: t }) => t("spacing"), placeholderColor: ({ theme: t }) => t("colors"), placeholderOpacity: ({ theme: t }) => t("opacity"), ringColor: ({ theme: t }) => ({ DEFAULT: "currentcolor", ...t("colors") }), ringOffsetColor: ({ theme: t }) => t("colors"), ringOffsetWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px", ...ke }, ringOpacity: ({ theme: t }) => ({ DEFAULT: "0.5", ...t("opacity") }), ringWidth: { DEFAULT: "3px", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px", ...ke }, rotate: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", 45: "45deg", 90: "90deg", 180: "180deg", ...gt }, saturate: { 0: "0", 50: ".5", 100: "1", 150: "1.5", 200: "2", ...re }, scale: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", ...re }, screens: { sm: "40rem", md: "48rem", lg: "64rem", xl: "80rem", "2xl": "96rem" }, scrollMargin: ({ theme: t }) => t("spacing"), scrollPadding: ({ theme: t }) => t("spacing"), sepia: { 0: "0", DEFAULT: "100%", ...re }, skew: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", ...gt }, space: ({ theme: t }) => t("spacing"), spacing: { px: "1px", 0: "0px", 0.5: "0.125rem", 1: "0.25rem", 1.5: "0.375rem", 2: "0.5rem", 2.5: "0.625rem", 3: "0.75rem", 3.5: "0.875rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem", 11: "2.75rem", 12: "3rem", 14: "3.5rem", 16: "4rem", 20: "5rem", 24: "6rem", 28: "7rem", 32: "8rem", 36: "9rem", 40: "10rem", 44: "11rem", 48: "12rem", 52: "13rem", 56: "14rem", 60: "15rem", 64: "16rem", 72: "18rem", 80: "20rem", 96: "24rem" }, stroke: ({ theme: t }) => ({ none: "none", ...t("colors") }), strokeWidth: { 0: "0", 1: "1", 2: "2", ...le }, supports: {}, data: {}, textColor: ({ theme: t }) => t("colors"), textDecorationColor: ({ theme: t }) => t("colors"), textDecorationThickness: { auto: "auto", "from-font": "from-font", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px", ...ke }, textIndent: ({ theme: t }) => t("spacing"), textOpacity: ({ theme: t }) => t("opacity"), textUnderlineOffset: { auto: "auto", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px", ...ke }, transformOrigin: { center: "center", top: "top", "top-right": "top right", right: "right", "bottom-right": "bottom right", bottom: "bottom", "bottom-left": "bottom left", left: "left", "top-left": "top left" }, transitionDelay: { 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1000: "1000ms", ...ao }, transitionDuration: { DEFAULT: "150ms", 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1000: "1000ms", ...ao }, transitionProperty: { none: "none", all: "all", DEFAULT: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter", colors: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)", linear: "linear", in: "cubic-bezier(0.4, 0, 1, 1)", out: "cubic-bezier(0, 0, 0.2, 1)", "in-out": "cubic-bezier(0.4, 0, 0.2, 1)" }, translate: ({ theme: t }) => ({ "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%", ...t("spacing") }), size: ({ theme: t }) => ({ auto: "auto", "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", ...t("spacing") }), width: ({ theme: t }) => ({ auto: "auto", "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", screen: "100vw", svw: "100svw", lvw: "100lvw", dvw: "100dvw", min: "min-content", max: "max-content", fit: "fit-content", ...t("spacing") }), willChange: { auto: "auto", scroll: "scroll-position", contents: "contents", transform: "transform" }, zIndex: { auto: "auto", 0: "0", 10: "10", 20: "20", 30: "30", 40: "40", 50: "50", ...le } };
function co(t) {
  return { theme: { ...uo, colors: ({ theme: r }) => r("color", {}), extend: { fontSize: ({ theme: r }) => ({ ...r("text", {}) }), boxShadow: ({ theme: r }) => ({ ...r("shadow", {}) }), animation: ({ theme: r }) => ({ ...r("animate", {}) }), aspectRatio: ({ theme: r }) => ({ ...r("aspect", {}) }), borderRadius: ({ theme: r }) => ({ ...r("radius", {}) }), screens: ({ theme: r }) => ({ ...r("breakpoint", {}) }), letterSpacing: ({ theme: r }) => ({ ...r("tracking", {}) }), lineHeight: ({ theme: r }) => ({ ...r("leading", {}) }), transitionDuration: { DEFAULT: t.get(["--default-transition-duration"]) ?? null }, transitionTimingFunction: { DEFAULT: t.get(["--default-transition-timing-function"]) ?? null }, maxWidth: ({ theme: r }) => ({ ...r("container", {}) }) } } };
}
var ln = { blocklist: [], future: {}, prefix: "", important: false, darkMode: null, theme: {}, plugins: [], content: { files: [] } };
function Wt(t, r) {
  let o = { design: t, configs: [], plugins: [], content: { files: [] }, theme: {}, extend: {}, result: structuredClone(ln) };
  for (let i of r)
    Mt(o, i);
  for (let i of o.configs)
    "darkMode" in i && i.darkMode !== undefined && (o.result.darkMode = i.darkMode ?? null), "prefix" in i && i.prefix !== undefined && (o.result.prefix = i.prefix ?? ""), "blocklist" in i && i.blocklist !== undefined && (o.result.blocklist = i.blocklist ?? []), "important" in i && i.important !== undefined && (o.result.important = i.important ?? false);
  let e = sn(o);
  return { resolvedConfig: { ...o.result, content: o.content, theme: o.theme, plugins: o.plugins }, replacedThemeKeys: e };
}
function an(t, r) {
  if (Array.isArray(t) && Re(t[0]))
    return t.concat(r);
  if (Array.isArray(r) && Re(r[0]) && Re(t))
    return [t, ...r];
  if (Array.isArray(r))
    return r;
}
function Mt(t, { config: r, base: o, path: e, reference: i }) {
  let s = [];
  for (let u of r.plugins ?? [])
    "__isOptionsFunction" in u ? s.push({ ...u(), reference: i }) : ("handler" in u) ? s.push({ ...u, reference: i }) : s.push({ handler: u, reference: i });
  if (Array.isArray(r.presets) && r.presets.length === 0)
    throw new Error("Error in the config file/plugin/preset. An empty preset (`preset: []`) is not currently supported.");
  for (let u of r.presets ?? [])
    Mt(t, { path: e, base: o, config: u, reference: i });
  for (let u of s)
    t.plugins.push(u), u.config && Mt(t, { path: e, base: o, config: u.config, reference: !!u.reference });
  let a = r.content ?? [], f = Array.isArray(a) ? a : a.files;
  for (let u of f)
    t.content.files.push(typeof u == "object" ? u : { base: o, pattern: u });
  t.configs.push(r);
}
function sn(t) {
  let r = new Set, o = pt(t.design, () => t.theme, i), e = Object.assign(o, { theme: o, colors: mt });
  function i(s) {
    return typeof s == "function" ? s(e) ?? null : s ?? null;
  }
  for (let s of t.configs) {
    let a = s.theme ?? {}, f = a.extend ?? {};
    for (let u in a)
      u !== "extend" && r.add(u);
    Object.assign(t.theme, a);
    for (let u in f)
      t.extend[u] ??= [], t.extend[u].push(f[u]);
  }
  delete t.theme.extend;
  for (let s in t.extend) {
    let a = [t.theme[s], ...t.extend[s]];
    t.theme[s] = () => {
      let f = a.map(i);
      return Le({}, f, an);
    };
  }
  for (let s in t.theme)
    t.theme[s] = i(t.theme[s]);
  if (t.theme.screens && typeof t.theme.screens == "object")
    for (let s of Object.keys(t.theme.screens)) {
      let a = t.theme.screens[s];
      a && typeof a == "object" && (("raw" in a) || ("max" in a) || ("min" in a) && (t.theme.screens[s] = a.min));
    }
  return r;
}
function fo(t, r) {
  let o = t.theme.container || {};
  if (typeof o != "object" || o === null)
    return;
  let e = un(o, r);
  e.length !== 0 && r.utilities.static("container", () => structuredClone(e));
}
function un({ center: t, padding: r, screens: o }, e) {
  let i = [], s = null;
  if (t && i.push(l("margin-inline", "auto")), (typeof r == "string" || typeof r == "object" && r !== null && ("DEFAULT" in r)) && i.push(l("padding-inline", typeof r == "string" ? r : r.DEFAULT)), typeof o == "object" && o !== null) {
    s = new Map;
    let a = Array.from(e.theme.namespace("--breakpoint").entries());
    if (a.sort((f, u) => ye(f[1], u[1], "asc")), a.length > 0) {
      let [f] = a[0];
      i.push(F("@media", `(width >= --theme(--breakpoint-${f}))`, [l("max-width", "none")]));
    }
    for (let [f, u] of Object.entries(o)) {
      if (typeof u == "object")
        if ("min" in u)
          u = u.min;
        else
          continue;
      s.set(f, F("@media", `(width >= ${u})`, [l("max-width", u)]));
    }
  }
  if (typeof r == "object" && r !== null) {
    let a = Object.entries(r).filter(([f]) => f !== "DEFAULT").map(([f, u]) => [f, e.theme.resolveValue(f, ["--breakpoint"]), u]).filter(Boolean);
    a.sort((f, u) => ye(f[1], u[1], "asc"));
    for (let [f, , u] of a)
      if (s && s.has(f))
        s.get(f).nodes.push(l("padding-inline", u));
      else {
        if (s)
          continue;
        i.push(F("@media", `(width >= theme(--breakpoint-${f}))`, [l("padding-inline", u)]));
      }
  }
  if (s)
    for (let [, a] of s)
      i.push(a);
  return i;
}
function po({ addVariant: t, config: r }) {
  let o = r("darkMode", null), [e, i = ".dark"] = Array.isArray(o) ? o : [o];
  if (e === "variant") {
    let s;
    if (Array.isArray(i) || typeof i == "function" ? s = i : typeof i == "string" && (s = [i]), Array.isArray(s))
      for (let a of s)
        a === ".dark" ? (e = false, console.warn('When using `variant` for `darkMode`, you must provide a selector.\nExample: `darkMode: ["variant", ".your-selector &"]`')) : a.includes("&") || (e = false, console.warn('When using `variant` for `darkMode`, your selector must contain `&`.\nExample `darkMode: ["variant", ".your-selector &"]`'));
    i = s;
  }
  e === null || (e === "selector" ? t("dark", `&:where(${i}, ${i} *)`) : e === "media" ? t("dark", "@media (prefers-color-scheme: dark)") : e === "variant" ? t("dark", i) : e === "class" && t("dark", `&:is(${i} *)`));
}
function mo(t) {
  for (let [r, o] of [["t", "top"], ["tr", "top right"], ["r", "right"], ["br", "bottom right"], ["b", "bottom"], ["bl", "bottom left"], ["l", "left"], ["tl", "top left"]])
    t.utilities.static(`bg-gradient-to-${r}`, () => [l("--tw-gradient-position", `to ${o} in oklab`), l("background-image", "linear-gradient(var(--tw-gradient-stops))")]);
  t.utilities.static("bg-left-top", () => [l("background-position", "left top")]), t.utilities.static("bg-right-top", () => [l("background-position", "right top")]), t.utilities.static("bg-left-bottom", () => [l("background-position", "left bottom")]), t.utilities.static("bg-right-bottom", () => [l("background-position", "right bottom")]), t.utilities.static("object-left-top", () => [l("object-position", "left top")]), t.utilities.static("object-right-top", () => [l("object-position", "right top")]), t.utilities.static("object-left-bottom", () => [l("object-position", "left bottom")]), t.utilities.static("object-right-bottom", () => [l("object-position", "right bottom")]), t.utilities.functional("max-w-screen", (r) => {
    if (!r.value || r.value.kind === "arbitrary")
      return;
    let o = t.theme.resolve(r.value.value, ["--breakpoint"]);
    if (o)
      return [l("max-width", o)];
  }), t.utilities.static("overflow-ellipsis", () => [l("text-overflow", "ellipsis")]), t.utilities.static("decoration-slice", () => [l("-webkit-box-decoration-break", "slice"), l("box-decoration-break", "slice")]), t.utilities.static("decoration-clone", () => [l("-webkit-box-decoration-break", "clone"), l("box-decoration-break", "clone")]), t.utilities.functional("flex-shrink", (r) => {
    if (!r.modifier) {
      if (!r.value)
        return [l("flex-shrink", "1")];
      if (r.value.kind === "arbitrary")
        return [l("flex-shrink", r.value.value)];
      if (E(r.value.value))
        return [l("flex-shrink", r.value.value)];
    }
  }), t.utilities.functional("flex-grow", (r) => {
    if (!r.modifier) {
      if (!r.value)
        return [l("flex-grow", "1")];
      if (r.value.kind === "arbitrary")
        return [l("flex-grow", r.value.value)];
      if (E(r.value.value))
        return [l("flex-grow", r.value.value)];
    }
  });
}
function go(t, r) {
  let o = t.theme.screens || {}, e = r.variants.get("min")?.order ?? 0, i = [];
  for (let [a, f] of Object.entries(o)) {
    let m = function(v) {
      r.variants.static(a, (k) => {
        k.nodes = [F("@media", d, k.nodes)];
      }, { order: v });
    };
    var s = m;
    let u = r.variants.get(a), c = r.theme.resolveValue(a, ["--breakpoint"]);
    if (u && c && !r.theme.hasDefault(`--breakpoint-${a}`))
      continue;
    let g = true;
    typeof f == "string" && (g = false);
    let d = cn(f);
    g ? i.push(m) : m(e);
  }
  if (i.length !== 0) {
    for (let [, a] of r.variants.variants)
      a.order > e && (a.order += i.length);
    r.variants.compareFns = new Map(Array.from(r.variants.compareFns).map(([a, f]) => (a > e && (a += i.length), [a, f])));
    for (let [a, f] of i.entries())
      f(e + a + 1);
  }
}
function cn(t) {
  return (Array.isArray(t) ? t : [t]).map((o) => typeof o == "string" ? { min: o } : o && typeof o == "object" ? o : null).map((o) => {
    if (o === null)
      return null;
    if ("raw" in o)
      return o.raw;
    let e = "";
    return o.max !== undefined && (e += `${o.max} >= `), e += "width", o.min !== undefined && (e += ` >= ${o.min}`), `(${e})`;
  }).filter(Boolean).join(", ");
}
function ho(t, r) {
  let o = t.theme.aria || {}, e = t.theme.supports || {}, i = t.theme.data || {};
  if (Object.keys(o).length > 0) {
    let s = r.variants.get("aria"), a = s?.applyFn, f = s?.compounds;
    r.variants.functional("aria", (u, c) => {
      let g = c.value;
      return g && g.kind === "named" && g.value in o ? a?.(u, { ...c, value: { kind: "arbitrary", value: o[g.value] } }) : a?.(u, c);
    }, { compounds: f });
  }
  if (Object.keys(e).length > 0) {
    let s = r.variants.get("supports"), a = s?.applyFn, f = s?.compounds;
    r.variants.functional("supports", (u, c) => {
      let g = c.value;
      return g && g.kind === "named" && g.value in e ? a?.(u, { ...c, value: { kind: "arbitrary", value: e[g.value] } }) : a?.(u, c);
    }, { compounds: f });
  }
  if (Object.keys(i).length > 0) {
    let s = r.variants.get("data"), a = s?.applyFn, f = s?.compounds;
    r.variants.functional("data", (u, c) => {
      let g = c.value;
      return g && g.kind === "named" && g.value in i ? a?.(u, { ...c, value: { kind: "arbitrary", value: i[g.value] } }) : a?.(u, c);
    }, { compounds: f });
  }
}
var fn = /^[a-z]+$/;
async function vo({ designSystem: t, base: r, ast: o, loadModule: e, sources: i }) {
  let s = 0, a = [], f = [];
  D(o, (d, { parent: m, replaceWith: v, context: k }) => {
    if (d.kind === "at-rule") {
      if (d.name === "@plugin") {
        if (m !== null)
          throw new Error("`@plugin` cannot be nested.");
        let x = d.params.slice(1, -1);
        if (x.length === 0)
          throw new Error("`@plugin` must have a path.");
        let y = {};
        for (let N of d.nodes ?? []) {
          if (N.kind !== "declaration")
            throw new Error(`Unexpected \`@plugin\` option:

${ne([N])}

\`@plugin\` options must be a flat list of declarations.`);
          if (N.value === undefined)
            continue;
          let b = N.value, V = z(b, ",").map((R) => {
            if (R = R.trim(), R === "null")
              return null;
            if (R === "true")
              return true;
            if (R === "false")
              return false;
            if (Number.isNaN(Number(R))) {
              if (R[0] === '"' && R[R.length - 1] === '"' || R[0] === "'" && R[R.length - 1] === "'")
                return R.slice(1, -1);
              if (R[0] === "{" && R[R.length - 1] === "}")
                throw new Error(`Unexpected \`@plugin\` option: Value of declaration \`${ne([N]).trim()}\` is not supported.

Using an object as a plugin option is currently only supported in JavaScript configuration files.`);
            } else
              return Number(R);
            return R;
          });
          y[N.property] = V.length === 1 ? V[0] : V;
        }
        a.push([{ id: x, base: k.base, reference: !!k.reference }, Object.keys(y).length > 0 ? y : null]), v([]), s |= 4;
        return;
      }
      if (d.name === "@config") {
        if (d.nodes.length > 0)
          throw new Error("`@config` cannot have a body.");
        if (m !== null)
          throw new Error("`@config` cannot be nested.");
        f.push({ id: d.params.slice(1, -1), base: k.base, reference: !!k.reference }), v([]), s |= 4;
        return;
      }
    }
  }), mo(t);
  let u = t.resolveThemeValue;
  if (t.resolveThemeValue = function(m, v) {
    return m.startsWith("--") ? u(m, v) : (s |= ko({ designSystem: t, base: r, ast: o, sources: i, configs: [], pluginDetails: [] }), t.resolveThemeValue(m, v));
  }, !a.length && !f.length)
    return 0;
  let [c, g] = await Promise.all([Promise.all(f.map(async ({ id: d, base: m, reference: v }) => {
    let k = await e(d, m, "config");
    return { path: d, base: k.base, config: k.module, reference: v };
  })), Promise.all(a.map(async ([{ id: d, base: m, reference: v }, k]) => {
    let x = await e(d, m, "plugin");
    return { path: d, base: x.base, plugin: x.module, options: k, reference: v };
  }))]);
  return s |= ko({ designSystem: t, base: r, ast: o, sources: i, configs: c, pluginDetails: g }), s;
}
function ko({ designSystem: t, base: r, ast: o, sources: e, configs: i, pluginDetails: s }) {
  let a = 0, u = [...s.map((y) => {
    if (!y.options)
      return { config: { plugins: [y.plugin] }, base: y.base, reference: y.reference };
    if ("__isOptionsFunction" in y.plugin)
      return { config: { plugins: [y.plugin(y.options)] }, base: y.base, reference: y.reference };
    throw new Error(`The plugin "${y.path}" does not accept options`);
  }), ...i], { resolvedConfig: c } = Wt(t, [{ config: co(t.theme), base: r, reference: true }, ...u, { config: { plugins: [po] }, base: r, reference: true }]), { resolvedConfig: g, replacedThemeKeys: d } = Wt(t, u), m = t.resolveThemeValue;
  t.resolveThemeValue = function(N, b) {
    if (N[0] === "-" && N[1] === "-")
      return m(N, b);
    let V = k.theme(N, undefined);
    if (Array.isArray(V) && V.length === 2)
      return V[0];
    if (Array.isArray(V))
      return V.join(", ");
    if (typeof V == "string")
      return V;
  };
  let v = { designSystem: t, ast: o, resolvedConfig: c, featuresRef: { set current(y) {
    a |= y;
  } } }, k = Ft({ ...v, referenceMode: false }), x;
  for (let { handler: y, reference: N } of c.plugins)
    N ? (x ||= Ft({ ...v, referenceMode: true }), y(x)) : y(k);
  if (Fr(t, g, d), lo(t, g, d), ho(g, t), go(g, t), fo(g, t), !t.theme.prefix && c.prefix) {
    if (c.prefix.endsWith("-") && (c.prefix = c.prefix.slice(0, -1), console.warn(`The prefix "${c.prefix}" is invalid. Prefixes must be lowercase ASCII letters (a-z) only and is written as a variant before all utilities. We have fixed up the prefix for you. Remove the trailing \`-\` to silence this warning.`)), !fn.test(c.prefix))
      throw new Error(`The prefix "${c.prefix}" is invalid. Prefixes must be lowercase ASCII letters (a-z) only.`);
    t.theme.prefix = c.prefix;
  }
  if (!t.important && c.important === true && (t.important = true), typeof c.important == "string") {
    let y = c.important;
    D(o, (N, { replaceWith: b, parent: V }) => {
      if (N.kind === "at-rule" && !(N.name !== "@tailwind" || N.params !== "utilities"))
        return V?.kind === "rule" && V.selector === y ? 2 : (b(M(y, [N])), 2);
    });
  }
  for (let y of c.blocklist)
    t.invalidCandidates.add(y);
  for (let y of c.content.files) {
    if ("raw" in y)
      throw new Error(`Error in the config file/plugin/preset. The \`content\` key contains a \`raw\` entry:

${JSON.stringify(y, null, 2)}

This feature is not currently supported.`);
    let N = false;
    y.pattern[0] == "!" && (N = true, y.pattern = y.pattern.slice(1)), e.push({ ...y, negated: N });
  }
  return a;
}
function wo(t) {
  let r = [0];
  for (let i = 0;i < t.length; i++)
    t.charCodeAt(i) === 10 && r.push(i + 1);
  function o(i) {
    let s = 0, a = r.length;
    for (;a > 0; ) {
      let u = (a | 0) >> 1, c = s + u;
      r[c] <= i ? (s = c + 1, a = a - u - 1) : a = u;
    }
    s -= 1;
    let f = i - r[s];
    return { line: s + 1, column: f };
  }
  function e({ line: i, column: s }) {
    i -= 1, i = Math.min(Math.max(i, 0), r.length - 1);
    let a = r[i], f = r[i + 1] ?? a;
    return Math.min(Math.max(a + s, 0), f);
  }
  return { find: o, findOffset: e };
}
function bo({ ast: t }) {
  let r = new W((i) => wo(i.code)), o = new W((i) => ({ url: i.file, content: i.code, ignore: false })), e = { file: null, sources: [], mappings: [] };
  D(t, (i) => {
    if (!i.src || !i.dst)
      return;
    let s = o.get(i.src[0]);
    if (!s.content)
      return;
    let a = r.get(i.src[0]), f = r.get(i.dst[0]), u = s.content.slice(i.src[1], i.src[2]), c = 0;
    for (let m of u.split(`
`)) {
      if (m.trim() !== "") {
        let v = a.find(i.src[1] + c), k = f.find(i.dst[1]);
        e.mappings.push({ name: null, originalPosition: { source: s, ...v }, generatedPosition: k });
      }
      c += m.length, c += 1;
    }
    let g = a.find(i.src[2]), d = f.find(i.dst[2]);
    e.mappings.push({ name: null, originalPosition: { source: s, ...g }, generatedPosition: d });
  });
  for (let i of r.keys())
    e.sources.push(o.get(i));
  return e.mappings.sort((i, s) => i.generatedPosition.line - s.generatedPosition.line || i.generatedPosition.column - s.generatedPosition.column || (i.originalPosition?.line ?? 0) - (s.originalPosition?.line ?? 0) || (i.originalPosition?.column ?? 0) - (s.originalPosition?.column ?? 0)), e;
}
var yo = /^(-?\d+)\.\.(-?\d+)(?:\.\.(-?\d+))?$/;
function ht(t) {
  let r = t.indexOf("{");
  if (r === -1)
    return [t];
  let o = [], e = t.slice(0, r), i = t.slice(r), s = 0, a = i.lastIndexOf("}");
  for (let d = 0;d < i.length; d++) {
    let m = i[d];
    if (m === "{")
      s++;
    else if (m === "}" && (s--, s === 0)) {
      a = d;
      break;
    }
  }
  if (a === -1)
    throw new Error(`The pattern \`${t}\` is not balanced.`);
  let f = i.slice(1, a), u = i.slice(a + 1), c;
  pn(f) ? c = dn(f) : c = z(f, ","), c = c.flatMap((d) => ht(d));
  let g = ht(u);
  for (let d of g)
    for (let m of c)
      o.push(e + m + d);
  return o;
}
function pn(t) {
  return yo.test(t);
}
function dn(t) {
  let r = t.match(yo);
  if (!r)
    return [t];
  let [, o, e, i] = r, s = i ? parseInt(i, 10) : undefined, a = [];
  if (/^-?\d+$/.test(o) && /^-?\d+$/.test(e)) {
    let f = parseInt(o, 10), u = parseInt(e, 10);
    if (s === undefined && (s = f <= u ? 1 : -1), s === 0)
      throw new Error("Step cannot be zero in sequence expansion.");
    let c = f < u;
    c && s < 0 && (s = -s), !c && s > 0 && (s = -s);
    for (let g = f;c ? g <= u : g >= u; g += s)
      a.push(g.toString());
  }
  return a;
}
var mn = /^[a-z]+$/;
function gn() {
  throw new Error("No `loadModule` function provided to `compile`");
}
function hn() {
  throw new Error("No `loadStylesheet` function provided to `compile`");
}
function kn(t) {
  let r = 0, o = null;
  for (let e of z(t, " "))
    e === "reference" ? r |= 2 : e === "inline" ? r |= 1 : e === "default" ? r |= 4 : e === "static" ? r |= 8 : e.startsWith("prefix(") && e.endsWith(")") && (o = e.slice(7, -1));
  return [r, o];
}
async function vn(t, { base: r = "", from: o, loadModule: e = gn, loadStylesheet: i = hn } = {}) {
  let s = 0;
  t = [se({ base: r }, t)], s |= await It(t, r, i, 0, o !== undefined);
  let a = null, f = new Qe, u = [], c = [], g = null, d = null, m = [], v = [], k = [], x = [], y = null;
  D(t, (b, { parent: V, replaceWith: R, context: U }) => {
    if (b.kind === "at-rule") {
      if (b.name === "@tailwind" && (b.params === "utilities" || b.params.startsWith("utilities"))) {
        if (d !== null) {
          R([]);
          return;
        }
        if (U.reference) {
          R([]);
          return;
        }
        let _ = z(b.params, " ");
        for (let L of _)
          if (L.startsWith("source(")) {
            let O = L.slice(7, -1);
            if (O === "none") {
              y = O;
              continue;
            }
            if (O[0] === '"' && O[O.length - 1] !== '"' || O[0] === "'" && O[O.length - 1] !== "'" || O[0] !== "'" && O[0] !== '"')
              throw new Error("`source(…)` paths must be quoted.");
            y = { base: U.sourceBase ?? U.base, pattern: O.slice(1, -1) };
          }
        d = b, s |= 16;
      }
      if (b.name === "@utility") {
        if (V !== null)
          throw new Error("`@utility` cannot be nested.");
        if (b.nodes.length === 0)
          throw new Error(`\`@utility ${b.params}\` is empty. Utilities should include at least one property.`);
        let _ = Tr(b);
        if (_ === null)
          throw new Error(`\`@utility ${b.params}\` defines an invalid utility name. Utilities should be alphanumeric and start with a lowercase letter.`);
        c.push(_);
      }
      if (b.name === "@source") {
        if (b.nodes.length > 0)
          throw new Error("`@source` cannot have a body.");
        if (V !== null)
          throw new Error("`@source` cannot be nested.");
        let _ = false, L = false, O = b.params;
        if (O[0] === "n" && O.startsWith("not ") && (_ = true, O = O.slice(4)), O[0] === "i" && O.startsWith("inline(") && (L = true, O = O.slice(7, -1)), O[0] === '"' && O[O.length - 1] !== '"' || O[0] === "'" && O[O.length - 1] !== "'" || O[0] !== "'" && O[0] !== '"')
          throw new Error("`@source` paths must be quoted.");
        let H = O.slice(1, -1);
        if (L) {
          let I = _ ? x : k, q = z(H, " ");
          for (let X of q)
            for (let oe of ht(X))
              I.push(oe);
        } else
          v.push({ base: U.base, pattern: H, negated: _ });
        R([]);
        return;
      }
      if (b.name === "@variant" && (V === null ? b.nodes.length === 0 ? b.name = "@custom-variant" : (D(b.nodes, (_) => {
        if (_.kind === "at-rule" && _.name === "@slot")
          return b.name = "@custom-variant", 2;
      }), b.name === "@variant" && m.push(b)) : m.push(b)), b.name === "@custom-variant") {
        if (V !== null)
          throw new Error("`@custom-variant` cannot be nested.");
        R([]);
        let [_, L] = z(b.params, " ");
        if (!ut.test(_))
          throw new Error(`\`@custom-variant ${_}\` defines an invalid variant name. Variants should only contain alphanumeric, dashes or underscore characters.`);
        if (b.nodes.length > 0 && L)
          throw new Error(`\`@custom-variant ${_}\` cannot have both a selector and a body.`);
        if (b.nodes.length === 0) {
          if (!L)
            throw new Error(`\`@custom-variant ${_}\` has no selector or body.`);
          let O = z(L.slice(1, -1), ",");
          if (O.length === 0 || O.some((q) => q.trim() === ""))
            throw new Error(`\`@custom-variant ${_} (${O.join(",")})\` selector is invalid.`);
          let H = [], I = [];
          for (let q of O)
            q = q.trim(), q[0] === "@" ? H.push(q) : I.push(q);
          u.push((q) => {
            q.variants.static(_, (X) => {
              let oe = [];
              I.length > 0 && oe.push(M(I.join(", "), X.nodes));
              for (let n of H)
                oe.push(G(n, X.nodes));
              X.nodes = oe;
            }, { compounds: Ae([...I, ...H]) });
          });
          return;
        } else {
          u.push((O) => {
            O.variants.fromAst(_, b.nodes);
          });
          return;
        }
      }
      if (b.name === "@media") {
        let _ = z(b.params, " "), L = [];
        for (let O of _)
          if (O.startsWith("source(")) {
            let H = O.slice(7, -1);
            D(b.nodes, (I, { replaceWith: q }) => {
              if (I.kind === "at-rule" && I.name === "@tailwind" && I.params === "utilities")
                return I.params += ` source(${H})`, q([se({ sourceBase: U.base }, [I])]), 2;
            });
          } else if (O.startsWith("theme(")) {
            let H = O.slice(6, -1), I = H.includes("reference");
            D(b.nodes, (q) => {
              if (q.kind !== "at-rule") {
                if (I)
                  throw new Error('Files imported with `@import "…" theme(reference)` must only contain `@theme` blocks.\nUse `@reference "…";` instead.');
                return 0;
              }
              if (q.name === "@theme")
                return q.params += " " + H, 1;
            });
          } else if (O.startsWith("prefix(")) {
            let H = O.slice(7, -1);
            D(b.nodes, (I) => {
              if (I.kind === "at-rule" && I.name === "@theme")
                return I.params += ` prefix(${H})`, 1;
            });
          } else
            O === "important" ? a = true : O === "reference" ? b.nodes = [se({ reference: true }, b.nodes)] : L.push(O);
        L.length > 0 ? b.params = L.join(" ") : _.length > 0 && R(b.nodes);
      }
      if (b.name === "@theme") {
        let [_, L] = kn(b.params);
        if (U.reference && (_ |= 2), L) {
          if (!mn.test(L))
            throw new Error(`The prefix "${L}" is invalid. Prefixes must be lowercase ASCII letters (a-z) only.`);
          f.prefix = L;
        }
        return D(b.nodes, (O) => {
          if (O.kind === "at-rule" && O.name === "@keyframes")
            return f.addKeyframes(O), 1;
          if (O.kind === "comment")
            return;
          if (O.kind === "declaration" && O.property.startsWith("--")) {
            f.add(ve(O.property), O.value ?? "", _, O.src);
            return;
          }
          let H = ne([F(b.name, b.params, [O])]).split(`
`).map((I, q, X) => `${q === 0 || q >= X.length - 2 ? " " : ">"} ${I}`).join(`
`);
          throw new Error(`\`@theme\` blocks must only contain custom properties or \`@keyframes\`.

${H}`);
        }), g ? R([]) : (g = M(":root, :host", []), g.src = b.src, R([g])), 1;
      }
    }
  });
  let N = Ur(f);
  if (a && (N.important = a), x.length > 0)
    for (let b of x)
      N.invalidCandidates.add(b);
  s |= await vo({ designSystem: N, base: r, ast: t, loadModule: e, sources: v });
  for (let b of u)
    b(N);
  for (let b of c)
    b(N);
  if (g) {
    let b = [];
    for (let [R, U] of N.theme.entries()) {
      if (U.options & 2)
        continue;
      let _ = l(me(R), U.value);
      _.src = U.src, b.push(_);
    }
    let V = N.theme.getKeyframes();
    for (let R of V)
      t.push(se({ theme: true }, [j([R])]));
    g.nodes = [se({ theme: true }, b)];
  }
  if (d) {
    let b = d;
    b.kind = "context", b.context = {};
  }
  if (m.length > 0) {
    for (let b of m) {
      let V = M("&", b.nodes), R = b.params, U = N.parseVariant(R);
      if (U === null)
        throw new Error(`Cannot use \`@variant\` with unknown variant: ${R}`);
      if (Te(V, U, N.variants) === null)
        throw new Error(`Cannot use \`@variant\` with variant: ${R}`);
      Object.assign(b, V);
    }
    s |= 32;
  }
  return s |= Ve(t, N), s |= je(t, N), D(t, (b, { replaceWith: V }) => {
    if (b.kind === "at-rule")
      return b.name === "@utility" && V([]), 1;
  }), { designSystem: N, ast: t, sources: v, root: y, utilitiesNode: d, features: s, inlineCandidates: k };
}
async function wn(t, r = {}) {
  let { designSystem: o, ast: e, sources: i, root: s, utilitiesNode: a, features: f, inlineCandidates: u } = await vn(t, r);
  e.unshift(Je(`! tailwindcss v${qt} | MIT License | https://tailwindcss.com `));
  function c(k) {
    o.invalidCandidates.add(k);
  }
  let g = new Set, d = null, m = 0, v = false;
  for (let k of u)
    o.invalidCandidates.has(k) || (g.add(k), v = true);
  return { sources: i, root: s, features: f, build(k) {
    if (f === 0)
      return t;
    if (!a)
      return d ??= be(e, o, r.polyfills), d;
    let x = v, y = false;
    v = false;
    let N = g.size;
    for (let V of k)
      if (!o.invalidCandidates.has(V))
        if (V[0] === "-" && V[1] === "-") {
          let R = o.theme.markUsedVariable(V);
          x ||= R, y ||= R;
        } else
          g.add(V), x ||= g.size !== N;
    if (!x)
      return d ??= be(e, o, r.polyfills), d;
    let b = he(g, o, { onInvalidCandidate: c }).astNodes;
    return r.from && D(b, (V) => {
      V.src ??= a.src;
    }), !y && m === b.length ? (d ??= be(e, o, r.polyfills), d) : (m = b.length, a.nodes = b, d = be(e, o, r.polyfills), d);
  } };
}
async function xo(t, r = {}) {
  let o = $e(t, { from: r.from }), e = await wn(o, r), i = o, s = t;
  return { ...e, build(a) {
    let f = e.build(a);
    return f === i || (s = ne(f, !!r.from), i = f), s;
  }, buildSourceMap() {
    return bo({ ast: i });
  } };
}
var Ao = `@layer theme, base, components, utilities;

@import './theme.css' layer(theme);
@import './preflight.css' layer(base);
@import './utilities.css' layer(utilities);
`;
var Co = `/*
  1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
  2. Remove default margins and padding
  3. Reset all borders.
*/

*,
::after,
::before,
::backdrop,
::file-selector-button {
  box-sizing: border-box; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 2 */
  border: 0 solid; /* 3 */
}

/*
  1. Use a consistent sensible line-height in all browsers.
  2. Prevent adjustments of font size after orientation changes in iOS.
  3. Use a more readable tab size.
  4. Use the user's configured \`sans\` font-family by default.
  5. Use the user's configured \`sans\` font-feature-settings by default.
  6. Use the user's configured \`sans\` font-variation-settings by default.
  7. Disable tap highlights on iOS.
*/

html,
:host {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  tab-size: 4; /* 3 */
  font-family: --theme(
    --default-font-family,
    ui-sans-serif,
    system-ui,
    sans-serif,
    'Apple Color Emoji',
    'Segoe UI Emoji',
    'Segoe UI Symbol',
    'Noto Color Emoji'
  ); /* 4 */
  font-feature-settings: --theme(--default-font-feature-settings, normal); /* 5 */
  font-variation-settings: --theme(--default-font-variation-settings, normal); /* 6 */
  -webkit-tap-highlight-color: transparent; /* 7 */
}

/*
  1. Add the correct height in Firefox.
  2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
  3. Reset the default border style to a 1px solid border.
*/

hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
  Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
  text-decoration: underline dotted;
}

/*
  Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
  Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  -webkit-text-decoration: inherit;
  text-decoration: inherit;
}

/*
  Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
  1. Use the user's configured \`mono\` font-family by default.
  2. Use the user's configured \`mono\` font-feature-settings by default.
  3. Use the user's configured \`mono\` font-variation-settings by default.
  4. Correct the odd \`em\` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: --theme(
    --default-mono-font-family,
    ui-monospace,
    SFMono-Regular,
    Menlo,
    Monaco,
    Consolas,
    'Liberation Mono',
    'Courier New',
    monospace
  ); /* 1 */
  font-feature-settings: --theme(--default-mono-font-feature-settings, normal); /* 2 */
  font-variation-settings: --theme(--default-mono-font-variation-settings, normal); /* 3 */
  font-size: 1em; /* 4 */
}

/*
  Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
  Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
  1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
  2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
  3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
  Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
  Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
  Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
  Make lists unstyled by default.
*/

ol,
ul,
menu {
  list-style: none;
}

/*
  1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
  2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
      This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
  Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/*
  1. Inherit font styles in all browsers.
  2. Remove border radius in all browsers.
  3. Remove background color in all browsers.
  4. Ensure consistent opacity for disabled states in all browsers.
*/

button,
input,
select,
optgroup,
textarea,
::file-selector-button {
  font: inherit; /* 1 */
  font-feature-settings: inherit; /* 1 */
  font-variation-settings: inherit; /* 1 */
  letter-spacing: inherit; /* 1 */
  color: inherit; /* 1 */
  border-radius: 0; /* 2 */
  background-color: transparent; /* 3 */
  opacity: 1; /* 4 */
}

/*
  Restore default font weight.
*/

:where(select:is([multiple], [size])) optgroup {
  font-weight: bolder;
}

/*
  Restore indentation.
*/

:where(select:is([multiple], [size])) optgroup option {
  padding-inline-start: 20px;
}

/*
  Restore space after button.
*/

::file-selector-button {
  margin-inline-end: 4px;
}

/*
  Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
*/

::placeholder {
  opacity: 1;
}

/*
  Set the default placeholder color to a semi-transparent version of the current text color in browsers that do not
  crash when using \`color-mix(…)\` with \`currentcolor\`. (https://github.com/tailwindlabs/tailwindcss/issues/17194)
*/

@supports (not (-webkit-appearance: -apple-pay-button)) /* Not Safari */ or
  (contain-intrinsic-size: 1px) /* Safari 17+ */ {
  ::placeholder {
    color: color-mix(in oklab, currentcolor 50%, transparent);
  }
}

/*
  Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
  Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
  1. Ensure date/time inputs have the same height when empty in iOS Safari.
  2. Ensure text alignment can be changed on date/time inputs in iOS Safari.
*/

::-webkit-date-and-time-value {
  min-height: 1lh; /* 1 */
  text-align: inherit; /* 2 */
}

/*
  Prevent height from changing on date/time inputs in macOS Safari when the input is set to \`display: block\`.
*/

::-webkit-datetime-edit {
  display: inline-flex;
}

/*
  Remove excess padding from pseudo-elements in date/time inputs to ensure consistent height across browsers.
*/

::-webkit-datetime-edit-fields-wrapper {
  padding: 0;
}

::-webkit-datetime-edit,
::-webkit-datetime-edit-year-field,
::-webkit-datetime-edit-month-field,
::-webkit-datetime-edit-day-field,
::-webkit-datetime-edit-hour-field,
::-webkit-datetime-edit-minute-field,
::-webkit-datetime-edit-second-field,
::-webkit-datetime-edit-millisecond-field,
::-webkit-datetime-edit-meridiem-field {
  padding-block: 0;
}

/*
  Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
  Correct the inability to style the border radius in iOS Safari.
*/

button,
input:where([type='button'], [type='reset'], [type='submit']),
::file-selector-button {
  appearance: button;
}

/*
  Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
  Make elements with the HTML hidden attribute stay hidden by default.
*/

[hidden]:where(:not([hidden='until-found'])) {
  display: none !important;
}
`;
var $o = `@theme default {
  --font-sans:
    ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
    'Noto Color Emoji';
  --font-serif: ui-serif, Georgia, Cambria, 'Times New Roman', Times, serif;
  --font-mono:
    ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New',
    monospace;

  --color-red-50: oklch(97.1% 0.013 17.38);
  --color-red-100: oklch(93.6% 0.032 17.717);
  --color-red-200: oklch(88.5% 0.062 18.334);
  --color-red-300: oklch(80.8% 0.114 19.571);
  --color-red-400: oklch(70.4% 0.191 22.216);
  --color-red-500: oklch(63.7% 0.237 25.331);
  --color-red-600: oklch(57.7% 0.245 27.325);
  --color-red-700: oklch(50.5% 0.213 27.518);
  --color-red-800: oklch(44.4% 0.177 26.899);
  --color-red-900: oklch(39.6% 0.141 25.723);
  --color-red-950: oklch(25.8% 0.092 26.042);

  --color-orange-50: oklch(98% 0.016 73.684);
  --color-orange-100: oklch(95.4% 0.038 75.164);
  --color-orange-200: oklch(90.1% 0.076 70.697);
  --color-orange-300: oklch(83.7% 0.128 66.29);
  --color-orange-400: oklch(75% 0.183 55.934);
  --color-orange-500: oklch(70.5% 0.213 47.604);
  --color-orange-600: oklch(64.6% 0.222 41.116);
  --color-orange-700: oklch(55.3% 0.195 38.402);
  --color-orange-800: oklch(47% 0.157 37.304);
  --color-orange-900: oklch(40.8% 0.123 38.172);
  --color-orange-950: oklch(26.6% 0.079 36.259);

  --color-amber-50: oklch(98.7% 0.022 95.277);
  --color-amber-100: oklch(96.2% 0.059 95.617);
  --color-amber-200: oklch(92.4% 0.12 95.746);
  --color-amber-300: oklch(87.9% 0.169 91.605);
  --color-amber-400: oklch(82.8% 0.189 84.429);
  --color-amber-500: oklch(76.9% 0.188 70.08);
  --color-amber-600: oklch(66.6% 0.179 58.318);
  --color-amber-700: oklch(55.5% 0.163 48.998);
  --color-amber-800: oklch(47.3% 0.137 46.201);
  --color-amber-900: oklch(41.4% 0.112 45.904);
  --color-amber-950: oklch(27.9% 0.077 45.635);

  --color-yellow-50: oklch(98.7% 0.026 102.212);
  --color-yellow-100: oklch(97.3% 0.071 103.193);
  --color-yellow-200: oklch(94.5% 0.129 101.54);
  --color-yellow-300: oklch(90.5% 0.182 98.111);
  --color-yellow-400: oklch(85.2% 0.199 91.936);
  --color-yellow-500: oklch(79.5% 0.184 86.047);
  --color-yellow-600: oklch(68.1% 0.162 75.834);
  --color-yellow-700: oklch(55.4% 0.135 66.442);
  --color-yellow-800: oklch(47.6% 0.114 61.907);
  --color-yellow-900: oklch(42.1% 0.095 57.708);
  --color-yellow-950: oklch(28.6% 0.066 53.813);

  --color-lime-50: oklch(98.6% 0.031 120.757);
  --color-lime-100: oklch(96.7% 0.067 122.328);
  --color-lime-200: oklch(93.8% 0.127 124.321);
  --color-lime-300: oklch(89.7% 0.196 126.665);
  --color-lime-400: oklch(84.1% 0.238 128.85);
  --color-lime-500: oklch(76.8% 0.233 130.85);
  --color-lime-600: oklch(64.8% 0.2 131.684);
  --color-lime-700: oklch(53.2% 0.157 131.589);
  --color-lime-800: oklch(45.3% 0.124 130.933);
  --color-lime-900: oklch(40.5% 0.101 131.063);
  --color-lime-950: oklch(27.4% 0.072 132.109);

  --color-green-50: oklch(98.2% 0.018 155.826);
  --color-green-100: oklch(96.2% 0.044 156.743);
  --color-green-200: oklch(92.5% 0.084 155.995);
  --color-green-300: oklch(87.1% 0.15 154.449);
  --color-green-400: oklch(79.2% 0.209 151.711);
  --color-green-500: oklch(72.3% 0.219 149.579);
  --color-green-600: oklch(62.7% 0.194 149.214);
  --color-green-700: oklch(52.7% 0.154 150.069);
  --color-green-800: oklch(44.8% 0.119 151.328);
  --color-green-900: oklch(39.3% 0.095 152.535);
  --color-green-950: oklch(26.6% 0.065 152.934);

  --color-emerald-50: oklch(97.9% 0.021 166.113);
  --color-emerald-100: oklch(95% 0.052 163.051);
  --color-emerald-200: oklch(90.5% 0.093 164.15);
  --color-emerald-300: oklch(84.5% 0.143 164.978);
  --color-emerald-400: oklch(76.5% 0.177 163.223);
  --color-emerald-500: oklch(69.6% 0.17 162.48);
  --color-emerald-600: oklch(59.6% 0.145 163.225);
  --color-emerald-700: oklch(50.8% 0.118 165.612);
  --color-emerald-800: oklch(43.2% 0.095 166.913);
  --color-emerald-900: oklch(37.8% 0.077 168.94);
  --color-emerald-950: oklch(26.2% 0.051 172.552);

  --color-teal-50: oklch(98.4% 0.014 180.72);
  --color-teal-100: oklch(95.3% 0.051 180.801);
  --color-teal-200: oklch(91% 0.096 180.426);
  --color-teal-300: oklch(85.5% 0.138 181.071);
  --color-teal-400: oklch(77.7% 0.152 181.912);
  --color-teal-500: oklch(70.4% 0.14 182.503);
  --color-teal-600: oklch(60% 0.118 184.704);
  --color-teal-700: oklch(51.1% 0.096 186.391);
  --color-teal-800: oklch(43.7% 0.078 188.216);
  --color-teal-900: oklch(38.6% 0.063 188.416);
  --color-teal-950: oklch(27.7% 0.046 192.524);

  --color-cyan-50: oklch(98.4% 0.019 200.873);
  --color-cyan-100: oklch(95.6% 0.045 203.388);
  --color-cyan-200: oklch(91.7% 0.08 205.041);
  --color-cyan-300: oklch(86.5% 0.127 207.078);
  --color-cyan-400: oklch(78.9% 0.154 211.53);
  --color-cyan-500: oklch(71.5% 0.143 215.221);
  --color-cyan-600: oklch(60.9% 0.126 221.723);
  --color-cyan-700: oklch(52% 0.105 223.128);
  --color-cyan-800: oklch(45% 0.085 224.283);
  --color-cyan-900: oklch(39.8% 0.07 227.392);
  --color-cyan-950: oklch(30.2% 0.056 229.695);

  --color-sky-50: oklch(97.7% 0.013 236.62);
  --color-sky-100: oklch(95.1% 0.026 236.824);
  --color-sky-200: oklch(90.1% 0.058 230.902);
  --color-sky-300: oklch(82.8% 0.111 230.318);
  --color-sky-400: oklch(74.6% 0.16 232.661);
  --color-sky-500: oklch(68.5% 0.169 237.323);
  --color-sky-600: oklch(58.8% 0.158 241.966);
  --color-sky-700: oklch(50% 0.134 242.749);
  --color-sky-800: oklch(44.3% 0.11 240.79);
  --color-sky-900: oklch(39.1% 0.09 240.876);
  --color-sky-950: oklch(29.3% 0.066 243.157);

  --color-blue-50: oklch(97% 0.014 254.604);
  --color-blue-100: oklch(93.2% 0.032 255.585);
  --color-blue-200: oklch(88.2% 0.059 254.128);
  --color-blue-300: oklch(80.9% 0.105 251.813);
  --color-blue-400: oklch(70.7% 0.165 254.624);
  --color-blue-500: oklch(62.3% 0.214 259.815);
  --color-blue-600: oklch(54.6% 0.245 262.881);
  --color-blue-700: oklch(48.8% 0.243 264.376);
  --color-blue-800: oklch(42.4% 0.199 265.638);
  --color-blue-900: oklch(37.9% 0.146 265.522);
  --color-blue-950: oklch(28.2% 0.091 267.935);

  --color-indigo-50: oklch(96.2% 0.018 272.314);
  --color-indigo-100: oklch(93% 0.034 272.788);
  --color-indigo-200: oklch(87% 0.065 274.039);
  --color-indigo-300: oklch(78.5% 0.115 274.713);
  --color-indigo-400: oklch(67.3% 0.182 276.935);
  --color-indigo-500: oklch(58.5% 0.233 277.117);
  --color-indigo-600: oklch(51.1% 0.262 276.966);
  --color-indigo-700: oklch(45.7% 0.24 277.023);
  --color-indigo-800: oklch(39.8% 0.195 277.366);
  --color-indigo-900: oklch(35.9% 0.144 278.697);
  --color-indigo-950: oklch(25.7% 0.09 281.288);

  --color-violet-50: oklch(96.9% 0.016 293.756);
  --color-violet-100: oklch(94.3% 0.029 294.588);
  --color-violet-200: oklch(89.4% 0.057 293.283);
  --color-violet-300: oklch(81.1% 0.111 293.571);
  --color-violet-400: oklch(70.2% 0.183 293.541);
  --color-violet-500: oklch(60.6% 0.25 292.717);
  --color-violet-600: oklch(54.1% 0.281 293.009);
  --color-violet-700: oklch(49.1% 0.27 292.581);
  --color-violet-800: oklch(43.2% 0.232 292.759);
  --color-violet-900: oklch(38% 0.189 293.745);
  --color-violet-950: oklch(28.3% 0.141 291.089);

  --color-purple-50: oklch(97.7% 0.014 308.299);
  --color-purple-100: oklch(94.6% 0.033 307.174);
  --color-purple-200: oklch(90.2% 0.063 306.703);
  --color-purple-300: oklch(82.7% 0.119 306.383);
  --color-purple-400: oklch(71.4% 0.203 305.504);
  --color-purple-500: oklch(62.7% 0.265 303.9);
  --color-purple-600: oklch(55.8% 0.288 302.321);
  --color-purple-700: oklch(49.6% 0.265 301.924);
  --color-purple-800: oklch(43.8% 0.218 303.724);
  --color-purple-900: oklch(38.1% 0.176 304.987);
  --color-purple-950: oklch(29.1% 0.149 302.717);

  --color-fuchsia-50: oklch(97.7% 0.017 320.058);
  --color-fuchsia-100: oklch(95.2% 0.037 318.852);
  --color-fuchsia-200: oklch(90.3% 0.076 319.62);
  --color-fuchsia-300: oklch(83.3% 0.145 321.434);
  --color-fuchsia-400: oklch(74% 0.238 322.16);
  --color-fuchsia-500: oklch(66.7% 0.295 322.15);
  --color-fuchsia-600: oklch(59.1% 0.293 322.896);
  --color-fuchsia-700: oklch(51.8% 0.253 323.949);
  --color-fuchsia-800: oklch(45.2% 0.211 324.591);
  --color-fuchsia-900: oklch(40.1% 0.17 325.612);
  --color-fuchsia-950: oklch(29.3% 0.136 325.661);

  --color-pink-50: oklch(97.1% 0.014 343.198);
  --color-pink-100: oklch(94.8% 0.028 342.258);
  --color-pink-200: oklch(89.9% 0.061 343.231);
  --color-pink-300: oklch(82.3% 0.12 346.018);
  --color-pink-400: oklch(71.8% 0.202 349.761);
  --color-pink-500: oklch(65.6% 0.241 354.308);
  --color-pink-600: oklch(59.2% 0.249 0.584);
  --color-pink-700: oklch(52.5% 0.223 3.958);
  --color-pink-800: oklch(45.9% 0.187 3.815);
  --color-pink-900: oklch(40.8% 0.153 2.432);
  --color-pink-950: oklch(28.4% 0.109 3.907);

  --color-rose-50: oklch(96.9% 0.015 12.422);
  --color-rose-100: oklch(94.1% 0.03 12.58);
  --color-rose-200: oklch(89.2% 0.058 10.001);
  --color-rose-300: oklch(81% 0.117 11.638);
  --color-rose-400: oklch(71.2% 0.194 13.428);
  --color-rose-500: oklch(64.5% 0.246 16.439);
  --color-rose-600: oklch(58.6% 0.253 17.585);
  --color-rose-700: oklch(51.4% 0.222 16.935);
  --color-rose-800: oklch(45.5% 0.188 13.697);
  --color-rose-900: oklch(41% 0.159 10.272);
  --color-rose-950: oklch(27.1% 0.105 12.094);

  --color-slate-50: oklch(98.4% 0.003 247.858);
  --color-slate-100: oklch(96.8% 0.007 247.896);
  --color-slate-200: oklch(92.9% 0.013 255.508);
  --color-slate-300: oklch(86.9% 0.022 252.894);
  --color-slate-400: oklch(70.4% 0.04 256.788);
  --color-slate-500: oklch(55.4% 0.046 257.417);
  --color-slate-600: oklch(44.6% 0.043 257.281);
  --color-slate-700: oklch(37.2% 0.044 257.287);
  --color-slate-800: oklch(27.9% 0.041 260.031);
  --color-slate-900: oklch(20.8% 0.042 265.755);
  --color-slate-950: oklch(12.9% 0.042 264.695);

  --color-gray-50: oklch(98.5% 0.002 247.839);
  --color-gray-100: oklch(96.7% 0.003 264.542);
  --color-gray-200: oklch(92.8% 0.006 264.531);
  --color-gray-300: oklch(87.2% 0.01 258.338);
  --color-gray-400: oklch(70.7% 0.022 261.325);
  --color-gray-500: oklch(55.1% 0.027 264.364);
  --color-gray-600: oklch(44.6% 0.03 256.802);
  --color-gray-700: oklch(37.3% 0.034 259.733);
  --color-gray-800: oklch(27.8% 0.033 256.848);
  --color-gray-900: oklch(21% 0.034 264.665);
  --color-gray-950: oklch(13% 0.028 261.692);

  --color-zinc-50: oklch(98.5% 0 0);
  --color-zinc-100: oklch(96.7% 0.001 286.375);
  --color-zinc-200: oklch(92% 0.004 286.32);
  --color-zinc-300: oklch(87.1% 0.006 286.286);
  --color-zinc-400: oklch(70.5% 0.015 286.067);
  --color-zinc-500: oklch(55.2% 0.016 285.938);
  --color-zinc-600: oklch(44.2% 0.017 285.786);
  --color-zinc-700: oklch(37% 0.013 285.805);
  --color-zinc-800: oklch(27.4% 0.006 286.033);
  --color-zinc-900: oklch(21% 0.006 285.885);
  --color-zinc-950: oklch(14.1% 0.005 285.823);

  --color-neutral-50: oklch(98.5% 0 0);
  --color-neutral-100: oklch(97% 0 0);
  --color-neutral-200: oklch(92.2% 0 0);
  --color-neutral-300: oklch(87% 0 0);
  --color-neutral-400: oklch(70.8% 0 0);
  --color-neutral-500: oklch(55.6% 0 0);
  --color-neutral-600: oklch(43.9% 0 0);
  --color-neutral-700: oklch(37.1% 0 0);
  --color-neutral-800: oklch(26.9% 0 0);
  --color-neutral-900: oklch(20.5% 0 0);
  --color-neutral-950: oklch(14.5% 0 0);

  --color-stone-50: oklch(98.5% 0.001 106.423);
  --color-stone-100: oklch(97% 0.001 106.424);
  --color-stone-200: oklch(92.3% 0.003 48.717);
  --color-stone-300: oklch(86.9% 0.005 56.366);
  --color-stone-400: oklch(70.9% 0.01 56.259);
  --color-stone-500: oklch(55.3% 0.013 58.071);
  --color-stone-600: oklch(44.4% 0.011 73.639);
  --color-stone-700: oklch(37.4% 0.01 67.558);
  --color-stone-800: oklch(26.8% 0.007 34.298);
  --color-stone-900: oklch(21.6% 0.006 56.043);
  --color-stone-950: oklch(14.7% 0.004 49.25);

  --color-black: #000;
  --color-white: #fff;

  --spacing: 0.25rem;

  --breakpoint-sm: 40rem;
  --breakpoint-md: 48rem;
  --breakpoint-lg: 64rem;
  --breakpoint-xl: 80rem;
  --breakpoint-2xl: 96rem;

  --container-3xs: 16rem;
  --container-2xs: 18rem;
  --container-xs: 20rem;
  --container-sm: 24rem;
  --container-md: 28rem;
  --container-lg: 32rem;
  --container-xl: 36rem;
  --container-2xl: 42rem;
  --container-3xl: 48rem;
  --container-4xl: 56rem;
  --container-5xl: 64rem;
  --container-6xl: 72rem;
  --container-7xl: 80rem;

  --text-xs: 0.75rem;
  --text-xs--line-height: calc(1 / 0.75);
  --text-sm: 0.875rem;
  --text-sm--line-height: calc(1.25 / 0.875);
  --text-base: 1rem;
  --text-base--line-height: calc(1.5 / 1);
  --text-lg: 1.125rem;
  --text-lg--line-height: calc(1.75 / 1.125);
  --text-xl: 1.25rem;
  --text-xl--line-height: calc(1.75 / 1.25);
  --text-2xl: 1.5rem;
  --text-2xl--line-height: calc(2 / 1.5);
  --text-3xl: 1.875rem;
  --text-3xl--line-height: calc(2.25 / 1.875);
  --text-4xl: 2.25rem;
  --text-4xl--line-height: calc(2.5 / 2.25);
  --text-5xl: 3rem;
  --text-5xl--line-height: 1;
  --text-6xl: 3.75rem;
  --text-6xl--line-height: 1;
  --text-7xl: 4.5rem;
  --text-7xl--line-height: 1;
  --text-8xl: 6rem;
  --text-8xl--line-height: 1;
  --text-9xl: 8rem;
  --text-9xl--line-height: 1;

  --font-weight-thin: 100;
  --font-weight-extralight: 200;
  --font-weight-light: 300;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  --font-weight-extrabold: 800;
  --font-weight-black: 900;

  --tracking-tighter: -0.05em;
  --tracking-tight: -0.025em;
  --tracking-normal: 0em;
  --tracking-wide: 0.025em;
  --tracking-wider: 0.05em;
  --tracking-widest: 0.1em;

  --leading-tight: 1.25;
  --leading-snug: 1.375;
  --leading-normal: 1.5;
  --leading-relaxed: 1.625;
  --leading-loose: 2;

  --radius-xs: 0.125rem;
  --radius-sm: 0.25rem;
  --radius-md: 0.375rem;
  --radius-lg: 0.5rem;
  --radius-xl: 0.75rem;
  --radius-2xl: 1rem;
  --radius-3xl: 1.5rem;
  --radius-4xl: 2rem;

  --shadow-2xs: 0 1px rgb(0 0 0 / 0.05);
  --shadow-xs: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);

  --inset-shadow-2xs: inset 0 1px rgb(0 0 0 / 0.05);
  --inset-shadow-xs: inset 0 1px 1px rgb(0 0 0 / 0.05);
  --inset-shadow-sm: inset 0 2px 4px rgb(0 0 0 / 0.05);

  --drop-shadow-xs: 0 1px 1px rgb(0 0 0 / 0.05);
  --drop-shadow-sm: 0 1px 2px rgb(0 0 0 / 0.15);
  --drop-shadow-md: 0 3px 3px rgb(0 0 0 / 0.12);
  --drop-shadow-lg: 0 4px 4px rgb(0 0 0 / 0.15);
  --drop-shadow-xl: 0 9px 7px rgb(0 0 0 / 0.1);
  --drop-shadow-2xl: 0 25px 25px rgb(0 0 0 / 0.15);

  --text-shadow-2xs: 0px 1px 0px rgb(0 0 0 / 0.15);
  --text-shadow-xs: 0px 1px 1px rgb(0 0 0 / 0.2);
  --text-shadow-sm:
    0px 1px 0px rgb(0 0 0 / 0.075), 0px 1px 1px rgb(0 0 0 / 0.075), 0px 2px 2px rgb(0 0 0 / 0.075);
  --text-shadow-md:
    0px 1px 1px rgb(0 0 0 / 0.1), 0px 1px 2px rgb(0 0 0 / 0.1), 0px 2px 4px rgb(0 0 0 / 0.1);
  --text-shadow-lg:
    0px 1px 2px rgb(0 0 0 / 0.1), 0px 3px 2px rgb(0 0 0 / 0.1), 0px 4px 8px rgb(0 0 0 / 0.1);

  --ease-in: cubic-bezier(0.4, 0, 1, 1);
  --ease-out: cubic-bezier(0, 0, 0.2, 1);
  --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);

  --animate-spin: spin 1s linear infinite;
  --animate-ping: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;
  --animate-pulse: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  --animate-bounce: bounce 1s infinite;

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  @keyframes ping {
    75%,
    100% {
      transform: scale(2);
      opacity: 0;
    }
  }

  @keyframes pulse {
    50% {
      opacity: 0.5;
    }
  }

  @keyframes bounce {
    0%,
    100% {
      transform: translateY(-25%);
      animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
    }

    50% {
      transform: none;
      animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
    }
  }

  --blur-xs: 4px;
  --blur-sm: 8px;
  --blur-md: 12px;
  --blur-lg: 16px;
  --blur-xl: 24px;
  --blur-2xl: 40px;
  --blur-3xl: 64px;

  --perspective-dramatic: 100px;
  --perspective-near: 300px;
  --perspective-normal: 500px;
  --perspective-midrange: 800px;
  --perspective-distant: 1200px;

  --aspect-video: 16 / 9;

  --default-transition-duration: 150ms;
  --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  --default-font-family: --theme(--font-sans, initial);
  --default-font-feature-settings: --theme(--font-sans--font-feature-settings, initial);
  --default-font-variation-settings: --theme(--font-sans--font-variation-settings, initial);
  --default-mono-font-family: --theme(--font-mono, initial);
  --default-mono-font-feature-settings: --theme(--font-mono--font-feature-settings, initial);
  --default-mono-font-variation-settings: --theme(--font-mono--font-variation-settings, initial);
}

/* Deprecated */
@theme default inline reference {
  --blur: 8px;
  --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --shadow-inner: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);
  --drop-shadow: 0 1px 2px rgb(0 0 0 / 0.1), 0 1px 1px rgb(0 0 0 / 0.06);
  --radius: 0.25rem;
  --max-width-prose: 65ch;
}
`;
var So = `@tailwind utilities;
`;
var We = { index: Ao, preflight: Co, theme: $o, utilities: So };
var kt = class {
  start(r) {
    performance.mark(`${r} (start)`);
  }
  end(r, o) {
    performance.mark(`${r} (end)`), performance.measure(r, { start: `${r} (start)`, end: `${r} (end)`, detail: o });
  }
  hit(r, o) {
    performance.mark(r, { detail: o });
  }
  error(r) {
    throw performance.mark("(error)", { detail: { error: `${r}` } }), r;
  }
};
var Bt;
var No = new Set;
var vt;
var Vo = Promise.resolve();
var ce = new kt;
async function Eo() {
  ce.start("Initialize compiler");
  let t = '@import "tailwindcss";';
  ce.start("Compile CSS");
  try {
    Bt = await xo(t, { base: "/", loadStylesheet: Sn, loadModule: Nn }), vt || (vt = document.createElement("style"), document.head.append(vt));
  } finally {
    ce.end("Compile CSS"), ce.end("Initialize compiler");
  }
}
async function Sn(t, r) {
  function o() {
    if (t === "tailwindcss")
      return { path: "virtual:tailwindcss/index.css", base: r, content: We.index };
    if (t === "tailwindcss/preflight" || t === "tailwindcss/preflight.css" || t === "./preflight.css")
      return { path: "virtual:tailwindcss/preflight.css", base: r, content: We.preflight };
    if (t === "tailwindcss/theme" || t === "tailwindcss/theme.css" || t === "./theme.css")
      return { path: "virtual:tailwindcss/theme.css", base: r, content: We.theme };
    if (t === "tailwindcss/utilities" || t === "tailwindcss/utilities.css" || t === "./utilities.css")
      return { path: "virtual:tailwindcss/utilities.css", base: r, content: We.utilities };
    throw new Error(`The browser build does not support @import for "${t}"`);
  }
  try {
    let e = o();
    return ce.hit("Loaded stylesheet", { id: t, base: r, size: e.content.length }), e;
  } catch (e) {
    throw ce.hit("Failed to load stylesheet", { id: t, base: r, error: e.message ?? e }), e;
  }
}
async function Nn() {
  throw new Error("The browser build does not support plugins or config files.");
}
async function Vn(t) {
  Bt || await Eo();
  let r = t.filter((e) => !No.has(e));
  if (r.length === 0)
    return;
  ce.start("Process new classes");
  for (let e of r)
    No.add(e);
  let o = Bt.build(r);
  vt.textContent += o, ce.end("Process new classes", { count: r.length });
}
function Tn(t) {
  Vo = Vo.then(() => Vn(t)).catch((r) => ce.error(r));
}
function To(t) {
  return t.trim().split(/\s+/).filter(Boolean);
}
function iu(...t) {
  let r = [], o = [];
  for (let e of t)
    if (e) {
      if (typeof e == "string") {
        let i = To(e);
        r.push(...i), o.push(...i);
      } else if (typeof e == "object")
        for (let [i, s] of Object.entries(e)) {
          let a = To(i);
          o.push(...a), s && r.push(...a);
        }
    }
  return Tn(o), r.join(" ");
}
Eo().catch((t) => ce.error(t));

// src/index.ts
var import_maplibre_gl = __toESM(require_maplibre_gl(), 1);
var { main, div } = useTags();
var app = main({
  id: "app",
  class: iu("absolute w-full h-[calc(100%-2rem)] top-8 flex flex-col items-center justify-center bg-black text-white")
}, div({
  id: "globe",
  class: iu("absolute w-full h-full [&_*]:outline-none")
}));
document.body.appendChild(app);
await finish();
function calculateTimeAngle() {
  const now = new Date;
  const hours = now.getHours();
  const minutes = now.getMinutes();
  const decimal_time = hours + minutes / 60;
  let time_angle = (decimal_time / 24 * 360 + 180) % 360;
  return time_angle - 90;
}
var time_angle = calculateTimeAngle();
var map = new import_maplibre_gl.Map({
  container: "globe",
  zoom: 0,
  canvasContextAttributes: {
    contextType: "webgl2",
    antialias: true,
    powerPreference: "high-performance"
  },
  center: [137.9150899566626, 36.25956997955441],
  style: {
    version: 8,
    name: "orto",
    metadata: {},
    center: [1.537786, 41.837539],
    zoom: 12,
    bearing: 0,
    pitch: 0,
    sources: {
      orto_esri: {
        type: "raster",
        tiles: ["https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"],
        tileSize: 256,
        attribution: "ESRI &copy; <a href='http://www.esri.com'>ESRI</a>",
        maxzoom: 18
      }
    },
    projection: {
      type: "globe"
    },
    sky: {
      "atmosphere-blend": ["interpolate", ["linear"], ["zoom"], 0, 1, 1.5, 1, 3, 0]
    },
    light: {
      anchor: "map",
      position: [1.5, 90, time_angle]
    },
    layers: [
      {
        id: "background",
        type: "background",
        paint: {
          "background-color": "#F4F9F4"
        }
      },
      {
        id: "orto_esri",
        type: "raster",
        source: "orto_esri",
        layout: {
          visibility: "visible"
        },
        paint: {
          "raster-resampling": "nearest"
        }
      }
    ]
  },
  transformRequest: (url, resource_type) => {
    return {
      url,
      headers: {},
      credentials: "same-origin"
    };
  }
});
await finish();
setInterval(() => {
  time_angle = calculateTimeAngle();
  map.setLight({
    anchor: "map",
    position: [1.5, 90, time_angle]
  });
}, 60 * 60 * 1000);
app.appendChild(div({
  id: "zoom_info",
  class: iu("absolute top-4 right-4 z-1")
}, () => map.getZoom()));
GlobalStyleSheet(css`
	.maplibregl-ctrl-bottom-right {
		position: fixed;
		bottom: 0.5rem;
		right: 0.5rem;
		font-size: 0.75rem;
		opacity: 0.5;

		summary {
			display: none;
		}
	}
`);
