<!doctype html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta copy="3" />

		<!-- Browser Support -->
		<!--
			Determining browser support is hard.
			LLMs are useful for this task.
			I wonder how much would it cost to implement a browser support API that uses an LLM.
			Or even using a local one.
		-->
		<script type="application/json+browser-support">
			{
				"html+css": {
					"chrome": "29 (2013)",
					"firefox": "28 (2014)",
					"safari": "9 (2015)",
					"min": "2013",
					"max": "2015"
				},
				"javascript": {
					"chrome": "89 (2021)",
					"firefox": "108 (2022)",
					"safari": "16.4 (2023)",
					"min": "2021",
					"max": "2023"
				}
			}
		</script>

		<!-- Style reset and vars -->
		<style name="base">
			:root {
				--font-default: "Inter", sans-serif;
				--font-monospace: "Departure Mono", monospace;
			}

			/*
			  1. Prevent padding and border from affecting element width.
			  2. Remove default margins and padding
			  3. Reset all borders.
			*/

			*,
			::after,
			::before {
				box-sizing: border-box; /* 1 */
				margin: 0; /* 2 */
				padding: 0; /* 2 */
				border: 0 solid; /* 3 */
			}

			/*
			  1. Use a consistent sensible line-height in all browsers.
			  2. Prevent adjustments of font size after orientation changes in iOS.
			  3. Use a more readable tab size.
			  4. Use system font stack.
			  5. Disable tap highlights on iOS.
			*/

			html {
				line-height: 1.5; /* 1 */
				-webkit-text-size-adjust: 100%; /* 2 */
				tab-size: 4; /* 3 */
				font-family: var(--font-default); /* 4 */
				-webkit-tap-highlight-color: transparent; /* 5 */
			}

			/*
			  1. Add the correct height in Firefox.
			  2. Correct the inheritance of border color in Firefox.
			  3. Reset the default border style to a 1px solid border.
			*/

			hr {
				height: 0; /* 1 */
				color: inherit; /* 2 */
				border-top-width: 1px; /* 3 */
			}

			/*
			  Add the correct text decoration in Chrome, Edge, and Safari.
			*/

			abbr[title] {
				-webkit-text-decoration: underline dotted;
				text-decoration: underline dotted;
			}

			/*
			  Remove the default font size and weight for headings.
			*/

			h1,
			h2,
			h3,
			h4,
			h5,
			h6 {
				font-size: inherit;
				font-weight: inherit;
			}

			/*
			  Reset links to optimize for opt-in styling instead of opt-out.
			*/

			a {
				color: inherit;
				text-decoration: inherit;
			}

			/*
			  Add the correct font weight in Edge and Safari.
			*/

			b,
			strong {
				font-weight: bolder;
			}

			/*
			  1. Use monospace font family.
			  2. Correct the odd `em` font sizing in all browsers.
			*/

			code,
			kbd,
			samp,
			pre {
				font-family: var(--font-monospace); /* 1 */
				font-size: 1em; /* 2 */
			}

			/*
			  Add the correct font size in all browsers.
			*/

			small {
				font-size: 80%;
			}

			/*
			  Prevent `sub` and `sup` elements from affecting the line height in all browsers.
			*/

			sub,
			sup {
				font-size: 75%;
				line-height: 0;
				position: relative;
				vertical-align: baseline;
			}

			sub {
				bottom: -0.25em;
			}

			sup {
				top: -0.5em;
			}

			/*
			  1. Remove text indentation from table contents in Chrome and Safari.
			  2. Correct table border color inheritance in all Chrome and Safari.
			  3. Remove gaps between table borders by default.
			*/

			table {
				text-indent: 0; /* 1 */
				border-color: inherit; /* 2 */
				border-collapse: collapse; /* 3 */
			}

			/*
			  Use the modern Firefox focus style for all focusable elements.
			*/

			/*:-moz-focusring {
				outline: auto;
			}*/

			/*
			  Add the correct vertical alignment in Chrome and Firefox.
			*/

			progress {
				vertical-align: baseline;
			}

			/*
			  Add the correct display in Chrome and Safari.
			*/

			summary {
				display: list-item;
			}

			/*
			  Make lists unstyled by default.
			*/

			ol,
			ul,
			menu {
				list-style: none;
			}

			/*
			  1. Make replaced elements `display: block` by default.
			  2. Add `vertical-align: middle` to align replaced elements more sensibly by default.
			*/

			img,
			svg,
			video,
			canvas,
			audio,
			iframe,
			embed,
			object {
				display: block; /* 1 */
				vertical-align: middle; /* 2 */
			}

			/*
			  Constrain images and videos to the parent width and preserve their intrinsic aspect ratio.
			*/

			img,
			video {
				max-width: 100%;
				height: auto;
			}

			/*
			  1. Inherit font styles in all browsers.
			  2. Remove border radius in all browsers.
			  3. Remove background color in all browsers.
			*/

			button,
			input,
			select,
			optgroup,
			textarea {
				font-family: inherit; /* 1 */
				font-size: inherit; /* 1 */
				font-weight: inherit; /* 1 */
				line-height: inherit; /* 1 */
				color: inherit; /* 1 */
				border-radius: 0; /* 2 */
				background-color: transparent; /* 3 */
				text-align: left;
			}

			/*
			  Reset the default placeholder opacity in Firefox.
			*/

			::placeholder {
				opacity: 1;
				color: #9ca3af;
			}

			/*
			  Prevent resizing textareas horizontally by default.
			*/

			textarea {
				resize: vertical;
			}

			/*
			  Remove the inner padding in Chrome and Safari on macOS.
			*/

			::-webkit-search-decoration {
				-webkit-appearance: none;
			}

			/*
			  Remove excess padding from pseudo-elements in date/time inputs.
			*/

			::-webkit-datetime-edit,
			::-webkit-datetime-edit-year-field,
			::-webkit-datetime-edit-month-field,
			::-webkit-datetime-edit-day-field,
			::-webkit-datetime-edit-hour-field,
			::-webkit-datetime-edit-minute-field,
			::-webkit-datetime-edit-second-field,
			::-webkit-datetime-edit-millisecond-field,
			::-webkit-datetime-edit-meridiem-field {
				padding: 0;
			}

			/*
			  Remove the additional `:invalid` styles in Firefox.
			*/

			/*:-moz-ui-invalid {
				box-shadow: none;
			}*/

			/*
			  Correct the inability to style the border radius in iOS Safari.
			*/

			button,
			input[type="button"],
			input[type="reset"],
			input[type="submit"] {
				-webkit-appearance: button;
			}

			/*
			  Correct the cursor style of increment and decrement buttons in Safari.
			*/

			::-webkit-inner-spin-button,
			::-webkit-outer-spin-button {
				height: auto;
			}

			/*
			  Make elements with the HTML hidden attribute stay hidden by default.
			*/

			[hidden] {
				display: none !important;
			}
		</style>

		<!-- Blob Module Handler -->
		<script>
			const preferences = {
				autoUpdateModules: true,
			};

			window.addEventListener("load", async () => {
				const load_start_time = performance.now();
				const blob_modules = new Map();
				const blob_urls = new Map();
				const remote_modules = new Map();

				//
				// Remote Blob Module Cache
				//

				function openCache() {
					return new Promise((resolve, reject) => {
						const request = indexedDB.open("blob_module_cache", 1);

						request.onerror = () => reject(request.error);
						request.onsuccess = () => resolve(request.result);

						request.onupgradeneeded = (event) => {
							const db = event.target.result;
							if (!db.objectStoreNames.contains("modules")) {
								const store = db.createObjectStore("modules", { keyPath: "url" });
								store.createIndex("timestamp", "timestamp", { unique: false });
							}
						};
					});
				}

				window.getCachedModule = async function (url) {
					try {
						const db = await openCache();
						const transaction = db.transaction(["modules"], "readonly");
						const store = transaction.objectStore("modules");

						return new Promise((resolve, reject) => {
							const request = store.get(url);
							request.onerror = () => reject(request.error);
							request.onsuccess = () => resolve(request.result);
						});
					} catch (error) {
						console.warn("Failed to get cached module:", error);
						return null;
					}
				};

				window.setCachedModule = async function (url, content) {
					try {
						const db = await openCache();
						const transaction = db.transaction(["modules"], "readwrite");
						const store = transaction.objectStore("modules");

						const cache_entry = {
							url: url,
							content: content,
							timestamp: Date.now(),
						};

						return new Promise((resolve, reject) => {
							const request = store.put(cache_entry);
							request.onerror = () => reject(request.error);
							request.onsuccess = () => resolve();
						});
					} catch (error) {
						console.warn("Failed to cache module:", error);
					}
				};

				// Cache busting function - exposing globally
				window.clearBlobModuleCache = async function (url = null) {
					try {
						const db = await openCache();
						const transaction = db.transaction(["modules"], "readwrite");
						const store = transaction.objectStore("modules");

						return new Promise((resolve, reject) => {
							let request;

							if (url) {
								// Clear specific URL
								request = store.delete(url);
								request.onsuccess = () => {
									console.log(`Cleared cache for: ${url}`);
									resolve();
								};
							} else {
								// Clear all cached modules
								request = store.clear();
								request.onsuccess = () => {
									console.log("Cleared all blob module cache");
									resolve();
								};
							}

							request.onerror = () => reject(request.error);
						});
					} catch (error) {
						console.warn("Failed to clear cache:", error);
					}
				};

				//
				// Blob Style Processing
				//

				const blob_styles = new Map();
				const blob_style_urls = new Map();
				const remote_styles = new Map();

				const style_tags = document.querySelectorAll("style[remote]");

				// First pass: collect all style contents and remote URLs
				style_tags.forEach((style) => {
					const remote_url = style.getAttribute("remote");
					const style_id = remote_url; // Use URL as identifier since styles don't have names

					if (!remote_url) {
						console.warn("style tag missing remote attribute");
						return;
					}

					// Check for name collisions
					if (blob_styles.has(style_id) || remote_styles.has(style_id)) {
						console.warn(`Style URL collision detected: "${style_id}" already exists. Skipping duplicate.`);
						return;
					}

					const content = style.textContent.trim();

					if (!content) {
						// Empty content with remote URL - fetch remote
						remote_styles.set(style_id, remote_url);
						return;
					} else {
						// Both remote and content exist - store local, compare later
						blob_styles.set(style_id, content);
						remote_styles.set(style_id, remote_url);
						return;
					}
				});

				// Fetch remote styles (with caching) and create local copies before proceeding
				for (const [style_id, remote_url] of remote_styles) {
					try {
						let remote_content;

						if (preferences.autoUpdateModules) {
							// Auto-update mode: fetch from remote first, fallback to cache
							try {
								console.log(`Fetching remote style from ${remote_url} (auto-update mode)`);
								const response = await fetch(remote_url);
								remote_content = await response.text();

								// Update the cache with fresh content
								await setCachedModule(remote_url, remote_content);
								console.log(`Updated cache for remote style from ${remote_url}`);
							} catch (fetch_error) {
								console.warn(`Failed to fetch remote style from "${remote_url}", falling back to cache:`, fetch_error);

								// Fallback to cached version
								const cached_style = await getCachedModule(remote_url);
								if (cached_style) {
									console.log(`Using cached style from ${remote_url} as fallback`);
									remote_content = cached_style.content;
								} else {
									throw new Error("No cached version available");
								}
							}
						} else {
							// Cache-first mode: check cache first, then fetch remote if needed
							const cached_style = await getCachedModule(remote_url);

							if (cached_style) {
								console.log(`Using cached style from ${remote_url}`);
								remote_content = cached_style.content;
							} else {
								console.log(`Fetching remote style from ${remote_url}`);
								const response = await fetch(remote_url);
								remote_content = await response.text();

								// Cache the fetched content
								await setCachedModule(remote_url, remote_content);
								console.log(`Cached remote style from ${remote_url}`);
							}
						}

						if (blob_styles.has(style_id)) {
							// Compare with existing local content
							const local_content = blob_styles.get(style_id);
							if (remote_content.trim() !== local_content.trim()) {
								console.warn(`Remote and local content are different for style "${remote_url}". Using local content.`);
							}
							// Keep local content
						} else {
							// No local content, use fetched remote content
							blob_styles.set(style_id, remote_content);
							console.log(`Successfully loaded remote style from ${remote_url}`);
						}
					} catch (error) {
						console.warn(`Failed to fetch remote style from "${remote_url}":`, error);
						if (!blob_styles.has(style_id)) {
							console.log(`Will keep original remote reference for style "${remote_url}"`);
						} else if (blob_styles.has(style_id)) {
							console.log(`Using local style for "${remote_url}"`);
						}
					}
				}

				// Create blob URLs for all styles and update style tags
				blob_styles.forEach((content, style_id) => {
					const style_blob = new Blob([content], { type: "text/css" });
					const blob_url = URL.createObjectURL(style_blob);
					blob_style_urls.set(style_id, blob_url);

					// Find the corresponding style tag and update it
					const style_tag = Array.from(style_tags).find((tag) => tag.getAttribute("remote") === style_id);
					if (style_tag) {
						// Clear the content
						style_tag.textContent = "";

						// Create a new link element to load the CSS
						const link_element = document.createElement("link");
						link_element.rel = "stylesheet";
						link_element.href = blob_url;

						// Insert the link element after the style tag
						style_tag.parentNode.insertBefore(link_element, style_tag.nextSibling);

						console.log(`Created blob URL link for ${style_id}`);
					}
				});

				// Expose blob style metadata map
				window.__blob_style_map__ = new Map();

				// Populate the style metadata map
				blob_styles.forEach((content, style_id) => {
					const blob_url = blob_style_urls.get(style_id);
					const src_bytes = new Blob([content]).size;

					const metadata = {
						remote_url: style_id,
						src_bytes,
						blob_url,
					};

					window.__blob_style_map__.set(style_id, metadata);
				});

				//
				// Blob Module Processing
				//

				const blob_scripts = document.querySelectorAll('script[type="blob-module"]');

				// First pass: collect all module contents and remote URLs, skip disabled modules
				blob_scripts.forEach((script) => {
					const module_name = script.getAttribute("name");
					const remote_url = script.getAttribute("remote");
					const is_disabled = script.hasAttribute("disabled");

					if (!module_name) {
						console.warn("blob-module script missing name attribute");
						return;
					}

					// Skip disabled modules
					if (is_disabled) {
						console.log(`Skipping disabled module: "${module_name}"`);
						return;
					}

					// Check for name collisions
					if (blob_modules.has(module_name) || remote_modules.has(module_name)) {
						console.warn(`Module name collision detected: "${module_name}" already exists. Skipping duplicate.`);
						return;
					}

					// @TODO: We could minify or format here since this will be the source map from blobs
					const content = script.textContent.trim();

					if (remote_url) {
						if (!content) {
							// Empty content with remote URL - fetch remote
							remote_modules.set(module_name, remote_url);
							return;
						} else {
							// Both remote and content exist - store local, compare later
							blob_modules.set(module_name, content);
							remote_modules.set(module_name, remote_url);
							return;
						}
					}

					// No remote URL, just store content
					blob_modules.set(module_name, content);
				});

				// Fetch remote modules (with caching) and create local copies before proceeding
				for (const [module_name, remote_url] of remote_modules) {
					try {
						let remote_content;

						if (preferences.autoUpdateModules) {
							// Auto-update mode: fetch from remote first, fallback to cache
							try {
								console.log(`Fetching remote module "${module_name}" from ${remote_url} (auto-update mode)`);
								const response = await fetch(remote_url);
								remote_content = await response.text();

								// Update the cache with fresh content
								await setCachedModule(remote_url, remote_content);
								console.log(`Updated cache for remote module "${module_name}"`);
							} catch (fetch_error) {
								console.warn(`Failed to fetch remote module "${module_name}", falling back to cache:`, fetch_error);

								// Fallback to cached version
								const cached_module = await getCachedModule(remote_url);
								if (cached_module) {
									console.log(`Using cached module "${module_name}" as fallback`);
									remote_content = cached_module.content;
								} else {
									throw new Error("No cached version available");
								}
							}
						} else {
							// Cache-first mode: check cache first, then fetch remote if needed
							const cached_module = await getCachedModule(remote_url);

							if (cached_module) {
								console.log(`Using cached module "${module_name}" from ${remote_url}`);
								remote_content = cached_module.content;
							} else {
								console.log(`Fetching remote module "${module_name}" from ${remote_url}`);
								const response = await fetch(remote_url);
								remote_content = await response.text();

								// Cache the fetched content
								await setCachedModule(remote_url, remote_content);
								console.log(`Cached remote module "${module_name}"`);
							}
						}

						if (blob_modules.has(module_name)) {
							// Compare with existing local content
							const local_content = blob_modules.get(module_name);
							if (remote_content.trim() !== local_content.trim()) {
								console.warn(
									`Remote and local content are different for module "${module_name}". Using local content.`,
								);
							}
							// Keep local content
						} else {
							// No local content, use fetched remote content
							blob_modules.set(module_name, remote_content);
							console.log(`Successfully loaded remote module "${module_name}"`);
						}
					} catch (error) {
						console.warn(`Failed to fetch remote module "${module_name}":`, error);
						if (!blob_modules.has(module_name)) {
							// Use remote URL directly in importmap
							blob_urls.set(module_name, remote_url);
							console.log(`Will use remote URL directly for module "${module_name}"`);
						} else if (blob_modules.has(module_name)) {
							console.log(`Using local module "${module_name}"`);
						}
					}
				}

				// Create blob URLs for all modules
				blob_modules.forEach((content, module_name) => {
					const module_blob = new Blob([content], { type: "text/javascript" });
					const blob_url = URL.createObjectURL(module_blob);
					blob_urls.set(module_name, blob_url);
				});

				// Clear script tag contents and add blob URL attributes (only for non-disabled modules)
				blob_scripts.forEach((script) => {
					const module_name = script.getAttribute("name");
					const is_disabled = script.hasAttribute("disabled");

					// Skip disabled modules
					if (is_disabled) {
						return;
					}

					const blob_url = blob_urls.get(module_name);

					if (blob_url) {
						// Clear the textContent to free up memory
						script.textContent = "";
						// Add blob URL as attribute for reference
						script.setAttribute("blob", blob_url);
					}
				});

				// Create import map with all blob URLs
				const imports = {};
				blob_urls.forEach((url, name) => {
					imports[name] = url;
				});

				const import_map = document.createElement("script");
				import_map.type = "importmap";
				import_map.textContent = JSON.stringify({ imports }, null, 2);
				document.head.appendChild(import_map);

				// Run the main module if it exists and is not disabled
				if (blob_modules.has("main")) {
					setTimeout(() => {
						const main_script = document.createElement("script");
						main_script.type = "module";
						main_script.setAttribute("entrypoint", "");
						main_script.textContent = `
						const main_start_time = performance.now();
						const load_duration = main_start_time - ${load_start_time};
						console.log(\`Main module started \${load_duration.toFixed(2)}ms after page load\`);
						import("main");
					`;
						document.head.appendChild(main_script);
					}, 0);
				}

				// Expose blob module metadata map
				window.__blob_module_map__ = new Map();

				// Populate the metadata map (including disabled modules for reference)
				blob_scripts.forEach((script) => {
					const module_name = script.getAttribute("name");
					const remote_url = script.getAttribute("remote") || null;
					const is_disabled = script.hasAttribute("disabled");
					const blob_url = blob_urls.get(module_name) || null;
					const content = blob_modules.get(module_name) || "";

					// Calculate source size in bytes
					const src_bytes = new Blob([content]).size;

					const metadata = {
						module_name,
						src_bytes,
						remote_url,
						blob_url,
						is_disabled,
					};

					window.__blob_module_map__.set(module_name, metadata);
				});

				//
				// Editable HTML Export
				//

				window.downloadHtmlFile = function () {
					// Clone the current document
					const doc_clone = document.cloneNode(true);

					// Remove the importmap script we added
					const import_map_script = doc_clone.querySelector('script[type="importmap"]');
					if (import_map_script) {
						import_map_script.remove();
					}

					// Remove the main execution script we added
					const main_execution_script = doc_clone.querySelector("script[entrypoint]");
					if (main_execution_script) {
						main_execution_script.remove();
					}

					// Process blob-module scripts
					const cloned_blob_scripts = doc_clone.querySelectorAll('script[type="blob-module"]');
					cloned_blob_scripts.forEach((script) => {
						const module_name = script.getAttribute("name");
						const remote_url = script.getAttribute("remote");
						const no_download = script.hasAttribute("nodownload");
						const is_disabled = script.hasAttribute("disabled");

						// Remove blob attribute if it exists
						if (script.hasAttribute("blob")) {
							script.removeAttribute("blob");
						}

						// Skip processing content for disabled modules
						if (is_disabled) {
							return;
						}

						// Get the module content
						const module_content = blob_modules.get(module_name);

						// Check for nodownload modules
						if (module_content && !no_download) {
							script.textContent = module_content;
						} else if (no_download) {
							// Keep the remote URL but clear any local content
							script.textContent = "";
						}
					});

					// Process remote styles
					const original_style_tags = doc_clone.querySelectorAll("style[remote]");
					original_style_tags.forEach((style) => {
						const remote_url = style.getAttribute("remote");
						const no_download = style.hasAttribute("nodownload");

						if (no_download) {
							// Keep empty with just the remote attribute
							style.textContent = "";
						} else {
							// Get the style content and inline it
							const style_content = blob_styles.get(remote_url);
							if (style_content) {
								style.textContent = style_content;
							}
						}
					});

					// Remove the blob link elements we created
					const blob_links = doc_clone.querySelectorAll('link[href^="blob:"]');
					blob_links.forEach((link) => link.remove());

					// Get the full HTML
					const html_content = `<!DOCTYPE html>\n${doc_clone.documentElement.outerHTML}`;

					// Create and trigger download
					const blob = new Blob([html_content], { type: "text/html" });
					const url = URL.createObjectURL(blob);

					const download_link = document.createElement("a");
					download_link.href = url;
					download_link.download = "index.html";
					download_link.click();

					// Clean up the blob URL
					URL.revokeObjectURL(url);

					console.log("HTML file download initiated");
				};
			});
		</script>

		<!-- Main Entry -->
		<script type="blob-module" name="main">
			import { showModuleEditor } from "module-editor";
			import { useTags } from "ima";

			showModuleEditor();
		</script>

		<!-- Tools -->
		<script type="blob-module" name="utils" remote="./lib/utils.js"></script>
		<script type="blob-module" name="ima" remote="./lib/ima.0.6.1.js"></script>

		<!-- Module Editor -->
		<script type="blob-module" name="acorn" remote="./lib/acorn.js"></script>
		<script type="blob-module" name="astring" remote="./lib/astring.js"></script>
		<script type="blob-module" name="astravel" remote="./lib/astravel.js"></script>
		<script type="blob-module" name="formatter" remote="./lib/formatter.js"></script>
		<script type="blob-module" name="hljs" remote="./lib/hljs/hl.min.js"></script>
		<script type="blob-module" name="codepad" remote="./lib/codepad.js"></script>
		<script type="blob-module" name="module-editor" remote="./lib/module-editor.js"></script>
		<script type="application/json+module-editor-map">
			[
				{
					"id": "some-id",
					"module-ref": "ima",
					"style": "left: 0; position: absolute;",
					"data": ""
				}
			]
		</script>

		<!-- Tooling (disabled) -->
		<script
			type="blob-module"
			name="tsc"
			remote="file:///Users/fernando/repos/om/user/spaces/blank/tsc.js"
			disabled
			nodownload
		></script>
		<script
			type="blob-module"
			name="assemblyscript"
			remote="https://cdn.jsdelivr.net/npm/assemblyscript@0.28.4/dist/assemblyscript.js"
			disabled
			nodownload
		></script>
		<script
			type="blob-module"
			name="asc"
			remote="https://cdn.jsdelivr.net/npm/assemblyscript@0.28.4/dist/asc.js"
			disabled
			nodownload
		></script>
		<script
			type="blob-module"
			name="binaryen"
			remote="https://cdn.jsdelivr.net/npm/binaryen@123.0.0-nightly.20250530/index.js"
			disabled
			nodownload
		></script>
		<script
			type="blob-module"
			name="long"
			remote="https://cdn.jsdelivr.net/npm/long@5.2.4/index.js"
			disabled
			nodownload
		></script>
	</head>
	<body></body>
</html>
