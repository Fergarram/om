<!doctype html>
<html>
	<head>
		<meta charset="UTF-8" />
		<!-- Browser Support -->
		<!--
			Determining browser support is hard.
			LLMs are useful for this task.
			I wonder how much would it cost to implement a browser support API that uses an LLM.
			Or even using a local one.
		-->
		<script type="application/json+browser-support">
			{
				"html+css": {
					"chrome": "29 (2013)",
					"firefox": "28 (2014)",
					"safari": "9 (2015)",
					"min": "2013",
					"max": "2015"
				},
				"javascript": {
					"chrome": "89 (2021)",
					"firefox": "108 (2022)",
					"safari": "16.4 (2023)",
					"min": "2021",
					"max": "2023"
				}
			}
		</script>

		<!-- Typescript Compiler -->
		<script src="./tsc.js"></script>

		<!-- Blob Module Handler -->
		<script>
			window.addEventListener("load", async () => {
				const load_start_time = performance.now();
				const blob_modules = new Map();
				const blob_urls = new Map();
				const remote_modules = new Map();

				//
				// Content Hashing Utility
				//

				async function hashContent(content) {
					const encoder = new TextEncoder();
					const data = encoder.encode(content);
					const hashBuffer = await crypto.subtle.digest("SHA-256", data);
					const hashArray = Array.from(new Uint8Array(hashBuffer));
					return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
				}

				//
				// Transpilation Cache
				//

				function openTranspilationCache() {
					return new Promise((resolve, reject) => {
						const request = indexedDB.open("transpilation_cache", 1);

						request.onerror = () => reject(request.error);
						request.onsuccess = () => resolve(request.result);

						request.onupgradeneeded = (event) => {
							const db = event.target.result;
							if (!db.objectStoreNames.contains("transpiled")) {
								const store = db.createObjectStore("transpiled", { keyPath: "key" });
								store.createIndex("timestamp", "timestamp", { unique: false });
								store.createIndex("module_name", "module_name", { unique: false });
							}
						};
					});
				}

				async function getCachedTranspilation(module_name, source_hash, lang) {
					try {
						const db = await openTranspilationCache();
						const transaction = db.transaction(["transpiled"], "readonly");
						const store = transaction.objectStore("transpiled");
						const key = `${module_name}:${lang}:${source_hash}`;

						return new Promise((resolve, reject) => {
							const request = store.get(key);
							request.onerror = () => reject(request.error);
							request.onsuccess = () => resolve(request.result);
						});
					} catch (error) {
						console.warn("Failed to get cached transpilation:", error);
						return null;
					}
				}

				async function setCachedTranspilation(module_name, source_hash, lang, source_content, transpiled_content) {
					try {
						const db = await openTranspilationCache();
						const transaction = db.transaction(["transpiled"], "readwrite");
						const store = transaction.objectStore("transpiled");
						const key = `${module_name}:${lang}:${source_hash}`;

						const cache_entry = {
							key: key,
							module_name: module_name,
							lang: lang,
							source_hash: source_hash,
							source_content: source_content,
							transpiled_content: transpiled_content,
							timestamp: Date.now(),
						};

						return new Promise((resolve, reject) => {
							const request = store.put(cache_entry);
							request.onerror = () => reject(request.error);
							request.onsuccess = () => resolve();
						});
					} catch (error) {
						console.warn("Failed to cache transpilation:", error);
					}
				}

				// Cache busting function for transpilation cache
				window.clearTranspilationCache = async function (module_name = null) {
					try {
						const db = await openTranspilationCache();
						const transaction = db.transaction(["transpiled"], "readwrite");
						const store = transaction.objectStore("transpiled");

						return new Promise((resolve, reject) => {
							if (module_name) {
								// Clear all entries for a specific module
								const index = store.index("module_name");
								const request = index.openCursor(IDBKeyRange.only(module_name));

								request.onsuccess = (event) => {
									const cursor = event.target.result;
									if (cursor) {
										cursor.delete();
										cursor.continue();
									} else {
										console.log(`Cleared transpilation cache for module: ${module_name}`);
										resolve();
									}
								};
								request.onerror = () => reject(request.error);
							} else {
								// Clear all cached transpilations
								const request = store.clear();
								request.onsuccess = () => {
									console.log("Cleared all transpilation cache");
									resolve();
								};
								request.onerror = () => reject(request.error);
							}
						});
					} catch (error) {
						console.warn("Failed to clear transpilation cache:", error);
					}
				};

				//
				// Language Processing
				//

				function isTypeScriptSupported() {
					return (
						typeof window.std !== "undefined" &&
						typeof window.std.typescript !== "undefined" &&
						typeof window.std.typescript.transpile === "function"
					);
				}

				function transpileTypeScript(content, module_name) {
					if (!isTypeScriptSupported()) {
						throw new Error(`TypeScript compiler not available. Cannot transpile module "${module_name}"`);
					}

					try {
						const result = window.std.typescript.transpile(content, {
							target: window.std.typescript.ScriptTarget.ES2020,
							module: window.std.typescript.ModuleKind.ES2020,
							moduleResolution: window.std.typescript.ModuleResolutionKind.Bundler,
							allowImportingTsExtensions: false,
							noEmitOnError: false,
							noImplicitAny: false,
							removeComments: false,
							sourceMap: false,
						});

						console.log(`Successfully transpiled TypeScript module "${module_name}"`);
						return result;
					} catch (error) {
						console.error(`Failed to transpile TypeScript module "${module_name}":`, error);
						throw error;
					}
				}

				async function processModuleByLanguage(content, lang, module_name) {
					if (!lang || lang === "javascript" || lang === "js") {
						return content; // No processing needed for JavaScript
					}

					if (lang === "typescript" || lang === "ts") {
						// Check cache first
						const source_hash = await hashContent(content);
						const cached_transpilation = await getCachedTranspilation(module_name, source_hash, lang);

						if (cached_transpilation) {
							console.log(`Using cached transpilation for module "${module_name}"`);
							return cached_transpilation.transpiled_content;
						}

						// Transpile and cache
						console.log(`Transpiling TypeScript module "${module_name}"`);
						const transpiled_content = transpileTypeScript(content, module_name);

						// Cache the transpilation
						await setCachedTranspilation(module_name, source_hash, lang, content, transpiled_content);
						console.log(`Cached transpilation for module "${module_name}"`);

						return transpiled_content;
					}

					console.warn(`Unsupported language "${lang}" for module "${module_name}". Treating as JavaScript.`);
					return content;
				}

				//
				// Remote Blob Module Cache
				//

				function openCache() {
					return new Promise((resolve, reject) => {
						const request = indexedDB.open("blob_module_cache", 1);

						request.onerror = () => reject(request.error);
						request.onsuccess = () => resolve(request.result);

						request.onupgradeneeded = (event) => {
							const db = event.target.result;
							if (!db.objectStoreNames.contains("modules")) {
								const store = db.createObjectStore("modules", { keyPath: "url" });
								store.createIndex("timestamp", "timestamp", { unique: false });
							}
						};
					});
				}

				async function getCachedModule(url) {
					try {
						const db = await openCache();
						const transaction = db.transaction(["modules"], "readonly");
						const store = transaction.objectStore("modules");

						return new Promise((resolve, reject) => {
							const request = store.get(url);
							request.onerror = () => reject(request.error);
							request.onsuccess = () => resolve(request.result);
						});
					} catch (error) {
						console.warn("Failed to get cached module:", error);
						return null;
					}
				}

				async function setCachedModule(url, content) {
					try {
						const db = await openCache();
						const transaction = db.transaction(["modules"], "readwrite");
						const store = transaction.objectStore("modules");

						const cache_entry = {
							url: url,
							content: content,
							timestamp: Date.now(),
						};

						return new Promise((resolve, reject) => {
							const request = store.put(cache_entry);
							request.onerror = () => reject(request.error);
							request.onsuccess = () => resolve();
						});
					} catch (error) {
						console.warn("Failed to cache module:", error);
					}
				}

				// Cache busting function - exposing globally
				window.clearBlobModuleCache = async function (url = null) {
					try {
						const db = await openCache();
						const transaction = db.transaction(["modules"], "readwrite");
						const store = transaction.objectStore("modules");

						return new Promise((resolve, reject) => {
							let request;

							if (url) {
								// Clear specific URL
								request = store.delete(url);
								request.onsuccess = () => {
									console.log(`Cleared cache for: ${url}`);
									resolve();
								};
							} else {
								// Clear all cached modules
								request = store.clear();
								request.onsuccess = () => {
									console.log("Cleared all blob module cache");
									resolve();
								};
							}

							request.onerror = () => reject(request.error);
						});
					} catch (error) {
						console.warn("Failed to clear cache:", error);
					}
				};

				//
				// Blob Module Processing
				//

				const blob_scripts = document.querySelectorAll('script[type="blob-module"]');

				// First pass: collect all module contents and remote URLs
				for (const script of blob_scripts) {
					const module_name = script.getAttribute("name");
					const remote_url = script.getAttribute("remote");
					const lang = script.getAttribute("lang");

					if (!module_name) {
						console.warn("blob-module script missing name attribute");
						continue;
					}

					// Check for name collisions
					if (blob_modules.has(module_name) || remote_modules.has(module_name)) {
						console.warn(`Module name collision detected: "${module_name}" already exists. Skipping duplicate.`);
						continue;
					}

					const content = script.textContent.trim();

					if (remote_url) {
						if (!content) {
							// Empty content with remote URL - fetch remote
							remote_modules.set(module_name, { url: remote_url, lang });
							continue;
						} else {
							// Both remote and content exist - store local, compare later
							try {
								const processed_content = await processModuleByLanguage(content, lang, module_name);
								blob_modules.set(module_name, processed_content);
								remote_modules.set(module_name, { url: remote_url, lang });
								continue;
							} catch (error) {
								console.error(`Failed to process local module "${module_name}":`, error);
								continue;
							}
						}
					}

					// No remote URL, just process and store content
					try {
						const processed_content = await processModuleByLanguage(content, lang, module_name);
						blob_modules.set(module_name, processed_content);
					} catch (error) {
						console.error(`Failed to process module "${module_name}":`, error);
					}
				}

				// Fetch remote modules (with caching) and create local copies before proceeding
				for (const [module_name, remote_info] of remote_modules) {
					try {
						const { url: remote_url, lang } = remote_info;

						// Check cache first
						const cached_module = await getCachedModule(remote_url);
						let remote_content;

						if (cached_module) {
							console.log(`Using cached module "${module_name}" from ${remote_url}`);
							remote_content = cached_module.content;
						} else {
							console.log(`Fetching remote module "${module_name}" from ${remote_url}`);
							const response = await fetch(remote_url);
							remote_content = await response.text();

							// Cache the fetched content
							await setCachedModule(remote_url, remote_content);
							console.log(`Cached remote module "${module_name}"`);
						}

						// Process the remote content based on language
						let processed_remote_content;
						try {
							processed_remote_content = await processModuleByLanguage(remote_content, lang, module_name);
						} catch (error) {
							console.error(`Failed to process remote module "${module_name}":`, error);
							continue;
						}

						if (blob_modules.has(module_name)) {
							// Compare with existing local content
							// @TODO: Minify and compare minified content instead
							const local_content = blob_modules.get(module_name);
							if (processed_remote_content.trim() !== local_content.trim()) {
								console.warn(
									`Remote and local content are different for module "${module_name}". Using local content.`,
								);
							}
							// Keep local content
						} else {
							// No local content, use processed remote content
							blob_modules.set(module_name, processed_remote_content);
							console.log(`Successfully loaded remote module "${module_name}"`);
						}
					} catch (error) {
						console.warn(`Failed to fetch remote module "${module_name}":`, error);
						if (!blob_modules.has(module_name)) {
							// Use remote URL directly in importmap
							blob_urls.set(module_name, remote_info.url);
							console.log(`Will use remote URL directly for module "${module_name}"`);
						} else if (blob_modules.has(module_name)) {
							console.log(`Using local module "${module_name}"`);
						}
					}
				}

				// Create blob URLs for all modules
				blob_modules.forEach((content, module_name) => {
					const module_blob = new Blob([content], { type: "text/javascript" });
					const blob_url = URL.createObjectURL(module_blob);
					blob_urls.set(module_name, blob_url);
				});

				// Clear script tag contents and add blob URL attributes
				blob_scripts.forEach((script) => {
					const module_name = script.getAttribute("name");
					const blob_url = blob_urls.get(module_name);

					if (blob_url) {
						// Clear the textContent to free up memory
						script.textContent = "";
						// Add blob URL as attribute for reference
						script.setAttribute("blob", blob_url);
					}
				});

				// Create import map with all blob URLs
				const imports = {};
				blob_urls.forEach((url, name) => {
					imports[name] = url;
				});

				const import_map = document.createElement("script");
				import_map.type = "importmap";
				import_map.textContent = JSON.stringify({ imports }, null, 2);
				document.head.appendChild(import_map);

				// Run the main module if it exists
				if (blob_modules.has("main")) {
					setTimeout(() => {
						const main_script = document.createElement("script");
						main_script.type = "module";
						main_script.setAttribute("entrypoint", "");
						main_script.textContent = `
							const main_start_time = performance.now();
							const load_duration = main_start_time - ${load_start_time};
							console.log(\`Main module started \${load_duration.toFixed(2)}ms after page load\`);
							import("main");
						`;
						document.head.appendChild(main_script);
					}, 0);
				}

				// Expose blob module metadata map
				window.__blob_module_map__ = new Map();

				// Populate the metadata map
				blob_scripts.forEach((script) => {
					const module_name = script.getAttribute("name");
					const remote_url = script.getAttribute("remote") || null;
					const lang = script.getAttribute("lang") || "javascript";
					const blob_url = blob_urls.get(module_name) || null;
					const content = blob_modules.get(module_name) || "";

					// Calculate source size in bytes
					const src_bytes = new Blob([content]).size;

					const metadata = {
						module_name,
						src_bytes,
						remote_url,
						blob_url,
						lang,
					};

					window.__blob_module_map__.set(module_name, metadata);
				});

				//
				// Editable HTML Export
				//

				window.downloadHtmlFile = function () {
					// Clone the current document
					const doc_clone = document.cloneNode(true);

					// Remove the importmap script we added
					const import_map_script = doc_clone.querySelector('script[type="importmap"]');
					if (import_map_script) {
						import_map_script.remove();
					}

					// Remove the main execution script we added
					const main_execution_script = doc_clone.querySelector("script[entrypoint]");
					main_execution_script.remove();

					// Process blob-module scripts
					const cloned_blob_scripts = doc_clone.querySelectorAll('script[type="blob-module"]');

					cloned_blob_scripts.forEach((script) => {
						const module_name = script.getAttribute("name");
						const remote_url = script.getAttribute("remote");
						const no_download = script.hasAttribute("nodownload");
						const lang = script.getAttribute("lang");

						// Remove blob attribute if it exists
						if (script.hasAttribute("blob")) {
							script.removeAttribute("blob");
						}

						// Get the original module content (before processing)
						const original_content = blob_modules.get(module_name);

						// For download, we want to preserve the original source code
						// Find the original script element to get unprocessed content
						const original_script = Array.from(document.querySelectorAll('script[type="blob-module"]')).find(
							(s) => s.getAttribute("name") === module_name,
						);

						// Check for nodownload modules
						if (original_script && !no_download) {
							// Use original unprocessed content for download
							const original_text = original_script.textContent.trim();
							if (original_text) {
								script.textContent = original_text;
							} else if (original_content) {
								// Fallback to processed content if original is empty
								script.textContent = original_content;
							}
						} else if (no_download) {
							// Keep the remote URL but clear any local content
							script.textContent = "";
						}
					});

					// Get the full HTML
					const html_content = `<!DOCTYPE html>\n${doc_clone.documentElement.outerHTML}`;

					// Create and trigger download
					const blob = new Blob([html_content], { type: "text/html" });
					const url = URL.createObjectURL(blob);

					const download_link = document.createElement("a");
					download_link.href = url;
					download_link.download = "index.html";
					download_link.click();

					// Clean up the blob URL
					URL.revokeObjectURL(url);

					console.log("HTML file download initiated");
				};
			});
		</script>

		<!-- Main Entry -->
		<script type="blob-module" name="main" lang="typescript">
			import { sayHello } from "@/some/module";
			import { useTags } from "ima";
			const { canvas, div } = useTags();

			// Create a 32x32 canvas for the cursor
			const cursor_canvas = canvas({
				width: 32,
				height: 32,
				style: "display: none;", // Hide the canvas since we only need its data
			}) as HTMLCanvasElement;

			document.body.appendChild(cursor_canvas);

			const ctx: CanvasRenderingContext2D = cursor_canvas.getContext("2d")!;
			let frame: number = 0;

			function drawCursor(): void {
				// Clear canvas
				ctx.clearRect(0, 0, 32, 32);

				// Animate the cursor shape - a pulsing circle
				const pulse: number = Math.sin(frame * 0.1) * 0.3 + 0.7; // oscillate between 0.4 and 1.0
				const radius: number = 8 * pulse;

				// Draw cursor shape
				ctx.fillStyle = "#ffffff";
				ctx.strokeStyle = "#000000";
				ctx.lineWidth = 2;

				// Draw a circle at center
				ctx.beginPath();
				ctx.arc(16, 16, radius, 0, Math.PI * 2);
				ctx.fill();
				ctx.stroke();

				// Convert canvas to base64 data URL
				const data_url: string = cursor_canvas.toDataURL("image/png");

				// Set as cursor
				document.body.style.willChange = "cursor";
				document.body.style.cursor = `url(${data_url}) 16 16, auto`;

				frame++;
				requestAnimationFrame(drawCursor);
			}

			// Start the animation
			drawCursor();

			const content = div(
				{
					style: `
					display: flex;
					flex-direction: column;
					align-items: center;
					justify-content: center;
					height: 100vh;
					color: white;
					background: #222;
					font-family: monospace;
					font-size: 18px;
					gap: 10px;
				`,
				},
				[
					"Move your cursor around!",
				],
			);

			document.body.replaceChildren(content);

			console.log(sayHello("TypeScript World"));
		</script>

		<!-- Local Modules -->
		<script type="blob-module" name="@/some/module" lang="typescript">
			export function sayHello(name: string): string {
				return `Hello, ${name}!`;
			}

			export function formatMessage(message: string, author: string = "Anonymous"): string {
				return `[${author}]: ${message}`;
			}

			export interface Config {
				debug: boolean;
				version: string;
			}

			export const config: Config = {
				debug: true,
				version: "1.0.0",
			};
		</script>

		<!-- Remote Modules -->
		<script type="blob-module" name="ima" remote="https://cdn.jsdelivr.net/gh/Fergarram/ima@main/ima-0.6.0.esm.js"></script>
		<!-- local url reference works -->
		<!--<script type="blob-module" name="ima" remote="./ima.js"></script>-->
		<!--
		<script
			type="blob-module"
			name="assemblyscript"
			remote="https://cdn.jsdelivr.net/npm/assemblyscript@0.28.4/dist/assemblyscript.js"
			nodownload
		></script>
		<script
			type="blob-module"
			name="asc"
			remote="https://cdn.jsdelivr.net/npm/assemblyscript@0.28.4/dist/asc.js"
			nodownload
		></script>
		<script
			type="blob-module"
			name="binaryen"
			remote="https://cdn.jsdelivr.net/npm/binaryen@123.0.0-nightly.20250530/index.js"
			nodownload
		></script>
		<script type="blob-module" name="long" remote="https://cdn.jsdelivr.net/npm/long@5.2.4/index.js" nodownload></script> -->
	</head>
	<body></body>
</html>
