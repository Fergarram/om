<!DOCTYPE html>
<html><head>
		<meta charset="UTF-8">
		<meta copy="3">

		<!-- Browser Support -->
		<!--
			Determining browser support is hard.
			LLMs are useful for this task.
			I wonder how much would it cost to implement a browser support API that uses an LLM.
			Or even using a local one.
		-->
		<script type="application/json+browser-support">
			{
				"html+css": {
					"chrome": "29 (2013)",
					"firefox": "28 (2014)",
					"safari": "9 (2015)",
					"min": "2013",
					"max": "2015"
				},
				"javascript": {
					"chrome": "89 (2021)",
					"firefox": "108 (2022)",
					"safari": "16.4 (2023)",
					"min": "2021",
					"max": "2023"
				}
			}
		</script>

		<!-- Style reset and vars -->
		<style name="base">
			:root {
				--font-default: "Inter", sans-serif;
				--font-monospace: "Departure Mono", monospace;
			}

			/*
			  1. Prevent padding and border from affecting element width.
			  2. Remove default margins and padding
			  3. Reset all borders.
			*/

			*,
			::after,
			::before {
				box-sizing: border-box; /* 1 */
				margin: 0; /* 2 */
				padding: 0; /* 2 */
				border: 0 solid; /* 3 */
			}

			/*
			  1. Use a consistent sensible line-height in all browsers.
			  2. Prevent adjustments of font size after orientation changes in iOS.
			  3. Use a more readable tab size.
			  4. Use system font stack.
			  5. Disable tap highlights on iOS.
			*/

			html {
				line-height: 1.5; /* 1 */
				-webkit-text-size-adjust: 100%; /* 2 */
				tab-size: 4; /* 3 */
				font-family: var(--font-default); /* 4 */
				-webkit-tap-highlight-color: transparent; /* 5 */
			}

			/*
			  1. Add the correct height in Firefox.
			  2. Correct the inheritance of border color in Firefox.
			  3. Reset the default border style to a 1px solid border.
			*/

			hr {
				height: 0; /* 1 */
				color: inherit; /* 2 */
				border-top-width: 1px; /* 3 */
			}

			/*
			  Add the correct text decoration in Chrome, Edge, and Safari.
			*/

			abbr[title] {
				-webkit-text-decoration: underline dotted;
				text-decoration: underline dotted;
			}

			/*
			  Remove the default font size and weight for headings.
			*/

			h1,
			h2,
			h3,
			h4,
			h5,
			h6 {
				font-size: inherit;
				font-weight: inherit;
			}

			/*
			  Reset links to optimize for opt-in styling instead of opt-out.
			*/

			a {
				color: inherit;
				text-decoration: inherit;
			}

			/*
			  Add the correct font weight in Edge and Safari.
			*/

			b,
			strong {
				font-weight: bolder;
			}

			/*
			  1. Use monospace font family.
			  2. Correct the odd `em` font sizing in all browsers.
			*/

			code,
			kbd,
			samp,
			pre {
				font-family: var(--font-monospace); /* 1 */
				font-size: 1em; /* 2 */
			}

			/*
			  Add the correct font size in all browsers.
			*/

			small {
				font-size: 80%;
			}

			/*
			  Prevent `sub` and `sup` elements from affecting the line height in all browsers.
			*/

			sub,
			sup {
				font-size: 75%;
				line-height: 0;
				position: relative;
				vertical-align: baseline;
			}

			sub {
				bottom: -0.25em;
			}

			sup {
				top: -0.5em;
			}

			/*
			  1. Remove text indentation from table contents in Chrome and Safari.
			  2. Correct table border color inheritance in all Chrome and Safari.
			  3. Remove gaps between table borders by default.
			*/

			table {
				text-indent: 0; /* 1 */
				border-color: inherit; /* 2 */
				border-collapse: collapse; /* 3 */
			}

			/*
			  Use the modern Firefox focus style for all focusable elements.
			*/

			/*:-moz-focusring {
				outline: auto;
			}*/

			/*
			  Add the correct vertical alignment in Chrome and Firefox.
			*/

			progress {
				vertical-align: baseline;
			}

			/*
			  Add the correct display in Chrome and Safari.
			*/

			summary {
				display: list-item;
			}

			/*
			  Make lists unstyled by default.
			*/

			ol,
			ul,
			menu {
				list-style: none;
			}

			/*
			  1. Make replaced elements `display: block` by default.
			  2. Add `vertical-align: middle` to align replaced elements more sensibly by default.
			*/

			img,
			svg,
			video,
			canvas,
			audio,
			iframe,
			embed,
			object {
				display: block; /* 1 */
				vertical-align: middle; /* 2 */
			}

			/*
			  Constrain images and videos to the parent width and preserve their intrinsic aspect ratio.
			*/

			img,
			video {
				max-width: 100%;
				height: auto;
			}

			/*
			  1. Inherit font styles in all browsers.
			  2. Remove border radius in all browsers.
			  3. Remove background color in all browsers.
			*/

			button,
			input,
			select,
			optgroup,
			textarea {
				font-family: inherit; /* 1 */
				font-size: inherit; /* 1 */
				font-weight: inherit; /* 1 */
				line-height: inherit; /* 1 */
				color: inherit; /* 1 */
				border-radius: 0; /* 2 */
				background-color: transparent; /* 3 */
				text-align: left;
			}

			/*
			  Reset the default placeholder opacity in Firefox.
			*/

			::placeholder {
				opacity: 1;
				color: #9ca3af;
			}

			/*
			  Prevent resizing textareas horizontally by default.
			*/

			textarea {
				resize: vertical;
			}

			/*
			  Remove the inner padding in Chrome and Safari on macOS.
			*/

			::-webkit-search-decoration {
				-webkit-appearance: none;
			}

			/*
			  Remove excess padding from pseudo-elements in date/time inputs.
			*/

			::-webkit-datetime-edit,
			::-webkit-datetime-edit-year-field,
			::-webkit-datetime-edit-month-field,
			::-webkit-datetime-edit-day-field,
			::-webkit-datetime-edit-hour-field,
			::-webkit-datetime-edit-minute-field,
			::-webkit-datetime-edit-second-field,
			::-webkit-datetime-edit-millisecond-field,
			::-webkit-datetime-edit-meridiem-field {
				padding: 0;
			}

			/*
			  Remove the additional `:invalid` styles in Firefox.
			*/

			/*:-moz-ui-invalid {
				box-shadow: none;
			}*/

			/*
			  Correct the inability to style the border radius in iOS Safari.
			*/

			button,
			input[type="button"],
			input[type="reset"],
			input[type="submit"] {
				-webkit-appearance: button;
			}

			/*
			  Correct the cursor style of increment and decrement buttons in Safari.
			*/

			::-webkit-inner-spin-button,
			::-webkit-outer-spin-button {
				height: auto;
			}

			/*
			  Make elements with the HTML hidden attribute stay hidden by default.
			*/

			[hidden] {
				display: none !important;
			}
		</style>

		<!-- Blob Module Loader -->
		<script id="module-loader">window.__blob_module_loader_settings__ = {
	prefers_remote_modules: true,
};

window.addEventListener("load", async () => {
	const load_start_time = performance.now();
	const blob_urls = new Map();
	const remote_modules = new Map();

	window.__blob_modules__ = new Map();

	//
	// Remote Blob Module Cache
	//

	function openCache() {
		return new Promise((resolve, reject) => {
			const request = indexedDB.open("blob_module_cache", 1);

			request.onerror = () => reject(request.error);
			request.onsuccess = () => resolve(request.result);

			request.onupgradeneeded = (event) => {
				const db = event.target.result;
				if (!db.objectStoreNames.contains("modules")) {
					const store = db.createObjectStore("modules", {
						keyPath: "url"
					});
					store.createIndex("timestamp", "timestamp", {
						unique: false
					});
				}
			};
		});
	}

	window.getCachedModule = async function(url) {
		try {
			const db = await openCache();
			const transaction = db.transaction(["modules"], "readonly");
			const store = transaction.objectStore("modules");

			return new Promise((resolve, reject) => {
				const request = store.get(url);
				request.onerror = () => reject(request.error);
				request.onsuccess = () => resolve(request.result);
			});
		} catch (error) {
			console.warn("Failed to get cached module:", error);
			return null;
		}
	};

	window.setCachedModule = async function(url, content) {
		try {
			const db = await openCache();
			const transaction = db.transaction(["modules"], "readwrite");
			const store = transaction.objectStore("modules");

			const cache_entry = {
				url: url,
				content: content,
				timestamp: Date.now(),
			};

			return new Promise((resolve, reject) => {
				const request = store.put(cache_entry);
				request.onerror = () => reject(request.error);
				request.onsuccess = () => resolve();
			});
		} catch (error) {
			console.warn("Failed to cache module:", error);
		}
	};

	// Cache busting function - exposing globally
	window.clearBlobModuleCache = async function(url = null) {
		try {
			const db = await openCache();
			const transaction = db.transaction(["modules"], "readwrite");
			const store = transaction.objectStore("modules");

			return new Promise((resolve, reject) => {
				let request;

				if (url) {
					// Clear specific URL
					request = store.delete(url);
					request.onsuccess = () => {
						console.log(`Cleared cache for: ${url}`);
						resolve();
					};
				} else {
					// Clear all cached modules
					request = store.clear();
					request.onsuccess = () => {
						console.log("Cleared all blob module cache");
						resolve();
					};
				}

				request.onerror = () => reject(request.error);
			});
		} catch (error) {
			console.warn("Failed to clear cache:", error);
		}
	};

	//
	// Blob Style Processing
	//

	const blob_styles = new Map();
	const blob_style_urls = new Map();
	const remote_styles = new Map();

	const style_tags = document.querySelectorAll("style[remote]");

	// First pass: collect all style contents and remote URLs
	style_tags.forEach((style) => {
		const remote_url = style.getAttribute("remote");
		const style_id = remote_url; // Use URL as identifier since styles don't have names

		if (!remote_url) {
			console.warn("style tag missing remote attribute");
			return;
		}

		// Check for name collisions
		if (blob_styles.has(style_id) || remote_styles.has(style_id)) {
			console.warn(`Style URL collision detected: "${style_id}" already exists. Skipping duplicate.`);
			return;
		}

		const content = style.textContent.trim();

		if (!content) {
			// Empty content with remote URL - fetch remote
			remote_styles.set(style_id, remote_url);
			return;
		} else {
			// Both remote and content exist - store local, compare later
			blob_styles.set(style_id, content);
			remote_styles.set(style_id, remote_url);
			return;
		}
	});

	// Fetch remote styles (with caching) and create local copies before proceeding
	for (const [style_id, remote_url] of remote_styles) {
		try {
			let remote_content;

			if (__blob_module_loader_settings__.prefers_remote_modules) {
				// Auto-update mode: fetch from remote first, fallback to cache
				try {
					console.log(`Fetching remote style from ${remote_url} (auto-update mode)`);
					const response = await fetch(remote_url);
					remote_content = await response.text();

					// Update the cache with fresh content
					await setCachedModule(remote_url, remote_content);
					console.log(`Updated cache for remote style from ${remote_url}`);
				} catch (fetch_error) {
					console.warn(`Failed to fetch remote style from "${remote_url}", falling back to cache:`,
						fetch_error);

					// Fallback to cached version
					const cached_style = await getCachedModule(remote_url);
					if (cached_style) {
						console.log(`Using cached style from ${remote_url} as fallback`);
						remote_content = cached_style.content;
					} else {
						throw new Error("No cached version available");
					}
				}
			} else {
				// Cache-first mode: check cache first, then fetch remote if needed
				const cached_style = await getCachedModule(remote_url);

				if (cached_style) {
					console.log(`Using cached style from ${remote_url}`);
					remote_content = cached_style.content;
				} else {
					console.log(`Fetching remote style from ${remote_url}`);
					const response = await fetch(remote_url);
					remote_content = await response.text();

					// Cache the fetched content
					await setCachedModule(remote_url, remote_content);
					console.log(`Cached remote style from ${remote_url}`);
				}
			}

			if (blob_styles.has(style_id)) {
				// Compare with existing local content
				const local_content = blob_styles.get(style_id);
				if (remote_content.trim() !== local_content.trim()) {
					if (__blob_module_loader_settings__.prefers_remote_modules) {
						console.log(
							`Remote and local content differ for style "${remote_url}". Using remote content (auto-update mode).`,
						);
						blob_styles.set(style_id, remote_content); // Use remote content
					} else {
						console.warn(
							`Remote and local content are different for style "${remote_url}". Using local content.`,
						);
						// Keep local content (no change needed)
					}
				}
				// If content is the same, keep existing (local) content
			} else {
				// No local content, use fetched remote content
				blob_styles.set(style_id, remote_content);
				console.log(`Successfully loaded remote style from ${remote_url}`);
			}
		} catch (error) {
			console.warn(`Failed to fetch remote style from "${remote_url}":`, error);
			if (!blob_styles.has(style_id)) {
				console.log(`Will keep original remote reference for style "${remote_url}"`);
			} else if (blob_styles.has(style_id)) {
				console.log(`Using local style for "${remote_url}"`);
			}
		}
	}

	// Create blob URLs for all styles and update style tags
	blob_styles.forEach((content, style_id) => {
		const style_blob = new Blob([content], {
			type: "text/css"
		});
		const blob_url = URL.createObjectURL(style_blob);
		blob_style_urls.set(style_id, blob_url);

		// Find the corresponding style tag and update it
		const style_tag = Array.from(style_tags).find((tag) => tag.getAttribute("remote") === style_id);
		if (style_tag) {
			// Clear the content
			style_tag.textContent = "";

			// Create a new link element to load the CSS
			const link_element = document.createElement("link");
			link_element.rel = "stylesheet";
			link_element.href = blob_url;

			// Insert the link element after the style tag
			style_tag.parentNode.insertBefore(link_element, style_tag.nextSibling);

			console.log(`Created blob URL link for ${style_id}`);
		}
	});

	// Expose blob style metadata map
	window.__blob_style_map__ = new Map();

	// Populate the style metadata map
	blob_styles.forEach((content, style_id) => {
		const blob_url = blob_style_urls.get(style_id);
		const src_bytes = new Blob([content]).size;

		const metadata = {
			remote_url: style_id,
			src_bytes,
			blob_url,
		};

		window.__blob_style_map__.set(style_id, metadata);
	});

	//
	// Blob Module Processing
	//

	const blob_scripts = document.querySelectorAll('script[type="blob-module"]');

	// First pass: collect all module contents and remote URLs, skip disabled modules
	blob_scripts.forEach((script) => {
		const module_name = script.getAttribute("name");
		const remote_url = script.getAttribute("remote");
		const is_disabled = script.hasAttribute("disabled");

		if (!module_name) {
			console.warn("blob-module script missing name attribute");
			return;
		}

		// Skip disabled modules
		if (is_disabled) {
			console.log(`Skipping disabled module: "${module_name}"`);
			return;
		}

		// Check for name collisions
		if (__blob_modules__.has(module_name) || remote_modules.has(module_name)) {
			console.warn(
				`Module name collision detected: "${module_name}" already exists. Skipping duplicate.`);
			return;
		}

		// @TODO: We could minify or format here since this will be the source map from blobs
		const content = script.textContent.trim();

		if (remote_url) {
			if (!content) {
				// Empty content with remote URL - fetch remote
				remote_modules.set(module_name, remote_url);
				return;
			} else {
				// Both remote and content exist - store local, compare later
				__blob_modules__.set(module_name, content);
				remote_modules.set(module_name, remote_url);
				return;
			}
		}

		// No remote URL, just store content
		__blob_modules__.set(module_name, content);
	});

	// Fetch remote modules (with caching) and create local copies before proceeding
	for (const [module_name, remote_url] of remote_modules) {
		try {
			let remote_content;

			if (__blob_module_loader_settings__.prefers_remote_modules) {
				// Auto-update mode: fetch from remote first, fallback to cache
				try {
					console.log(`Fetching remote module "${module_name}" from ${remote_url} (auto-update mode)`);
					const response = await fetch(remote_url);
					remote_content = await response.text();

					// Update the cache with fresh content
					await setCachedModule(remote_url, remote_content);
					console.log(`Updated cache for remote module "${module_name}"`);
				} catch (fetch_error) {
					console.warn(`Failed to fetch remote module "${module_name}", falling back to cache:`,
						fetch_error);

					// Fallback to cached version
					const cached_module = await getCachedModule(remote_url);
					if (cached_module) {
						console.log(`Using cached module "${module_name}" as fallback`);
						remote_content = cached_module.content;
					} else {
						throw new Error("No cached version available");
					}
				}
			} else {
				// Cache-first mode: check cache first, then fetch remote if needed
				const cached_module = await getCachedModule(remote_url);

				if (cached_module) {
					console.log(`Using cached module "${module_name}" from ${remote_url}`);
					remote_content = cached_module.content;
				} else {
					console.log(`Fetching remote module "${module_name}" from ${remote_url}`);
					const response = await fetch(remote_url);
					remote_content = await response.text();

					// Cache the fetched content
					await setCachedModule(remote_url, remote_content);
					console.log(`Cached remote module "${module_name}"`);
				}
			}

			if (__blob_modules__.has(module_name)) {
				// Compare with existing local content
				const local_content = __blob_modules__.get(module_name);
				if (remote_content.trim() !== local_content.trim()) {
					if (__blob_module_loader_settings__.prefers_remote_modules) {
						console.log(
							`Remote and local content differ for module "${module_name}". Using remote content (auto-update mode).`,
						);
						__blob_modules__.set(module_name, remote_content); // Use remote content
					} else {
						console.warn(
							`Remote and local content are different for module "${module_name}". Using local content.`,
						);
						// Keep local content (no change needed)
					}
				}
				// If content is the same, keep existing (local) content
			} else {
				// No local content, use fetched remote content
				__blob_modules__.set(module_name, remote_content);
				console.log(`Successfully loaded remote module "${module_name}"`);
			}
		} catch (error) {
			console.warn(`Failed to fetch remote module "${module_name}":`, error);
			if (!__blob_modules__.has(module_name)) {
				// Use remote URL directly in importmap
				blob_urls.set(module_name, remote_url);
				console.log(`Will use remote URL directly for module "${module_name}"`);
			} else if (__blob_modules__.has(module_name)) {
				console.log(`Using local module "${module_name}"`);
			}
		}
	}

	// Create blob URLs for all modules
	__blob_modules__.forEach((content, module_name) => {
		const module_blob = new Blob([content], {
			type: "text/javascript"
		});
		const blob_url = URL.createObjectURL(module_blob);
		blob_urls.set(module_name, blob_url);
	});

	// Clear script tag contents and add blob URL attributes (only for non-disabled modules)
	blob_scripts.forEach((script) => {
		const module_name = script.getAttribute("name");
		const is_disabled = script.hasAttribute("disabled");

		// Skip disabled modules
		if (is_disabled) {
			return;
		}

		const blob_url = blob_urls.get(module_name);

		if (blob_url) {
			// Clear the textContent to free up memory
			script.textContent = "";
			// Add blob URL as attribute for reference
			script.setAttribute("blob", blob_url);
		}
	});

	// Create import map with all blob URLs
	const imports = {};
	blob_urls.forEach((url, name) => {
		imports[name] = url;
	});

	const import_map = document.createElement("script");
	import_map.type = "importmap";
	import_map.textContent = JSON.stringify({
		imports
	}, null, 2);
	document.head.appendChild(import_map);

	// Run the main module if it exists and is not disabled
	if (__blob_modules__.has("main")) {
		setTimeout(() => {
			const main_script = document.createElement("script");
			main_script.type = "module";
			main_script.setAttribute("entrypoint", "");
			main_script.textContent = `
						const main_start_time = performance.now();
						const load_duration = main_start_time - ${load_start_time};
						console.log(\`Main module started \${load_duration.toFixed(2)}ms after page load\`);
						import("main");
					`;
			document.head.appendChild(main_script);
		}, 0);
	}

	// Expose blob module metadata map
	window.__blob_module_map__ = new Map();

	// Populate the metadata map (including disabled modules for reference)
	blob_scripts.forEach((script) => {
		const module_name = script.getAttribute("name");
		const remote_url = script.getAttribute("remote") || null;
		const is_disabled = script.hasAttribute("disabled");
		const blob_url = blob_urls.get(module_name) || null;
		const content = __blob_modules__.get(module_name) || "";

		// Calculate source size in bytes
		const src_bytes = new Blob([content]).size;

		const metadata = {
			module_name,
			src_bytes,
			remote_url,
			blob_url,
			is_disabled,
		};

		window.__blob_module_map__.set(module_name, metadata);
	});

	//
	// Editable HTML Export
	//
	//

	window.getDocumentOuterHtml = function() {
		// Clone the current document
		const doc_clone = document.cloneNode(true);

		// Remove the importmap script we added
		const import_map_script = doc_clone.querySelector('script[type="importmap"]');
		if (import_map_script) {
			import_map_script.remove();
		}

		// Remove the main execution script we added
		const main_execution_script = doc_clone.querySelector("script[entrypoint]");
		if (main_execution_script) {
			main_execution_script.remove();
		}

		// Process blob-module scripts
		const cloned_blob_scripts = doc_clone.querySelectorAll('script[type="blob-module"]');
		cloned_blob_scripts.forEach((script) => {
			const module_name = script.getAttribute("name");
			const remote_url = script.getAttribute("remote");
			const no_download = script.hasAttribute("nodownload");
			const is_disabled = script.hasAttribute("disabled");

			// Remove blob attribute if it exists
			if (script.hasAttribute("blob")) {
				script.removeAttribute("blob");
			}

			// Skip processing content for disabled modules
			if (is_disabled) {
				return;
			}

			// Get the module content
			const module_content = __blob_modules__.get(module_name);

			// Check for nodownload modules
			if (module_content && !no_download) {
				script.textContent = module_content;
			} else if (no_download) {
				// Keep the remote URL but clear any local content
				script.textContent = "";
			}
		});

		// Process remote styles
		const original_style_tags = doc_clone.querySelectorAll("style[remote]");
		original_style_tags.forEach((style) => {
			const remote_url = style.getAttribute("remote");
			const no_download = style.hasAttribute("nodownload");

			if (no_download) {
				// Keep empty with just the remote attribute
				style.textContent = "";
			} else {
				// Get the style content and inline it
				const style_content = blob_styles.get(remote_url);
				if (style_content) {
					style.textContent = style_content;
				}
			}
		});

		// Remove the blob link elements we created
		const blob_links = doc_clone.querySelectorAll('link[href^="blob:"]');
		blob_links.forEach((link) => link.remove());

		// Get the full HTML
		return `<!DOCTYPE html>\n${doc_clone.documentElement.outerHTML}`;
	};

	window.saveHtmlFile = async function() {
		// Try to use Om sys function
		if (location.origin === "file://" && globalThis.__sys) {
			try {
				await __sys.invoke("file.write", location.pathname, getDocumentOuterHtml());
				return;
			} catch (error) {
				console.error("Failed to save HTML file using Om sys:", error);
			}
		}

		// Check if File System Access API is available
		if (window.showSaveFilePicker) {
			try {
				// Show save file picker
				const file_handle = await window.showSaveFilePicker({
					suggestedName: `${document.title || Date.now()}.html`,
					types: [{
						description: "HTML files",
						accept: {
							"text/html": [".html", ".htm"]
						},
					}, ],
				});

				const html_content = getDocumentOuterHtml();

				// Write to file
				const writable = await file_handle.createWritable();
				await writable.write(html_content);
				await writable.close();

				console.log("HTML file saved successfully");
				return;
			} catch (error) {
				if (error.name === "AbortError") {
					console.log("Save operation was cancelled by user");
					return;
				} else {
					console.warn(
						"Failed to save file using File System Access API, falling back to download:",
						error);
				}
			}
		}

		// Fallback to download method
		alert("File System Access API not available, falling back to download");
		console.log("File System Access API not available, falling back to download");

		const html_content = getDocumentOuterHtml();

		// Create and trigger download
		const blob = new Blob([html_content], {
			type: "text/html"
		});
		const url = URL.createObjectURL(blob);

		const download_link = document.createElement("a");
		download_link.href = url;
		download_link.download = "index.html";
		download_link.click();

		// Clean up the blob URL
		URL.revokeObjectURL(url);

		console.log("HTML file download initiated");
	};
});</script>

		<!-- Main Entry -->
		<script type="blob-module" name="main">import {
	showModuleEditor
} from "module-editor";
import {
	useStyledTags
} from "@std/ima-utils";

const t = useStyledTags();

const root_el = document.querySelector("main");

function Main() {

	// Main website content goes here...

	return t.main({
			styles: {
				key: "main-wrapper",
				css: `
					& {
						display: flex;
						align-items: center;
						justify-content: center;
						width: 100%;
						height: 100vh;
					}
				`,
			}
		},
		t.div({
				styles: {
					key: "key-is-always-required",
					css: `
						& {
							background: white;
							width: 50%;
							height: 50%;
							display: flex;
							align-items: center;
							justify-content: center;
							container-type: inline-size;
							container-name: card;
						}

						& span {
							color: black;
							transition: all cubic-bezier(0.175, 0.885, 0.32, 1.275) 500ms;
						}

						@media (min-width: 800px) {
							& span {
								font-size: 2.5rem;
								transform: rotate(360deg);
							}
						}
					`
				}
			},
			t.span(Math.random().toFixed(3)))
	);
}

// Hydrate existing <main>
if (root_el) {
	// Process whatever before replacing to hydrate
	root_el.replaceWith(
		Main()
	);
}

// Append if <main> not found
else {
	document.body.appendChild(Main());
}

window.addEventListener("keydown", (e) => {
	if (e.metaKey && e.key === "Escape") {
		e.preventDefault();
		showModuleEditor();
	}
})

window.showModuleEditor = showModuleEditor;</script>

		<!-- Tools -->
		<script type="blob-module" name="@std/utils" remote="../modules/client/utils.js">//
// Utils
//

// Commonly used utilities for general purpose JS programming.
// by Fernando Garcia (fergarram)
//

const __added_styles = new Set();

export function uniqueId() {
	// Check if crypto API is available
	if (typeof crypto === "undefined") {
		throw new Error("Crypto API is not available in this environment");
	}

	// Generate random values
	const random_values = new Uint8Array(16);
	crypto.getRandomValues(random_values);

	// Set version (4) and variant bits according to RFC4122
	random_values[6] = (random_values[6] & 0x0f) | 0x40; // version 4
	random_values[8] = (random_values[8] & 0x3f) | 0x80; // variant 1

	// Convert to hex string and format as UUID
	const hex_values = Array.from(random_values).map((byte) => byte.toString(16).padStart(2, "0"));

	return [
		hex_values.slice(0, 4).join(""),
		hex_values.slice(4, 6).join(""),
		hex_values.slice(6, 8).join(""),
		hex_values.slice(8, 10).join(""),
		hex_values.slice(10, 16).join(""),
	].join("-");
}

export function isUserTyping() {
	// Check if the active element is an input (excluding buttons, checkboxes, radio, etc.)
	if (document.activeElement?.tagName === "INPUT") {
		const input_type = document.activeElement.type.toLowerCase();
		const non_text_types = ["button", "checkbox", "radio", "submit", "reset", "file", "image", "range", "color", "hidden"];
		if (!non_text_types.includes(input_type)) {
			return true;
		}
	}

	// Check if the active element is a textarea
	if (document.activeElement?.tagName === "TEXTAREA") {
		return true;
	}

	// Check if the active element has contenteditable attribute
	if (document.activeElement?.getAttribute("contenteditable") === "true") {
		return true;
	}

	return false;
}

export function fade(color, opacity) {
	return `color-mix(in oklch, var(${color}), transparent ${100 - opacity}%)`;
}

export function docMain() {
	return document.body.querySelector("main");
}

export function debounce(fn, delay) {
	let timeout_id = null;
	let resolve_callback = null;

	// Create a promise that we'll resolve when the debounced function actually executes
	const debounced = (...args) => {
		if (timeout_id) {
			clearTimeout(timeout_id);
		}

		// Create new promise for this call
		debounced.callback = new Promise((resolve) => {
			resolve_callback = resolve;
		});

		timeout_id = window.setTimeout(() => {
			const result = fn.apply(null, args);
			if (resolve_callback) {
				resolve_callback(result);
			}
			timeout_id = null;
		}, delay);

		return debounced.callback;
	};

	// Attach the promise as a property of the function
	debounced.callback = Promise.resolve();

	// Add cancel method
	debounced.cancel = () => {
		if (timeout_id) {
			clearTimeout(timeout_id);
			timeout_id = null;
		}
	};

	return debounced;
}

export function tryCatch(func) {
	try {
		const result = func();
		// Check if the result is a promise
		if (result instanceof Promise) {
			// Return a promise that resolves to the tuple
			return result
				.then((resolved_result) => [resolved_result, null])
				.catch((error) => [null, error instanceof Error ? error : new Error(String(error))]);
		}
		// Return the tuple directly for synchronous results
		return [result, null];
	} catch (error) {
		return [null, error instanceof Error ? error : new Error(String(error))];
	}
}

export function isScrollable(element) {
	if (!element) return false;
	const style = window.getComputedStyle(element);
	const overflow_y = style.getPropertyValue("overflow-y");
	const overflow_x = style.getPropertyValue("overflow-x");
	return (
		(overflow_y === "scroll" || overflow_y === "auto" || overflow_x === "scroll" || overflow_x === "auto") &&
		(element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth)
	);
}

export function useGlobalStyles(styles) {
	// Skip if already added
	if (__added_styles.has(styles)) {
		return;
	}

	const sheet = createStylesheet("global_styles");

	// Mark as added
	__added_styles.add(styles);

	// Remove comments and normalize whitespace
	const cleaned_css = styles
		.replace(/\/\*[\s\S]*?\*\//g, "") // Remove CSS comments
		.replace(/\s+/g, " ")
		.trim();

	// Parse the CSS into individual rules
	let rules = [];
	let current_rule = "";
	let brace_count = 0;

	for (let i = 0; i < cleaned_css.length; i++) {
		const char = cleaned_css[i];
		current_rule += char;

		if (char === "{") {
			brace_count++;
		} else if (char === "}") {
			brace_count--;

			// If we've closed a top-level rule
			if (brace_count === 0) {
				rules.push(current_rule.trim());
				current_rule = "";
			}
		}
	}

	// Insert each rule into the stylesheet
	for (const rule of rules) {
		try {
			sheet.insertRule(rule, sheet.cssRules.length);
		} catch (error) {
			console.error(`Failed to insert CSS rule: ${rule}`, error);
		}
	}
}

export function createStylesheet(id) {
	let sheet = document.adoptedStyleSheets.find((sheet) => sheet.id === id);
	if (!sheet) {
		sheet = new CSSStyleSheet();
		sheet.id = id;
		document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];
	}
	return sheet;
}

export function createShadowStylesheet(shadow_root, id) {
	let sheet = shadow_root.adoptedStyleSheets.find((sheet) => sheet.id === id);
	if (!sheet) {
		sheet = new CSSStyleSheet();
		sheet.id = id;
		shadow_root.adoptedStyleSheets = [...shadow_root.adoptedStyleSheets, sheet];
	}
	return sheet;
}

export function useShadowStyles(shadow_root, styles, id = "default") {
	// Create a unique key for this shadow root + styles combination
	const shadow_key = `shadow_${id}_${styles}`;

	// Skip if already added
	if (__added_styles.has(shadow_key)) {
		return createShadowStylesheet(shadow_root, id);
	}

	const sheet = createShadowStylesheet(shadow_root, id);

	// Mark as added
	__added_styles.add(shadow_key);

	// Clear existing rules
	while (sheet.cssRules.length > 0) {
		sheet.deleteRule(0);
	}

	// Same CSS parsing logic as useGlobalStyles...
	const cleaned_css = styles
		.replace(/\/\*[\s\S]*?\*\//g, "")
		.replace(/\s+/g, " ")
		.trim();

	let rules = [];
	let current_rule = "";
	let brace_count = 0;

	for (let i = 0; i < cleaned_css.length; i++) {
		const char = cleaned_css[i];
		current_rule += char;

		if (char === "{") {
			brace_count++;
		} else if (char === "}") {
			brace_count--;

			if (brace_count === 0) {
				rules.push(current_rule.trim());
				current_rule = "";
			}
		}
	}

	for (const rule of rules) {
		try {
			sheet.insertRule(rule, sheet.cssRules.length);
		} catch (error) {
			console.error(`Failed to insert CSS rule: ${rule}`, error);
		}
	}

	return sheet;
}

export function repeat(length, val) {
	return Array.from(
		{
			length,
		},
		() => val,
	);
}

export function throttle(func, wait) {
	let waiting = false;
	return function (...args) {
		if (!waiting) {
			func(...args);
			waiting = true;
			setTimeout(() => (waiting = false), wait);
		}
	};
}

export function finish(time = 0) {
	return new Promise((resolve) => setTimeout(resolve, time));
}

export function finishFrame() {
	return new Promise((resolve) => requestAnimationFrame(() => resolve()));
}

export function css(strings, ...values) {
	return strings.reduce((result, str, i) => result + str + (i < values.length ? values[i] : ""), "");
}

export function convertFromWindowsPath(path) {
	return path.replace(/\\/g, "/");
}

export function convertToWindowsPath(path) {
	return path.replace(/\//g, "\\");
}

export function isImageFile(ext) {
	const exts = ["jpg", "jpeg", "png", "gif", "webp"];
	return exts.includes(ext.toLowerCase());
}

export function getImageMediaType(filepath) {
	const ext = filepath.toLowerCase();
	if (ext.endsWith(".jpg") || ext.endsWith(".jpeg")) return "image/jpeg";
	if (ext.endsWith(".png")) return "image/png";
	if (ext.endsWith(".gif")) return "image/gif";
	if (ext.endsWith(".webp")) return "image/webp";
	return null;
}

export function isSoundFile(ext) {
	const exts = ["mp3", "wav", "ogg", "m4a", "aac", "flac", "wma", "aiff", "mid", "midi"];
	return exts.includes(ext.toLowerCase());
}

export function getFileLanguage(filename) {
	const extension = filename.split(".").pop()?.toLowerCase() || "";

	const language_map = {
		// Programming Languages
		js: "javascript",
		ts: "typescript",
		jsx: "javascript",
		tsx: "typescript",
		py: "python",
		cpp: "cpp",
		c: "c",
		h: "cpp",
		hpp: "cpp",
		cs: "csharp",
		java: "java",
		rb: "ruby",
		php: "php",
		go: "go",
		rs: "rust",
		swift: "swift",

		// Web Technologies
		html: "html",
		htm: "html",
		css: "css",
		scss: "scss",
		less: "less",
		json: "json",
		xml: "xml",
		svg: "xml",

		// Markup/Config
		md: "markdown",
		markdown: "markdown",
		yaml: "yaml",
		yml: "yaml",
		toml: "toml",
		ini: "ini",

		// Shell Scripts
		sh: "shell",
		bash: "shell",
		zsh: "shell",
		bat: "bat",
		cmd: "bat",

		// Game Development
		glsl: "glsl",
		frag: "glsl",
		vert: "glsl",
		shader: "glsl",

		// Data formats
		csv: "plaintext",
		txt: "plaintext",
		log: "plaintext",

		// Chat files
		chat: "markdown",
	};

	return language_map[extension] || "plaintext";
}

export function cn(...classes) {
	return classes
		.flatMap((cls) => {
			if (typeof cls === "string" || cls === undefined) {
				return cls;
			}
			if (Array.isArray(cls)) {
				return cls;
			}
			if (typeof cls === "object" && cls !== null) {
				return Object.entries(cls)
					.filter(([_, value]) => value)
					.map(([key, _]) => key);
			}
			return undefined;
		})
		.filter(Boolean)
		.join(" ");
}</script>
		<script type="blob-module" name="@std/ima" remote="../modules/client/ima.js">//
// IMA (今) 0.7.0
// by fergarram
//

// A tiny immediate-mode inspired UI rendering engine.

//
// Index:
//

// — Tags
// — Reactive System
// — Static Generation

//
// Tag Generation
//

export function useStaticTags() {
	return new Proxy({}, { get: staticTagGenerator });
}

export function useTags(options) {
	const is_static = typeof window === "undefined";

	// Handle backward compatibility - if options is a string, treat it as namespace
	const resolved_options = typeof options === "string" ? { namespace: options } : options || {};

	if (is_static) {
		return useStaticTags();
	} else {
		return new Proxy(
			{},
			{
				get: (target, tag) => tagGenerator(target, String(tag), resolved_options),
			},
		);
	}
}

//
// DOM Element Generation
//

if (typeof window === "undefined") {
	// In environments without DOM (like Bun/Node server-side), provide no-op versions
	// of the reactive functions to prevent errors
	const warn = () => console.warn("Trying to use client-side tags on server.");
	globalThis.document = {
		createElement: warn,
		createTextNode: warn,
		createComment: warn,
		createElementNS: warn,
	};
}

export function parseTagArgs(args) {
	let props = {};
	let children = args;
	let ref;
	let innerHTML;

	if (args.length > 0) {
		const first_arg = args[0];

		// If first argument is a string, number, HTMLElement, or function, all args are children
		if (
			typeof first_arg === "string" ||
			typeof first_arg === "number" ||
			(typeof window !== "undefined" && first_arg instanceof HTMLElement) ||
			typeof first_arg === "function"
		) {
			children = args;
		}
		// If first argument is a plain object, treat it as props
		else if (Object.getPrototypeOf(first_arg || 0) === Object.prototype) {
			const [props_arg, ...rest_args] = args;
			const { is, ref: prop_ref, innerHTML: prop_innerHTML, ...rest_props } = props_arg;
			props = rest_props;
			children = rest_args;
			ref = prop_ref;
			innerHTML = prop_innerHTML;
		}
	}

	return { props, children, ref, innerHTML };
}

export function tagGenerator(_, tag, options) {
	return (...args) => {
		const { props, children, ref, innerHTML } = parseTagArgs(args);

		const element = options?.namespace ? document.createElementNS(options.namespace, tag) : document.createElement(tag);

		if (ref) {
			ref.current = element;
		}

		// Handle props/attributes
		for (const [attr_key, value] of Object.entries(props)) {
			let processed_name = attr_key;
			let processed_value = value;

			// Apply custom attribute processing if provided
			if (options?.attr) {
				const result = options.attr(attr_key, value);
				processed_name = result.name;
				processed_value = result.value;
			}

			if (processed_name.startsWith("on") && typeof processed_value === "function") {
				const event_name = processed_name.substring(2).toLowerCase();
				element.addEventListener(event_name, processed_value);
				continue;
			}

			if (typeof processed_value === "function" && !processed_name.startsWith("on")) {
				setupReactiveAttr(element, processed_name, processed_value);
				continue;
			}

			if (processed_value === true) {
				element.setAttribute(processed_name, "true");
			} else if (processed_value === false) {
				element.setAttribute(processed_name, "false");
			} else if (processed_value !== null && processed_value !== undefined) {
				element.setAttribute(processed_name, String(processed_value));
			}
		}

		// Handle innerHTML - set it directly and skip processing children
		if (innerHTML !== undefined) {
			element.innerHTML = String(innerHTML);
			return element;
		}

		// Process children and append to element
		for (const child of children.flat(Infinity)) {
			if (child != null) {
				if (child instanceof Node) {
					element.appendChild(child);
				} else if (typeof child === "function") {
					const reactive_node = setupReactiveNode(child);
					element.appendChild(reactive_node);
				} else {
					element.appendChild(document.createTextNode(String(child)));
				}
			}
		}

		return element;
	};
}

//
// Reactive System
//

// Reactive nodes
const reactive_markers = [];
const reactive_callbacks = [];
const reactive_prev_values = [];
let reactive_node_count = 0;

// Reactive attributes
const reactive_attr_elements = [];
const reactive_attr_names = [];
const reactive_attr_callbacks = [];
const reactive_attr_prev_values = [];
let reactive_attr_count = 0;

let frame_time = 0;
let cleanup_counter = 0;

// Start the frame loop immediately
if (typeof window !== "undefined") {
	requestAnimationFrame(updateReactiveComponents);
}

function updateReactiveComponents() {
	// Start timing the update
	const start_time = performance.now();

	let found_disconnected_attrs = false;
	let found_disconnected_nodes = false;

	// Update reactive attributes
	for (let i = 0; i < reactive_attr_count; i++) {
		const element = reactive_attr_elements[i];

		// Track if we find disconnected elements
		if (!element || !element.isConnected) {
			found_disconnected_attrs = true;
			continue;
		}

		const attr_name = reactive_attr_names[i];
		const callback = reactive_attr_callbacks[i];

		if (!attr_name || !callback) continue;

		const new_value = callback();

		// Only update if value changed
		if (new_value !== reactive_attr_prev_values[i]) {
			if (new_value === true) {
				element.setAttribute(attr_name, "true");
			} else if (new_value === false) {
				element.setAttribute(attr_name, "false");
			} else if (new_value === null || new_value === undefined) {
				element.removeAttribute(attr_name);
			} else {
				element.setAttribute(attr_name, String(new_value));
			}

			reactive_attr_prev_values[i] = new_value;
		}
	}

	// Update reactive nodes
	for (let i = 0; i < reactive_node_count; i++) {
		const marker = reactive_markers[i];

		// Track if we find disconnected markers
		if (!marker || !marker.isConnected) {
			found_disconnected_nodes = true;
			continue;
		}

		const callback = reactive_callbacks[i];
		if (!callback) continue;

		const new_value = callback();

		// Get the current node (should be right before the marker)
		const current_node = marker.previousSibling;
		if (!current_node) continue;

		// Determine if we need to update based on content
		let needs_update = false;

		if (new_value instanceof Node) {
			if (current_node instanceof HTMLElement && new_value instanceof HTMLElement) {
				// For HTML elements, compare their HTML content
				if (current_node.outerHTML !== new_value.outerHTML) {
					needs_update = true;
				}
			} else {
				// For non-HTMLElements or mixed types, always update
				needs_update = true;
			}
		} else {
			// For text values, compare with current node
			const new_text = String(new_value || "");
			if (current_node.nodeType === Node.TEXT_NODE) {
				needs_update = current_node.textContent !== new_text;
			} else {
				needs_update = true; // Different node types
			}
		}

		// Only update DOM if needed
		if (needs_update) {
			let new_node;

			if (new_value instanceof Node) {
				new_node = new_value;
			} else {
				new_node = document.createTextNode(String(new_value || ""));
			}

			current_node.replaceWith(new_node);
		}
	}

	// Only perform cleanup if we found disconnected components
	if (found_disconnected_attrs || found_disconnected_nodes) {
		cleanup_counter++;
		if (cleanup_counter >= 60) {
			cleanup_counter = 0;
			cleanupDisconnectedReactives();
		}
	}

	// Calculate and store the time it took to update
	frame_time = performance.now() - start_time;

	// Always schedule the next frame
	requestAnimationFrame(updateReactiveComponents);
}

function cleanupDisconnectedReactives() {
	// Cleanup reactive nodes
	let write_index = 0;
	for (let read_index = 0; read_index < reactive_node_count; read_index++) {
		const marker = reactive_markers[read_index];
		const callback = reactive_callbacks[read_index];
		const prev_value = reactive_prev_values[read_index];

		// Keep if marker is still connected
		if (marker && marker.isConnected) {
			if (write_index !== read_index) {
				reactive_markers[write_index] = marker;
				reactive_callbacks[write_index] = callback;
				reactive_prev_values[write_index] = prev_value;
			}
			write_index++;
		}
	}

	// Clear the remaining slots and update count
	for (let i = write_index; i < reactive_node_count; i++) {
		reactive_markers[i] = null;
		reactive_callbacks[i] = null;
		reactive_prev_values[i] = null;
	}
	reactive_node_count = write_index;

	// Cleanup reactive attributes
	write_index = 0;
	for (let read_index = 0; read_index < reactive_attr_count; read_index++) {
		const element = reactive_attr_elements[read_index];
		const attr_name = reactive_attr_names[read_index];
		const callback = reactive_attr_callbacks[read_index];
		const prev_value = reactive_attr_prev_values[read_index];

		// Keep if element is still connected
		if (element && element.isConnected) {
			if (write_index !== read_index) {
				reactive_attr_elements[write_index] = element;
				reactive_attr_names[write_index] = attr_name;
				reactive_attr_callbacks[write_index] = callback;
				reactive_attr_prev_values[write_index] = prev_value;
			}
			write_index++;
		}
	}

	// Clear the remaining slots and update count
	for (let i = write_index; i < reactive_attr_count; i++) {
		reactive_attr_elements[i] = null;
		reactive_attr_names[i] = null;
		reactive_attr_callbacks[i] = null;
		reactive_attr_prev_values[i] = undefined;
	}
	reactive_attr_count = write_index;
}

export function getFrameTime() {
	return frame_time;
}

function setupReactiveNode(callback) {
	const node_index = reactive_node_count++;

	// Create a marker comment node
	const marker = document.createComment(`reactive-${node_index}`);

	// Get initial value
	const initial_value = callback();

	// Create the initial node
	let initial_node;

	if (initial_value instanceof Node) {
		initial_node = initial_value;
	} else {
		initial_node = document.createTextNode(String(initial_value || ""));
	}

	// Create a fragment to hold both the marker and the content
	const fragment = document.createDocumentFragment();
	fragment.appendChild(initial_node);
	fragment.appendChild(marker);

	// Store reactive data
	reactive_markers[node_index] = marker;
	reactive_callbacks[node_index] = callback;
	reactive_prev_values[node_index] = initial_node;

	return fragment;
}

function setupReactiveAttr(element, attr_name, callback) {
	const attr_index = reactive_attr_count++;

	// Initialize with current value
	const initial_value = callback();

	// Set the initial attribute value
	if (initial_value === true) {
		element.setAttribute(attr_name, "true");
	} else if (initial_value === false) {
		element.setAttribute(attr_name, "false");
	} else if (initial_value !== null && initial_value !== undefined) {
		element.setAttribute(attr_name, String(initial_value));
	}

	// Store references
	reactive_attr_elements[attr_index] = element;
	reactive_attr_names[attr_index] = attr_name;
	reactive_attr_callbacks[attr_index] = callback;
	reactive_attr_prev_values[attr_index] = initial_value;
}

//
// Static Generation
//

// Void elements that are self-closing
const VOID_ELEMENTS = new Set([
	"area",
	"base",
	"br",
	"col",
	"embed",
	"hr",
	"img",
	"input",
	"link",
	"meta",
	"param",
	"source",
	"track",
	"wbr",
]);

export function escapeHtml(value) {
	return value
		.replace(/&/g, "&amp;")
		.replace(/"/g, "&quot;")
		.replace(/'/g, "&#39;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;");
}

export function buildAttributesHtml(props) {
	let html = "";

	for (const [key, value] of Object.entries(props)) {
		// Skip event handlers and functions
		if (key.startsWith("on") || typeof value === "function") {
			continue;
		}
		// Regular attributes
		if (value === true) {
			html += ` ${key}`;
		} else if (value !== false && value != null) {
			html += ` ${key}="${escapeHtml(String(value))}"`;
		}
	}

	return html;
}

function staticTagGenerator(_, tag) {
	return (...args) => {
		const { props, children, innerHTML } = parseTagArgs(args);

		// Start building the HTML string
		let html = `<${tag}${buildAttributesHtml(props)}`;

		// Self-closing tags
		if (VOID_ELEMENTS.has(tag)) {
			return html + "/>";
		}

		html += ">";

		// Handle innerHTML - if present, ignore children and use innerHTML instead
		if (innerHTML !== undefined) {
			const inner_html_content = typeof innerHTML === "function" ? innerHTML() : innerHTML;
			html += String(inner_html_content);
			return html + `</${tag}>`;
		}

		// Process children
		for (const child of children.flat(Infinity)) {
			if (child != null) {
				if (typeof child === "function") {
					// Resolve function children
					html += String(child());
				} else {
					// Don't escape HTML content - treat it as raw HTML
					html += String(child);
				}
			}
		}

		return html + `</${tag}>`;
	};
}</script>

<script type="blob-module" name="@std/ima-utils" remote="../modules/client/ima-utils.js">//
// IMA Utils
//

// Extra utils for working with IMA
// by Fernando Garcia (fergarram)
//

import { useTags } from "@std/ima";
import { useGlobalStyles, uniqueId, useShadowStyles } from "@std/utils";

export function useStyledTags(opts) {
	return useTags({
		...opts,
		attr(name, value) {
			if (name === "styles") {
				// Only handle object format
				if (typeof value === "object" && value !== null) {
					if (!value.key) {
						console.warn("Styles key can't be empty", value);
						return {
							name: "styles-key",
							value: "",
						};
					}

					const id = value.key;
					const css = value.css || "";

					const processed_css = css.replaceAll("&", `[styles-key="${id}"]`);
					if (opts && opts.shadow_root) {
						useShadowStyles(
							typeof opts.shadow_root === "function" ? opts.shadow_root() : opts.shadow_root,
							processed_css,
							id
						);
					} else {
						useGlobalStyles(processed_css);
					}

					return {
						name: "styles-key",
						value: id,
					};
				}

				// Fallback for non-object types
				console.warn("Styles attribute must be an object with 'key' and 'css' properties. Nothing will be done.", value);
				return {
					name: "styles-key",
					value: "",
				};
			}

			// Return default for other attributes
			return opts && opts.attr ? opts.attr(name, value) : { name, value };
		},
	});
}

export function useCustomStyledTag(tag_name, definition, opts) {
	return useCustomTag(tag_name, definition, {
		...opts,
		use_styles: true,
	});
}

export function useCustomTag(tag_name, definition, opts) {
	if (!customElements.get(tag_name)) {
		customElements.define(
			tag_name,
			class extends HTMLElement {
				static observedAttributes = definition.attrs ?? [];
				#connected;
				#disconnected;
				#adopted;
				#attributeChanged;

				constructor() {
					super();

					const ac = new AbortController();
					const $listen = (evt, handler, options = true) => {
						let defaultOptions = { signal: ac.signal };
						if (typeof options === "boolean") {
							defaultOptions.capture = options;
						} else {
							defaultOptions = Object.assign(options, defaultOptions);
						}
						this.addEventListener(evt, handler, defaultOptions);
					};

					this.ac = ac;

					const { connected, disconnected, adopted, attributeChanged } = definition.apply(this, [{ $listen }]) ?? {};

					this.#connected = connected?.bind(this);
					this.#disconnected = disconnected?.bind(this);
					this.#adopted = adopted?.bind(this);
					this.#attributeChanged = attributeChanged?.bind(this);
				}

				connectedCallback() {
					this.#connected?.();
				}

				disconnectedCallback() {
					this.#disconnected?.();
					this.ac.abort();
				}

				adoptedCallback() {
					this.#adopted?.();
				}

				attributeChangedCallback(...args) {
					this.#attributeChanged?.(...args);
				}
			},
		);

		if (opts && opts.use_styles) {
			delete opts.use_styles;
			return useStyledTags(opts)[tag_name];
		} else {
			return useTags(opts)[tag_name];
		}
	}
}</script>

		<!-- Module Editor -->
		<script type="blob-module" name="@std/js-parser" remote="../modules/client/acorn.js">// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues

var qZ = (B, D) => () => (D || B((D = {
	exports: {}
}).exports, D), D.exports);
var _Q = qZ((OJ, OQ) => {
	(function(B, D) {
		typeof OJ === "object" && typeof OQ !== "undefined" ? D(OJ) : typeof define === "function" && define.amd ?
			define(["exports"], D) : (B = typeof globalThis !== "undefined" ? globalThis : B || self, D(B
				.acorn = {}))
	})(OJ, function(B) {
		var D = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32,
				4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37,
				13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1,
				2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10,
				9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243,
				14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10,
				10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4,
				2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87,
				9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3,
				22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
				1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726,
				6, 110, 6, 6, 9, 4759, 9, 787719, 239
			],
			PJ = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37,
				11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10,
				2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4,
				0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43,
				28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27,
				10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14,
				44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
				6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9,
				2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37,
				47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2,
				0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2,
				36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2,
				33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763,
				568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
				65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9,
				395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2,
				64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2,
				24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19,
				43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1,
				2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2,
				0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
				4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191
			],
			BQ =
			"‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･",
			kJ =
			"ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
			_J = {
				3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
				5: "class enum extends super const export import",
				6: "enum",
				strict: "implements interface let package private protected public static yield",
				strictBind: "eval arguments"
			},
			BJ =
			"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",
			UQ = {
				5: BJ,
				"5module": BJ + " export import",
				6: BJ + " const class extends export import super"
			},
			NQ = /^in(stanceof)?$/,
			$Q = new RegExp("[" + kJ + "]"),
			IQ = new RegExp("[" + kJ + BQ + "]");

		function UJ(J, Q) {
			var Z = 65536;
			for (var q = 0; q < Q.length; q += 2) {
				if (Z += Q[q], Z > J) return !1;
				if (Z += Q[q + 1], Z >= J) return !0
			}
			return !1
		}

		function T(J, Q) {
			if (J < 65) return J === 36;
			if (J < 91) return !0;
			if (J < 97) return J === 95;
			if (J < 123) return !0;
			if (J <= 65535) return J >= 170 && $Q.test(String.fromCharCode(J));
			if (Q === !1) return !1;
			return UJ(J, PJ)
		}

		function x(J, Q) {
			if (J < 48) return J === 36;
			if (J < 58) return !0;
			if (J < 65) return !1;
			if (J < 91) return !0;
			if (J < 97) return J === 95;
			if (J < 123) return !0;
			if (J <= 65535) return J >= 170 && IQ.test(String.fromCharCode(J));
			if (Q === !1) return !1;
			return UJ(J, PJ) || UJ(J, D)
		}
		var _ = function J(Q, Z) {
			if (Z === void 0) Z = {};
			this.label = Q, this.keyword = Z.keyword, this.beforeExpr = !!Z.beforeExpr, this.startsExpr = !!Z
				.startsExpr, this.isLoop = !!Z.isLoop, this.isAssign = !!Z.isAssign, this.prefix = !!Z.prefix,
				this.postfix = !!Z.postfix, this.binop = Z.binop || null, this.updateContext = null
		};

		function w(J, Q) {
			return new _(J, {
				beforeExpr: !0,
				binop: Q
			})
		}
		var S = {
				beforeExpr: !0
			},
			C = {
				startsExpr: !0
			},
			WJ = {};

		function O(J, Q) {
			if (Q === void 0) Q = {};
			return Q.keyword = J, WJ[J] = new _(J, Q)
		}
		var W = {
				num: new _("num", C),
				regexp: new _("regexp", C),
				string: new _("string", C),
				name: new _("name", C),
				privateId: new _("privateId", C),
				eof: new _("eof"),
				bracketL: new _("[", {
					beforeExpr: !0,
					startsExpr: !0
				}),
				bracketR: new _("]"),
				braceL: new _("{", {
					beforeExpr: !0,
					startsExpr: !0
				}),
				braceR: new _("}"),
				parenL: new _("(", {
					beforeExpr: !0,
					startsExpr: !0
				}),
				parenR: new _(")"),
				comma: new _(",", S),
				semi: new _(";", S),
				colon: new _(":", S),
				dot: new _("."),
				question: new _("?", S),
				questionDot: new _("?."),
				arrow: new _("=>", S),
				template: new _("template"),
				invalidTemplate: new _("invalidTemplate"),
				ellipsis: new _("...", S),
				backQuote: new _("`", C),
				dollarBraceL: new _("${", {
					beforeExpr: !0,
					startsExpr: !0
				}),
				eq: new _("=", {
					beforeExpr: !0,
					isAssign: !0
				}),
				assign: new _("_=", {
					beforeExpr: !0,
					isAssign: !0
				}),
				incDec: new _("++/--", {
					prefix: !0,
					postfix: !0,
					startsExpr: !0
				}),
				prefix: new _("!/~", {
					beforeExpr: !0,
					prefix: !0,
					startsExpr: !0
				}),
				logicalOR: w("||", 1),
				logicalAND: w("&&", 2),
				bitwiseOR: w("|", 3),
				bitwiseXOR: w("^", 4),
				bitwiseAND: w("&", 5),
				equality: w("==/!=/===/!==", 6),
				relational: w("</>/<=/>=", 7),
				bitShift: w("<</>>/>>>", 8),
				plusMin: new _("+/-", {
					beforeExpr: !0,
					binop: 9,
					prefix: !0,
					startsExpr: !0
				}),
				modulo: w("%", 10),
				star: w("*", 10),
				slash: w("/", 10),
				starstar: new _("**", {
					beforeExpr: !0
				}),
				coalesce: w("??", 1),
				_break: O("break"),
				_case: O("case", S),
				_catch: O("catch"),
				_continue: O("continue"),
				_debugger: O("debugger"),
				_default: O("default", S),
				_do: O("do", {
					isLoop: !0,
					beforeExpr: !0
				}),
				_else: O("else", S),
				_finally: O("finally"),
				_for: O("for", {
					isLoop: !0
				}),
				_function: O("function", C),
				_if: O("if"),
				_return: O("return", S),
				_switch: O("switch"),
				_throw: O("throw", S),
				_try: O("try"),
				_var: O("var"),
				_const: O("const"),
				_while: O("while", {
					isLoop: !0
				}),
				_with: O("with"),
				_new: O("new", {
					beforeExpr: !0,
					startsExpr: !0
				}),
				_this: O("this", C),
				_super: O("super", C),
				_class: O("class", C),
				_extends: O("extends", S),
				_export: O("export"),
				_import: O("import", C),
				_null: O("null", C),
				_true: O("true", C),
				_false: O("false", C),
				_in: O("in", {
					beforeExpr: !0,
					binop: 7
				}),
				_instanceof: O("instanceof", {
					beforeExpr: !0,
					binop: 7
				}),
				_typeof: O("typeof", {
					beforeExpr: !0,
					prefix: !0,
					startsExpr: !0
				}),
				_void: O("void", {
					beforeExpr: !0,
					prefix: !0,
					startsExpr: !0
				}),
				_delete: O("delete", {
					beforeExpr: !0,
					prefix: !0,
					startsExpr: !0
				})
			},
			b = /\r\n?|\n|\u2028|\u2029/,
			TJ = new RegExp(b.source, "g");

		function l(J) {
			return J === 10 || J === 13 || J === 8232 || J === 8233
		}

		function DJ(J, Q, Z) {
			if (Z === void 0) Z = J.length;
			for (var q = Q; q < Z; q++) {
				var X = J.charCodeAt(q);
				if (l(X)) return q < Z - 1 && X === 13 && J.charCodeAt(q + 1) === 10 ? q + 2 : q + 1
			}
			return -1
		}
		var NJ = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
			I = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
			EJ = Object.prototype,
			vQ = EJ.hasOwnProperty,
			bQ = EJ.toString,
			c = Object.hasOwn || function(J, Q) {
				return vQ.call(J, Q)
			},
			yJ = Array.isArray || function(J) {
				return bQ.call(J) === "[object Array]"
			},
			xJ = Object.create(null);

		function f(J) {
			return xJ[J] || (xJ[J] = new RegExp("^(?:" + J.replace(/ /g, "|") + ")$"))
		}

		function g(J) {
			if (J <= 65535) return String.fromCharCode(J);
			return J -= 65536, String.fromCharCode((J >> 10) + 55296, (J & 1023) + 56320)
		}
		var AQ = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,
			d = function J(Q, Z) {
				this.line = Q, this.column = Z
			};
		d.prototype.offset = function J(Q) {
			return new d(this.line, this.column + Q)
		};
		var s = function J(Q, Z, q) {
			if (this.start = Z, this.end = q, Q.sourceFile !== null) this.source = Q.sourceFile
		};

		function $J(J, Q) {
			for (var Z = 1, q = 0;;) {
				var X = DJ(J, q, Q);
				if (X < 0) return new d(Z, Q - q);
				++Z, q = X
			}
		}
		var XJ = {
				ecmaVersion: null,
				sourceType: "script",
				onInsertedSemicolon: null,
				onTrailingComma: null,
				allowReserved: null,
				allowReturnOutsideFunction: !1,
				allowImportExportEverywhere: !1,
				allowAwaitOutsideFunction: null,
				allowSuperOutsideMethod: null,
				allowHashBang: !1,
				checkPrivateFields: !0,
				locations: !1,
				onToken: null,
				onComment: null,
				ranges: !1,
				program: null,
				sourceFile: null,
				directSourceFile: null,
				preserveParens: !1
			},
			gJ = !1;

		function CQ(J) {
			var Q = {};
			for (var Z in XJ) Q[Z] = J && c(J, Z) ? J[Z] : XJ[Z];
			if (Q.ecmaVersion === "latest") Q.ecmaVersion = 1e8;
			else if (Q.ecmaVersion == null) {
				if (!gJ && typeof console === "object" && console.warn) gJ = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`);
				Q.ecmaVersion = 11
			} else if (Q.ecmaVersion >= 2015) Q.ecmaVersion -= 2009;
			if (Q.allowReserved == null) Q.allowReserved = Q.ecmaVersion < 5;
			if (!J || J.allowHashBang == null) Q.allowHashBang = Q.ecmaVersion >= 14;
			if (yJ(Q.onToken)) {
				var q = Q.onToken;
				Q.onToken = function(X) {
					return q.push(X)
				}
			}
			if (yJ(Q.onComment)) Q.onComment = wQ(Q, Q.onComment);
			return Q
		}

		function wQ(J, Q) {
			return function(Z, q, X, Y, j, H) {
				var K = {
					type: Z ? "Block" : "Line",
					value: q,
					start: X,
					end: Y
				};
				if (J.locations) K.loc = new s(this, j, H);
				if (J.ranges) K.range = [X, Y];
				Q.push(K)
			}
		}
		var t = 1,
			i = 2,
			IJ = 4,
			mJ = 8,
			vJ = 16,
			hJ = 32,
			YJ = 64,
			fJ = 128,
			p = 256,
			e = 512,
			jJ = t | i | p;

		function bJ(J, Q) {
			return i | (J ? IJ : 0) | (Q ? mJ : 0)
		}
		var HJ = 0,
			AJ = 1,
			m = 2,
			uJ = 3,
			lJ = 4,
			pJ = 5,
			$ = function J(Q, Z, q) {
				this.options = Q = CQ(Q), this.sourceFile = Q.sourceFile, this.keywords = f(UQ[Q.ecmaVersion >= 6 ?
					6 : Q.sourceType === "module" ? "5module" : 5]);
				var X = "";
				if (Q.allowReserved !== !0) {
					if (X = _J[Q.ecmaVersion >= 6 ? 6 : Q.ecmaVersion === 5 ? 5 : 3], Q.sourceType === "module")
						X += " await"
				}
				this.reservedWords = f(X);
				var Y = (X ? X + " " : "") + _J.strict;
				if (this.reservedWordsStrict = f(Y), this.reservedWordsStrictBind = f(Y + " " + _J.strictBind), this
					.input = String(Z), this.containsEsc = !1, q) this.pos = q, this.lineStart = this.input
					.lastIndexOf(`
`, q - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(b).length;
				else this.pos = this.lineStart = 0, this.curLine = 1;
				if (this.type = W.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this
					.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this
					.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this
					.exprAllowed = !0, this.inModule = Q.sourceType === "module", this.strict = this.inModule ||
					this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1,
					this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this
					.undefinedExports = Object.create(null), this.pos === 0 && Q.allowHashBang && this.input.slice(
						0, 2) === "#!") this.skipLineComment(2);
				this.scopeStack = [], this.enterScope(t), this.regexpState = null, this.privateNameStack = []
			},
			E = {
				inFunction: {
					configurable: !0
				},
				inGenerator: {
					configurable: !0
				},
				inAsync: {
					configurable: !0
				},
				canAwait: {
					configurable: !0
				},
				allowSuper: {
					configurable: !0
				},
				allowDirectSuper: {
					configurable: !0
				},
				treatFunctionsAsVar: {
					configurable: !0
				},
				allowNewDotTarget: {
					configurable: !0
				},
				inClassStaticBlock: {
					configurable: !0
				}
			};
		$.prototype.parse = function J() {
			var Q = this.options.program || this.startNode();
			return this.nextToken(), this.parseTopLevel(Q)
		}, E.inFunction.get = function() {
			return (this.currentVarScope().flags & i) > 0
		}, E.inGenerator.get = function() {
			return (this.currentVarScope().flags & mJ) > 0
		}, E.inAsync.get = function() {
			return (this.currentVarScope().flags & IJ) > 0
		}, E.canAwait.get = function() {
			for (var J = this.scopeStack.length - 1; J >= 0; J--) {
				var Q = this.scopeStack[J],
					Z = Q.flags;
				if (Z & (p | e)) return !1;
				if (Z & i) return (Z & IJ) > 0
			}
			return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction
		}, E.allowSuper.get = function() {
			var J = this.currentThisScope(),
				Q = J.flags;
			return (Q & YJ) > 0 || this.options.allowSuperOutsideMethod
		}, E.allowDirectSuper.get = function() {
			return (this.currentThisScope().flags & fJ) > 0
		}, E.treatFunctionsAsVar.get = function() {
			return this.treatFunctionsAsVarInScope(this.currentScope())
		}, E.allowNewDotTarget.get = function() {
			for (var J = this.scopeStack.length - 1; J >= 0; J--) {
				var Q = this.scopeStack[J],
					Z = Q.flags;
				if (Z & (p | e) || Z & i && !(Z & vJ)) return !0
			}
			return !1
		}, E.inClassStaticBlock.get = function() {
			return (this.currentVarScope().flags & p) > 0
		}, $.extend = function J() {
			var Q = [],
				Z = arguments.length;
			while (Z--) Q[Z] = arguments[Z];
			var q = this;
			for (var X = 0; X < Q.length; X++) q = Q[X](q);
			return q
		}, $.parse = function J(Q, Z) {
			return new this(Z, Q).parse()
		}, $.parseExpressionAt = function J(Q, Z, q) {
			var X = new this(q, Q, Z);
			return X.nextToken(), X.parseExpression()
		}, $.tokenizer = function J(Q, Z) {
			return new this(Z, Q)
		}, Object.defineProperties($.prototype, E);
		var A = $.prototype,
			SQ = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
		A.strictDirective = function(J) {
			if (this.options.ecmaVersion < 5) return !1;
			for (;;) {
				I.lastIndex = J, J += I.exec(this.input)[0].length;
				var Q = SQ.exec(this.input.slice(J));
				if (!Q) return !1;
				if ((Q[1] || Q[2]) === "use strict") {
					I.lastIndex = J + Q[0].length;
					var Z = I.exec(this.input),
						q = Z.index + Z[0].length,
						X = this.input.charAt(q);
					return X === ";" || X === "}" || b.test(Z[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(X) || X ===
						"!" && this.input.charAt(q + 1) === "=")
				}
				if (J += Q[0].length, I.lastIndex = J, J += I.exec(this.input)[0].length, this.input[J] === ";")
					J++
			}
		}, A.eat = function(J) {
			if (this.type === J) return this.next(), !0;
			else return !1
		}, A.isContextual = function(J) {
			return this.type === W.name && this.value === J && !this.containsEsc
		}, A.eatContextual = function(J) {
			if (!this.isContextual(J)) return !1;
			return this.next(), !0
		}, A.expectContextual = function(J) {
			if (!this.eatContextual(J)) this.unexpected()
		}, A.canInsertSemicolon = function() {
			return this.type === W.eof || this.type === W.braceR || b.test(this.input.slice(this.lastTokEnd,
				this.start))
		}, A.insertSemicolon = function() {
			if (this.canInsertSemicolon()) {
				if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this
					.lastTokEndLoc);
				return !0
			}
		}, A.semicolon = function() {
			if (!this.eat(W.semi) && !this.insertSemicolon()) this.unexpected()
		}, A.afterTrailingComma = function(J, Q) {
			if (this.type === J) {
				if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this
					.lastTokStartLoc);
				if (!Q) this.next();
				return !0
			}
		}, A.expect = function(J) {
			this.eat(J) || this.unexpected()
		}, A.unexpected = function(J) {
			this.raise(J != null ? J : this.start, "Unexpected token")
		};
		var KJ = function J() {
			this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this
				.doubleProto = -1
		};
		A.checkPatternErrors = function(J, Q) {
			if (!J) return;
			if (J.trailingComma > -1) this.raiseRecoverable(J.trailingComma,
				"Comma is not permitted after the rest element");
			var Z = Q ? J.parenthesizedAssign : J.parenthesizedBind;
			if (Z > -1) this.raiseRecoverable(Z, Q ? "Assigning to rvalue" : "Parenthesized pattern")
		}, A.checkExpressionErrors = function(J, Q) {
			if (!J) return !1;
			var {
				shorthandAssign: Z,
				doubleProto: q
			} = J;
			if (!Q) return Z >= 0 || q >= 0;
			if (Z >= 0) this.raise(Z,
			"Shorthand property assignments are valid only in destructuring patterns");
			if (q >= 0) this.raiseRecoverable(q, "Redefinition of __proto__ property")
		}, A.checkYieldAwaitInDefaultParams = function() {
			if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos,
				"Yield expression cannot be a default value");
			if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value")
		}, A.isSimpleAssignTarget = function(J) {
			if (J.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(J.expression);
			return J.type === "Identifier" || J.type === "MemberExpression"
		};
		var G = $.prototype;
		G.parseTopLevel = function(J) {
			var Q = Object.create(null);
			if (!J.body) J.body = [];
			while (this.type !== W.eof) {
				var Z = this.parseStatement(null, !0, Q);
				J.body.push(Z)
			}
			if (this.inModule)
				for (var q = 0, X = Object.keys(this.undefinedExports); q < X.length; q += 1) {
					var Y = X[q];
					this.raiseRecoverable(this.undefinedExports[Y].start, "Export '" + Y + "' is not defined")
				}
			return this.adaptDirectivePrologue(J.body), this.next(), J.sourceType = this.options.sourceType,
				this.finishNode(J, "Program")
		};
		var CJ = {
				kind: "loop"
			},
			LQ = {
				kind: "switch"
			};
		G.isLet = function(J) {
			if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
			I.lastIndex = this.pos;
			var Q = I.exec(this.input),
				Z = this.pos + Q[0].length,
				q = this.input.charCodeAt(Z);
			if (q === 91 || q === 92) return !0;
			if (J) return !1;
			if (q === 123 || q > 55295 && q < 56320) return !0;
			if (T(q, !0)) {
				var X = Z + 1;
				while (x(q = this.input.charCodeAt(X), !0)) ++X;
				if (q === 92 || q > 55295 && q < 56320) return !0;
				var Y = this.input.slice(Z, X);
				if (!NQ.test(Y)) return !0
			}
			return !1
		}, G.isAsyncFunction = function() {
			if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
			I.lastIndex = this.pos;
			var J = I.exec(this.input),
				Q = this.pos + J[0].length,
				Z;
			return !b.test(this.input.slice(this.pos, Q)) && this.input.slice(Q, Q + 8) === "function" && (Q +
				8 === this.input.length || !(x(Z = this.input.charCodeAt(Q + 8)) || Z > 55295 && Z < 56320))
		}, G.isUsingKeyword = function(J, Q) {
			if (this.options.ecmaVersion < 17 || !this.isContextual(J ? "await" : "using")) return !1;
			I.lastIndex = this.pos;
			var Z = I.exec(this.input),
				q = this.pos + Z[0].length;
			if (b.test(this.input.slice(this.pos, q))) return !1;
			if (J) {
				var X = q + 5,
					Y;
				if (this.input.slice(q, X) !== "using" || X === this.input.length || x(Y = this.input
						.charCodeAt(X)) || Y > 55295 && Y < 56320) return !1;
				I.lastIndex = X;
				var j = I.exec(this.input);
				if (j && b.test(this.input.slice(X, X + j[0].length))) return !1
			}
			if (Q) {
				var H = q + 2,
					K;
				if (this.input.slice(q, H) === "of") {
					if (H === this.input.length || !x(K = this.input.charCodeAt(H)) && !(K > 55295 && K <
						56320)) return !1
				}
			}
			var R = this.input.charCodeAt(q);
			return T(R, !0) || R === 92
		}, G.isAwaitUsing = function(J) {
			return this.isUsingKeyword(!0, J)
		}, G.isUsing = function(J) {
			return this.isUsingKeyword(!1, J)
		}, G.parseStatement = function(J, Q, Z) {
			var q = this.type,
				X = this.startNode(),
				Y;
			if (this.isLet(J)) q = W._var, Y = "let";
			switch (q) {
				case W._break:
				case W._continue:
					return this.parseBreakContinueStatement(X, q.keyword);
				case W._debugger:
					return this.parseDebuggerStatement(X);
				case W._do:
					return this.parseDoStatement(X);
				case W._for:
					return this.parseForStatement(X);
				case W._function:
					if (J && (this.strict || J !== "if" && J !== "label") && this.options.ecmaVersion >= 6) this
						.unexpected();
					return this.parseFunctionStatement(X, !1, !J);
				case W._class:
					if (J) this.unexpected();
					return this.parseClass(X, !0);
				case W._if:
					return this.parseIfStatement(X);
				case W._return:
					return this.parseReturnStatement(X);
				case W._switch:
					return this.parseSwitchStatement(X);
				case W._throw:
					return this.parseThrowStatement(X);
				case W._try:
					return this.parseTryStatement(X);
				case W._const:
				case W._var:
					if (Y = Y || this.value, J && Y !== "var") this.unexpected();
					return this.parseVarStatement(X, Y);
				case W._while:
					return this.parseWhileStatement(X);
				case W._with:
					return this.parseWithStatement(X);
				case W.braceL:
					return this.parseBlock(!0, X);
				case W.semi:
					return this.parseEmptyStatement(X);
				case W._export:
				case W._import:
					if (this.options.ecmaVersion > 10 && q === W._import) {
						I.lastIndex = this.pos;
						var j = I.exec(this.input),
							H = this.pos + j[0].length,
							K = this.input.charCodeAt(H);
						if (K === 40 || K === 46) return this.parseExpressionStatement(X, this
						.parseExpression())
					}
					if (!this.options.allowImportExportEverywhere) {
						if (!Q) this.raise(this.start,
						"'import' and 'export' may only appear at the top level");
						if (!this.inModule) this.raise(this.start,
							"'import' and 'export' may appear only with 'sourceType: module'")
					}
					return q === W._import ? this.parseImport(X) : this.parseExport(X, Z);
				default:
					if (this.isAsyncFunction()) {
						if (J) this.unexpected();
						return this.next(), this.parseFunctionStatement(X, !0, !J)
					}
					var R = this.isAwaitUsing(!1) ? "await using" : this.isUsing(!1) ? "using" : null;
					if (R) {
						if (Q && this.options.sourceType === "script") this.raise(this.start,
							"Using declaration cannot appear in the top level when source type is `script`");
						if (R === "await using") {
							if (!this.canAwait) this.raise(this.start,
								"Await using cannot appear outside of async function");
							this.next()
						}
						return this.next(), this.parseVar(X, !1, R), this.semicolon(), this.finishNode(X,
							"VariableDeclaration")
					}
					var M = this.value,
						N = this.parseExpression();
					if (q === W.name && N.type === "Identifier" && this.eat(W.colon)) return this
						.parseLabeledStatement(X, M, N, J);
					else return this.parseExpressionStatement(X, N)
			}
		}, G.parseBreakContinueStatement = function(J, Q) {
			var Z = Q === "break";
			if (this.next(), this.eat(W.semi) || this.insertSemicolon()) J.label = null;
			else if (this.type !== W.name) this.unexpected();
			else J.label = this.parseIdent(), this.semicolon();
			var q = 0;
			for (; q < this.labels.length; ++q) {
				var X = this.labels[q];
				if (J.label == null || X.name === J.label.name) {
					if (X.kind != null && (Z || X.kind === "loop")) break;
					if (J.label && Z) break
				}
			}
			if (q === this.labels.length) this.raise(J.start, "Unsyntactic " + Q);
			return this.finishNode(J, Z ? "BreakStatement" : "ContinueStatement")
		}, G.parseDebuggerStatement = function(J) {
			return this.next(), this.semicolon(), this.finishNode(J, "DebuggerStatement")
		}, G.parseDoStatement = function(J) {
			if (this.next(), this.labels.push(CJ), J.body = this.parseStatement("do"), this.labels.pop(), this
				.expect(W._while), J.test = this.parseParenExpression(), this.options.ecmaVersion >= 6) this
				.eat(W.semi);
			else this.semicolon();
			return this.finishNode(J, "DoWhileStatement")
		}, G.parseForStatement = function(J) {
			this.next();
			var Q = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this
				.lastTokStart : -1;
			if (this.labels.push(CJ), this.enterScope(0), this.expect(W.parenL), this.type === W.semi) {
				if (Q > -1) this.unexpected(Q);
				return this.parseFor(J, null)
			}
			var Z = this.isLet();
			if (this.type === W._var || this.type === W._const || Z) {
				var q = this.startNode(),
					X = Z ? "let" : this.value;
				return this.next(), this.parseVar(q, !0, X), this.finishNode(q, "VariableDeclaration"), this
					.parseForAfterInit(J, q, Q)
			}
			var Y = this.isContextual("let"),
				j = !1,
				H = this.isUsing(!0) ? "using" : this.isAwaitUsing(!0) ? "await using" : null;
			if (H) {
				var K = this.startNode();
				if (this.next(), H === "await using") this.next();
				return this.parseVar(K, !0, H), this.finishNode(K, "VariableDeclaration"), this
					.parseForAfterInit(J, K, Q)
			}
			var R = this.containsEsc,
				M = new KJ,
				N = this.start,
				v = Q > -1 ? this.parseExprSubscripts(M, "await") : this.parseExpression(!0, M);
			if (this.type === W._in || (j = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
				if (Q > -1) {
					if (this.type === W._in) this.unexpected(Q);
					J.await = !0
				} else if (j && this.options.ecmaVersion >= 8) {
					if (v.start === N && !R && v.type === "Identifier" && v.name === "async") this.unexpected();
					else if (this.options.ecmaVersion >= 9) J.await = !1
				}
				if (Y && j) this.raise(v.start,
				"The left-hand side of a for-of loop may not start with 'let'.");
				return this.toAssignable(v, !1, M), this.checkLValPattern(v), this.parseForIn(J, v)
			} else this.checkExpressionErrors(M, !0);
			if (Q > -1) this.unexpected(Q);
			return this.parseFor(J, v)
		}, G.parseForAfterInit = function(J, Q, Z) {
			if ((this.type === W._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && Q
				.declarations.length === 1) {
				if (this.options.ecmaVersion >= 9)
					if (this.type === W._in) {
						if (Z > -1) this.unexpected(Z)
					} else J.await = Z > -1;
				return this.parseForIn(J, Q)
			}
			if (Z > -1) this.unexpected(Z);
			return this.parseFor(J, Q)
		}, G.parseFunctionStatement = function(J, Q, Z) {
			return this.next(), this.parseFunction(J, JJ | (Z ? 0 : wJ), !1, Q)
		}, G.parseIfStatement = function(J) {
			return this.next(), J.test = this.parseParenExpression(), J.consequent = this.parseStatement("if"),
				J.alternate = this.eat(W._else) ? this.parseStatement("if") : null, this.finishNode(J,
					"IfStatement")
		}, G.parseReturnStatement = function(J) {
			if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start,
				"'return' outside of function");
			if (this.next(), this.eat(W.semi) || this.insertSemicolon()) J.argument = null;
			else J.argument = this.parseExpression(), this.semicolon();
			return this.finishNode(J, "ReturnStatement")
		}, G.parseSwitchStatement = function(J) {
			this.next(), J.discriminant = this.parseParenExpression(), J.cases = [], this.expect(W.braceL), this
				.labels.push(LQ), this.enterScope(0);
			var Q;
			for (var Z = !1; this.type !== W.braceR;)
				if (this.type === W._case || this.type === W._default) {
					var q = this.type === W._case;
					if (Q) this.finishNode(Q, "SwitchCase");
					if (J.cases.push(Q = this.startNode()), Q.consequent = [], this.next(), q) Q.test = this
						.parseExpression();
					else {
						if (Z) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
						Z = !0, Q.test = null
					}
					this.expect(W.colon)
				} else {
					if (!Q) this.unexpected();
					Q.consequent.push(this.parseStatement(null))
				} if (this.exitScope(), Q) this.finishNode(Q, "SwitchCase");
			return this.next(), this.labels.pop(), this.finishNode(J, "SwitchStatement")
		}, G.parseThrowStatement = function(J) {
			if (this.next(), b.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd,
				"Illegal newline after throw");
			return J.argument = this.parseExpression(), this.semicolon(), this.finishNode(J, "ThrowStatement")
		};
		var PQ = [];
		G.parseCatchClauseParam = function() {
			var J = this.parseBindingAtom(),
				Q = J.type === "Identifier";
			return this.enterScope(Q ? hJ : 0), this.checkLValPattern(J, Q ? lJ : m), this.expect(W.parenR), J
		}, G.parseTryStatement = function(J) {
			if (this.next(), J.block = this.parseBlock(), J.handler = null, this.type === W._catch) {
				var Q = this.startNode();
				if (this.next(), this.eat(W.parenL)) Q.param = this.parseCatchClauseParam();
				else {
					if (this.options.ecmaVersion < 10) this.unexpected();
					Q.param = null, this.enterScope(0)
				}
				Q.body = this.parseBlock(!1), this.exitScope(), J.handler = this.finishNode(Q, "CatchClause")
			}
			if (J.finalizer = this.eat(W._finally) ? this.parseBlock() : null, !J.handler && !J.finalizer) this
				.raise(J.start, "Missing catch or finally clause");
			return this.finishNode(J, "TryStatement")
		}, G.parseVarStatement = function(J, Q, Z) {
			return this.next(), this.parseVar(J, !1, Q, Z), this.semicolon(), this.finishNode(J,
				"VariableDeclaration")
		}, G.parseWhileStatement = function(J) {
			return this.next(), J.test = this.parseParenExpression(), this.labels.push(CJ), J.body = this
				.parseStatement("while"), this.labels.pop(), this.finishNode(J, "WhileStatement")
		}, G.parseWithStatement = function(J) {
			if (this.strict) this.raise(this.start, "'with' in strict mode");
			return this.next(), J.object = this.parseParenExpression(), J.body = this.parseStatement("with"),
				this.finishNode(J, "WithStatement")
		}, G.parseEmptyStatement = function(J) {
			return this.next(), this.finishNode(J, "EmptyStatement")
		}, G.parseLabeledStatement = function(J, Q, Z, q) {
			for (var X = 0, Y = this.labels; X < Y.length; X += 1) {
				var j = Y[X];
				if (j.name === Q) this.raise(Z.start, "Label '" + Q + "' is already declared")
			}
			var H = this.type.isLoop ? "loop" : this.type === W._switch ? "switch" : null;
			for (var K = this.labels.length - 1; K >= 0; K--) {
				var R = this.labels[K];
				if (R.statementStart === J.start) R.statementStart = this.start, R.kind = H;
				else break
			}
			return this.labels.push({
					name: Q,
					kind: H,
					statementStart: this.start
				}), J.body = this.parseStatement(q ? q.indexOf("label") === -1 ? q + "label" : q : "label"),
				this.labels.pop(), J.label = Z, this.finishNode(J, "LabeledStatement")
		}, G.parseExpressionStatement = function(J, Q) {
			return J.expression = Q, this.semicolon(), this.finishNode(J, "ExpressionStatement")
		}, G.parseBlock = function(J, Q, Z) {
			if (J === void 0) J = !0;
			if (Q === void 0) Q = this.startNode();
			if (Q.body = [], this.expect(W.braceL), J) this.enterScope(0);
			while (this.type !== W.braceR) {
				var q = this.parseStatement(null);
				Q.body.push(q)
			}
			if (Z) this.strict = !1;
			if (this.next(), J) this.exitScope();
			return this.finishNode(Q, "BlockStatement")
		}, G.parseFor = function(J, Q) {
			return J.init = Q, this.expect(W.semi), J.test = this.type === W.semi ? null : this
				.parseExpression(), this.expect(W.semi), J.update = this.type === W.parenR ? null : this
				.parseExpression(), this.expect(W.parenR), J.body = this.parseStatement("for"), this
			.exitScope(), this.labels.pop(), this.finishNode(J, "ForStatement")
		}, G.parseForIn = function(J, Q) {
			var Z = this.type === W._in;
			if (this.next(), Q.type === "VariableDeclaration" && Q.declarations[0].init != null && (!Z || this
					.options.ecmaVersion < 8 || this.strict || Q.kind !== "var" || Q.declarations[0].id.type !==
					"Identifier")) this.raise(Q.start, (Z ? "for-in" : "for-of") +
				" loop variable declaration may not have an initializer");
			return J.left = Q, J.right = Z ? this.parseExpression() : this.parseMaybeAssign(), this.expect(W
					.parenR), J.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this
				.finishNode(J, Z ? "ForInStatement" : "ForOfStatement")
		}, G.parseVar = function(J, Q, Z, q) {
			J.declarations = [], J.kind = Z;
			for (;;) {
				var X = this.startNode();
				if (this.parseVarId(X, Z), this.eat(W.eq)) X.init = this.parseMaybeAssign(Q);
				else if (!q && Z === "const" && !(this.type === W._in || this.options.ecmaVersion >= 6 && this
						.isContextual("of"))) this.unexpected();
				else if (!q && (Z === "using" || Z === "await using") && this.options.ecmaVersion >= 17 && this
					.type !== W._in && !this.isContextual("of")) this.raise(this.lastTokEnd,
					"Missing initializer in " + Z + " declaration");
				else if (!q && X.id.type !== "Identifier" && !(Q && (this.type === W._in || this.isContextual(
						"of")))) this.raise(this.lastTokEnd,
					"Complex binding patterns require an initialization value");
				else X.init = null;
				if (J.declarations.push(this.finishNode(X, "VariableDeclarator")), !this.eat(W.comma)) break
			}
			return J
		}, G.parseVarId = function(J, Q) {
			J.id = Q === "using" || Q === "await using" ? this.parseIdent() : this.parseBindingAtom(), this
				.checkLValPattern(J.id, Q === "var" ? AJ : m, !1)
		};
		var JJ = 1,
			wJ = 2,
			cJ = 4;
		G.parseFunction = function(J, Q, Z, q, X) {
			if (this.initFunction(J), this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !q) {
				if (this.type === W.star && Q & wJ) this.unexpected();
				J.generator = this.eat(W.star)
			}
			if (this.options.ecmaVersion >= 8) J.async = !!q;
			if (Q & JJ) {
				if (J.id = Q & cJ && this.type !== W.name ? null : this.parseIdent(), J.id && !(Q & wJ)) this
					.checkLValSimple(J.id, this.strict || J.generator || J.async ? this.treatFunctionsAsVar ?
						AJ : m : uJ)
			}
			var Y = this.yieldPos,
				j = this.awaitPos,
				H = this.awaitIdentPos;
			if (this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(bJ(J.async, J
					.generator)), !(Q & JJ)) J.id = this.type === W.name ? this.parseIdent() : null;
			return this.parseFunctionParams(J), this.parseFunctionBody(J, Z, !1, X), this.yieldPos = Y, this
				.awaitPos = j, this.awaitIdentPos = H, this.finishNode(J, Q & JJ ? "FunctionDeclaration" :
					"FunctionExpression")
		}, G.parseFunctionParams = function(J) {
			this.expect(W.parenL), J.params = this.parseBindingList(W.parenR, !1, this.options.ecmaVersion >=
				8), this.checkYieldAwaitInDefaultParams()
		}, G.parseClass = function(J, Q) {
			this.next();
			var Z = this.strict;
			this.strict = !0, this.parseClassId(J, Q), this.parseClassSuper(J);
			var q = this.enterClassBody(),
				X = this.startNode(),
				Y = !1;
			X.body = [], this.expect(W.braceL);
			while (this.type !== W.braceR) {
				var j = this.parseClassElement(J.superClass !== null);
				if (j) {
					if (X.body.push(j), j.type === "MethodDefinition" && j.kind === "constructor") {
						if (Y) this.raiseRecoverable(j.start, "Duplicate constructor in the same class");
						Y = !0
					} else if (j.key && j.key.type === "PrivateIdentifier" && kQ(q, j)) this.raiseRecoverable(j
						.key.start, "Identifier '#" + j.key.name + "' has already been declared")
				}
			}
			return this.strict = Z, this.next(), J.body = this.finishNode(X, "ClassBody"), this.exitClassBody(),
				this.finishNode(J, Q ? "ClassDeclaration" : "ClassExpression")
		}, G.parseClassElement = function(J) {
			if (this.eat(W.semi)) return null;
			var Q = this.options.ecmaVersion,
				Z = this.startNode(),
				q = "",
				X = !1,
				Y = !1,
				j = "method",
				H = !1;
			if (this.eatContextual("static")) {
				if (Q >= 13 && this.eat(W.braceL)) return this.parseClassStaticBlock(Z), Z;
				if (this.isClassElementNameStart() || this.type === W.star) H = !0;
				else q = "static"
			}
			if (Z.static = H, !q && Q >= 8 && this.eatContextual("async"))
				if ((this.isClassElementNameStart() || this.type === W.star) && !this.canInsertSemicolon())
					Y = !0;
				else q = "async";
			if (!q && (Q >= 9 || !Y) && this.eat(W.star)) X = !0;
			if (!q && !Y && !X) {
				var K = this.value;
				if (this.eatContextual("get") || this.eatContextual("set"))
					if (this.isClassElementNameStart()) j = K;
					else q = K
			}
			if (q) Z.computed = !1, Z.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), Z.key
				.name = q, this.finishNode(Z.key, "Identifier");
			else this.parseClassElementName(Z);
			if (Q < 13 || this.type === W.parenL || j !== "method" || X || Y) {
				var R = !Z.static && zJ(Z, "constructor"),
					M = R && J;
				if (R && j !== "method") this.raise(Z.key.start, "Constructor can't have get/set modifier");
				Z.kind = R ? "constructor" : j, this.parseClassMethod(Z, X, Y, M)
			} else this.parseClassField(Z);
			return Z
		}, G.isClassElementNameStart = function() {
			return this.type === W.name || this.type === W.privateId || this.type === W.num || this.type === W
				.string || this.type === W.bracketL || this.type.keyword
		}, G.parseClassElementName = function(J) {
			if (this.type === W.privateId) {
				if (this.value === "constructor") this.raise(this.start,
					"Classes can't have an element named '#constructor'");
				J.computed = !1, J.key = this.parsePrivateIdent()
			} else this.parsePropertyName(J)
		}, G.parseClassMethod = function(J, Q, Z, q) {
			var X = J.key;
			if (J.kind === "constructor") {
				if (Q) this.raise(X.start, "Constructor can't be a generator");
				if (Z) this.raise(X.start, "Constructor can't be an async method")
			} else if (J.static && zJ(J, "prototype")) this.raise(X.start,
				"Classes may not have a static property named prototype");
			var Y = J.value = this.parseMethod(Q, Z, q);
			if (J.kind === "get" && Y.params.length !== 0) this.raiseRecoverable(Y.start,
				"getter should have no params");
			if (J.kind === "set" && Y.params.length !== 1) this.raiseRecoverable(Y.start,
				"setter should have exactly one param");
			if (J.kind === "set" && Y.params[0].type === "RestElement") this.raiseRecoverable(Y.params[0].start,
				"Setter cannot use rest params");
			return this.finishNode(J, "MethodDefinition")
		}, G.parseClassField = function(J) {
			if (zJ(J, "constructor")) this.raise(J.key.start, "Classes can't have a field named 'constructor'");
			else if (J.static && zJ(J, "prototype")) this.raise(J.key.start,
				"Classes can't have a static field named 'prototype'");
			if (this.eat(W.eq)) this.enterScope(e | YJ), J.value = this.parseMaybeAssign(), this.exitScope();
			else J.value = null;
			return this.semicolon(), this.finishNode(J, "PropertyDefinition")
		}, G.parseClassStaticBlock = function(J) {
			J.body = [];
			var Q = this.labels;
			this.labels = [], this.enterScope(p | YJ);
			while (this.type !== W.braceR) {
				var Z = this.parseStatement(null);
				J.body.push(Z)
			}
			return this.next(), this.exitScope(), this.labels = Q, this.finishNode(J, "StaticBlock")
		}, G.parseClassId = function(J, Q) {
			if (this.type === W.name) {
				if (J.id = this.parseIdent(), Q) this.checkLValSimple(J.id, m, !1)
			} else {
				if (Q === !0) this.unexpected();
				J.id = null
			}
		}, G.parseClassSuper = function(J) {
			J.superClass = this.eat(W._extends) ? this.parseExprSubscripts(null, !1) : null
		}, G.enterClassBody = function() {
			var J = {
				declared: Object.create(null),
				used: []
			};
			return this.privateNameStack.push(J), J.declared
		}, G.exitClassBody = function() {
			var J = this.privateNameStack.pop(),
				Q = J.declared,
				Z = J.used;
			if (!this.options.checkPrivateFields) return;
			var q = this.privateNameStack.length,
				X = q === 0 ? null : this.privateNameStack[q - 1];
			for (var Y = 0; Y < Z.length; ++Y) {
				var j = Z[Y];
				if (!c(Q, j.name))
					if (X) X.used.push(j);
					else this.raiseRecoverable(j.start, "Private field '#" + j.name +
						"' must be declared in an enclosing class")
			}
		};

		function kQ(J, Q) {
			var Z = Q.key.name,
				q = J[Z],
				X = "true";
			if (Q.type === "MethodDefinition" && (Q.kind === "get" || Q.kind === "set")) X = (Q.static ? "s" :
				"i") + Q.kind;
			if (q === "iget" && X === "iset" || q === "iset" && X === "iget" || q === "sget" && X === "sset" ||
				q === "sset" && X === "sget") return J[Z] = "true", !1;
			else if (!q) return J[Z] = X, !1;
			else return !0
		}

		function zJ(J, Q) {
			var {
				computed: Z,
				key: q
			} = J;
			return !Z && (q.type === "Identifier" && q.name === Q || q.type === "Literal" && q.value === Q)
		}
		G.parseExportAllDeclaration = function(J, Q) {
			if (this.options.ecmaVersion >= 11)
				if (this.eatContextual("as")) J.exported = this.parseModuleExportName(), this.checkExport(Q, J
					.exported, this.lastTokStart);
				else J.exported = null;
			if (this.expectContextual("from"), this.type !== W.string) this.unexpected();
			if (J.source = this.parseExprAtom(), this.options.ecmaVersion >= 16) J.attributes = this
				.parseWithClause();
			return this.semicolon(), this.finishNode(J, "ExportAllDeclaration")
		}, G.parseExport = function(J, Q) {
			if (this.next(), this.eat(W.star)) return this.parseExportAllDeclaration(J, Q);
			if (this.eat(W._default)) return this.checkExport(Q, "default", this.lastTokStart), J.declaration =
				this.parseExportDefaultDeclaration(), this.finishNode(J, "ExportDefaultDeclaration");
			if (this.shouldParseExportStatement()) {
				if (J.declaration = this.parseExportDeclaration(J), J.declaration.type ===
					"VariableDeclaration") this.checkVariableExport(Q, J.declaration.declarations);
				else this.checkExport(Q, J.declaration.id, J.declaration.id.start);
				if (J.specifiers = [], J.source = null, this.options.ecmaVersion >= 16) J.attributes = []
			} else {
				if (J.declaration = null, J.specifiers = this.parseExportSpecifiers(Q), this.eatContextual(
						"from")) {
					if (this.type !== W.string) this.unexpected();
					if (J.source = this.parseExprAtom(), this.options.ecmaVersion >= 16) J.attributes = this
						.parseWithClause()
				} else {
					for (var Z = 0, q = J.specifiers; Z < q.length; Z += 1) {
						var X = q[Z];
						if (this.checkUnreserved(X.local), this.checkLocalExport(X.local), X.local.type ===
							"Literal") this.raise(X.local.start,
							"A string literal cannot be used as an exported binding without `from`.")
					}
					if (J.source = null, this.options.ecmaVersion >= 16) J.attributes = []
				}
				this.semicolon()
			}
			return this.finishNode(J, "ExportNamedDeclaration")
		}, G.parseExportDeclaration = function(J) {
			return this.parseStatement(null)
		}, G.parseExportDefaultDeclaration = function() {
			var J;
			if (this.type === W._function || (J = this.isAsyncFunction())) {
				var Q = this.startNode();
				if (this.next(), J) this.next();
				return this.parseFunction(Q, JJ | cJ, !1, J)
			} else if (this.type === W._class) {
				var Z = this.startNode();
				return this.parseClass(Z, "nullableID")
			} else {
				var q = this.parseMaybeAssign();
				return this.semicolon(), q
			}
		}, G.checkExport = function(J, Q, Z) {
			if (!J) return;
			if (typeof Q !== "string") Q = Q.type === "Identifier" ? Q.name : Q.value;
			if (c(J, Q)) this.raiseRecoverable(Z, "Duplicate export '" + Q + "'");
			J[Q] = !0
		}, G.checkPatternExport = function(J, Q) {
			var Z = Q.type;
			if (Z === "Identifier") this.checkExport(J, Q, Q.start);
			else if (Z === "ObjectPattern")
				for (var q = 0, X = Q.properties; q < X.length; q += 1) {
					var Y = X[q];
					this.checkPatternExport(J, Y)
				} else if (Z === "ArrayPattern")
					for (var j = 0, H = Q.elements; j < H.length; j += 1) {
						var K = H[j];
						if (K) this.checkPatternExport(J, K)
					} else if (Z === "Property") this.checkPatternExport(J, Q.value);
					else if (Z === "AssignmentPattern") this.checkPatternExport(J, Q.left);
			else if (Z === "RestElement") this.checkPatternExport(J, Q.argument)
		}, G.checkVariableExport = function(J, Q) {
			if (!J) return;
			for (var Z = 0, q = Q; Z < q.length; Z += 1) {
				var X = q[Z];
				this.checkPatternExport(J, X.id)
			}
		}, G.shouldParseExportStatement = function() {
			return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword ===
				"class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction()
		}, G.parseExportSpecifier = function(J) {
			var Q = this.startNode();
			return Q.local = this.parseModuleExportName(), Q.exported = this.eatContextual("as") ? this
				.parseModuleExportName() : Q.local, this.checkExport(J, Q.exported, Q.exported.start), this
				.finishNode(Q, "ExportSpecifier")
		}, G.parseExportSpecifiers = function(J) {
			var Q = [],
				Z = !0;
			this.expect(W.braceL);
			while (!this.eat(W.braceR)) {
				if (!Z) {
					if (this.expect(W.comma), this.afterTrailingComma(W.braceR)) break
				} else Z = !1;
				Q.push(this.parseExportSpecifier(J))
			}
			return Q
		}, G.parseImport = function(J) {
			if (this.next(), this.type === W.string) J.specifiers = PQ, J.source = this.parseExprAtom();
			else J.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), J.source = this
				.type === W.string ? this.parseExprAtom() : this.unexpected();
			if (this.options.ecmaVersion >= 16) J.attributes = this.parseWithClause();
			return this.semicolon(), this.finishNode(J, "ImportDeclaration")
		}, G.parseImportSpecifier = function() {
			var J = this.startNode();
			if (J.imported = this.parseModuleExportName(), this.eatContextual("as")) J.local = this
		.parseIdent();
			else this.checkUnreserved(J.imported), J.local = J.imported;
			return this.checkLValSimple(J.local, m), this.finishNode(J, "ImportSpecifier")
		}, G.parseImportDefaultSpecifier = function() {
			var J = this.startNode();
			return J.local = this.parseIdent(), this.checkLValSimple(J.local, m), this.finishNode(J,
				"ImportDefaultSpecifier")
		}, G.parseImportNamespaceSpecifier = function() {
			var J = this.startNode();
			return this.next(), this.expectContextual("as"), J.local = this.parseIdent(), this.checkLValSimple(J
				.local, m), this.finishNode(J, "ImportNamespaceSpecifier")
		}, G.parseImportSpecifiers = function() {
			var J = [],
				Q = !0;
			if (this.type === W.name) {
				if (J.push(this.parseImportDefaultSpecifier()), !this.eat(W.comma)) return J
			}
			if (this.type === W.star) return J.push(this.parseImportNamespaceSpecifier()), J;
			this.expect(W.braceL);
			while (!this.eat(W.braceR)) {
				if (!Q) {
					if (this.expect(W.comma), this.afterTrailingComma(W.braceR)) break
				} else Q = !1;
				J.push(this.parseImportSpecifier())
			}
			return J
		}, G.parseWithClause = function() {
			var J = [];
			if (!this.eat(W._with)) return J;
			this.expect(W.braceL);
			var Q = {},
				Z = !0;
			while (!this.eat(W.braceR)) {
				if (!Z) {
					if (this.expect(W.comma), this.afterTrailingComma(W.braceR)) break
				} else Z = !1;
				var q = this.parseImportAttribute(),
					X = q.key.type === "Identifier" ? q.key.name : q.key.value;
				if (c(Q, X)) this.raiseRecoverable(q.key.start, "Duplicate attribute key '" + X + "'");
				Q[X] = !0, J.push(q)
			}
			return J
		}, G.parseImportAttribute = function() {
			var J = this.startNode();
			if (J.key = this.type === W.string ? this.parseExprAtom() : this.parseIdent(this.options
					.allowReserved !== "never"), this.expect(W.colon), this.type !== W.string) this
		.unexpected();
			return J.value = this.parseExprAtom(), this.finishNode(J, "ImportAttribute")
		}, G.parseModuleExportName = function() {
			if (this.options.ecmaVersion >= 13 && this.type === W.string) {
				var J = this.parseLiteral(this.value);
				if (AQ.test(J.value)) this.raise(J.start, "An export name cannot include a lone surrogate.");
				return J
			}
			return this.parseIdent(!0)
		}, G.adaptDirectivePrologue = function(J) {
			for (var Q = 0; Q < J.length && this.isDirectiveCandidate(J[Q]); ++Q) J[Q].directive = J[Q]
				.expression.raw.slice(1, -1)
		}, G.isDirectiveCandidate = function(J) {
			return this.options.ecmaVersion >= 5 && J.type === "ExpressionStatement" && J.expression.type ===
				"Literal" && typeof J.expression.value === "string" && (this.input[J.start] === '"' || this
					.input[J.start] === "'")
		};
		var L = $.prototype;
		L.toAssignable = function(J, Q, Z) {
			if (this.options.ecmaVersion >= 6 && J) switch (J.type) {
				case "Identifier":
					if (this.inAsync && J.name === "await") this.raise(J.start,
						"Cannot use 'await' as identifier inside an async function");
					break;
				case "ObjectPattern":
				case "ArrayPattern":
				case "AssignmentPattern":
				case "RestElement":
					break;
				case "ObjectExpression":
					if (J.type = "ObjectPattern", Z) this.checkPatternErrors(Z, !0);
					for (var q = 0, X = J.properties; q < X.length; q += 1) {
						var Y = X[q];
						if (this.toAssignable(Y, Q), Y.type === "RestElement" && (Y.argument.type ===
								"ArrayPattern" || Y.argument.type === "ObjectPattern")) this.raise(Y
							.argument.start, "Unexpected token")
					}
					break;
				case "Property":
					if (J.kind !== "init") this.raise(J.key.start,
						"Object pattern can't contain getter or setter");
					this.toAssignable(J.value, Q);
					break;
				case "ArrayExpression":
					if (J.type = "ArrayPattern", Z) this.checkPatternErrors(Z, !0);
					this.toAssignableList(J.elements, Q);
					break;
				case "SpreadElement":
					if (J.type = "RestElement", this.toAssignable(J.argument, Q), J.argument.type ===
						"AssignmentPattern") this.raise(J.argument.start,
						"Rest elements cannot have a default value");
					break;
				case "AssignmentExpression":
					if (J.operator !== "=") this.raise(J.left.end,
						"Only '=' operator can be used for specifying default value.");
					J.type = "AssignmentPattern", delete J.operator, this.toAssignable(J.left, Q);
					break;
				case "ParenthesizedExpression":
					this.toAssignable(J.expression, Q, Z);
					break;
				case "ChainExpression":
					this.raiseRecoverable(J.start, "Optional chaining cannot appear in left-hand side");
					break;
				case "MemberExpression":
					if (!Q) break;
				default:
					this.raise(J.start, "Assigning to rvalue")
			} else if (Z) this.checkPatternErrors(Z, !0);
			return J
		}, L.toAssignableList = function(J, Q) {
			var Z = J.length;
			for (var q = 0; q < Z; q++) {
				var X = J[q];
				if (X) this.toAssignable(X, Q)
			}
			if (Z) {
				var Y = J[Z - 1];
				if (this.options.ecmaVersion === 6 && Q && Y && Y.type === "RestElement" && Y.argument.type !==
					"Identifier") this.unexpected(Y.argument.start)
			}
			return J
		}, L.parseSpread = function(J) {
			var Q = this.startNode();
			return this.next(), Q.argument = this.parseMaybeAssign(!1, J), this.finishNode(Q, "SpreadElement")
		}, L.parseRestBinding = function() {
			var J = this.startNode();
			if (this.next(), this.options.ecmaVersion === 6 && this.type !== W.name) this.unexpected();
			return J.argument = this.parseBindingAtom(), this.finishNode(J, "RestElement")
		}, L.parseBindingAtom = function() {
			if (this.options.ecmaVersion >= 6) switch (this.type) {
				case W.bracketL:
					var J = this.startNode();
					return this.next(), J.elements = this.parseBindingList(W.bracketR, !0, !0), this
						.finishNode(J, "ArrayPattern");
				case W.braceL:
					return this.parseObj(!0)
			}
			return this.parseIdent()
		}, L.parseBindingList = function(J, Q, Z, q) {
			var X = [],
				Y = !0;
			while (!this.eat(J)) {
				if (Y) Y = !1;
				else this.expect(W.comma);
				if (Q && this.type === W.comma) X.push(null);
				else if (Z && this.afterTrailingComma(J)) break;
				else if (this.type === W.ellipsis) {
					var j = this.parseRestBinding();
					if (this.parseBindingListItem(j), X.push(j), this.type === W.comma) this.raiseRecoverable(
						this.start, "Comma is not permitted after the rest element");
					this.expect(J);
					break
				} else X.push(this.parseAssignableListItem(q))
			}
			return X
		}, L.parseAssignableListItem = function(J) {
			var Q = this.parseMaybeDefault(this.start, this.startLoc);
			return this.parseBindingListItem(Q), Q
		}, L.parseBindingListItem = function(J) {
			return J
		}, L.parseMaybeDefault = function(J, Q, Z) {
			if (Z = Z || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(W.eq)) return Z;
			var q = this.startNodeAt(J, Q);
			return q.left = Z, q.right = this.parseMaybeAssign(), this.finishNode(q, "AssignmentPattern")
		}, L.checkLValSimple = function(J, Q, Z) {
			if (Q === void 0) Q = HJ;
			var q = Q !== HJ;
			switch (J.type) {
				case "Identifier":
					if (this.strict && this.reservedWordsStrictBind.test(J.name)) this.raiseRecoverable(J.start,
						(q ? "Binding " : "Assigning to ") + J.name + " in strict mode");
					if (q) {
						if (Q === m && J.name === "let") this.raiseRecoverable(J.start,
							"let is disallowed as a lexically bound name");
						if (Z) {
							if (c(Z, J.name)) this.raiseRecoverable(J.start, "Argument name clash");
							Z[J.name] = !0
						}
						if (Q !== pJ) this.declareName(J.name, Q, J.start)
					}
					break;
				case "ChainExpression":
					this.raiseRecoverable(J.start, "Optional chaining cannot appear in left-hand side");
					break;
				case "MemberExpression":
					if (q) this.raiseRecoverable(J.start, "Binding member expression");
					break;
				case "ParenthesizedExpression":
					if (q) this.raiseRecoverable(J.start, "Binding parenthesized expression");
					return this.checkLValSimple(J.expression, Q, Z);
				default:
					this.raise(J.start, (q ? "Binding" : "Assigning to") + " rvalue")
			}
		}, L.checkLValPattern = function(J, Q, Z) {
			if (Q === void 0) Q = HJ;
			switch (J.type) {
				case "ObjectPattern":
					for (var q = 0, X = J.properties; q < X.length; q += 1) {
						var Y = X[q];
						this.checkLValInnerPattern(Y, Q, Z)
					}
					break;
				case "ArrayPattern":
					for (var j = 0, H = J.elements; j < H.length; j += 1) {
						var K = H[j];
						if (K) this.checkLValInnerPattern(K, Q, Z)
					}
					break;
				default:
					this.checkLValSimple(J, Q, Z)
			}
		}, L.checkLValInnerPattern = function(J, Q, Z) {
			if (Q === void 0) Q = HJ;
			switch (J.type) {
				case "Property":
					this.checkLValInnerPattern(J.value, Q, Z);
					break;
				case "AssignmentPattern":
					this.checkLValPattern(J.left, Q, Z);
					break;
				case "RestElement":
					this.checkLValPattern(J.argument, Q, Z);
					break;
				default:
					this.checkLValPattern(J, Q, Z)
			}
		};
		var P = function J(Q, Z, q, X, Y) {
				this.token = Q, this.isExpr = !!Z, this.preserveSpace = !!q, this.override = X, this.generator = !!Y
			},
			U = {
				b_stat: new P("{", !1),
				b_expr: new P("{", !0),
				b_tmpl: new P("${", !1),
				p_stat: new P("(", !1),
				p_expr: new P("(", !0),
				q_tmpl: new P("`", !0, !0, function(J) {
					return J.tryReadTemplateToken()
				}),
				f_stat: new P("function", !1),
				f_expr: new P("function", !0),
				f_expr_gen: new P("function", !0, !1, null, !0),
				f_gen: new P("function", !1, !1, null, !0)
			},
			n = $.prototype;
		n.initialContext = function() {
				return [U.b_stat]
			}, n.curContext = function() {
				return this.context[this.context.length - 1]
			}, n.braceIsBlock = function(J) {
				var Q = this.curContext();
				if (Q === U.f_expr || Q === U.f_stat) return !0;
				if (J === W.colon && (Q === U.b_stat || Q === U.b_expr)) return !Q.isExpr;
				if (J === W._return || J === W.name && this.exprAllowed) return b.test(this.input.slice(this
					.lastTokEnd, this.start));
				if (J === W._else || J === W.semi || J === W.eof || J === W.parenR || J === W.arrow) return !0;
				if (J === W.braceL) return Q === U.b_stat;
				if (J === W._var || J === W._const || J === W.name) return !1;
				return !this.exprAllowed
			}, n.inGeneratorContext = function() {
				for (var J = this.context.length - 1; J >= 1; J--) {
					var Q = this.context[J];
					if (Q.token === "function") return Q.generator
				}
				return !1
			}, n.updateContext = function(J) {
				var Q, Z = this.type;
				if (Z.keyword && J === W.dot) this.exprAllowed = !1;
				else if (Q = Z.updateContext) Q.call(this, J);
				else this.exprAllowed = Z.beforeExpr
			}, n.overrideContext = function(J) {
				if (this.curContext() !== J) this.context[this.context.length - 1] = J
			}, W.parenR.updateContext = W.braceR.updateContext = function() {
				if (this.context.length === 1) {
					this.exprAllowed = !0;
					return
				}
				var J = this.context.pop();
				if (J === U.b_stat && this.curContext().token === "function") J = this.context.pop();
				this.exprAllowed = !J.isExpr
			}, W.braceL.updateContext = function(J) {
				this.context.push(this.braceIsBlock(J) ? U.b_stat : U.b_expr), this.exprAllowed = !0
			}, W.dollarBraceL.updateContext = function() {
				this.context.push(U.b_tmpl), this.exprAllowed = !0
			}, W.parenL.updateContext = function(J) {
				var Q = J === W._if || J === W._for || J === W._with || J === W._while;
				this.context.push(Q ? U.p_stat : U.p_expr), this.exprAllowed = !0
			}, W.incDec.updateContext = function() {}, W._function.updateContext = W._class.updateContext =
			function(J) {
				if (J.beforeExpr && J !== W._else && !(J === W.semi && this.curContext() !== U.p_stat) && !(J === W
						._return && b.test(this.input.slice(this.lastTokEnd, this.start))) && !((J === W.colon ||
						J === W.braceL) && this.curContext() === U.b_stat)) this.context.push(U.f_expr);
				else this.context.push(U.f_stat);
				this.exprAllowed = !1
			}, W.colon.updateContext = function() {
				if (this.curContext().token === "function") this.context.pop();
				this.exprAllowed = !0
			}, W.backQuote.updateContext = function() {
				if (this.curContext() === U.q_tmpl) this.context.pop();
				else this.context.push(U.q_tmpl);
				this.exprAllowed = !1
			}, W.star.updateContext = function(J) {
				if (J === W._function) {
					var Q = this.context.length - 1;
					if (this.context[Q] === U.f_expr) this.context[Q] = U.f_expr_gen;
					else this.context[Q] = U.f_gen
				}
				this.exprAllowed = !0
			}, W.name.updateContext = function(J) {
				var Q = !1;
				if (this.options.ecmaVersion >= 6 && J !== W.dot) {
					if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this
						.inGeneratorContext()) Q = !0
				}
				this.exprAllowed = Q
			};
		var F = $.prototype;
		F.checkPropClash = function(J, Q, Z) {
			if (this.options.ecmaVersion >= 9 && J.type === "SpreadElement") return;
			if (this.options.ecmaVersion >= 6 && (J.computed || J.method || J.shorthand)) return;
			var q = J.key,
				X;
			switch (q.type) {
				case "Identifier":
					X = q.name;
					break;
				case "Literal":
					X = String(q.value);
					break;
				default:
					return
			}
			var Y = J.kind;
			if (this.options.ecmaVersion >= 6) {
				if (X === "__proto__" && Y === "init") {
					if (Q.proto)
						if (Z) {
							if (Z.doubleProto < 0) Z.doubleProto = q.start
						} else this.raiseRecoverable(q.start, "Redefinition of __proto__ property");
					Q.proto = !0
				}
				return
			}
			X = "$" + X;
			var j = Q[X];
			if (j) {
				var H;
				if (Y === "init") H = this.strict && j.init || j.get || j.set;
				else H = j.init || j[Y];
				if (H) this.raiseRecoverable(q.start, "Redefinition of property")
			} else j = Q[X] = {
				init: !1,
				get: !1,
				set: !1
			};
			j[Y] = !0
		}, F.parseExpression = function(J, Q) {
			var Z = this.start,
				q = this.startLoc,
				X = this.parseMaybeAssign(J, Q);
			if (this.type === W.comma) {
				var Y = this.startNodeAt(Z, q);
				Y.expressions = [X];
				while (this.eat(W.comma)) Y.expressions.push(this.parseMaybeAssign(J, Q));
				return this.finishNode(Y, "SequenceExpression")
			}
			return X
		}, F.parseMaybeAssign = function(J, Q, Z) {
			if (this.isContextual("yield"))
				if (this.inGenerator) return this.parseYield(J);
				else this.exprAllowed = !1;
			var q = !1,
				X = -1,
				Y = -1,
				j = -1;
			if (Q) X = Q.parenthesizedAssign, Y = Q.trailingComma, j = Q.doubleProto, Q.parenthesizedAssign = Q
				.trailingComma = -1;
			else Q = new KJ, q = !0;
			var H = this.start,
				K = this.startLoc;
			if (this.type === W.parenL || this.type === W.name) this.potentialArrowAt = this.start, this
				.potentialArrowInForAwait = J === "await";
			var R = this.parseMaybeConditional(J, Q);
			if (Z) R = Z.call(this, R, H, K);
			if (this.type.isAssign) {
				var M = this.startNodeAt(H, K);
				if (M.operator = this.value, this.type === W.eq) R = this.toAssignable(R, !1, Q);
				if (!q) Q.parenthesizedAssign = Q.trailingComma = Q.doubleProto = -1;
				if (Q.shorthandAssign >= R.start) Q.shorthandAssign = -1;
				if (this.type === W.eq) this.checkLValPattern(R);
				else this.checkLValSimple(R);
				if (M.left = R, this.next(), M.right = this.parseMaybeAssign(J), j > -1) Q.doubleProto = j;
				return this.finishNode(M, "AssignmentExpression")
			} else if (q) this.checkExpressionErrors(Q, !0);
			if (X > -1) Q.parenthesizedAssign = X;
			if (Y > -1) Q.trailingComma = Y;
			return R
		}, F.parseMaybeConditional = function(J, Q) {
			var Z = this.start,
				q = this.startLoc,
				X = this.parseExprOps(J, Q);
			if (this.checkExpressionErrors(Q)) return X;
			if (this.eat(W.question)) {
				var Y = this.startNodeAt(Z, q);
				return Y.test = X, Y.consequent = this.parseMaybeAssign(), this.expect(W.colon), Y.alternate =
					this.parseMaybeAssign(J), this.finishNode(Y, "ConditionalExpression")
			}
			return X
		}, F.parseExprOps = function(J, Q) {
			var Z = this.start,
				q = this.startLoc,
				X = this.parseMaybeUnary(Q, !1, !1, J);
			if (this.checkExpressionErrors(Q)) return X;
			return X.start === Z && X.type === "ArrowFunctionExpression" ? X : this.parseExprOp(X, Z, q, -1, J)
		}, F.parseExprOp = function(J, Q, Z, q, X) {
			var Y = this.type.binop;
			if (Y != null && (!X || this.type !== W._in)) {
				if (Y > q) {
					var j = this.type === W.logicalOR || this.type === W.logicalAND,
						H = this.type === W.coalesce;
					if (H) Y = W.logicalAND.binop;
					var K = this.value;
					this.next();
					var R = this.start,
						M = this.startLoc,
						N = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, X), R, M, Y, X),
						v = this.buildBinary(Q, Z, J, N, K, j || H);
					if (j && this.type === W.coalesce || H && (this.type === W.logicalOR || this.type === W
							.logicalAND)) this.raiseRecoverable(this.start,
						"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"
						);
					return this.parseExprOp(v, Q, Z, q, X)
				}
			}
			return J
		}, F.buildBinary = function(J, Q, Z, q, X, Y) {
			if (q.type === "PrivateIdentifier") this.raise(q.start,
				"Private identifier can only be left side of binary expression");
			var j = this.startNodeAt(J, Q);
			return j.left = Z, j.operator = X, j.right = q, this.finishNode(j, Y ? "LogicalExpression" :
				"BinaryExpression")
		}, F.parseMaybeUnary = function(J, Q, Z, q) {
			var X = this.start,
				Y = this.startLoc,
				j;
			if (this.isContextual("await") && this.canAwait) j = this.parseAwait(q), Q = !0;
			else if (this.type.prefix) {
				var H = this.startNode(),
					K = this.type === W.incDec;
				if (H.operator = this.value, H.prefix = !0, this.next(), H.argument = this.parseMaybeUnary(null,
						!0, K, q), this.checkExpressionErrors(J, !0), K) this.checkLValSimple(H.argument);
				else if (this.strict && H.operator === "delete" && dJ(H.argument)) this.raiseRecoverable(H
					.start, "Deleting local variable in strict mode");
				else if (H.operator === "delete" && SJ(H.argument)) this.raiseRecoverable(H.start,
					"Private fields can not be deleted");
				else Q = !0;
				j = this.finishNode(H, K ? "UpdateExpression" : "UnaryExpression")
			} else if (!Q && this.type === W.privateId) {
				if ((q || this.privateNameStack.length === 0) && this.options.checkPrivateFields) this
					.unexpected();
				if (j = this.parsePrivateIdent(), this.type !== W._in) this.unexpected()
			} else {
				if (j = this.parseExprSubscripts(J, q), this.checkExpressionErrors(J)) return j;
				while (this.type.postfix && !this.canInsertSemicolon()) {
					var R = this.startNodeAt(X, Y);
					R.operator = this.value, R.prefix = !1, R.argument = j, this.checkLValSimple(j), this
					.next(), j = this.finishNode(R, "UpdateExpression")
				}
			}
			if (!Z && this.eat(W.starstar))
				if (Q) this.unexpected(this.lastTokStart);
				else return this.buildBinary(X, Y, j, this.parseMaybeUnary(null, !1, !1, q), "**", !1);
			else return j
		};

		function dJ(J) {
			return J.type === "Identifier" || J.type === "ParenthesizedExpression" && dJ(J.expression)
		}

		function SJ(J) {
			return J.type === "MemberExpression" && J.property.type === "PrivateIdentifier" || J.type ===
				"ChainExpression" && SJ(J.expression) || J.type === "ParenthesizedExpression" && SJ(J.expression)
		}
		F.parseExprSubscripts = function(J, Q) {
			var Z = this.start,
				q = this.startLoc,
				X = this.parseExprAtom(J, Q);
			if (X.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !==
				")") return X;
			var Y = this.parseSubscripts(X, Z, q, !1, Q);
			if (J && Y.type === "MemberExpression") {
				if (J.parenthesizedAssign >= Y.start) J.parenthesizedAssign = -1;
				if (J.parenthesizedBind >= Y.start) J.parenthesizedBind = -1;
				if (J.trailingComma >= Y.start) J.trailingComma = -1
			}
			return Y
		}, F.parseSubscripts = function(J, Q, Z, q, X) {
			var Y = this.options.ecmaVersion >= 8 && J.type === "Identifier" && J.name === "async" && this
				.lastTokEnd === J.end && !this.canInsertSemicolon() && J.end - J.start === 5 && this
				.potentialArrowAt === J.start,
				j = !1;
			while (!0) {
				var H = this.parseSubscript(J, Q, Z, q, Y, j, X);
				if (H.optional) j = !0;
				if (H === J || H.type === "ArrowFunctionExpression") {
					if (j) {
						var K = this.startNodeAt(Q, Z);
						K.expression = H, H = this.finishNode(K, "ChainExpression")
					}
					return H
				}
				J = H
			}
		}, F.shouldParseAsyncArrow = function() {
			return !this.canInsertSemicolon() && this.eat(W.arrow)
		}, F.parseSubscriptAsyncArrow = function(J, Q, Z, q) {
			return this.parseArrowExpression(this.startNodeAt(J, Q), Z, !0, q)
		}, F.parseSubscript = function(J, Q, Z, q, X, Y, j) {
			var H = this.options.ecmaVersion >= 11,
				K = H && this.eat(W.questionDot);
			if (q && K) this.raise(this.lastTokStart,
				"Optional chaining cannot appear in the callee of new expressions");
			var R = this.eat(W.bracketL);
			if (R || K && this.type !== W.parenL && this.type !== W.backQuote || this.eat(W.dot)) {
				var M = this.startNodeAt(Q, Z);
				if (M.object = J, R) M.property = this.parseExpression(), this.expect(W.bracketR);
				else if (this.type === W.privateId && J.type !== "Super") M.property = this.parsePrivateIdent();
				else M.property = this.parseIdent(this.options.allowReserved !== "never");
				if (M.computed = !!R, H) M.optional = K;
				J = this.finishNode(M, "MemberExpression")
			} else if (!q && this.eat(W.parenL)) {
				var N = new KJ,
					v = this.yieldPos,
					qJ = this.awaitPos,
					a = this.awaitIdentPos;
				this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
				var VJ = this.parseExprList(W.parenR, this.options.ecmaVersion >= 8, !1, N);
				if (X && !K && this.shouldParseAsyncArrow()) {
					if (this.checkPatternErrors(N, !1), this.checkYieldAwaitInDefaultParams(), this
						.awaitIdentPos > 0) this.raise(this.awaitIdentPos,
						"Cannot use 'await' as identifier inside an async function");
					return this.yieldPos = v, this.awaitPos = qJ, this.awaitIdentPos = a, this
						.parseSubscriptAsyncArrow(Q, Z, VJ, j)
				}
				this.checkExpressionErrors(N, !0), this.yieldPos = v || this.yieldPos, this.awaitPos = qJ ||
					this.awaitPos, this.awaitIdentPos = a || this.awaitIdentPos;
				var o = this.startNodeAt(Q, Z);
				if (o.callee = J, o.arguments = VJ, H) o.optional = K;
				J = this.finishNode(o, "CallExpression")
			} else if (this.type === W.backQuote) {
				if (K || Y) this.raise(this.start,
					"Optional chaining cannot appear in the tag of tagged template expressions");
				var r = this.startNodeAt(Q, Z);
				r.tag = J, r.quasi = this.parseTemplate({
					isTagged: !0
				}), J = this.finishNode(r, "TaggedTemplateExpression")
			}
			return J
		}, F.parseExprAtom = function(J, Q, Z) {
			if (this.type === W.slash) this.readRegexp();
			var q, X = this.potentialArrowAt === this.start;
			switch (this.type) {
				case W._super:
					if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
					if (q = this.startNode(), this.next(), this.type === W.parenL && !this.allowDirectSuper)
						this.raise(q.start, "super() call outside constructor of a subclass");
					if (this.type !== W.dot && this.type !== W.bracketL && this.type !== W.parenL) this
						.unexpected();
					return this.finishNode(q, "Super");
				case W._this:
					return q = this.startNode(), this.next(), this.finishNode(q, "ThisExpression");
				case W.name:
					var Y = this.start,
						j = this.startLoc,
						H = this.containsEsc,
						K = this.parseIdent(!1);
					if (this.options.ecmaVersion >= 8 && !H && K.name === "async" && !this
					.canInsertSemicolon() && this.eat(W._function)) return this.overrideContext(U.f_expr), this
						.parseFunction(this.startNodeAt(Y, j), 0, !1, !0, Q);
					if (X && !this.canInsertSemicolon()) {
						if (this.eat(W.arrow)) return this.parseArrowExpression(this.startNodeAt(Y, j), [K], !1,
							Q);
						if (this.options.ecmaVersion >= 8 && K.name === "async" && this.type === W.name && !H &&
							(!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
							if (K = this.parseIdent(!1), this.canInsertSemicolon() || !this.eat(W.arrow)) this
								.unexpected();
							return this.parseArrowExpression(this.startNodeAt(Y, j), [K], !0, Q)
						}
					}
					return K;
				case W.regexp:
					var R = this.value;
					return q = this.parseLiteral(R.value), q.regex = {
						pattern: R.pattern,
						flags: R.flags
					}, q;
				case W.num:
				case W.string:
					return this.parseLiteral(this.value);
				case W._null:
				case W._true:
				case W._false:
					return q = this.startNode(), q.value = this.type === W._null ? null : this.type === W._true,
						q.raw = this.type.keyword, this.next(), this.finishNode(q, "Literal");
				case W.parenL:
					var M = this.start,
						N = this.parseParenAndDistinguishExpression(X, Q);
					if (J) {
						if (J.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(N)) J.parenthesizedAssign =
							M;
						if (J.parenthesizedBind < 0) J.parenthesizedBind = M
					}
					return N;
				case W.bracketL:
					return q = this.startNode(), this.next(), q.elements = this.parseExprList(W.bracketR, !0, !
						0, J), this.finishNode(q, "ArrayExpression");
				case W.braceL:
					return this.overrideContext(U.b_expr), this.parseObj(!1, J);
				case W._function:
					return q = this.startNode(), this.next(), this.parseFunction(q, 0);
				case W._class:
					return this.parseClass(this.startNode(), !1);
				case W._new:
					return this.parseNew();
				case W.backQuote:
					return this.parseTemplate();
				case W._import:
					if (this.options.ecmaVersion >= 11) return this.parseExprImport(Z);
					else return this.unexpected();
				default:
					return this.parseExprAtomDefault()
			}
		}, F.parseExprAtomDefault = function() {
			this.unexpected()
		}, F.parseExprImport = function(J) {
			var Q = this.startNode();
			if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
			if (this.next(), this.type === W.parenL && !J) return this.parseDynamicImport(Q);
			else if (this.type === W.dot) {
				var Z = this.startNodeAt(Q.start, Q.loc && Q.loc.start);
				return Z.name = "import", Q.meta = this.finishNode(Z, "Identifier"), this.parseImportMeta(Q)
			} else this.unexpected()
		}, F.parseDynamicImport = function(J) {
			if (this.next(), J.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16)
				if (!this.eat(W.parenR))
					if (this.expect(W.comma), !this.afterTrailingComma(W.parenR)) {
						if (J.options = this.parseMaybeAssign(), !this.eat(W.parenR)) {
							if (this.expect(W.comma), !this.afterTrailingComma(W.parenR)) this.unexpected()
						}
					} else J.options = null;
			else J.options = null;
			else if (!this.eat(W.parenR)) {
				var Q = this.start;
				if (this.eat(W.comma) && this.eat(W.parenR)) this.raiseRecoverable(Q,
					"Trailing comma is not allowed in import()");
				else this.unexpected(Q)
			}
			return this.finishNode(J, "ImportExpression")
		}, F.parseImportMeta = function(J) {
			this.next();
			var Q = this.containsEsc;
			if (J.property = this.parseIdent(!0), J.property.name !== "meta") this.raiseRecoverable(J.property
				.start, "The only valid meta property for import is 'import.meta'");
			if (Q) this.raiseRecoverable(J.start, "'import.meta' must not contain escaped characters");
			if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) this
				.raiseRecoverable(J.start, "Cannot use 'import.meta' outside a module");
			return this.finishNode(J, "MetaProperty")
		}, F.parseLiteral = function(J) {
			var Q = this.startNode();
			if (Q.value = J, Q.raw = this.input.slice(this.start, this.end), Q.raw.charCodeAt(Q.raw.length -
				1) === 110) Q.bigint = Q.value != null ? Q.value.toString() : Q.raw.slice(0, -1).replace(/_/g,
				"");
			return this.next(), this.finishNode(Q, "Literal")
		}, F.parseParenExpression = function() {
			this.expect(W.parenL);
			var J = this.parseExpression();
			return this.expect(W.parenR), J
		}, F.shouldParseArrow = function(J) {
			return !this.canInsertSemicolon()
		}, F.parseParenAndDistinguishExpression = function(J, Q) {
			var Z = this.start,
				q = this.startLoc,
				X, Y = this.options.ecmaVersion >= 8;
			if (this.options.ecmaVersion >= 6) {
				this.next();
				var j = this.start,
					H = this.startLoc,
					K = [],
					R = !0,
					M = !1,
					N = new KJ,
					v = this.yieldPos,
					qJ = this.awaitPos,
					a;
				this.yieldPos = 0, this.awaitPos = 0;
				while (this.type !== W.parenR)
					if (R ? R = !1 : this.expect(W.comma), Y && this.afterTrailingComma(W.parenR, !0)) {
						M = !0;
						break
					} else if (this.type === W.ellipsis) {
					if (a = this.start, K.push(this.parseParenItem(this.parseRestBinding())), this.type === W
						.comma) this.raiseRecoverable(this.start,
						"Comma is not permitted after the rest element");
					break
				} else K.push(this.parseMaybeAssign(!1, N, this.parseParenItem));
				var VJ = this.lastTokEnd,
					o = this.lastTokEndLoc;
				if (this.expect(W.parenR), J && this.shouldParseArrow(K) && this.eat(W.arrow)) return this
					.checkPatternErrors(N, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = v,
					this.awaitPos = qJ, this.parseParenArrowList(Z, q, K, Q);
				if (!K.length || M) this.unexpected(this.lastTokStart);
				if (a) this.unexpected(a);
				if (this.checkExpressionErrors(N, !0), this.yieldPos = v || this.yieldPos, this.awaitPos = qJ ||
					this.awaitPos, K.length > 1) X = this.startNodeAt(j, H), X.expressions = K, this
					.finishNodeAt(X, "SequenceExpression", VJ, o);
				else X = K[0]
			} else X = this.parseParenExpression();
			if (this.options.preserveParens) {
				var r = this.startNodeAt(Z, q);
				return r.expression = X, this.finishNode(r, "ParenthesizedExpression")
			} else return X
		}, F.parseParenItem = function(J) {
			return J
		}, F.parseParenArrowList = function(J, Q, Z, q) {
			return this.parseArrowExpression(this.startNodeAt(J, Q), Z, !1, q)
		};
		var TQ = [];
		F.parseNew = function() {
			if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
			var J = this.startNode();
			if (this.next(), this.options.ecmaVersion >= 6 && this.type === W.dot) {
				var Q = this.startNodeAt(J.start, J.loc && J.loc.start);
				Q.name = "new", J.meta = this.finishNode(Q, "Identifier"), this.next();
				var Z = this.containsEsc;
				if (J.property = this.parseIdent(!0), J.property.name !== "target") this.raiseRecoverable(J
					.property.start, "The only valid meta property for new is 'new.target'");
				if (Z) this.raiseRecoverable(J.start, "'new.target' must not contain escaped characters");
				if (!this.allowNewDotTarget) this.raiseRecoverable(J.start,
					"'new.target' can only be used in functions and class static block");
				return this.finishNode(J, "MetaProperty")
			}
			var q = this.start,
				X = this.startLoc;
			if (J.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), q, X, !0, !1), this.eat(W
					.parenL)) J.arguments = this.parseExprList(W.parenR, this.options.ecmaVersion >= 8, !1);
			else J.arguments = TQ;
			return this.finishNode(J, "NewExpression")
		}, F.parseTemplateElement = function(J) {
			var Q = J.isTagged,
				Z = this.startNode();
			if (this.type === W.invalidTemplate) {
				if (!Q) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
				Z.value = {
					raw: this.value.replace(/\r\n?/g, `
`),
					cooked: null
				}
			} else Z.value = {
				raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
				cooked: this.value
			};
			return this.next(), Z.tail = this.type === W.backQuote, this.finishNode(Z, "TemplateElement")
		}, F.parseTemplate = function(J) {
			if (J === void 0) J = {};
			var Q = J.isTagged;
			if (Q === void 0) Q = !1;
			var Z = this.startNode();
			this.next(), Z.expressions = [];
			var q = this.parseTemplateElement({
				isTagged: Q
			});
			Z.quasis = [q];
			while (!q.tail) {
				if (this.type === W.eof) this.raise(this.pos, "Unterminated template literal");
				this.expect(W.dollarBraceL), Z.expressions.push(this.parseExpression()), this.expect(W.braceR),
					Z.quasis.push(q = this.parseTemplateElement({
						isTagged: Q
					}))
			}
			return this.next(), this.finishNode(Z, "TemplateLiteral")
		}, F.isAsyncProp = function(J) {
			return !J.computed && J.key.type === "Identifier" && J.key.name === "async" && (this.type === W
				.name || this.type === W.num || this.type === W.string || this.type === W.bracketL || this
				.type.keyword || this.options.ecmaVersion >= 9 && this.type === W.star) && !b.test(this
				.input.slice(this.lastTokEnd, this.start))
		}, F.parseObj = function(J, Q) {
			var Z = this.startNode(),
				q = !0,
				X = {};
			Z.properties = [], this.next();
			while (!this.eat(W.braceR)) {
				if (!q) {
					if (this.expect(W.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(W
						.braceR)) break
				} else q = !1;
				var Y = this.parseProperty(J, Q);
				if (!J) this.checkPropClash(Y, X, Q);
				Z.properties.push(Y)
			}
			return this.finishNode(Z, J ? "ObjectPattern" : "ObjectExpression")
		}, F.parseProperty = function(J, Q) {
			var Z = this.startNode(),
				q, X, Y, j;
			if (this.options.ecmaVersion >= 9 && this.eat(W.ellipsis)) {
				if (J) {
					if (Z.argument = this.parseIdent(!1), this.type === W.comma) this.raiseRecoverable(this
						.start, "Comma is not permitted after the rest element");
					return this.finishNode(Z, "RestElement")
				}
				if (Z.argument = this.parseMaybeAssign(!1, Q), this.type === W.comma && Q && Q.trailingComma <
					0) Q.trailingComma = this.start;
				return this.finishNode(Z, "SpreadElement")
			}
			if (this.options.ecmaVersion >= 6) {
				if (Z.method = !1, Z.shorthand = !1, J || Q) Y = this.start, j = this.startLoc;
				if (!J) q = this.eat(W.star)
			}
			var H = this.containsEsc;
			if (this.parsePropertyName(Z), !J && !H && this.options.ecmaVersion >= 8 && !q && this.isAsyncProp(
					Z)) X = !0, q = this.options.ecmaVersion >= 9 && this.eat(W.star), this.parsePropertyName(
			Z);
			else X = !1;
			return this.parsePropertyValue(Z, J, q, X, Y, j, Q, H), this.finishNode(Z, "Property")
		}, F.parseGetterSetter = function(J) {
			var Q = J.key.name;
			this.parsePropertyName(J), J.value = this.parseMethod(!1), J.kind = Q;
			var Z = J.kind === "get" ? 0 : 1;
			if (J.value.params.length !== Z) {
				var q = J.value.start;
				if (J.kind === "get") this.raiseRecoverable(q, "getter should have no params");
				else this.raiseRecoverable(q, "setter should have exactly one param")
			} else if (J.kind === "set" && J.value.params[0].type === "RestElement") this.raiseRecoverable(J
				.value.params[0].start, "Setter cannot use rest params")
		}, F.parsePropertyValue = function(J, Q, Z, q, X, Y, j, H) {
			if ((Z || q) && this.type === W.colon) this.unexpected();
			if (this.eat(W.colon)) J.value = Q ? this.parseMaybeDefault(this.start, this.startLoc) : this
				.parseMaybeAssign(!1, j), J.kind = "init";
			else if (this.options.ecmaVersion >= 6 && this.type === W.parenL) {
				if (Q) this.unexpected();
				J.method = !0, J.value = this.parseMethod(Z, q), J.kind = "init"
			} else if (!Q && !H && this.options.ecmaVersion >= 5 && !J.computed && J.key.type ===
				"Identifier" && (J.key.name === "get" || J.key.name === "set") && (this.type !== W.comma && this
					.type !== W.braceR && this.type !== W.eq)) {
				if (Z || q) this.unexpected();
				this.parseGetterSetter(J)
			} else if (this.options.ecmaVersion >= 6 && !J.computed && J.key.type === "Identifier") {
				if (Z || q) this.unexpected();
				if (this.checkUnreserved(J.key), J.key.name === "await" && !this.awaitIdentPos) this
					.awaitIdentPos = X;
				if (Q) J.value = this.parseMaybeDefault(X, Y, this.copyNode(J.key));
				else if (this.type === W.eq && j) {
					if (j.shorthandAssign < 0) j.shorthandAssign = this.start;
					J.value = this.parseMaybeDefault(X, Y, this.copyNode(J.key))
				} else J.value = this.copyNode(J.key);
				J.kind = "init", J.shorthand = !0
			} else this.unexpected()
		}, F.parsePropertyName = function(J) {
			if (this.options.ecmaVersion >= 6)
				if (this.eat(W.bracketL)) return J.computed = !0, J.key = this.parseMaybeAssign(), this.expect(W
					.bracketR), J.key;
				else J.computed = !1;
			return J.key = this.type === W.num || this.type === W.string ? this.parseExprAtom() : this
				.parseIdent(this.options.allowReserved !== "never")
		}, F.initFunction = function(J) {
			if (J.id = null, this.options.ecmaVersion >= 6) J.generator = J.expression = !1;
			if (this.options.ecmaVersion >= 8) J.async = !1
		}, F.parseMethod = function(J, Q, Z) {
			var q = this.startNode(),
				X = this.yieldPos,
				Y = this.awaitPos,
				j = this.awaitIdentPos;
			if (this.initFunction(q), this.options.ecmaVersion >= 6) q.generator = J;
			if (this.options.ecmaVersion >= 8) q.async = !!Q;
			return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(bJ(Q, q
					.generator) | YJ | (Z ? fJ : 0)), this.expect(W.parenL), q.params = this.parseBindingList(W
					.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this
				.parseFunctionBody(q, !1, !0, !1), this.yieldPos = X, this.awaitPos = Y, this.awaitIdentPos = j,
				this.finishNode(q, "FunctionExpression")
		}, F.parseArrowExpression = function(J, Q, Z, q) {
			var X = this.yieldPos,
				Y = this.awaitPos,
				j = this.awaitIdentPos;
			if (this.enterScope(bJ(Z, !1) | vJ), this.initFunction(J), this.options.ecmaVersion >= 8) J
				.async = !!Z;
			return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, J.params = this
				.toAssignableList(Q, !0), this.parseFunctionBody(J, !0, !1, q), this.yieldPos = X, this
				.awaitPos = Y, this.awaitIdentPos = j, this.finishNode(J, "ArrowFunctionExpression")
		}, F.parseFunctionBody = function(J, Q, Z, q) {
			var X = Q && this.type !== W.braceL,
				Y = this.strict,
				j = !1;
			if (X) J.body = this.parseMaybeAssign(q), J.expression = !0, this.checkParams(J, !1);
			else {
				var H = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(J.params);
				if (!Y || H) {
					if (j = this.strictDirective(this.end), j && H) this.raiseRecoverable(J.start,
						"Illegal 'use strict' directive in function with non-simple parameter list")
				}
				var K = this.labels;
				if (this.labels = [], j) this.strict = !0;
				if (this.checkParams(J, !Y && !j && !Q && !Z && this.isSimpleParamList(J.params)), this
					.strict && J.id) this.checkLValSimple(J.id, pJ);
				J.body = this.parseBlock(!1, void 0, j && !Y), J.expression = !1, this.adaptDirectivePrologue(J
					.body.body), this.labels = K
			}
			this.exitScope()
		}, F.isSimpleParamList = function(J) {
			for (var Q = 0, Z = J; Q < Z.length; Q += 1) {
				var q = Z[Q];
				if (q.type !== "Identifier") return !1
			}
			return !0
		}, F.checkParams = function(J, Q) {
			var Z = Object.create(null);
			for (var q = 0, X = J.params; q < X.length; q += 1) {
				var Y = X[q];
				this.checkLValInnerPattern(Y, AJ, Q ? null : Z)
			}
		}, F.parseExprList = function(J, Q, Z, q) {
			var X = [],
				Y = !0;
			while (!this.eat(J)) {
				if (!Y) {
					if (this.expect(W.comma), Q && this.afterTrailingComma(J)) break
				} else Y = !1;
				var j = void 0;
				if (Z && this.type === W.comma) j = null;
				else if (this.type === W.ellipsis) {
					if (j = this.parseSpread(q), q && this.type === W.comma && q.trailingComma < 0) q
						.trailingComma = this.start
				} else j = this.parseMaybeAssign(!1, q);
				X.push(j)
			}
			return X
		}, F.checkUnreserved = function(J) {
			var {
				start: Q,
				end: Z,
				name: q
			} = J;
			if (this.inGenerator && q === "yield") this.raiseRecoverable(Q,
				"Cannot use 'yield' as identifier inside a generator");
			if (this.inAsync && q === "await") this.raiseRecoverable(Q,
				"Cannot use 'await' as identifier inside an async function");
			if (!(this.currentThisScope().flags & jJ) && q === "arguments") this.raiseRecoverable(Q,
				"Cannot use 'arguments' in class field initializer");
			if (this.inClassStaticBlock && (q === "arguments" || q === "await")) this.raise(Q, "Cannot use " +
				q + " in class static initialization block");
			if (this.keywords.test(q)) this.raise(Q, "Unexpected keyword '" + q + "'");
			if (this.options.ecmaVersion < 6 && this.input.slice(Q, Z).indexOf("\\") !== -1) return;
			var X = this.strict ? this.reservedWordsStrict : this.reservedWords;
			if (X.test(q)) {
				if (!this.inAsync && q === "await") this.raiseRecoverable(Q,
					"Cannot use keyword 'await' outside an async function");
				this.raiseRecoverable(Q, "The keyword '" + q + "' is reserved")
			}
		}, F.parseIdent = function(J) {
			var Q = this.parseIdentNode();
			if (this.next(!!J), this.finishNode(Q, "Identifier"), !J) {
				if (this.checkUnreserved(Q), Q.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = Q
					.start
			}
			return Q
		}, F.parseIdentNode = function() {
			var J = this.startNode();
			if (this.type === W.name) J.name = this.value;
			else if (this.type.keyword) {
				if (J.name = this.type.keyword, (J.name === "class" || J.name === "function") && (this
						.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46
						)) this.context.pop();
				this.type = W.name
			} else this.unexpected();
			return J
		}, F.parsePrivateIdent = function() {
			var J = this.startNode();
			if (this.type === W.privateId) J.name = this.value;
			else this.unexpected();
			if (this.next(), this.finishNode(J, "PrivateIdentifier"), this.options.checkPrivateFields)
				if (this.privateNameStack.length === 0) this.raise(J.start, "Private field '#" + J.name +
					"' must be declared in an enclosing class");
				else this.privateNameStack[this.privateNameStack.length - 1].used.push(J);
			return J
		}, F.parseYield = function(J) {
			if (!this.yieldPos) this.yieldPos = this.start;
			var Q = this.startNode();
			if (this.next(), this.type === W.semi || this.canInsertSemicolon() || this.type !== W.star && !this
				.type.startsExpr) Q.delegate = !1, Q.argument = null;
			else Q.delegate = this.eat(W.star), Q.argument = this.parseMaybeAssign(J);
			return this.finishNode(Q, "YieldExpression")
		}, F.parseAwait = function(J) {
			if (!this.awaitPos) this.awaitPos = this.start;
			var Q = this.startNode();
			return this.next(), Q.argument = this.parseMaybeUnary(null, !0, !1, J), this.finishNode(Q,
				"AwaitExpression")
		};
		var GJ = $.prototype;
		GJ.raise = function(J, Q) {
			var Z = $J(this.input, J);
			if (Q += " (" + Z.line + ":" + Z.column + ")", this.sourceFile) Q += " in " + this.sourceFile;
			var q = new SyntaxError(Q);
			throw q.pos = J, q.loc = Z, q.raisedAt = this.pos, q
		}, GJ.raiseRecoverable = GJ.raise, GJ.curPosition = function() {
			if (this.options.locations) return new d(this.curLine, this.pos - this.lineStart)
		};
		var u = $.prototype,
			DQ = function J(Q) {
				this.flags = Q, this.var = [], this.lexical = [], this.functions = []
			};
		u.enterScope = function(J) {
			this.scopeStack.push(new DQ(J))
		}, u.exitScope = function() {
			this.scopeStack.pop()
		}, u.treatFunctionsAsVarInScope = function(J) {
			return J.flags & i || !this.inModule && J.flags & t
		}, u.declareName = function(J, Q, Z) {
			var q = !1;
			if (Q === m) {
				var X = this.currentScope();
				if (q = X.lexical.indexOf(J) > -1 || X.functions.indexOf(J) > -1 || X.var.indexOf(J) > -1, X
					.lexical.push(J), this.inModule && X.flags & t) delete this.undefinedExports[J]
			} else if (Q === lJ) {
				var Y = this.currentScope();
				Y.lexical.push(J)
			} else if (Q === uJ) {
				var j = this.currentScope();
				if (this.treatFunctionsAsVar) q = j.lexical.indexOf(J) > -1;
				else q = j.lexical.indexOf(J) > -1 || j.var.indexOf(J) > -1;
				j.functions.push(J)
			} else
				for (var H = this.scopeStack.length - 1; H >= 0; --H) {
					var K = this.scopeStack[H];
					if (K.lexical.indexOf(J) > -1 && !(K.flags & hJ && K.lexical[0] === J) || !this
						.treatFunctionsAsVarInScope(K) && K.functions.indexOf(J) > -1) {
						q = !0;
						break
					}
					if (K.var.push(J), this.inModule && K.flags & t) delete this.undefinedExports[J];
					if (K.flags & jJ) break
				}
			if (q) this.raiseRecoverable(Z, "Identifier '" + J + "' has already been declared")
		}, u.checkLocalExport = function(J) {
			if (this.scopeStack[0].lexical.indexOf(J.name) === -1 && this.scopeStack[0].var.indexOf(J.name) ===
				-1) this.undefinedExports[J.name] = J
		}, u.currentScope = function() {
			return this.scopeStack[this.scopeStack.length - 1]
		}, u.currentVarScope = function() {
			for (var J = this.scopeStack.length - 1;; J--) {
				var Q = this.scopeStack[J];
				if (Q.flags & (jJ | e | p)) return Q
			}
		}, u.currentThisScope = function() {
			for (var J = this.scopeStack.length - 1;; J--) {
				var Q = this.scopeStack[J];
				if (Q.flags & (jJ | e | p) && !(Q.flags & vJ)) return Q
			}
		};
		var QJ = function J(Q, Z, q) {
				if (this.type = "", this.start = Z, this.end = 0, Q.options.locations) this.loc = new s(Q, q);
				if (Q.options.directSourceFile) this.sourceFile = Q.options.directSourceFile;
				if (Q.options.ranges) this.range = [Z, 0]
			},
			ZJ = $.prototype;
		ZJ.startNode = function() {
			return new QJ(this, this.start, this.startLoc)
		}, ZJ.startNodeAt = function(J, Q) {
			return new QJ(this, J, Q)
		};

		function iJ(J, Q, Z, q) {
			if (J.type = Q, J.end = Z, this.options.locations) J.loc.end = q;
			if (this.options.ranges) J.range[1] = Z;
			return J
		}
		ZJ.finishNode = function(J, Q) {
			return iJ.call(this, J, Q, this.lastTokEnd, this.lastTokEndLoc)
		}, ZJ.finishNodeAt = function(J, Q, Z, q) {
			return iJ.call(this, J, Q, Z, q)
		}, ZJ.copyNode = function(J) {
			var Q = new QJ(this, J.start, this.startLoc);
			for (var Z in J) Q[Z] = J[Z];
			return Q
		};
		var EQ =
			"Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz",
			nJ =
			"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",
			aJ = nJ + " Extended_Pictographic",
			oJ = aJ,
			rJ = oJ + " EBase EComp EMod EPres ExtPict",
			sJ = rJ,
			yQ = sJ,
			xQ = {
				9: nJ,
				10: aJ,
				11: oJ,
				12: rJ,
				13: sJ,
				14: yQ
			},
			gQ =
			"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji",
			mQ = {
				9: "",
				10: "",
				11: "",
				12: "",
				13: "",
				14: gQ
			},
			tJ =
			"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",
			eJ =
			"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",
			JQ = eJ +
			" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",
			QQ = JQ + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",
			ZQ = QQ + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",
			qQ = ZQ + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",
			hQ = qQ + " " + EQ,
			fQ = {
				9: eJ,
				10: JQ,
				11: QQ,
				12: ZQ,
				13: qQ,
				14: hQ
			},
			WQ = {};

		function uQ(J) {
			var Q = WQ[J] = {
				binary: f(xQ[J] + " " + tJ),
				binaryOfStrings: f(mQ[J]),
				nonBinary: {
					General_Category: f(tJ),
					Script: f(fQ[J])
				}
			};
			Q.nonBinary.Script_Extensions = Q.nonBinary.Script, Q.nonBinary.gc = Q.nonBinary.General_Category, Q
				.nonBinary.sc = Q.nonBinary.Script, Q.nonBinary.scx = Q.nonBinary.Script_Extensions
		}
		for (var LJ = 0, XQ = [9, 10, 11, 12, 13, 14]; LJ < XQ.length; LJ += 1) {
			var lQ = XQ[LJ];
			uQ(lQ)
		}
		var z = $.prototype,
			RJ = function J(Q, Z) {
				this.parent = Q, this.base = Z || this
			};
		RJ.prototype.separatedFrom = function J(Q) {
			for (var Z = this; Z; Z = Z.parent)
				for (var q = Q; q; q = q.parent)
					if (Z.base === q.base && Z !== q) return !0;
			return !1
		}, RJ.prototype.sibling = function J() {
			return new RJ(this.parent, this.base)
		};
		var y = function J(Q) {
			this.parser = Q, this.validFlags = "gim" + (Q.options.ecmaVersion >= 6 ? "uy" : "") + (Q.options
					.ecmaVersion >= 9 ? "s" : "") + (Q.options.ecmaVersion >= 13 ? "d" : "") + (Q.options
					.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = WQ[Q.options.ecmaVersion >= 14 ?
					14 : Q.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this
				.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this
				.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this
				.maxBackReference = 0, this.groupNames = Object.create(null), this.backReferenceNames = [], this
				.branchID = null
		};
		y.prototype.reset = function J(Q, Z, q) {
			var X = q.indexOf("v") !== -1,
				Y = q.indexOf("u") !== -1;
			if (this.start = Q | 0, this.source = Z + "", this.flags = q, X && this.parser.options
				.ecmaVersion >= 15) this.switchU = !0, this.switchV = !0, this.switchN = !0;
			else this.switchU = Y && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN =
				Y && this.parser.options.ecmaVersion >= 9
		}, y.prototype.raise = function J(Q) {
			this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + Q)
		}, y.prototype.at = function J(Q, Z) {
			if (Z === void 0) Z = !1;
			var q = this.source,
				X = q.length;
			if (Q >= X) return -1;
			var Y = q.charCodeAt(Q);
			if (!(Z || this.switchU) || Y <= 55295 || Y >= 57344 || Q + 1 >= X) return Y;
			var j = q.charCodeAt(Q + 1);
			return j >= 56320 && j <= 57343 ? (Y << 10) + j - 56613888 : Y
		}, y.prototype.nextIndex = function J(Q, Z) {
			if (Z === void 0) Z = !1;
			var q = this.source,
				X = q.length;
			if (Q >= X) return X;
			var Y = q.charCodeAt(Q),
				j;
			if (!(Z || this.switchU) || Y <= 55295 || Y >= 57344 || Q + 1 >= X || (j = q.charCodeAt(Q + 1)) <
				56320 || j > 57343) return Q + 1;
			return Q + 2
		}, y.prototype.current = function J(Q) {
			if (Q === void 0) Q = !1;
			return this.at(this.pos, Q)
		}, y.prototype.lookahead = function J(Q) {
			if (Q === void 0) Q = !1;
			return this.at(this.nextIndex(this.pos, Q), Q)
		}, y.prototype.advance = function J(Q) {
			if (Q === void 0) Q = !1;
			this.pos = this.nextIndex(this.pos, Q)
		}, y.prototype.eat = function J(Q, Z) {
			if (Z === void 0) Z = !1;
			if (this.current(Z) === Q) return this.advance(Z), !0;
			return !1
		}, y.prototype.eatChars = function J(Q, Z) {
			if (Z === void 0) Z = !1;
			var q = this.pos;
			for (var X = 0, Y = Q; X < Y.length; X += 1) {
				var j = Y[X],
					H = this.at(q, Z);
				if (H === -1 || H !== j) return !1;
				q = this.nextIndex(q, Z)
			}
			return this.pos = q, !0
		}, z.validateRegExpFlags = function(J) {
			var {
				validFlags: Q,
				flags: Z
			} = J, q = !1, X = !1;
			for (var Y = 0; Y < Z.length; Y++) {
				var j = Z.charAt(Y);
				if (Q.indexOf(j) === -1) this.raise(J.start, "Invalid regular expression flag");
				if (Z.indexOf(j, Y + 1) > -1) this.raise(J.start, "Duplicate regular expression flag");
				if (j === "u") q = !0;
				if (j === "v") X = !0
			}
			if (this.options.ecmaVersion >= 15 && q && X) this.raise(J.start, "Invalid regular expression flag")
		};

		function pQ(J) {
			for (var Q in J) return !0;
			return !1
		}
		z.validateRegExpPattern = function(J) {
			if (this.regexp_pattern(J), !J.switchN && this.options.ecmaVersion >= 9 && pQ(J.groupNames)) J
				.switchN = !0, this.regexp_pattern(J)
		}, z.regexp_pattern = function(J) {
			if (J.pos = 0, J.lastIntValue = 0, J.lastStringValue = "", J.lastAssertionIsQuantifiable = !1, J
				.numCapturingParens = 0, J.maxBackReference = 0, J.groupNames = Object.create(null), J
				.backReferenceNames.length = 0, J.branchID = null, this.regexp_disjunction(J), J.pos !== J
				.source.length) {
				if (J.eat(41)) J.raise("Unmatched ')'");
				if (J.eat(93) || J.eat(125)) J.raise("Lone quantifier brackets")
			}
			if (J.maxBackReference > J.numCapturingParens) J.raise("Invalid escape");
			for (var Q = 0, Z = J.backReferenceNames; Q < Z.length; Q += 1) {
				var q = Z[Q];
				if (!J.groupNames[q]) J.raise("Invalid named capture referenced")
			}
		}, z.regexp_disjunction = function(J) {
			var Q = this.options.ecmaVersion >= 16;
			if (Q) J.branchID = new RJ(J.branchID, null);
			this.regexp_alternative(J);
			while (J.eat(124)) {
				if (Q) J.branchID = J.branchID.sibling();
				this.regexp_alternative(J)
			}
			if (Q) J.branchID = J.branchID.parent;
			if (this.regexp_eatQuantifier(J, !0)) J.raise("Nothing to repeat");
			if (J.eat(123)) J.raise("Lone quantifier brackets")
		}, z.regexp_alternative = function(J) {
			while (J.pos < J.source.length && this.regexp_eatTerm(J));
		}, z.regexp_eatTerm = function(J) {
			if (this.regexp_eatAssertion(J)) {
				if (J.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(J)) {
					if (J.switchU) J.raise("Invalid quantifier")
				}
				return !0
			}
			if (J.switchU ? this.regexp_eatAtom(J) : this.regexp_eatExtendedAtom(J)) return this
				.regexp_eatQuantifier(J), !0;
			return !1
		}, z.regexp_eatAssertion = function(J) {
			var Q = J.pos;
			if (J.lastAssertionIsQuantifiable = !1, J.eat(94) || J.eat(36)) return !0;
			if (J.eat(92)) {
				if (J.eat(66) || J.eat(98)) return !0;
				J.pos = Q
			}
			if (J.eat(40) && J.eat(63)) {
				var Z = !1;
				if (this.options.ecmaVersion >= 9) Z = J.eat(60);
				if (J.eat(61) || J.eat(33)) {
					if (this.regexp_disjunction(J), !J.eat(41)) J.raise("Unterminated group");
					return J.lastAssertionIsQuantifiable = !Z, !0
				}
			}
			return J.pos = Q, !1
		}, z.regexp_eatQuantifier = function(J, Q) {
			if (Q === void 0) Q = !1;
			if (this.regexp_eatQuantifierPrefix(J, Q)) return J.eat(63), !0;
			return !1
		}, z.regexp_eatQuantifierPrefix = function(J, Q) {
			return J.eat(42) || J.eat(43) || J.eat(63) || this.regexp_eatBracedQuantifier(J, Q)
		}, z.regexp_eatBracedQuantifier = function(J, Q) {
			var Z = J.pos;
			if (J.eat(123)) {
				var q = 0,
					X = -1;
				if (this.regexp_eatDecimalDigits(J)) {
					if (q = J.lastIntValue, J.eat(44) && this.regexp_eatDecimalDigits(J)) X = J.lastIntValue;
					if (J.eat(125)) {
						if (X !== -1 && X < q && !Q) J.raise("numbers out of order in {} quantifier");
						return !0
					}
				}
				if (J.switchU && !Q) J.raise("Incomplete quantifier");
				J.pos = Z
			}
			return !1
		}, z.regexp_eatAtom = function(J) {
			return this.regexp_eatPatternCharacters(J) || J.eat(46) || this.regexp_eatReverseSolidusAtomEscape(
					J) || this.regexp_eatCharacterClass(J) || this.regexp_eatUncapturingGroup(J) || this
				.regexp_eatCapturingGroup(J)
		}, z.regexp_eatReverseSolidusAtomEscape = function(J) {
			var Q = J.pos;
			if (J.eat(92)) {
				if (this.regexp_eatAtomEscape(J)) return !0;
				J.pos = Q
			}
			return !1
		}, z.regexp_eatUncapturingGroup = function(J) {
			var Q = J.pos;
			if (J.eat(40)) {
				if (J.eat(63)) {
					if (this.options.ecmaVersion >= 16) {
						var Z = this.regexp_eatModifiers(J),
							q = J.eat(45);
						if (Z || q) {
							for (var X = 0; X < Z.length; X++) {
								var Y = Z.charAt(X);
								if (Z.indexOf(Y, X + 1) > -1) J.raise("Duplicate regular expression modifiers")
							}
							if (q) {
								var j = this.regexp_eatModifiers(J);
								if (!Z && !j && J.current() === 58) J.raise(
									"Invalid regular expression modifiers");
								for (var H = 0; H < j.length; H++) {
									var K = j.charAt(H);
									if (j.indexOf(K, H + 1) > -1 || Z.indexOf(K) > -1) J.raise(
										"Duplicate regular expression modifiers")
								}
							}
						}
					}
					if (J.eat(58)) {
						if (this.regexp_disjunction(J), J.eat(41)) return !0;
						J.raise("Unterminated group")
					}
				}
				J.pos = Q
			}
			return !1
		}, z.regexp_eatCapturingGroup = function(J) {
			if (J.eat(40)) {
				if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(J);
				else if (J.current() === 63) J.raise("Invalid group");
				if (this.regexp_disjunction(J), J.eat(41)) return J.numCapturingParens += 1, !0;
				J.raise("Unterminated group")
			}
			return !1
		}, z.regexp_eatModifiers = function(J) {
			var Q = "",
				Z = 0;
			while ((Z = J.current()) !== -1 && cQ(Z)) Q += g(Z), J.advance();
			return Q
		};

		function cQ(J) {
			return J === 105 || J === 109 || J === 115
		}
		z.regexp_eatExtendedAtom = function(J) {
			return J.eat(46) || this.regexp_eatReverseSolidusAtomEscape(J) || this.regexp_eatCharacterClass(
				J) || this.regexp_eatUncapturingGroup(J) || this.regexp_eatCapturingGroup(J) || this
				.regexp_eatInvalidBracedQuantifier(J) || this.regexp_eatExtendedPatternCharacter(J)
		}, z.regexp_eatInvalidBracedQuantifier = function(J) {
			if (this.regexp_eatBracedQuantifier(J, !0)) J.raise("Nothing to repeat");
			return !1
		}, z.regexp_eatSyntaxCharacter = function(J) {
			var Q = J.current();
			if (YQ(Q)) return J.lastIntValue = Q, J.advance(), !0;
			return !1
		};

		function YQ(J) {
			return J === 36 || J >= 40 && J <= 43 || J === 46 || J === 63 || J >= 91 && J <= 94 || J >= 123 && J <=
				125
		}
		z.regexp_eatPatternCharacters = function(J) {
			var Q = J.pos,
				Z = 0;
			while ((Z = J.current()) !== -1 && !YQ(Z)) J.advance();
			return J.pos !== Q
		}, z.regexp_eatExtendedPatternCharacter = function(J) {
			var Q = J.current();
			if (Q !== -1 && Q !== 36 && !(Q >= 40 && Q <= 43) && Q !== 46 && Q !== 63 && Q !== 91 && Q !== 94 &&
				Q !== 124) return J.advance(), !0;
			return !1
		}, z.regexp_groupSpecifier = function(J) {
			if (J.eat(63)) {
				if (!this.regexp_eatGroupName(J)) J.raise("Invalid group");
				var Q = this.options.ecmaVersion >= 16,
					Z = J.groupNames[J.lastStringValue];
				if (Z)
					if (Q)
						for (var q = 0, X = Z; q < X.length; q += 1) {
							var Y = X[q];
							if (!Y.separatedFrom(J.branchID)) J.raise("Duplicate capture group name")
						} else J.raise("Duplicate capture group name");
				if (Q)(Z || (J.groupNames[J.lastStringValue] = [])).push(J.branchID);
				else J.groupNames[J.lastStringValue] = !0
			}
		}, z.regexp_eatGroupName = function(J) {
			if (J.lastStringValue = "", J.eat(60)) {
				if (this.regexp_eatRegExpIdentifierName(J) && J.eat(62)) return !0;
				J.raise("Invalid capture group name")
			}
			return !1
		}, z.regexp_eatRegExpIdentifierName = function(J) {
			if (J.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(J)) {
				J.lastStringValue += g(J.lastIntValue);
				while (this.regexp_eatRegExpIdentifierPart(J)) J.lastStringValue += g(J.lastIntValue);
				return !0
			}
			return !1
		}, z.regexp_eatRegExpIdentifierStart = function(J) {
			var Q = J.pos,
				Z = this.options.ecmaVersion >= 11,
				q = J.current(Z);
			if (J.advance(Z), q === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(J, Z)) q = J.lastIntValue;
			if (dQ(q)) return J.lastIntValue = q, !0;
			return J.pos = Q, !1
		};

		function dQ(J) {
			return T(J, !0) || J === 36 || J === 95
		}
		z.regexp_eatRegExpIdentifierPart = function(J) {
			var Q = J.pos,
				Z = this.options.ecmaVersion >= 11,
				q = J.current(Z);
			if (J.advance(Z), q === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(J, Z)) q = J.lastIntValue;
			if (iQ(q)) return J.lastIntValue = q, !0;
			return J.pos = Q, !1
		};

		function iQ(J) {
			return x(J, !0) || J === 36 || J === 95 || J === 8204 || J === 8205
		}
		z.regexp_eatAtomEscape = function(J) {
			if (this.regexp_eatBackReference(J) || this.regexp_eatCharacterClassEscape(J) || this
				.regexp_eatCharacterEscape(J) || J.switchN && this.regexp_eatKGroupName(J)) return !0;
			if (J.switchU) {
				if (J.current() === 99) J.raise("Invalid unicode escape");
				J.raise("Invalid escape")
			}
			return !1
		}, z.regexp_eatBackReference = function(J) {
			var Q = J.pos;
			if (this.regexp_eatDecimalEscape(J)) {
				var Z = J.lastIntValue;
				if (J.switchU) {
					if (Z > J.maxBackReference) J.maxBackReference = Z;
					return !0
				}
				if (Z <= J.numCapturingParens) return !0;
				J.pos = Q
			}
			return !1
		}, z.regexp_eatKGroupName = function(J) {
			if (J.eat(107)) {
				if (this.regexp_eatGroupName(J)) return J.backReferenceNames.push(J.lastStringValue), !0;
				J.raise("Invalid named reference")
			}
			return !1
		}, z.regexp_eatCharacterEscape = function(J) {
			return this.regexp_eatControlEscape(J) || this.regexp_eatCControlLetter(J) || this.regexp_eatZero(
				J) || this.regexp_eatHexEscapeSequence(J) || this.regexp_eatRegExpUnicodeEscapeSequence(J, !
				1) || !J.switchU && this.regexp_eatLegacyOctalEscapeSequence(J) || this
				.regexp_eatIdentityEscape(J)
		}, z.regexp_eatCControlLetter = function(J) {
			var Q = J.pos;
			if (J.eat(99)) {
				if (this.regexp_eatControlLetter(J)) return !0;
				J.pos = Q
			}
			return !1
		}, z.regexp_eatZero = function(J) {
			if (J.current() === 48 && !FJ(J.lookahead())) return J.lastIntValue = 0, J.advance(), !0;
			return !1
		}, z.regexp_eatControlEscape = function(J) {
			var Q = J.current();
			if (Q === 116) return J.lastIntValue = 9, J.advance(), !0;
			if (Q === 110) return J.lastIntValue = 10, J.advance(), !0;
			if (Q === 118) return J.lastIntValue = 11, J.advance(), !0;
			if (Q === 102) return J.lastIntValue = 12, J.advance(), !0;
			if (Q === 114) return J.lastIntValue = 13, J.advance(), !0;
			return !1
		}, z.regexp_eatControlLetter = function(J) {
			var Q = J.current();
			if (jQ(Q)) return J.lastIntValue = Q % 32, J.advance(), !0;
			return !1
		};

		function jQ(J) {
			return J >= 65 && J <= 90 || J >= 97 && J <= 122
		}
		z.regexp_eatRegExpUnicodeEscapeSequence = function(J, Q) {
			if (Q === void 0) Q = !1;
			var Z = J.pos,
				q = Q || J.switchU;
			if (J.eat(117)) {
				if (this.regexp_eatFixedHexDigits(J, 4)) {
					var X = J.lastIntValue;
					if (q && X >= 55296 && X <= 56319) {
						var Y = J.pos;
						if (J.eat(92) && J.eat(117) && this.regexp_eatFixedHexDigits(J, 4)) {
							var j = J.lastIntValue;
							if (j >= 56320 && j <= 57343) return J.lastIntValue = (X - 55296) * 1024 + (j -
								56320) + 65536, !0
						}
						J.pos = Y, J.lastIntValue = X
					}
					return !0
				}
				if (q && J.eat(123) && this.regexp_eatHexDigits(J) && J.eat(125) && nQ(J.lastIntValue)) return !
					0;
				if (q) J.raise("Invalid unicode escape");
				J.pos = Z
			}
			return !1
		};

		function nQ(J) {
			return J >= 0 && J <= 1114111
		}
		z.regexp_eatIdentityEscape = function(J) {
			if (J.switchU) {
				if (this.regexp_eatSyntaxCharacter(J)) return !0;
				if (J.eat(47)) return J.lastIntValue = 47, !0;
				return !1
			}
			var Q = J.current();
			if (Q !== 99 && (!J.switchN || Q !== 107)) return J.lastIntValue = Q, J.advance(), !0;
			return !1
		}, z.regexp_eatDecimalEscape = function(J) {
			J.lastIntValue = 0;
			var Q = J.current();
			if (Q >= 49 && Q <= 57) {
				do J.lastIntValue = 10 * J.lastIntValue + (Q - 48), J.advance(); while ((Q = J.current()) >=
					48 && Q <= 57);
				return !0
			}
			return !1
		};
		var HQ = 0,
			h = 1,
			k = 2;
		z.regexp_eatCharacterClassEscape = function(J) {
			var Q = J.current();
			if (aQ(Q)) return J.lastIntValue = -1, J.advance(), h;
			var Z = !1;
			if (J.switchU && this.options.ecmaVersion >= 9 && ((Z = Q === 80) || Q === 112)) {
				J.lastIntValue = -1, J.advance();
				var q;
				if (J.eat(123) && (q = this.regexp_eatUnicodePropertyValueExpression(J)) && J.eat(125)) {
					if (Z && q === k) J.raise("Invalid property name");
					return q
				}
				J.raise("Invalid property name")
			}
			return HQ
		};

		function aQ(J) {
			return J === 100 || J === 68 || J === 115 || J === 83 || J === 119 || J === 87
		}
		z.regexp_eatUnicodePropertyValueExpression = function(J) {
			var Q = J.pos;
			if (this.regexp_eatUnicodePropertyName(J) && J.eat(61)) {
				var Z = J.lastStringValue;
				if (this.regexp_eatUnicodePropertyValue(J)) {
					var q = J.lastStringValue;
					return this.regexp_validateUnicodePropertyNameAndValue(J, Z, q), h
				}
			}
			if (J.pos = Q, this.regexp_eatLoneUnicodePropertyNameOrValue(J)) {
				var X = J.lastStringValue;
				return this.regexp_validateUnicodePropertyNameOrValue(J, X)
			}
			return HQ
		}, z.regexp_validateUnicodePropertyNameAndValue = function(J, Q, Z) {
			if (!c(J.unicodeProperties.nonBinary, Q)) J.raise("Invalid property name");
			if (!J.unicodeProperties.nonBinary[Q].test(Z)) J.raise("Invalid property value")
		}, z.regexp_validateUnicodePropertyNameOrValue = function(J, Q) {
			if (J.unicodeProperties.binary.test(Q)) return h;
			if (J.switchV && J.unicodeProperties.binaryOfStrings.test(Q)) return k;
			J.raise("Invalid property name")
		}, z.regexp_eatUnicodePropertyName = function(J) {
			var Q = 0;
			J.lastStringValue = "";
			while (KQ(Q = J.current())) J.lastStringValue += g(Q), J.advance();
			return J.lastStringValue !== ""
		};

		function KQ(J) {
			return jQ(J) || J === 95
		}
		z.regexp_eatUnicodePropertyValue = function(J) {
			var Q = 0;
			J.lastStringValue = "";
			while (oQ(Q = J.current())) J.lastStringValue += g(Q), J.advance();
			return J.lastStringValue !== ""
		};

		function oQ(J) {
			return KQ(J) || FJ(J)
		}
		z.regexp_eatLoneUnicodePropertyNameOrValue = function(J) {
			return this.regexp_eatUnicodePropertyValue(J)
		}, z.regexp_eatCharacterClass = function(J) {
			if (J.eat(91)) {
				var Q = J.eat(94),
					Z = this.regexp_classContents(J);
				if (!J.eat(93)) J.raise("Unterminated character class");
				if (Q && Z === k) J.raise("Negated character class may contain strings");
				return !0
			}
			return !1
		}, z.regexp_classContents = function(J) {
			if (J.current() === 93) return h;
			if (J.switchV) return this.regexp_classSetExpression(J);
			return this.regexp_nonEmptyClassRanges(J), h
		}, z.regexp_nonEmptyClassRanges = function(J) {
			while (this.regexp_eatClassAtom(J)) {
				var Q = J.lastIntValue;
				if (J.eat(45) && this.regexp_eatClassAtom(J)) {
					var Z = J.lastIntValue;
					if (J.switchU && (Q === -1 || Z === -1)) J.raise("Invalid character class");
					if (Q !== -1 && Z !== -1 && Q > Z) J.raise("Range out of order in character class")
				}
			}
		}, z.regexp_eatClassAtom = function(J) {
			var Q = J.pos;
			if (J.eat(92)) {
				if (this.regexp_eatClassEscape(J)) return !0;
				if (J.switchU) {
					var Z = J.current();
					if (Z === 99 || RQ(Z)) J.raise("Invalid class escape");
					J.raise("Invalid escape")
				}
				J.pos = Q
			}
			var q = J.current();
			if (q !== 93) return J.lastIntValue = q, J.advance(), !0;
			return !1
		}, z.regexp_eatClassEscape = function(J) {
			var Q = J.pos;
			if (J.eat(98)) return J.lastIntValue = 8, !0;
			if (J.switchU && J.eat(45)) return J.lastIntValue = 45, !0;
			if (!J.switchU && J.eat(99)) {
				if (this.regexp_eatClassControlLetter(J)) return !0;
				J.pos = Q
			}
			return this.regexp_eatCharacterClassEscape(J) || this.regexp_eatCharacterEscape(J)
		}, z.regexp_classSetExpression = function(J) {
			var Q = h,
				Z;
			if (this.regexp_eatClassSetRange(J));
			else if (Z = this.regexp_eatClassSetOperand(J)) {
				if (Z === k) Q = k;
				var q = J.pos;
				while (J.eatChars([38, 38])) {
					if (J.current() !== 38 && (Z = this.regexp_eatClassSetOperand(J))) {
						if (Z !== k) Q = h;
						continue
					}
					J.raise("Invalid character in character class")
				}
				if (q !== J.pos) return Q;
				while (J.eatChars([45, 45])) {
					if (this.regexp_eatClassSetOperand(J)) continue;
					J.raise("Invalid character in character class")
				}
				if (q !== J.pos) return Q
			} else J.raise("Invalid character in character class");
			for (;;) {
				if (this.regexp_eatClassSetRange(J)) continue;
				if (Z = this.regexp_eatClassSetOperand(J), !Z) return Q;
				if (Z === k) Q = k
			}
		}, z.regexp_eatClassSetRange = function(J) {
			var Q = J.pos;
			if (this.regexp_eatClassSetCharacter(J)) {
				var Z = J.lastIntValue;
				if (J.eat(45) && this.regexp_eatClassSetCharacter(J)) {
					var q = J.lastIntValue;
					if (Z !== -1 && q !== -1 && Z > q) J.raise("Range out of order in character class");
					return !0
				}
				J.pos = Q
			}
			return !1
		}, z.regexp_eatClassSetOperand = function(J) {
			if (this.regexp_eatClassSetCharacter(J)) return h;
			return this.regexp_eatClassStringDisjunction(J) || this.regexp_eatNestedClass(J)
		}, z.regexp_eatNestedClass = function(J) {
			var Q = J.pos;
			if (J.eat(91)) {
				var Z = J.eat(94),
					q = this.regexp_classContents(J);
				if (J.eat(93)) {
					if (Z && q === k) J.raise("Negated character class may contain strings");
					return q
				}
				J.pos = Q
			}
			if (J.eat(92)) {
				var X = this.regexp_eatCharacterClassEscape(J);
				if (X) return X;
				J.pos = Q
			}
			return null
		}, z.regexp_eatClassStringDisjunction = function(J) {
			var Q = J.pos;
			if (J.eatChars([92, 113])) {
				if (J.eat(123)) {
					var Z = this.regexp_classStringDisjunctionContents(J);
					if (J.eat(125)) return Z
				} else J.raise("Invalid escape");
				J.pos = Q
			}
			return null
		}, z.regexp_classStringDisjunctionContents = function(J) {
			var Q = this.regexp_classString(J);
			while (J.eat(124))
				if (this.regexp_classString(J) === k) Q = k;
			return Q
		}, z.regexp_classString = function(J) {
			var Q = 0;
			while (this.regexp_eatClassSetCharacter(J)) Q++;
			return Q === 1 ? h : k
		}, z.regexp_eatClassSetCharacter = function(J) {
			var Q = J.pos;
			if (J.eat(92)) {
				if (this.regexp_eatCharacterEscape(J) || this.regexp_eatClassSetReservedPunctuator(J)) return !
				0;
				if (J.eat(98)) return J.lastIntValue = 8, !0;
				return J.pos = Q, !1
			}
			var Z = J.current();
			if (Z < 0 || Z === J.lookahead() && rQ(Z)) return !1;
			if (sQ(Z)) return !1;
			return J.advance(), J.lastIntValue = Z, !0
		};

		function rQ(J) {
			return J === 33 || J >= 35 && J <= 38 || J >= 42 && J <= 44 || J === 46 || J >= 58 && J <= 64 || J ===
				94 || J === 96 || J === 126
		}

		function sQ(J) {
			return J === 40 || J === 41 || J === 45 || J === 47 || J >= 91 && J <= 93 || J >= 123 && J <= 125
		}
		z.regexp_eatClassSetReservedPunctuator = function(J) {
			var Q = J.current();
			if (tQ(Q)) return J.lastIntValue = Q, J.advance(), !0;
			return !1
		};

		function tQ(J) {
			return J === 33 || J === 35 || J === 37 || J === 38 || J === 44 || J === 45 || J >= 58 && J <= 62 ||
				J === 64 || J === 96 || J === 126
		}
		z.regexp_eatClassControlLetter = function(J) {
			var Q = J.current();
			if (FJ(Q) || Q === 95) return J.lastIntValue = Q % 32, J.advance(), !0;
			return !1
		}, z.regexp_eatHexEscapeSequence = function(J) {
			var Q = J.pos;
			if (J.eat(120)) {
				if (this.regexp_eatFixedHexDigits(J, 2)) return !0;
				if (J.switchU) J.raise("Invalid escape");
				J.pos = Q
			}
			return !1
		}, z.regexp_eatDecimalDigits = function(J) {
			var Q = J.pos,
				Z = 0;
			J.lastIntValue = 0;
			while (FJ(Z = J.current())) J.lastIntValue = 10 * J.lastIntValue + (Z - 48), J.advance();
			return J.pos !== Q
		};

		function FJ(J) {
			return J >= 48 && J <= 57
		}
		z.regexp_eatHexDigits = function(J) {
			var Q = J.pos,
				Z = 0;
			J.lastIntValue = 0;
			while (zQ(Z = J.current())) J.lastIntValue = 16 * J.lastIntValue + GQ(Z), J.advance();
			return J.pos !== Q
		};

		function zQ(J) {
			return J >= 48 && J <= 57 || J >= 65 && J <= 70 || J >= 97 && J <= 102
		}

		function GQ(J) {
			if (J >= 65 && J <= 70) return 10 + (J - 65);
			if (J >= 97 && J <= 102) return 10 + (J - 97);
			return J - 48
		}
		z.regexp_eatLegacyOctalEscapeSequence = function(J) {
			if (this.regexp_eatOctalDigit(J)) {
				var Q = J.lastIntValue;
				if (this.regexp_eatOctalDigit(J)) {
					var Z = J.lastIntValue;
					if (Q <= 3 && this.regexp_eatOctalDigit(J)) J.lastIntValue = Q * 64 + Z * 8 + J
					.lastIntValue;
					else J.lastIntValue = Q * 8 + Z
				} else J.lastIntValue = Q;
				return !0
			}
			return !1
		}, z.regexp_eatOctalDigit = function(J) {
			var Q = J.current();
			if (RQ(Q)) return J.lastIntValue = Q - 48, J.advance(), !0;
			return J.lastIntValue = 0, !1
		};

		function RQ(J) {
			return J >= 48 && J <= 55
		}
		z.regexp_eatFixedHexDigits = function(J, Q) {
			var Z = J.pos;
			J.lastIntValue = 0;
			for (var q = 0; q < Q; ++q) {
				var X = J.current();
				if (!zQ(X)) return J.pos = Z, !1;
				J.lastIntValue = 16 * J.lastIntValue + GQ(X), J.advance()
			}
			return !0
		};
		var MJ = function J(Q) {
				if (this.type = Q.type, this.value = Q.value, this.start = Q.start, this.end = Q.end, Q.options
					.locations) this.loc = new s(Q, Q.startLoc, Q.endLoc);
				if (Q.options.ranges) this.range = [Q.start, Q.end]
			},
			V = $.prototype;
		if (V.next = function(J) {
				if (!J && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start,
					"Escape sequence in keyword " + this.type.keyword);
				if (this.options.onToken) this.options.onToken(new MJ(this));
				this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this
					.lastTokStartLoc = this.startLoc, this.nextToken()
			}, V.getToken = function() {
				return this.next(), new MJ(this)
			}, typeof Symbol !== "undefined") V[Symbol.iterator] = function() {
			var J = this;
			return {
				next: function() {
					var Q = J.getToken();
					return {
						done: Q.type === W.eof,
						value: Q
					}
				}
			}
		};
		V.nextToken = function() {
			var J = this.curContext();
			if (!J || !J.preserveSpace) this.skipSpace();
			if (this.start = this.pos, this.options.locations) this.startLoc = this.curPosition();
			if (this.pos >= this.input.length) return this.finishToken(W.eof);
			if (J.override) return J.override(this);
			else this.readToken(this.fullCharCodeAtPos())
		}, V.readToken = function(J) {
			if (T(J, this.options.ecmaVersion >= 6) || J === 92) return this.readWord();
			return this.getTokenFromCode(J)
		}, V.fullCharCodeAtPos = function() {
			var J = this.input.charCodeAt(this.pos);
			if (J <= 55295 || J >= 56320) return J;
			var Q = this.input.charCodeAt(this.pos + 1);
			return Q <= 56319 || Q >= 57344 ? J : (J << 10) + Q - 56613888
		}, V.skipBlockComment = function() {
			var J = this.options.onComment && this.curPosition(),
				Q = this.pos,
				Z = this.input.indexOf("*/", this.pos += 2);
			if (Z === -1) this.raise(this.pos - 2, "Unterminated comment");
			if (this.pos = Z + 2, this.options.locations)
				for (var q = void 0, X = Q;
					(q = DJ(this.input, X, this.pos)) > -1;) ++this.curLine, X = this.lineStart = q;
			if (this.options.onComment) this.options.onComment(!0, this.input.slice(Q + 2, Z), Q, this.pos, J,
				this.curPosition())
		}, V.skipLineComment = function(J) {
			var Q = this.pos,
				Z = this.options.onComment && this.curPosition(),
				q = this.input.charCodeAt(this.pos += J);
			while (this.pos < this.input.length && !l(q)) q = this.input.charCodeAt(++this.pos);
			if (this.options.onComment) this.options.onComment(!1, this.input.slice(Q + J, this.pos), Q, this
				.pos, Z, this.curPosition())
		}, V.skipSpace = function() {
			J: while (this.pos < this.input.length) {
				var J = this.input.charCodeAt(this.pos);
				switch (J) {
					case 32:
					case 160:
						++this.pos;
						break;
					case 13:
						if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
					case 10:
					case 8232:
					case 8233:
						if (++this.pos, this.options.locations) ++this.curLine, this.lineStart = this.pos;
						break;
					case 47:
						switch (this.input.charCodeAt(this.pos + 1)) {
							case 42:
								this.skipBlockComment();
								break;
							case 47:
								this.skipLineComment(2);
								break;
							default:
								break J
						}
						break;
					default:
						if (J > 8 && J < 14 || J >= 5760 && NJ.test(String.fromCharCode(J))) ++this.pos;
						else break J
				}
			}
		}, V.finishToken = function(J, Q) {
			if (this.end = this.pos, this.options.locations) this.endLoc = this.curPosition();
			var Z = this.type;
			this.type = J, this.value = Q, this.updateContext(Z)
		}, V.readToken_dot = function() {
			var J = this.input.charCodeAt(this.pos + 1);
			if (J >= 48 && J <= 57) return this.readNumber(!0);
			var Q = this.input.charCodeAt(this.pos + 2);
			if (this.options.ecmaVersion >= 6 && J === 46 && Q === 46) return this.pos += 3, this.finishToken(W
				.ellipsis);
			else return ++this.pos, this.finishToken(W.dot)
		}, V.readToken_slash = function() {
			var J = this.input.charCodeAt(this.pos + 1);
			if (this.exprAllowed) return ++this.pos, this.readRegexp();
			if (J === 61) return this.finishOp(W.assign, 2);
			return this.finishOp(W.slash, 1)
		}, V.readToken_mult_modulo_exp = function(J) {
			var Q = this.input.charCodeAt(this.pos + 1),
				Z = 1,
				q = J === 42 ? W.star : W.modulo;
			if (this.options.ecmaVersion >= 7 && J === 42 && Q === 42) ++Z, q = W.starstar, Q = this.input
				.charCodeAt(this.pos + 2);
			if (Q === 61) return this.finishOp(W.assign, Z + 1);
			return this.finishOp(q, Z)
		}, V.readToken_pipe_amp = function(J) {
			var Q = this.input.charCodeAt(this.pos + 1);
			if (Q === J) {
				if (this.options.ecmaVersion >= 12) {
					var Z = this.input.charCodeAt(this.pos + 2);
					if (Z === 61) return this.finishOp(W.assign, 3)
				}
				return this.finishOp(J === 124 ? W.logicalOR : W.logicalAND, 2)
			}
			if (Q === 61) return this.finishOp(W.assign, 2);
			return this.finishOp(J === 124 ? W.bitwiseOR : W.bitwiseAND, 1)
		}, V.readToken_caret = function() {
			var J = this.input.charCodeAt(this.pos + 1);
			if (J === 61) return this.finishOp(W.assign, 2);
			return this.finishOp(W.bitwiseXOR, 1)
		}, V.readToken_plus_min = function(J) {
			var Q = this.input.charCodeAt(this.pos + 1);
			if (Q === J) {
				if (Q === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this
						.lastTokEnd === 0 || b.test(this.input.slice(this.lastTokEnd, this.pos)))) return this
					.skipLineComment(3), this.skipSpace(), this.nextToken();
				return this.finishOp(W.incDec, 2)
			}
			if (Q === 61) return this.finishOp(W.assign, 2);
			return this.finishOp(W.plusMin, 1)
		}, V.readToken_lt_gt = function(J) {
			var Q = this.input.charCodeAt(this.pos + 1),
				Z = 1;
			if (Q === J) {
				if (Z = J === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(
						this.pos + Z) === 61) return this.finishOp(W.assign, Z + 1);
				return this.finishOp(W.bitShift, Z)
			}
			if (Q === 33 && J === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this
				.input.charCodeAt(this.pos + 3) === 45) return this.skipLineComment(4), this.skipSpace(), this
				.nextToken();
			if (Q === 61) Z = 2;
			return this.finishOp(W.relational, Z)
		}, V.readToken_eq_excl = function(J) {
			var Q = this.input.charCodeAt(this.pos + 1);
			if (Q === 61) return this.finishOp(W.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
			if (J === 61 && Q === 62 && this.options.ecmaVersion >= 6) return this.pos += 2, this.finishToken(W
				.arrow);
			return this.finishOp(J === 61 ? W.eq : W.prefix, 1)
		}, V.readToken_question = function() {
			var J = this.options.ecmaVersion;
			if (J >= 11) {
				var Q = this.input.charCodeAt(this.pos + 1);
				if (Q === 46) {
					var Z = this.input.charCodeAt(this.pos + 2);
					if (Z < 48 || Z > 57) return this.finishOp(W.questionDot, 2)
				}
				if (Q === 63) {
					if (J >= 12) {
						var q = this.input.charCodeAt(this.pos + 2);
						if (q === 61) return this.finishOp(W.assign, 3)
					}
					return this.finishOp(W.coalesce, 2)
				}
			}
			return this.finishOp(W.question, 1)
		}, V.readToken_numberSign = function() {
			var J = this.options.ecmaVersion,
				Q = 35;
			if (J >= 13) {
				if (++this.pos, Q = this.fullCharCodeAtPos(), T(Q, !0) || Q === 92) return this.finishToken(W
					.privateId, this.readWord1())
			}
			this.raise(this.pos, "Unexpected character '" + g(Q) + "'")
		}, V.getTokenFromCode = function(J) {
			switch (J) {
				case 46:
					return this.readToken_dot();
				case 40:
					return ++this.pos, this.finishToken(W.parenL);
				case 41:
					return ++this.pos, this.finishToken(W.parenR);
				case 59:
					return ++this.pos, this.finishToken(W.semi);
				case 44:
					return ++this.pos, this.finishToken(W.comma);
				case 91:
					return ++this.pos, this.finishToken(W.bracketL);
				case 93:
					return ++this.pos, this.finishToken(W.bracketR);
				case 123:
					return ++this.pos, this.finishToken(W.braceL);
				case 125:
					return ++this.pos, this.finishToken(W.braceR);
				case 58:
					return ++this.pos, this.finishToken(W.colon);
				case 96:
					if (this.options.ecmaVersion < 6) break;
					return ++this.pos, this.finishToken(W.backQuote);
				case 48:
					var Q = this.input.charCodeAt(this.pos + 1);
					if (Q === 120 || Q === 88) return this.readRadixNumber(16);
					if (this.options.ecmaVersion >= 6) {
						if (Q === 111 || Q === 79) return this.readRadixNumber(8);
						if (Q === 98 || Q === 66) return this.readRadixNumber(2)
					}
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
					return this.readNumber(!1);
				case 34:
				case 39:
					return this.readString(J);
				case 47:
					return this.readToken_slash();
				case 37:
				case 42:
					return this.readToken_mult_modulo_exp(J);
				case 124:
				case 38:
					return this.readToken_pipe_amp(J);
				case 94:
					return this.readToken_caret();
				case 43:
				case 45:
					return this.readToken_plus_min(J);
				case 60:
				case 62:
					return this.readToken_lt_gt(J);
				case 61:
				case 33:
					return this.readToken_eq_excl(J);
				case 63:
					return this.readToken_question();
				case 126:
					return this.finishOp(W.prefix, 1);
				case 35:
					return this.readToken_numberSign()
			}
			this.raise(this.pos, "Unexpected character '" + g(J) + "'")
		}, V.finishOp = function(J, Q) {
			var Z = this.input.slice(this.pos, this.pos + Q);
			return this.pos += Q, this.finishToken(J, Z)
		}, V.readRegexp = function() {
			var J, Q, Z = this.pos;
			for (;;) {
				if (this.pos >= this.input.length) this.raise(Z, "Unterminated regular expression");
				var q = this.input.charAt(this.pos);
				if (b.test(q)) this.raise(Z, "Unterminated regular expression");
				if (!J) {
					if (q === "[") Q = !0;
					else if (q === "]" && Q) Q = !1;
					else if (q === "/" && !Q) break;
					J = q === "\\"
				} else J = !1;
				++this.pos
			}
			var X = this.input.slice(Z, this.pos);
			++this.pos;
			var Y = this.pos,
				j = this.readWord1();
			if (this.containsEsc) this.unexpected(Y);
			var H = this.regexpState || (this.regexpState = new y(this));
			H.reset(Z, X, j), this.validateRegExpFlags(H), this.validateRegExpPattern(H);
			var K = null;
			try {
				K = new RegExp(X, j)
			} catch (R) {}
			return this.finishToken(W.regexp, {
				pattern: X,
				flags: j,
				value: K
			})
		}, V.readInt = function(J, Q, Z) {
			var q = this.options.ecmaVersion >= 12 && Q === void 0,
				X = Z && this.input.charCodeAt(this.pos) === 48,
				Y = this.pos,
				j = 0,
				H = 0;
			for (var K = 0, R = Q == null ? 1 / 0 : Q; K < R; ++K, ++this.pos) {
				var M = this.input.charCodeAt(this.pos),
					N = void 0;
				if (q && M === 95) {
					if (X) this.raiseRecoverable(this.pos,
						"Numeric separator is not allowed in legacy octal numeric literals");
					if (H === 95) this.raiseRecoverable(this.pos,
						"Numeric separator must be exactly one underscore");
					if (K === 0) this.raiseRecoverable(this.pos,
						"Numeric separator is not allowed at the first of digits");
					H = M;
					continue
				}
				if (M >= 97) N = M - 97 + 10;
				else if (M >= 65) N = M - 65 + 10;
				else if (M >= 48 && M <= 57) N = M - 48;
				else N = 1 / 0;
				if (N >= J) break;
				H = M, j = j * J + N
			}
			if (q && H === 95) this.raiseRecoverable(this.pos - 1,
				"Numeric separator is not allowed at the last of digits");
			if (this.pos === Y || Q != null && this.pos - Y !== Q) return null;
			return j
		};

		function eQ(J, Q) {
			if (Q) return parseInt(J, 8);
			return parseFloat(J.replace(/_/g, ""))
		}

		function FQ(J) {
			if (typeof BigInt !== "function") return null;
			return BigInt(J.replace(/_/g, ""))
		}
		V.readRadixNumber = function(J) {
			var Q = this.pos;
			this.pos += 2;
			var Z = this.readInt(J);
			if (Z == null) this.raise(this.start + 2, "Expected number in radix " + J);
			if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) Z = FQ(this.input
				.slice(Q, this.pos)), ++this.pos;
			else if (T(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
			return this.finishToken(W.num, Z)
		}, V.readNumber = function(J) {
			var Q = this.pos;
			if (!J && this.readInt(10, void 0, !0) === null) this.raise(Q, "Invalid number");
			var Z = this.pos - Q >= 2 && this.input.charCodeAt(Q) === 48;
			if (Z && this.strict) this.raise(Q, "Invalid number");
			var q = this.input.charCodeAt(this.pos);
			if (!Z && !J && this.options.ecmaVersion >= 11 && q === 110) {
				var X = FQ(this.input.slice(Q, this.pos));
				if (++this.pos, T(this.fullCharCodeAtPos())) this.raise(this.pos,
					"Identifier directly after number");
				return this.finishToken(W.num, X)
			}
			if (Z && /[89]/.test(this.input.slice(Q, this.pos))) Z = !1;
			if (q === 46 && !Z) ++this.pos, this.readInt(10), q = this.input.charCodeAt(this.pos);
			if ((q === 69 || q === 101) && !Z) {
				if (q = this.input.charCodeAt(++this.pos), q === 43 || q === 45) ++this.pos;
				if (this.readInt(10) === null) this.raise(Q, "Invalid number")
			}
			if (T(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
			var Y = eQ(this.input.slice(Q, this.pos), Z);
			return this.finishToken(W.num, Y)
		}, V.readCodePoint = function() {
			var J = this.input.charCodeAt(this.pos),
				Q;
			if (J === 123) {
				if (this.options.ecmaVersion < 6) this.unexpected();
				var Z = ++this.pos;
				if (Q = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, Q > 1114111)
					this.invalidStringToken(Z, "Code point out of bounds")
			} else Q = this.readHexChar(4);
			return Q
		}, V.readString = function(J) {
			var Q = "",
				Z = ++this.pos;
			for (;;) {
				if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
				var q = this.input.charCodeAt(this.pos);
				if (q === J) break;
				if (q === 92) Q += this.input.slice(Z, this.pos), Q += this.readEscapedChar(!1), Z = this.pos;
				else if (q === 8232 || q === 8233) {
					if (this.options.ecmaVersion < 10) this.raise(this.start, "Unterminated string constant");
					if (++this.pos, this.options.locations) this.curLine++, this.lineStart = this.pos
				} else {
					if (l(q)) this.raise(this.start, "Unterminated string constant");
					++this.pos
				}
			}
			return Q += this.input.slice(Z, this.pos++), this.finishToken(W.string, Q)
		};
		var MQ = {};
		V.tryReadTemplateToken = function() {
			this.inTemplateElement = !0;
			try {
				this.readTmplToken()
			} catch (J) {
				if (J === MQ) this.readInvalidTemplateToken();
				else throw J
			}
			this.inTemplateElement = !1
		}, V.invalidStringToken = function(J, Q) {
			if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw MQ;
			else this.raise(J, Q)
		}, V.readTmplToken = function() {
			var J = "",
				Q = this.pos;
			for (;;) {
				if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
				var Z = this.input.charCodeAt(this.pos);
				if (Z === 96 || Z === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
					if (this.pos === this.start && (this.type === W.template || this.type === W
						.invalidTemplate))
						if (Z === 36) return this.pos += 2, this.finishToken(W.dollarBraceL);
						else return ++this.pos, this.finishToken(W.backQuote);
					return J += this.input.slice(Q, this.pos), this.finishToken(W.template, J)
				}
				if (Z === 92) J += this.input.slice(Q, this.pos), J += this.readEscapedChar(!0), Q = this.pos;
				else if (l(Z)) {
					switch (J += this.input.slice(Q, this.pos), ++this.pos, Z) {
						case 13:
							if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
						case 10:
							J += `
`;
							break;
						default:
							J += String.fromCharCode(Z);
							break
					}
					if (this.options.locations) ++this.curLine, this.lineStart = this.pos;
					Q = this.pos
				} else ++this.pos
			}
		}, V.readInvalidTemplateToken = function() {
			for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
				case "\\":
					++this.pos;
					break;
				case "$":
					if (this.input[this.pos + 1] !== "{") break;
				case "`":
					return this.finishToken(W.invalidTemplate, this.input.slice(this.start, this.pos));
				case "\r":
					if (this.input[this.pos + 1] === `
`) ++this.pos;
				case `
`:
				case "\u2028":
				case "\u2029":
					++this.curLine, this.lineStart = this.pos + 1;
					break
			}
			this.raise(this.start, "Unterminated template")
		}, V.readEscapedChar = function(J) {
			var Q = this.input.charCodeAt(++this.pos);
			switch (++this.pos, Q) {
				case 110:
					return `
`;
				case 114:
					return "\r";
				case 120:
					return String.fromCharCode(this.readHexChar(2));
				case 117:
					return g(this.readCodePoint());
				case 116:
					return "\t";
				case 98:
					return "\b";
				case 118:
					return "\v";
				case 102:
					return "\f";
				case 13:
					if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
				case 10:
					if (this.options.locations) this.lineStart = this.pos, ++this.curLine;
					return "";
				case 56:
				case 57:
					if (this.strict) this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
					if (J) {
						var Z = this.pos - 1;
						this.invalidStringToken(Z, "Invalid escape sequence in template string")
					}
				default:
					if (Q >= 48 && Q <= 55) {
						var q = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0],
							X = parseInt(q, 8);
						if (X > 255) q = q.slice(0, -1), X = parseInt(q, 8);
						if (this.pos += q.length - 1, Q = this.input.charCodeAt(this.pos), (q !== "0" || Q ===
								56 || Q === 57) && (this.strict || J)) this.invalidStringToken(this.pos - 1 - q
							.length, J ? "Octal literal in template string" : "Octal literal in strict mode"
							);
						return String.fromCharCode(X)
					}
					if (l(Q)) {
						if (this.options.locations) this.lineStart = this.pos, ++this.curLine;
						return ""
					}
					return String.fromCharCode(Q)
			}
		}, V.readHexChar = function(J) {
			var Q = this.pos,
				Z = this.readInt(16, J);
			if (Z === null) this.invalidStringToken(Q, "Bad character escape sequence");
			return Z
		}, V.readWord1 = function() {
			this.containsEsc = !1;
			var J = "",
				Q = !0,
				Z = this.pos,
				q = this.options.ecmaVersion >= 6;
			while (this.pos < this.input.length) {
				var X = this.fullCharCodeAtPos();
				if (x(X, q)) this.pos += X <= 65535 ? 1 : 2;
				else if (X === 92) {
					this.containsEsc = !0, J += this.input.slice(Z, this.pos);
					var Y = this.pos;
					if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos,
						"Expecting Unicode escape sequence \\uXXXX");
					++this.pos;
					var j = this.readCodePoint();
					if (!(Q ? T : x)(j, q)) this.invalidStringToken(Y, "Invalid Unicode escape");
					J += g(j), Z = this.pos
				} else break;
				Q = !1
			}
			return J + this.input.slice(Z, this.pos)
		}, V.readWord = function() {
			var J = this.readWord1(),
				Q = W.name;
			if (this.keywords.test(J)) Q = WJ[J];
			return this.finishToken(Q, J)
		};
		var VQ = "8.15.0";
		$.acorn = {
			Parser: $,
			version: VQ,
			defaultOptions: XJ,
			Position: d,
			SourceLocation: s,
			getLineInfo: $J,
			Node: QJ,
			TokenType: _,
			tokTypes: W,
			keywordTypes: WJ,
			TokContext: P,
			tokContexts: U,
			isIdentifierChar: x,
			isIdentifierStart: T,
			Token: MJ,
			isNewLine: l,
			lineBreak: b,
			lineBreakG: TJ,
			nonASCIIwhitespace: NJ
		};

		function JZ(J, Q) {
			return $.parse(J, Q)
		}

		function QZ(J, Q, Z) {
			return $.parseExpressionAt(J, Q, Z)
		}

		function ZZ(J, Q) {
			return $.tokenizer(J, Q)
		}
		B.Node = QJ, B.Parser = $, B.Position = d, B.SourceLocation = s, B.TokContext = P, B.Token = MJ, B
			.TokenType = _, B.defaultOptions = XJ, B.getLineInfo = $J, B.isIdentifierChar = x, B.isIdentifierStart =
			T, B.isNewLine = l, B.keywordTypes = WJ, B.lineBreak = b, B.lineBreakG = TJ, B.nonASCIIwhitespace = NJ,
			B.parse = JZ, B.parseExpressionAt = QZ, B.tokContexts = U, B.tokTypes = W, B.tokenizer = ZZ, B.version =
			VQ
	})
});
var WZ = _Q(),
	jZ = WZ;
export {
	jZ as
	default
};</script>
		<script type="blob-module" name="@std/formatter" remote="../modules/client/formatter.js">// js-beautify@1.15.4
//
//
// Credits:
//
// Created by Einar Lielmanis, einar@beautifier.io
//
// Maintained and expanded by Liam Newman bitwiseman@beautifier.io
//
// Thanks also to Jason Diamond, Patrick Hof, Nochum Sossonko, Andreas Schneider,
// Dave Vasilevsky, Vital Batmanov, Ron Baldwin, Gabriel Harrison, Chris J. Shull,
// Mathias Bynens, Vittorio Gambaletta and others.

var sI = Object.create;
var {
	getPrototypeOf: kI,
	defineProperty: mR,
	getOwnPropertyNames: oI
} = Object;
var aI = Object.prototype.hasOwnProperty;
var _I = (R, I, A) => {
	A = R != null ? sI(kI(R)) : {};
	let H = I || !R || !R.__esModule ? mR(A, "default", {
		value: R,
		enumerable: !0
	}) : A;
	for (let S of oI(R))
		if (!aI.call(H, S)) mR(H, S, {
			get: () => R[S],
			enumerable: !0
		});
	return H
};
var X = (R, I) => () => (I || R((I = {
	exports: {}
}).exports, I), I.exports);
var HR = X((rI, dR) => {
	function P(R) {
		this.__parent = R, this.__character_count = 0, this.__indent_count = -1, this.__alignment_count = 0, this
			.__wrap_point_index = 0, this.__wrap_point_character_count = 0, this.__wrap_point_indent_count = -1, this
			.__wrap_point_alignment_count = 0, this.__items = []
	}
	P.prototype.clone_empty = function() {
		var R = new P(this.__parent);
		return R.set_indent(this.__indent_count, this.__alignment_count), R
	};
	P.prototype.item = function(R) {
		if (R < 0) return this.__items[this.__items.length + R];
		else return this.__items[R]
	};
	P.prototype.has_match = function(R) {
		for (var I = this.__items.length - 1; I >= 0; I--)
			if (this.__items[I].match(R)) return !0;
		return !1
	};
	P.prototype.set_indent = function(R, I) {
		if (this.is_empty()) this.__indent_count = R || 0, this.__alignment_count = I || 0, this.__character_count =
			this.__parent.get_indent_size(this.__indent_count, this.__alignment_count)
	};
	P.prototype._set_wrap_point = function() {
		if (this.__parent.wrap_line_length) this.__wrap_point_index = this.__items.length, this
			.__wrap_point_character_count = this.__character_count, this.__wrap_point_indent_count = this.__parent
			.next_line.__indent_count, this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count
	};
	P.prototype._should_wrap = function() {
		return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this
			.__wrap_point_character_count > this.__parent.next_line.__character_count
	};
	P.prototype._allow_wrap = function() {
		if (this._should_wrap()) {
			this.__parent.add_new_line();
			var R = this.__parent.current_line;
			if (R.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count), R.__items = this
				.__items.slice(this.__wrap_point_index), this.__items = this.__items.slice(0, this
					.__wrap_point_index), R.__character_count += this.__character_count - this
				.__wrap_point_character_count, this.__character_count = this.__wrap_point_character_count, R
				.__items[0] === " ") R.__items.splice(0, 1), R.__character_count -= 1;
			return !0
		}
		return !1
	};
	P.prototype.is_empty = function() {
		return this.__items.length === 0
	};
	P.prototype.last = function() {
		if (!this.is_empty()) return this.__items[this.__items.length - 1];
		else return null
	};
	P.prototype.push = function(R) {
		this.__items.push(R);
		var I = R.lastIndexOf(`
`);
		if (I !== -1) this.__character_count = R.length - I;
		else this.__character_count += R.length
	};
	P.prototype.pop = function() {
		var R = null;
		if (!this.is_empty()) R = this.__items.pop(), this.__character_count -= R.length;
		return R
	};
	P.prototype._remove_indent = function() {
		if (this.__indent_count > 0) this.__indent_count -= 1, this.__character_count -= this.__parent.indent_size
	};
	P.prototype._remove_wrap_indent = function() {
		if (this.__wrap_point_indent_count > 0) this.__wrap_point_indent_count -= 1
	};
	P.prototype.trim = function() {
		while (this.last() === " ") this.__items.pop(), this.__character_count -= 1
	};
	P.prototype.toString = function() {
		var R = "";
		if (this.is_empty()) {
			if (this.__parent.indent_empty_lines) R = this.__parent.get_indent_string(this.__indent_count)
		} else R = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count), R += this.__items
			.join("");
		return R
	};

	function s(R, I) {
		if (this.__cache = [""], this.__indent_size = R.indent_size, this.__indent_string = R.indent_char, !R
			.indent_with_tabs) this.__indent_string = new Array(R.indent_size + 1).join(R.indent_char);
		if (I = I || "", R.indent_level > 0) I = new Array(R.indent_level + 1).join(this.__indent_string);
		this.__base_string = I, this.__base_string_length = I.length
	}
	s.prototype.get_indent_size = function(R, I) {
		var A = this.__base_string_length;
		if (I = I || 0, R < 0) A = 0;
		return A += R * this.__indent_size, A += I, A
	};
	s.prototype.get_indent_string = function(R, I) {
		var A = this.__base_string;
		if (I = I || 0, R < 0) R = 0, A = "";
		return I += R * this.__indent_size, this.__ensure_cache(I), A += this.__cache[I], A
	};
	s.prototype.__ensure_cache = function(R) {
		while (R >= this.__cache.length) this.__add_column()
	};
	s.prototype.__add_column = function() {
		var R = this.__cache.length,
			I = 0,
			A = "";
		if (this.__indent_size && R >= this.__indent_size) I = Math.floor(R / this.__indent_size), R -= I * this
			.__indent_size, A = new Array(I + 1).join(this.__indent_string);
		if (R) A += new Array(R + 1).join(" ");
		this.__cache.push(A)
	};

	function J(R, I) {
		this.__indent_cache = new s(R, I), this.raw = !1, this._end_with_newline = R.end_with_newline, this
			.indent_size = R.indent_size, this.wrap_line_length = R.wrap_line_length, this.indent_empty_lines = R
			.indent_empty_lines, this.__lines = [], this.previous_line = null, this.current_line = null, this
			.next_line = new P(this), this.space_before_token = !1, this.non_breaking_space = !1, this
			.previous_token_wrapped = !1, this.__add_outputline()
	}
	J.prototype.__add_outputline = function() {
		this.previous_line = this.current_line, this.current_line = this.next_line.clone_empty(), this.__lines.push(
			this.current_line)
	};
	J.prototype.get_line_number = function() {
		return this.__lines.length
	};
	J.prototype.get_indent_string = function(R, I) {
		return this.__indent_cache.get_indent_string(R, I)
	};
	J.prototype.get_indent_size = function(R, I) {
		return this.__indent_cache.get_indent_size(R, I)
	};
	J.prototype.is_empty = function() {
		return !this.previous_line && this.current_line.is_empty()
	};
	J.prototype.add_new_line = function(R) {
		if (this.is_empty() || !R && this.just_added_newline()) return !1;
		if (!this.raw) this.__add_outputline();
		return !0
	};
	J.prototype.get_code = function(R) {
		this.trim(!0);
		var I = this.current_line.pop();
		if (I) {
			if (I[I.length - 1] === `
`) I = I.replace(/\n+$/g, "");
			this.current_line.push(I)
		}
		if (this._end_with_newline) this.__add_outputline();
		var A = this.__lines.join(`
`);
		if (R !== `
`) A = A.replace(/[\n]/g, R);
		return A
	};
	J.prototype.set_wrap_point = function() {
		this.current_line._set_wrap_point()
	};
	J.prototype.set_indent = function(R, I) {
		if (R = R || 0, I = I || 0, this.next_line.set_indent(R, I), this.__lines.length > 1) return this
			.current_line.set_indent(R, I), !0;
		return this.current_line.set_indent(), !1
	};
	J.prototype.add_raw_token = function(R) {
		for (var I = 0; I < R.newlines; I++) this.__add_outputline();
		this.current_line.set_indent(-1), this.current_line.push(R.whitespace_before), this.current_line.push(R
			.text), this.space_before_token = !1, this.non_breaking_space = !1, this.previous_token_wrapped = !1
	};
	J.prototype.add_token = function(R) {
		this.__add_space_before_token(), this.current_line.push(R), this.space_before_token = !1, this
			.non_breaking_space = !1, this.previous_token_wrapped = this.current_line._allow_wrap()
	};
	J.prototype.__add_space_before_token = function() {
		if (this.space_before_token && !this.just_added_newline()) {
			if (!this.non_breaking_space) this.set_wrap_point();
			this.current_line.push(" ")
		}
	};
	J.prototype.remove_indent = function(R) {
		var I = this.__lines.length;
		while (R < I) this.__lines[R]._remove_indent(), R++;
		this.current_line._remove_wrap_indent()
	};
	J.prototype.trim = function(R) {
		R = R === void 0 ? !1 : R, this.current_line.trim();
		while (R && this.__lines.length > 1 && this.current_line.is_empty()) this.__lines.pop(), this.current_line =
			this.__lines[this.__lines.length - 1], this.current_line.trim();
		this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null
	};
	J.prototype.just_added_newline = function() {
		return this.current_line.is_empty()
	};
	J.prototype.just_added_blankline = function() {
		return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty()
	};
	J.prototype.ensure_empty_line_above = function(R, I) {
		var A = this.__lines.length - 2;
		while (A >= 0) {
			var H = this.__lines[A];
			if (H.is_empty()) break;
			else if (H.item(0).indexOf(R) !== 0 && H.item(-1) !== I) {
				this.__lines.splice(A + 1, 0, new P(this)), this.previous_line = this.__lines[this.__lines.length -
					2];
				break
			}
			A--
		}
	};
	rI.Output = J
});
var CR = X((eI, gR) => {
	function tI(R, I, A, H) {
		this.type = R, this.text = I, this.comments_before = null, this.newlines = A || 0, this.whitespace_before = H ||
			"", this.parent = null, this.next = null, this.previous = null, this.opened = null, this.closed = null, this
			.directives = null
	}
	eI.Token = tI
});
var XR = X((HA) => {
	var IA = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a",
		lR = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a",
		MR =
		"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc",
		pR =
		"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f",
		qR = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}",
		cR = "(?:" + qR + "|[" + IA + MR + "])",
		AA = "(?:" + qR + "|[" + lR + MR + pR + "])*";
	HA.identifier = new RegExp(cR + AA, "g");
	HA.identifierStart = new RegExp(cR);
	HA.identifierMatch = new RegExp("(?:" + qR + "|[" + lR + MR + pR + "])+");
	HA.newline = /[\n\r\u2028\u2029]/;
	HA.lineBreak = new RegExp(`\r
|` + HA.newline.source);
	HA.allLineBreaks = new RegExp(HA.lineBreak.source, "g")
});
var LR = X((UA, SR) => {
	function v(R, I) {
		if (this.raw_options = sR(R, I), this.disabled = this._get_boolean("disabled"), this.eol = this._get_characters(
				"eol", "auto"), this.end_with_newline = this._get_boolean("end_with_newline"), this.indent_size = this
			._get_number("indent_size", 4), this.indent_char = this._get_characters("indent_char", " "), this
			.indent_level = this._get_number("indent_level"), this.preserve_newlines = this._get_boolean(
				"preserve_newlines", !0), this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786),
			!this.preserve_newlines) this.max_preserve_newlines = 0;
		if (this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "\t"), this
			.indent_with_tabs) {
			if (this.indent_char = "\t", this.indent_size === 1) this.indent_size = 4
		}
		this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char")), this
			.indent_empty_lines = this._get_boolean("indent_empty_lines"), this.templating = this._get_selection_list(
				"templating", ["auto", "none", "angular", "django", "erb", "handlebars", "php", "smarty"], ["auto"])
	}
	v.prototype._get_array = function(R, I) {
		var A = this.raw_options[R],
			H = I || [];
		if (typeof A === "object") {
			if (A !== null && typeof A.concat === "function") H = A.concat()
		} else if (typeof A === "string") H = A.split(/[^a-zA-Z0-9_\/\-]+/);
		return H
	};
	v.prototype._get_boolean = function(R, I) {
		var A = this.raw_options[R],
			H = A === void 0 ? !!I : !!A;
		return H
	};
	v.prototype._get_characters = function(R, I) {
		var A = this.raw_options[R],
			H = I || "";
		if (typeof A === "string") H = A.replace(/\\r/, "\r").replace(/\\n/, `
`).replace(/\\t/, "\t");
		return H
	};
	v.prototype._get_number = function(R, I) {
		var A = this.raw_options[R];
		if (I = parseInt(I, 10), isNaN(I)) I = 0;
		var H = parseInt(A, 10);
		if (isNaN(H)) H = I;
		return H
	};
	v.prototype._get_selection = function(R, I, A) {
		var H = this._get_selection_list(R, I, A);
		if (H.length !== 1) throw new Error("Invalid Option Value: The option '" + R + `' can only be one of the following values:
` + I + `
You passed in: '` + this.raw_options[R] + "'");
		return H[0]
	};
	v.prototype._get_selection_list = function(R, I, A) {
		if (!I || I.length === 0) throw new Error("Selection list cannot be empty.");
		if (A = A || [I[0]], !this._is_valid_selection(A, I)) throw new Error("Invalid Default Value!");
		var H = this._get_array(R, A);
		if (!this._is_valid_selection(H, I)) throw new Error("Invalid Option Value: The option '" + R + `' can contain only the following values:
` + I + `
You passed in: '` + this.raw_options[R] + "'");
		return H
	};
	v.prototype._is_valid_selection = function(R, I) {
		return R.length && I.length && !R.some(function(A) {
			return I.indexOf(A) === -1
		})
	};

	function sR(R, I) {
		var A = {};
		R = kR(R);
		var H;
		for (H in R)
			if (H !== I) A[H] = R[H];
		if (I && R[I])
			for (H in R[I]) A[H] = R[I][H];
		return A
	}

	function kR(R) {
		var I = {},
			A;
		for (A in R) {
			var H = A.replace(/-/g, "_");
			I[H] = R[A]
		}
		return I
	}
	UA.Options = v;
	UA.normalizeOpts = kR;
	UA.mergeOpts = sR
});
var ER = X((DA, _R) => {
	var oR = LR().Options,
		GA = ["before-newline", "after-newline", "preserve-newline"];

	function aR(R) {
		oR.call(this, R, "js");
		var I = this.raw_options.brace_style || null;
		if (I === "expand-strict") this.raw_options.brace_style = "expand";
		else if (I === "collapse-preserve-inline") this.raw_options.brace_style = "collapse,preserve-inline";
		else if (this.raw_options.braces_on_own_line !== void 0) this.raw_options.brace_style = this.raw_options
			.braces_on_own_line ? "expand" : "collapse";
		var A = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none",
		"preserve-inline"]);
		this.brace_preserve_inline = !1, this.brace_style = "collapse";
		for (var H = 0; H < A.length; H++)
			if (A[H] === "preserve-inline") this.brace_preserve_inline = !0;
			else this.brace_style = A[H];
		if (this.unindent_chained_methods = this._get_boolean("unindent_chained_methods"), this.break_chained_methods =
			this._get_boolean("break_chained_methods"), this.space_in_paren = this._get_boolean("space_in_paren"), this
			.space_in_empty_paren = this._get_boolean("space_in_empty_paren"), this.jslint_happy = this._get_boolean(
				"jslint_happy"), this.space_after_anon_function = this._get_boolean("space_after_anon_function"), this
			.space_after_named_function = this._get_boolean("space_after_named_function"), this.keep_array_indentation =
			this._get_boolean("keep_array_indentation"), this.space_before_conditional = this._get_boolean(
				"space_before_conditional", !0), this.unescape_strings = this._get_boolean("unescape_strings"), this
			.e4x = this._get_boolean("e4x"), this.comma_first = this._get_boolean("comma_first"), this
			.operator_position = this._get_selection("operator_position", GA), this.test_output_raw = this._get_boolean(
				"test_output_raw"), this.jslint_happy) this.space_after_anon_function = !0
	}
	aR.prototype = new oR;
	DA.Options = aR
});
var FR = X((MA, nR) => {
	var rR = RegExp.prototype.hasOwnProperty("sticky");

	function Q(R) {
		this.__input = R || "", this.__input_length = this.__input.length, this.__position = 0
	}
	Q.prototype.restart = function() {
		this.__position = 0
	};
	Q.prototype.back = function() {
		if (this.__position > 0) this.__position -= 1
	};
	Q.prototype.hasNext = function() {
		return this.__position < this.__input_length
	};
	Q.prototype.next = function() {
		var R = null;
		if (this.hasNext()) R = this.__input.charAt(this.__position), this.__position += 1;
		return R
	};
	Q.prototype.peek = function(R) {
		var I = null;
		if (R = R || 0, R += this.__position, R >= 0 && R < this.__input_length) I = this.__input.charAt(R);
		return I
	};
	Q.prototype.__match = function(R, I) {
		R.lastIndex = I;
		var A = R.exec(this.__input);
		if (A && !(rR && R.sticky)) {
			if (A.index !== I) A = null
		}
		return A
	};
	Q.prototype.test = function(R, I) {
		if (I = I || 0, I += this.__position, I >= 0 && I < this.__input_length) return !!this.__match(R, I);
		else return !1
	};
	Q.prototype.testChar = function(R, I) {
		var A = this.peek(I);
		return R.lastIndex = 0, A !== null && R.test(A)
	};
	Q.prototype.match = function(R) {
		var I = this.__match(R, this.__position);
		if (I) this.__position += I[0].length;
		else I = null;
		return I
	};
	Q.prototype.read = function(R, I, A) {
		var H = "",
			S;
		if (R) {
			if (S = this.match(R), S) H += S[0]
		}
		if (I && (S || !R)) H += this.readUntil(I, A);
		return H
	};
	Q.prototype.readUntil = function(R, I) {
		var A = "",
			H = this.__position;
		R.lastIndex = this.__position;
		var S = R.exec(this.__input);
		if (S) {
			if (H = S.index, I) H += S[0].length
		} else H = this.__input_length;
		return A = this.__input.substring(this.__position, H), this.__position = H, A
	};
	Q.prototype.readUntilAfter = function(R) {
		return this.readUntil(R, !0)
	};
	Q.prototype.get_regexp = function(R, I) {
		var A = null,
			H = "g";
		if (I && rR) H = "y";
		if (typeof R === "string" && R !== "") A = new RegExp(R, H);
		else if (R) A = new RegExp(R.source, H);
		return A
	};
	Q.prototype.get_literal_regexp = function(R) {
		return RegExp(R.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"))
	};
	Q.prototype.peekUntilAfter = function(R) {
		var I = this.__position,
			A = this.readUntilAfter(R);
		return this.__position = I, A
	};
	Q.prototype.lookBack = function(R) {
		var I = this.__position - 1;
		return I >= R.length && this.__input.substring(I - R.length, I).toLowerCase() === R
	};
	MA.InputScanner = Q
});
var eR = X((XA, tR) => {
	function g(R) {
		this.__tokens = [], this.__tokens_length = this.__tokens.length, this.__position = 0, this.__parent_token = R
	}
	g.prototype.restart = function() {
		this.__position = 0
	};
	g.prototype.isEmpty = function() {
		return this.__tokens_length === 0
	};
	g.prototype.hasNext = function() {
		return this.__position < this.__tokens_length
	};
	g.prototype.next = function() {
		var R = null;
		if (this.hasNext()) R = this.__tokens[this.__position], this.__position += 1;
		return R
	};
	g.prototype.peek = function(R) {
		var I = null;
		if (R = R || 0, R += this.__position, R >= 0 && R < this.__tokens_length) I = this.__tokens[R];
		return I
	};
	g.prototype.add = function(R) {
		if (this.__parent_token) R.parent = this.__parent_token;
		this.__tokens.push(R), this.__tokens_length += 1
	};
	XA.TokenStream = g
});
var k = X((PA, RI) => {
	function b(R, I) {
		if (this._input = R, this._starting_pattern = null, this._match_pattern = null, this._until_pattern = null, this
			._until_after = !1, I) this._starting_pattern = this._input.get_regexp(I._starting_pattern, !0), this
			._match_pattern = this._input.get_regexp(I._match_pattern, !0), this._until_pattern = this._input
			.get_regexp(I._until_pattern), this._until_after = I._until_after
	}
	b.prototype.read = function() {
		var R = this._input.read(this._starting_pattern);
		if (!this._starting_pattern || R) R += this._input.read(this._match_pattern, this._until_pattern, this
			._until_after);
		return R
	};
	b.prototype.read_match = function() {
		return this._input.match(this._match_pattern)
	};
	b.prototype.until_after = function(R) {
		var I = this._create();
		return I._until_after = !0, I._until_pattern = this._input.get_regexp(R), I._update(), I
	};
	b.prototype.until = function(R) {
		var I = this._create();
		return I._until_after = !1, I._until_pattern = this._input.get_regexp(R), I._update(), I
	};
	b.prototype.starting_with = function(R) {
		var I = this._create();
		return I._starting_pattern = this._input.get_regexp(R, !0), I._update(), I
	};
	b.prototype.matching = function(R) {
		var I = this._create();
		return I._match_pattern = this._input.get_regexp(R, !0), I._update(), I
	};
	b.prototype._create = function() {
		return new b(this._input, this)
	};
	b.prototype._update = function() {};
	PA.Pattern = b
});
var HI = X((ZA, AI) => {
	var II = k().Pattern;

	function m(R, I) {
		if (II.call(this, R, I), I) this._line_regexp = this._input.get_regexp(I._line_regexp);
		else this.__set_whitespace_patterns("", "");
		this.newline_count = 0, this.whitespace_before_token = ""
	}
	m.prototype = new II;
	m.prototype.__set_whitespace_patterns = function(R, I) {
		R += "\\t ", I += "\\n\\r", this._match_pattern = this._input.get_regexp("[" + R + I + "]+", !0), this
			._newline_regexp = this._input.get_regexp("\\r\\n|[" + I + "]")
	};
	m.prototype.read = function() {
		this.newline_count = 0, this.whitespace_before_token = "";
		var R = this._input.read(this._match_pattern);
		if (R === " ") this.whitespace_before_token = " ";
		else if (R) {
			var I = this.__split(this._newline_regexp, R);
			this.newline_count = I.length - 1, this.whitespace_before_token = I[this.newline_count]
		}
		return R
	};
	m.prototype.matching = function(R, I) {
		var A = this._create();
		return A.__set_whitespace_patterns(R, I), A._update(), A
	};
	m.prototype._create = function() {
		return new m(this._input, this)
	};
	m.prototype.__split = function(R, I) {
		R.lastIndex = 0;
		var A = 0,
			H = [],
			S = R.exec(I);
		while (S) H.push(I.substring(A, S.index)), A = S.index + S[0].length, S = R.exec(I);
		if (A < I.length) H.push(I.substring(A, I.length));
		else H.push("");
		return H
	};
	ZA.WhitespacePattern = m
});
var a = X((VA, JR) => {
	var QA = FR().InputScanner,
		SI = CR().Token,
		PR = eR().TokenStream,
		NA = HI().WhitespacePattern,
		o = {
			START: "TK_START",
			RAW: "TK_RAW",
			EOF: "TK_EOF"
		},
		w = function(R, I) {
			this._input = new QA(R), this._options = I || {}, this.__tokens = null, this._patterns = {}, this._patterns
				.whitespace = new NA(this._input)
		};
	w.prototype.tokenize = function() {
		this._input.restart(), this.__tokens = new PR, this._reset();
		var R, I = new SI(o.START, ""),
			A = null,
			H = [],
			S = new PR;
		while (I.type !== o.EOF) {
			R = this._get_next_token(I, A);
			while (this._is_comment(R)) S.add(R), R = this._get_next_token(I, A);
			if (!S.isEmpty()) R.comments_before = S, S = new PR;
			if (R.parent = A, this._is_opening(R)) H.push(A), A = R;
			else if (A && this._is_closing(R, A)) R.opened = A, A.closed = R, A = H.pop(), R.parent = A;
			R.previous = I, I.next = R, this.__tokens.add(R), I = R
		}
		return this.__tokens
	};
	w.prototype._is_first_token = function() {
		return this.__tokens.isEmpty()
	};
	w.prototype._reset = function() {};
	w.prototype._get_next_token = function(R, I) {
		this._readWhitespace();
		var A = this._input.read(/.+/g);
		if (A) return this._create_token(o.RAW, A);
		else return this._create_token(o.EOF, "")
	};
	w.prototype._is_comment = function(R) {
		return !1
	};
	w.prototype._is_opening = function(R) {
		return !1
	};
	w.prototype._is_closing = function(R, I) {
		return !1
	};
	w.prototype._create_token = function(R, I) {
		var A = new SI(R, I, this._patterns.whitespace.newline_count, this._patterns.whitespace
			.whitespace_before_token);
		return A
	};
	w.prototype._readWhitespace = function() {
		return this._patterns.whitespace.read()
	};
	VA.Tokenizer = w;
	VA.TOKEN = o
});
var WR = X((zA, LI) => {
	function ZR(R, I) {
		R = typeof R === "string" ? R : R.source, I = typeof I === "string" ? I : I.source, this
			.__directives_block_pattern = new RegExp(R + / beautify( \w+[:]\w+)+ /.source + I, "g"), this
			.__directive_pattern = / (\w+)[:](\w+)/g, this.__directives_end_ignore_pattern = new RegExp(R +
				/\sbeautify\signore:end\s/.source + I, "g")
	}
	ZR.prototype.get_directives = function(R) {
		if (!R.match(this.__directives_block_pattern)) return null;
		var I = {};
		this.__directive_pattern.lastIndex = 0;
		var A = this.__directive_pattern.exec(R);
		while (A) I[A[1]] = A[2], A = this.__directive_pattern.exec(R);
		return I
	};
	ZR.prototype.readIgnored = function(R) {
		return R.readUntilAfter(this.__directives_end_ignore_pattern)
	};
	zA.Directives = ZR
});
var NR = X((fA, FI) => {
	var $R = k().Pattern,
		QR = {
			django: !1,
			erb: !1,
			handlebars: !1,
			php: !1,
			smarty: !1,
			angular: !1
		};

	function f(R, I) {
		if ($R.call(this, R, I), this.__template_pattern = null, this._disabled = Object.assign({}, QR), this
			._excluded = Object.assign({}, QR), I) this.__template_pattern = this._input.get_regexp(I
				.__template_pattern), this._excluded = Object.assign(this._excluded, I._excluded), this._disabled =
			Object.assign(this._disabled, I._disabled);
		var A = new $R(R);
		this.__patterns = {
			handlebars_comment: A.starting_with(/{{!--/).until_after(/--}}/),
			handlebars_unescaped: A.starting_with(/{{{/).until_after(/}}}/),
			handlebars: A.starting_with(/{{/).until_after(/}}/),
			php: A.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
			erb: A.starting_with(/<%[^%]/).until_after(/[^%]%>/),
			django: A.starting_with(/{%/).until_after(/%}/),
			django_value: A.starting_with(/{{/).until_after(/}}/),
			django_comment: A.starting_with(/{#/).until_after(/#}/),
			smarty: A.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
			smarty_comment: A.starting_with(/{\*/).until_after(/\*}/),
			smarty_literal: A.starting_with(/{literal}/).until_after(/{\/literal}/)
		}
	}
	f.prototype = new $R;
	f.prototype._create = function() {
		return new f(this._input, this)
	};
	f.prototype._update = function() {
		this.__set_templated_pattern()
	};
	f.prototype.disable = function(R) {
		var I = this._create();
		return I._disabled[R] = !0, I._update(), I
	};
	f.prototype.read_options = function(R) {
		var I = this._create();
		for (var A in QR) I._disabled[A] = R.templating.indexOf(A) === -1;
		return I._update(), I
	};
	f.prototype.exclude = function(R) {
		var I = this._create();
		return I._excluded[R] = !0, I._update(), I
	};
	f.prototype.read = function() {
		var R = "";
		if (this._match_pattern) R = this._input.read(this._starting_pattern);
		else R = this._input.read(this._starting_pattern, this.__template_pattern);
		var I = this._read_template();
		while (I) {
			if (this._match_pattern) I += this._input.read(this._match_pattern);
			else I += this._input.readUntil(this.__template_pattern);
			R += I, I = this._read_template()
		}
		if (this._until_after) R += this._input.readUntilAfter(this._until_pattern);
		return R
	};
	f.prototype.__set_templated_pattern = function() {
		var R = [];
		if (!this._disabled.php) R.push(this.__patterns.php._starting_pattern.source);
		if (!this._disabled.handlebars) R.push(this.__patterns.handlebars._starting_pattern.source);
		if (!this._disabled.angular) R.push(this.__patterns.handlebars._starting_pattern.source);
		if (!this._disabled.erb) R.push(this.__patterns.erb._starting_pattern.source);
		if (!this._disabled.django) R.push(this.__patterns.django._starting_pattern.source), R.push(this.__patterns
			.django_value._starting_pattern.source), R.push(this.__patterns.django_comment._starting_pattern
			.source);
		if (!this._disabled.smarty) R.push(this.__patterns.smarty._starting_pattern.source);
		if (this._until_pattern) R.push(this._until_pattern.source);
		this.__template_pattern = this._input.get_regexp("(?:" + R.join("|") + ")")
	};
	f.prototype._read_template = function() {
		var R = "",
			I = this._input.peek();
		if (I === "<") {
			var A = this._input.peek(1);
			if (!this._disabled.php && !this._excluded.php && A === "?") R = R || this.__patterns.php.read();
			if (!this._disabled.erb && !this._excluded.erb && A === "%") R = R || this.__patterns.erb.read()
		} else if (I === "{") {
			if (!this._disabled.handlebars && !this._excluded.handlebars) R = R || this.__patterns
				.handlebars_comment.read(), R = R || this.__patterns.handlebars_unescaped.read(), R = R || this
				.__patterns.handlebars.read();
			if (!this._disabled.django) {
				if (!this._excluded.django && !this._excluded.handlebars) R = R || this.__patterns.django_value
					.read();
				if (!this._excluded.django) R = R || this.__patterns.django_comment.read(), R = R || this.__patterns
					.django.read()
			}
			if (!this._disabled.smarty) {
				if (this._disabled.django && this._disabled.handlebars) R = R || this.__patterns.smarty_comment
					.read(), R = R || this.__patterns.smarty_literal.read(), R = R || this.__patterns.smarty.read()
			}
		}
		return R
	};
	fA.TemplatablePattern = f
});
var r = X((iA, _) => {
	var bA = FR().InputScanner,
		UI = a().Tokenizer,
		VR = a().TOKEN,
		wA = WR().Directives,
		z = XR(),
		xA = k().Pattern,
		KA = NR().TemplatablePattern;

	function jR(R, I) {
		return I.indexOf(R) !== -1
	}
	var U = {
			START_EXPR: "TK_START_EXPR",
			END_EXPR: "TK_END_EXPR",
			START_BLOCK: "TK_START_BLOCK",
			END_BLOCK: "TK_END_BLOCK",
			WORD: "TK_WORD",
			RESERVED: "TK_RESERVED",
			SEMICOLON: "TK_SEMICOLON",
			STRING: "TK_STRING",
			EQUALS: "TK_EQUALS",
			OPERATOR: "TK_OPERATOR",
			COMMA: "TK_COMMA",
			BLOCK_COMMENT: "TK_BLOCK_COMMENT",
			COMMENT: "TK_COMMENT",
			DOT: "TK_DOT",
			UNKNOWN: "TK_UNKNOWN",
			START: VR.START,
			RAW: VR.RAW,
			EOF: VR.EOF
		},
		WI = new wA(/\/\*/, /\*\//),
		vA =
		/0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/,
		mA = /[0-9]/,
		dA = /[^\d\.]/,
		gA = ">>> === !== &&= ??= ||= << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" "),
		l =
		">>>= ... >>= <<= === >>> !== **= &&= ??= ||= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |";
	l = l.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
	l = "\\?\\.(?!\\d) " + l;
	l = l.replace(/ /g, "|");
	var lA = new RegExp(l),
		hI = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export"
		.split(","),
		pA = hI.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async",
			"await", "from", "as", "class", "extends"
		]),
		cA = new RegExp("^(?:" + pA.join("|") + ")$"),
		UR, Z = function(R, I) {
			UI.call(this, R, I), this._patterns.whitespace = this._patterns.whitespace.matching(
				/\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source, /\u2028\u2029/.source);
			var A = new xA(this._input),
				H = new KA(this._input).read_options(this._options);
			this.__patterns = {
				template: H,
				identifier: H.starting_with(z.identifier).matching(z.identifierMatch),
				number: A.matching(vA),
				punct: A.matching(lA),
				comment: A.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
				block_comment: A.starting_with(/\/\*/).until_after(/\*\//),
				html_comment_start: A.matching(/<!--/),
				html_comment_end: A.matching(/-->/),
				include: A.starting_with(/#include/).until_after(z.lineBreak),
				shebang: A.starting_with(/#!/).until_after(z.lineBreak),
				xml: A.matching(
					/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/
					),
				single_quote: H.until(/['\\\n\r\u2028\u2029]/),
				double_quote: H.until(/["\\\n\r\u2028\u2029]/),
				template_text: H.until(/[`\\$]/),
				template_expression: H.until(/[`}\\]/)
			}
		};
	Z.prototype = new UI;
	Z.prototype._is_comment = function(R) {
		return R.type === U.COMMENT || R.type === U.BLOCK_COMMENT || R.type === U.UNKNOWN
	};
	Z.prototype._is_opening = function(R) {
		return R.type === U.START_BLOCK || R.type === U.START_EXPR
	};
	Z.prototype._is_closing = function(R, I) {
		return (R.type === U.END_BLOCK || R.type === U.END_EXPR) && (I && (R.text === "]" && I.text === "[" || R
			.text === ")" && I.text === "(" || R.text === "}" && I.text === "{"))
	};
	Z.prototype._reset = function() {
		UR = !1
	};
	Z.prototype._get_next_token = function(R, I) {
		var A = null;
		this._readWhitespace();
		var H = this._input.peek();
		if (H === null) return this._create_token(U.EOF, "");
		return A = A || this._read_non_javascript(H), A = A || this._read_string(H), A = A || this._read_pair(H,
				this._input.peek(1)), A = A || this._read_word(R), A = A || this._read_singles(H), A = A || this
			._read_comment(H), A = A || this._read_regexp(H, R), A = A || this._read_xml(H, R), A = A || this
			._read_punctuation(), A = A || this._create_token(U.UNKNOWN, this._input.next()), A
	};
	Z.prototype._read_word = function(R) {
		var I = this.__patterns.identifier.read();
		if (I !== "") {
			if (I = I.replace(z.allLineBreaks, `
`), !(R.type === U.DOT || R.type === U.RESERVED && (R.text === "set" || R.text === "get")) && cA.test(I)) {
				if ((I === "in" || I === "of") && (R.type === U.WORD || R.type === U.STRING)) return this
					._create_token(U.OPERATOR, I);
				return this._create_token(U.RESERVED, I)
			}
			return this._create_token(U.WORD, I)
		}
		if (I = this.__patterns.number.read(), I !== "") return this._create_token(U.WORD, I)
	};
	Z.prototype._read_singles = function(R) {
		var I = null;
		if (R === "(" || R === "[") I = this._create_token(U.START_EXPR, R);
		else if (R === ")" || R === "]") I = this._create_token(U.END_EXPR, R);
		else if (R === "{") I = this._create_token(U.START_BLOCK, R);
		else if (R === "}") I = this._create_token(U.END_BLOCK, R);
		else if (R === ";") I = this._create_token(U.SEMICOLON, R);
		else if (R === "." && dA.test(this._input.peek(1))) I = this._create_token(U.DOT, R);
		else if (R === ",") I = this._create_token(U.COMMA, R);
		if (I) this._input.next();
		return I
	};
	Z.prototype._read_pair = function(R, I) {
		var A = null;
		if (R === "#" && I === "{") A = this._create_token(U.START_BLOCK, R + I);
		if (A) this._input.next(), this._input.next();
		return A
	};
	Z.prototype._read_punctuation = function() {
		var R = this.__patterns.punct.read();
		if (R !== "")
			if (R === "=") return this._create_token(U.EQUALS, R);
			else if (R === "?.") return this._create_token(U.DOT, R);
		else return this._create_token(U.OPERATOR, R)
	};
	Z.prototype._read_non_javascript = function(R) {
		var I = "";
		if (R === "#") {
			if (this._is_first_token()) {
				if (I = this.__patterns.shebang.read(), I) return this._create_token(U.UNKNOWN, I.trim() + `
`)
			}
			if (I = this.__patterns.include.read(), I) return this._create_token(U.UNKNOWN, I.trim() + `
`);
			R = this._input.next();
			var A = "#";
			if (this._input.hasNext() && this._input.testChar(mA)) {
				do R = this._input.next(), A += R; while (this._input.hasNext() && R !== "#" && R !== "=");
				if (R === "#");
				else if (this._input.peek() === "[" && this._input.peek(1) === "]") A += "[]", this._input.next(),
					this._input.next();
				else if (this._input.peek() === "{" && this._input.peek(1) === "}") A += "{}", this._input.next(),
					this._input.next();
				return this._create_token(U.WORD, A)
			}
			this._input.back()
		} else if (R === "<" && this._is_first_token()) {
			if (I = this.__patterns.html_comment_start.read(), I) {
				while (this._input.hasNext() && !this._input.testChar(z.newline)) I += this._input.next();
				return UR = !0, this._create_token(U.COMMENT, I)
			}
		} else if (UR && R === "-") {
			if (I = this.__patterns.html_comment_end.read(), I) return UR = !1, this._create_token(U.COMMENT, I)
		}
		return null
	};
	Z.prototype._read_comment = function(R) {
		var I = null;
		if (R === "/") {
			var A = "";
			if (this._input.peek(1) === "*") {
				A = this.__patterns.block_comment.read();
				var H = WI.get_directives(A);
				if (H && H.ignore === "start") A += WI.readIgnored(this._input);
				A = A.replace(z.allLineBreaks, `
`), I = this._create_token(U.BLOCK_COMMENT, A), I.directives = H
			} else if (this._input.peek(1) === "/") A = this.__patterns.comment.read(), I = this._create_token(U
				.COMMENT, A)
		}
		return I
	};
	Z.prototype._read_string = function(R) {
		if (R === "`" || R === "'" || R === '"') {
			var I = this._input.next();
			if (this.has_char_escapes = !1, R === "`") I += this._read_string_recursive("`", !0, "${");
			else I += this._read_string_recursive(R);
			if (this.has_char_escapes && this._options.unescape_strings) I = uA(I);
			if (this._input.peek() === R) I += this._input.next();
			return I = I.replace(z.allLineBreaks, `
`), this._create_token(U.STRING, I)
		}
		return null
	};
	Z.prototype._allow_regexp_or_xml = function(R) {
		return R.type === U.RESERVED && jR(R.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) ||
			R.type === U.END_EXPR && R.text === ")" && R.opened.previous.type === U.RESERVED && jR(R.opened.previous
				.text, ["if", "while", "for"]) || jR(R.type, [U.COMMENT, U.START_EXPR, U.START_BLOCK, U.START, U
				.END_BLOCK, U.OPERATOR, U.EQUALS, U.EOF, U.SEMICOLON, U.COMMA
			])
	};
	Z.prototype._read_regexp = function(R, I) {
		if (R === "/" && this._allow_regexp_or_xml(I)) {
			var A = this._input.next(),
				H = !1,
				S = !1;
			while (this._input.hasNext() && ((H || S || this._input.peek() !== R) && !this._input.testChar(z
					.newline))) {
				if (A += this._input.peek(), !H) {
					if (H = this._input.peek() === "\\", this._input.peek() === "[") S = !0;
					else if (this._input.peek() === "]") S = !1
				} else H = !1;
				this._input.next()
			}
			if (this._input.peek() === R) A += this._input.next(), A += this._input.read(z.identifier);
			return this._create_token(U.STRING, A)
		}
		return null
	};
	Z.prototype._read_xml = function(R, I) {
		if (this._options.e4x && R === "<" && this._allow_regexp_or_xml(I)) {
			var A = "",
				H = this.__patterns.xml.read_match();
			if (H) {
				var S = H[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}"),
					F = S.indexOf("{") === 0,
					W = 0;
				while (H) {
					var G = !!H[1],
						T = H[2],
						N = !!H[H.length - 1] || T.slice(0, 8) === "![CDATA[";
					if (!N && (T === S || F && T.replace(/^{\s+/, "{").replace(/\s+}$/, "}")))
						if (G) --W;
						else ++W;
					if (A += H[0], W <= 0) break;
					H = this.__patterns.xml.read_match()
				}
				if (!H) A += this._input.match(/[\s\S]*/g)[0];
				return A = A.replace(z.allLineBreaks, `
`), this._create_token(U.STRING, A)
			}
		}
		return null
	};

	function uA(R) {
		var I = "",
			A = 0,
			H = new bA(R),
			S = null;
		while (H.hasNext()) {
			if (S = H.match(/([\s]|[^\\]|\\\\)+/g), S) I += S[0];
			if (H.peek() === "\\") {
				if (H.next(), H.peek() === "x") S = H.match(/x([0-9A-Fa-f]{2})/g);
				else if (H.peek() === "u") {
					if (S = H.match(/u([0-9A-Fa-f]{4})/g), !S) S = H.match(/u\{([0-9A-Fa-f]+)\}/g)
				} else {
					if (I += "\\", H.hasNext()) I += H.next();
					continue
				}
				if (!S) return R;
				if (A = parseInt(S[1], 16), A > 126 && A <= 255 && S[0].indexOf("x") === 0) return R;
				else if (A >= 0 && A < 32) I += "\\" + S[0];
				else if (A > 1114111) I += "\\" + S[0];
				else if (A === 34 || A === 39 || A === 92) I += "\\" + String.fromCharCode(A);
				else I += String.fromCharCode(A)
			}
		}
		return I
	}
	Z.prototype._read_string_recursive = function(R, I, A) {
		var H, S;
		if (R === "'") S = this.__patterns.single_quote;
		else if (R === '"') S = this.__patterns.double_quote;
		else if (R === "`") S = this.__patterns.template_text;
		else if (R === "}") S = this.__patterns.template_expression;
		var F = S.read(),
			W = "";
		while (this._input.hasNext()) {
			if (W = this._input.next(), W === R || !I && z.newline.test(W)) {
				this._input.back();
				break
			} else if (W === "\\" && this._input.hasNext()) {
				if (H = this._input.peek(), H === "x" || H === "u") this.has_char_escapes = !0;
				else if (H === "\r" && this._input.peek(1) === `
`) this._input.next();
				W += this._input.next()
			} else if (A) {
				if (A === "${" && W === "$" && this._input.peek() === "{") W += this._input.next();
				if (A === W) {
					if (R === "`") W += this._read_string_recursive("}", I, "`");
					else W += this._read_string_recursive("`", I, "${");
					if (this._input.hasNext()) W += this._input.next()
				}
			}
			W += S.read(), F += W
		}
		return F
	};
	iA.Tokenizer = Z;
	iA.TOKEN = U;
	iA.positionable_operators = gA.slice();
	iA.line_starters = hI.slice()
});
var DI = X((LH, GI) => {
	var _A = HR().Output,
		rA = CR().Token,
		hR = XR(),
		nA = ER().Options,
		tA = r().Tokenizer,
		RR = r().line_starters,
		n = r().positionable_operators,
		L = r().TOKEN;

	function Y(R, I) {
		return I.indexOf(R) !== -1
	}

	function eA(R) {
		return R.replace(/^\s+/g, "")
	}

	function RH(R) {
		var I = {};
		for (var A = 0; A < R.length; A++) I[R[A].replace(/-/g, "_")] = R[A];
		return I
	}

	function y(R, I) {
		return R && R.type === L.RESERVED && R.text === I
	}

	function q(R, I) {
		return R && R.type === L.RESERVED && Y(R.text, I)
	}
	var YR = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"],
		IH = ["before-newline", "after-newline", "preserve-newline"],
		t = RH(IH),
		YI = [t.before_newline, t.preserve_newline],
		h = {
			BlockStatement: "BlockStatement",
			Statement: "Statement",
			ObjectLiteral: "ObjectLiteral",
			ArrayLiteral: "ArrayLiteral",
			ForInitializer: "ForInitializer",
			Conditional: "Conditional",
			Expression: "Expression"
		};

	function TI(R, I) {
		if (I.multiline_frame || I.mode === h.ForInitializer || I.mode === h.Conditional) return;
		R.remove_indent(I.start_line_index)
	}

	function AH(R) {
		R = R.replace(hR.allLineBreaks, `
`);
		var I = [],
			A = R.indexOf(`
`);
		while (A !== -1) I.push(R.substring(0, A)), R = R.substring(A + 1), A = R.indexOf(`
`);
		if (R.length) I.push(R);
		return I
	}

	function d(R) {
		return R === h.ArrayLiteral
	}

	function e(R) {
		return Y(R, [h.Expression, h.ForInitializer, h.Conditional])
	}

	function HH(R, I) {
		for (var A = 0; A < R.length; A++) {
			var H = R[A].trim();
			if (H.charAt(0) !== I) return !1
		}
		return !0
	}

	function SH(R, I) {
		var A = 0,
			H = R.length,
			S;
		for (; A < H; A++)
			if (S = R[A], S && S.indexOf(I) !== 0) return !1;
		return !0
	}

	function D(R, I) {
		I = I || {}, this._source_text = R || "", this._output = null, this._tokens = null, this._last_last_text = null,
			this._flags = null, this._previous_flags = null, this._flag_store = null, this._options = new nA(I)
	}
	D.prototype.create_flags = function(R, I) {
		var A = 0;
		if (R) {
			if (A = R.indentation_level, !this._output.just_added_newline() && R.line_indent_level > A) A = R
				.line_indent_level
		}
		var H = {
			mode: I,
			parent: R,
			last_token: R ? R.last_token : new rA(L.START_BLOCK, ""),
			last_word: R ? R.last_word : "",
			declaration_statement: !1,
			declaration_assignment: !1,
			multiline_frame: !1,
			inline_frame: !1,
			if_block: !1,
			else_block: !1,
			class_start_block: !1,
			do_block: !1,
			do_while: !1,
			import_block: !1,
			in_case_statement: !1,
			in_case: !1,
			case_body: !1,
			case_block: !1,
			indentation_level: A,
			alignment: 0,
			line_indent_level: R ? R.line_indent_level : A,
			start_line_index: this._output.get_line_number(),
			ternary_depth: 0
		};
		return H
	};
	D.prototype._reset = function(R) {
		var I = R.match(/^[\t ]*/)[0];
		this._last_last_text = "", this._output = new _A(this._options, I), this._output.raw = this._options
			.test_output_raw, this._flag_store = [], this.set_mode(h.BlockStatement);
		var A = new tA(R, this._options);
		return this._tokens = A.tokenize(), R
	};
	D.prototype.beautify = function() {
		if (this._options.disabled) return this._source_text;
		var R, I = this._reset(this._source_text),
			A = this._options.eol;
		if (this._options.eol === "auto") {
			if (A = `
`, I && hR.lineBreak.test(I || "")) A = I.match(hR.lineBreak)[0]
		}
		var H = this._tokens.next();
		while (H) this.handle_token(H), this._last_last_text = this._flags.last_token.text, this._flags.last_token =
			H, H = this._tokens.next();
		return R = this._output.get_code(A), R
	};
	D.prototype.handle_token = function(R, I) {
		if (R.type === L.START_EXPR) this.handle_start_expr(R);
		else if (R.type === L.END_EXPR) this.handle_end_expr(R);
		else if (R.type === L.START_BLOCK) this.handle_start_block(R);
		else if (R.type === L.END_BLOCK) this.handle_end_block(R);
		else if (R.type === L.WORD) this.handle_word(R);
		else if (R.type === L.RESERVED) this.handle_word(R);
		else if (R.type === L.SEMICOLON) this.handle_semicolon(R);
		else if (R.type === L.STRING) this.handle_string(R);
		else if (R.type === L.EQUALS) this.handle_equals(R);
		else if (R.type === L.OPERATOR) this.handle_operator(R);
		else if (R.type === L.COMMA) this.handle_comma(R);
		else if (R.type === L.BLOCK_COMMENT) this.handle_block_comment(R, I);
		else if (R.type === L.COMMENT) this.handle_comment(R, I);
		else if (R.type === L.DOT) this.handle_dot(R);
		else if (R.type === L.EOF) this.handle_eof(R);
		else if (R.type === L.UNKNOWN) this.handle_unknown(R, I);
		else this.handle_unknown(R, I)
	};
	D.prototype.handle_whitespace_and_comments = function(R, I) {
		var A = R.newlines,
			H = this._options.keep_array_indentation && d(this._flags.mode);
		if (R.comments_before) {
			var S = R.comments_before.next();
			while (S) this.handle_whitespace_and_comments(S, I), this.handle_token(S, I), S = R.comments_before
				.next()
		}
		if (H)
			for (var F = 0; F < A; F += 1) this.print_newline(F > 0, I);
		else {
			if (this._options.max_preserve_newlines && A > this._options.max_preserve_newlines) A = this._options
				.max_preserve_newlines;
			if (this._options.preserve_newlines) {
				if (A > 1) {
					this.print_newline(!1, I);
					for (var W = 1; W < A; W += 1) this.print_newline(!0, I)
				}
			}
		}
	};
	var BR = ["async", "break", "continue", "return", "throw", "yield"];
	D.prototype.allow_wrap_or_preserved_newline = function(R, I) {
		if (I = I === void 0 ? !1 : I, this._output.just_added_newline()) return;
		var A = this._options.preserve_newlines && R.newlines || I,
			H = Y(this._flags.last_token.text, n) || Y(R.text, n);
		if (H) {
			var S = Y(this._flags.last_token.text, n) && Y(this._options.operator_position, YI) || Y(R.text, n);
			A = A && S
		}
		if (A) this.print_newline(!1, !0);
		else if (this._options.wrap_line_length) {
			if (q(this._flags.last_token, BR)) return;
			this._output.set_wrap_point()
		}
	};
	D.prototype.print_newline = function(R, I) {
		if (!I) {
			if (this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token
				.text !== "=" && (this._flags.last_token.type !== L.OPERATOR || this._flags.last_token.text ===
					"--" || this._flags.last_token.text === "++")) {
				var A = this._tokens.peek();
				while (this._flags.mode === h.Statement && !(this._flags.if_block && y(A, "else")) && !this._flags
					.do_block) this.restore_mode()
			}
		}
		if (this._output.add_new_line(R)) this._flags.multiline_frame = !0
	};
	D.prototype.print_token_line_indentation = function(R) {
		if (this._output.just_added_newline()) {
			if (this._options.keep_array_indentation && R.newlines && (R.text === "[" || d(this._flags.mode))) this
				._output.current_line.set_indent(-1), this._output.current_line.push(R.whitespace_before), this
				._output.space_before_token = !1;
			else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) this._flags
				.line_indent_level = this._flags.indentation_level
		}
	};
	D.prototype.print_token = function(R) {
		if (this._output.raw) {
			this._output.add_raw_token(R);
			return
		}
		if (this._options.comma_first && R.previous && R.previous.type === L.COMMA && this._output
			.just_added_newline()) {
			if (this._output.previous_line.last() === ",") {
				var I = this._output.previous_line.pop();
				if (this._output.previous_line.is_empty()) this._output.previous_line.push(I), this._output.trim(!
					0), this._output.current_line.pop(), this._output.trim();
				this.print_token_line_indentation(R), this._output.add_token(","), this._output
					.space_before_token = !0
			}
		}
		if (this.print_token_line_indentation(R), this._output.non_breaking_space = !0, this._output.add_token(R
				.text), this._output.previous_token_wrapped) this._flags.multiline_frame = !0
	};
	D.prototype.indent = function() {
		this._flags.indentation_level += 1, this._output.set_indent(this._flags.indentation_level, this._flags
			.alignment)
	};
	D.prototype.deindent = function() {
		if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags
				.parent.indentation_level)) this._flags.indentation_level -= 1, this._output.set_indent(this._flags
			.indentation_level, this._flags.alignment)
	};
	D.prototype.set_mode = function(R) {
		if (this._flags) this._flag_store.push(this._flags), this._previous_flags = this._flags;
		else this._previous_flags = this.create_flags(null, R);
		this._flags = this.create_flags(this._previous_flags, R), this._output.set_indent(this._flags
			.indentation_level, this._flags.alignment)
	};
	D.prototype.restore_mode = function() {
		if (this._flag_store.length > 0) {
			if (this._previous_flags = this._flags, this._flags = this._flag_store.pop(), this._previous_flags
				.mode === h.Statement) TI(this._output, this._previous_flags);
			this._output.set_indent(this._flags.indentation_level, this._flags.alignment)
		}
	};
	D.prototype.start_of_object_property = function() {
		return this._flags.parent.mode === h.ObjectLiteral && this._flags.mode === h.Statement && (this._flags
			.last_token.text === ":" && this._flags.ternary_depth === 0 || q(this._flags.last_token, ["get",
				"set"
			]))
	};
	D.prototype.start_of_statement = function(R) {
		var I = !1;
		if (I = I || q(this._flags.last_token, ["var", "let", "const"]) && R.type === L.WORD, I = I || y(this._flags
				.last_token, "do"), I = I || !(this._flags.parent.mode === h.ObjectLiteral && this._flags.mode === h
				.Statement) && q(this._flags.last_token, BR) && !R.newlines, I = I || y(this._flags.last_token,
				"else") && !(y(R, "if") && !R.comments_before), I = I || this._flags.last_token.type === L
			.END_EXPR && (this._previous_flags.mode === h.ForInitializer || this._previous_flags.mode === h
				.Conditional), I = I || this._flags.last_token.type === L.WORD && this._flags.mode === h
			.BlockStatement && !this._flags.in_case && !(R.text === "--" || R.text === "++") && this
			._last_last_text !== "function" && R.type !== L.WORD && R.type !== L.RESERVED, I = I || this._flags
			.mode === h.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 ||
				q(this._flags.last_token, ["get", "set"])), I) {
			if (this.set_mode(h.Statement), this.indent(), this.handle_whitespace_and_comments(R, !0), !this
				.start_of_object_property()) this.allow_wrap_or_preserved_newline(R, q(R, ["do", "for", "if",
				"while"
			]));
			return !0
		}
		return !1
	};
	D.prototype.handle_start_expr = function(R) {
		if (!this.start_of_statement(R)) this.handle_whitespace_and_comments(R);
		var I = h.Expression;
		if (R.text === "[") {
			if (this._flags.last_token.type === L.WORD || this._flags.last_token.text === ")") {
				if (q(this._flags.last_token, RR)) this._output.space_before_token = !0;
				if (this.print_token(R), this.set_mode(I), this.indent(), this._options.space_in_paren) this._output
					.space_before_token = !0;
				return
			}
			if (I = h.ArrayLiteral, d(this._flags.mode)) {
				if (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this
						._last_last_text === "]" || this._last_last_text === "}")) {
					if (!this._options.keep_array_indentation) this.print_newline()
				}
			}
			if (!Y(this._flags.last_token.type, [L.START_EXPR, L.END_EXPR, L.WORD, L.OPERATOR, L.DOT])) this._output
				.space_before_token = !0
		} else {
			if (this._flags.last_token.type === L.RESERVED) {
				if (this._flags.last_token.text === "for") this._output.space_before_token = this._options
					.space_before_conditional, I = h.ForInitializer;
				else if (Y(this._flags.last_token.text, ["if", "while", "switch"])) this._output
					.space_before_token = this._options.space_before_conditional, I = h.Conditional;
				else if (Y(this._flags.last_word, ["await", "async"])) this._output.space_before_token = !0;
				else if (this._flags.last_token.text === "import" && R.whitespace_before === "") this._output
					.space_before_token = !1;
				else if (Y(this._flags.last_token.text, RR) || this._flags.last_token.text === "catch") this._output
					.space_before_token = !0
			} else if (this._flags.last_token.type === L.EQUALS || this._flags.last_token.type === L.OPERATOR) {
				if (!this.start_of_object_property()) this.allow_wrap_or_preserved_newline(R)
			} else if (this._flags.last_token.type === L.WORD) {
				this._output.space_before_token = !1;
				var A = this._tokens.peek(-3);
				if (this._options.space_after_named_function && A) {
					var H = this._tokens.peek(-4);
					if (q(A, ["async", "function"]) || A.text === "*" && q(H, ["async", "function"])) this._output
						.space_before_token = !0;
					else if (this._flags.mode === h.ObjectLiteral) {
						if (A.text === "{" || A.text === "," || A.text === "*" && (H.text === "{" || H.text ===
							",")) this._output.space_before_token = !0
					} else if (this._flags.parent && this._flags.parent.class_start_block) this._output
						.space_before_token = !0
				}
			} else this.allow_wrap_or_preserved_newline(R);
			if (this._flags.last_token.type === L.RESERVED && (this._flags.last_word === "function" || this._flags
					.last_word === "typeof") || this._flags.last_token.text === "*" && (Y(this._last_last_text, [
					"function", "yield"
				]) || this._flags.mode === h.ObjectLiteral && Y(this._last_last_text, ["{", ","]))) this._output
				.space_before_token = this._options.space_after_anon_function
		}
		if (this._flags.last_token.text === ";" || this._flags.last_token.type === L.START_BLOCK) this
			.print_newline();
		else if (this._flags.last_token.type === L.END_EXPR || this._flags.last_token.type === L.START_EXPR || this
			._flags.last_token.type === L.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token
			.type === L.COMMA) this.allow_wrap_or_preserved_newline(R, R.newlines);
		if (this.print_token(R), this.set_mode(I), this._options.space_in_paren) this._output.space_before_token = !
			0;
		this.indent()
	};
	D.prototype.handle_end_expr = function(R) {
		while (this._flags.mode === h.Statement) this.restore_mode();
		if (this.handle_whitespace_and_comments(R), this._flags.multiline_frame) this
			.allow_wrap_or_preserved_newline(R, R.text === "]" && d(this._flags.mode) && !this._options
				.keep_array_indentation);
		if (this._options.space_in_paren)
			if (this._flags.last_token.type === L.START_EXPR && !this._options.space_in_empty_paren) this._output
				.trim(), this._output.space_before_token = !1;
			else this._output.space_before_token = !0;
		if (this.deindent(), this.print_token(R), this.restore_mode(), TI(this._output, this._previous_flags), this
			._flags.do_while && this._previous_flags.mode === h.Conditional) this._previous_flags.mode = h
			.Expression, this._flags.do_block = !1, this._flags.do_while = !1
	};
	D.prototype.handle_start_block = function(R) {
		this.handle_whitespace_and_comments(R);
		var I = this._tokens.peek(),
			A = this._tokens.peek(1);
		if (this._flags.last_word === "switch" && this._flags.last_token.type === L.END_EXPR) this.set_mode(h
			.BlockStatement), this._flags.in_case_statement = !0;
		else if (this._flags.case_body) this.set_mode(h.BlockStatement);
		else if (A && (Y(A.text, [":", ","]) && Y(I.type, [L.STRING, L.WORD, L.RESERVED]) || Y(I.text, ["get",
				"set", "..."
			]) && Y(A.type, [L.WORD, L.RESERVED])))
			if (Y(this._last_last_text, ["class", "interface"]) && !Y(A.text, [":", ","])) this.set_mode(h
				.BlockStatement);
			else this.set_mode(h.ObjectLiteral);
		else if (this._flags.last_token.type === L.OPERATOR && this._flags.last_token.text === "=>") this.set_mode(h
			.BlockStatement);
		else if (Y(this._flags.last_token.type, [L.EQUALS, L.START_EXPR, L.COMMA, L.OPERATOR]) || q(this._flags
				.last_token, ["return", "throw", "import", "default"])) this.set_mode(h.ObjectLiteral);
		else this.set_mode(h.BlockStatement);
		if (this._flags.last_token) {
			if (q(this._flags.last_token.previous, ["class", "extends"])) this._flags.class_start_block = !0
		}
		var H = !I.comments_before && I.text === "}",
			S = H && this._flags.last_word === "function" && this._flags.last_token.type === L.END_EXPR;
		if (this._options.brace_preserve_inline) {
			var F = 0,
				W = null;
			this._flags.inline_frame = !0;
			do
				if (F += 1, W = this._tokens.peek(F - 1), W.newlines) {
					this._flags.inline_frame = !1;
					break
				} while (W.type !== L.EOF && !(W.type === L.END_BLOCK && W.opened === R))
		}
		if ((this._options.brace_style === "expand" || this._options.brace_style === "none" && R.newlines) && !this
			._flags.inline_frame)
			if (this._flags.last_token.type !== L.OPERATOR && (S || this._flags.last_token.type === L.EQUALS || q(
					this._flags.last_token, YR) && this._flags.last_token.text !== "else")) this._output
				.space_before_token = !0;
			else this.print_newline(!1, !0);
		else {
			if (d(this._previous_flags.mode) && (this._flags.last_token.type === L.START_EXPR || this._flags
					.last_token.type === L.COMMA)) {
				if (this._flags.last_token.type === L.COMMA || this._options.space_in_paren) this._output
					.space_before_token = !0;
				if (this._flags.last_token.type === L.COMMA || this._flags.last_token.type === L.START_EXPR && this
					._flags.inline_frame) this.allow_wrap_or_preserved_newline(R), this._previous_flags
					.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame, this
					._flags.multiline_frame = !1
			}
			if (this._flags.last_token.type !== L.OPERATOR && this._flags.last_token.type !== L.START_EXPR)
				if (Y(this._flags.last_token.type, [L.START_BLOCK, L.SEMICOLON]) && !this._flags.inline_frame) this
					.print_newline();
				else this._output.space_before_token = !0
		}
		if (this.print_token(R), this.indent(), !H && !(this._options.brace_preserve_inline && this._flags
				.inline_frame)) this.print_newline()
	};
	D.prototype.handle_end_block = function(R) {
		this.handle_whitespace_and_comments(R);
		while (this._flags.mode === h.Statement) this.restore_mode();
		var I = this._flags.last_token.type === L.START_BLOCK;
		if (this._flags.inline_frame && !I) this._output.space_before_token = !0;
		else if (this._options.brace_style === "expand") {
			if (!I) this.print_newline()
		} else if (!I)
			if (d(this._flags.mode) && this._options.keep_array_indentation) this._options
				.keep_array_indentation = !1, this.print_newline(), this._options.keep_array_indentation = !0;
			else this.print_newline();
		this.restore_mode(), this.print_token(R)
	};
	D.prototype.handle_word = function(R) {
		if (R.type === L.RESERVED) {
			if (Y(R.text, ["set", "get"]) && this._flags.mode !== h.ObjectLiteral) R.type = L.WORD;
			else if (R.text === "import" && Y(this._tokens.peek().text, ["(", "."])) R.type = L.WORD;
			else if (Y(R.text, ["as", "from"]) && !this._flags.import_block) R.type = L.WORD;
			else if (this._flags.mode === h.ObjectLiteral) {
				var I = this._tokens.peek();
				if (I.text === ":") R.type = L.WORD
			}
		}
		if (this.start_of_statement(R)) {
			if (q(this._flags.last_token, ["var", "let", "const"]) && R.type === L.WORD) this._flags
				.declaration_statement = !0
		} else if (R.newlines && !e(this._flags.mode) && (this._flags.last_token.type !== L.OPERATOR || (this._flags
				.last_token.text === "--" || this._flags.last_token.text === "++")) && this._flags.last_token
			.type !== L.EQUALS && (this._options.preserve_newlines || !q(this._flags.last_token, ["var", "let",
				"const", "set", "get"
			]))) this.handle_whitespace_and_comments(R), this.print_newline();
		else this.handle_whitespace_and_comments(R);
		if (this._flags.do_block && !this._flags.do_while)
			if (y(R, "while")) {
				this._output.space_before_token = !0, this.print_token(R), this._output.space_before_token = !0,
					this._flags.do_while = !0;
				return
			} else this.print_newline(), this._flags.do_block = !1;
		if (this._flags.if_block)
			if (!this._flags.else_block && y(R, "else")) this._flags.else_block = !0;
			else {
				while (this._flags.mode === h.Statement) this.restore_mode();
				this._flags.if_block = !1, this._flags.else_block = !1
			} if (this._flags.in_case_statement && q(R, ["case", "default"])) {
			if (this.print_newline(), !this._flags.case_block && (this._flags.case_body || this._options
					.jslint_happy)) this.deindent();
			this._flags.case_body = !1, this.print_token(R), this._flags.in_case = !0;
			return
		}
		if (this._flags.last_token.type === L.COMMA || this._flags.last_token.type === L.START_EXPR || this._flags
			.last_token.type === L.EQUALS || this._flags.last_token.type === L.OPERATOR) {
			if (!this.start_of_object_property() && !(Y(this._flags.last_token.text, ["+", "-"]) && this
					._last_last_text === ":" && this._flags.parent.mode === h.ObjectLiteral)) this
				.allow_wrap_or_preserved_newline(R)
		}
		if (y(R, "function")) {
			if (Y(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !(Y(this._flags
						.last_token.text, ["(", "[", "{", ":", "=", ","]) || this._flags.last_token.type === L
					.OPERATOR)) {
				if (!this._output.just_added_blankline() && !R.comments_before) this.print_newline(), this
					.print_newline(!0)
			}
			if (this._flags.last_token.type === L.RESERVED || this._flags.last_token.type === L.WORD)
				if (q(this._flags.last_token, ["get", "set", "new", "export"]) || q(this._flags.last_token, BR))
					this._output.space_before_token = !0;
				else if (y(this._flags.last_token, "default") && this._last_last_text === "export") this._output
				.space_before_token = !0;
			else if (this._flags.last_token.text === "declare") this._output.space_before_token = !0;
			else this.print_newline();
			else if (this._flags.last_token.type === L.OPERATOR || this._flags.last_token.text === "=") this._output
				.space_before_token = !0;
			else if (!this._flags.multiline_frame && (e(this._flags.mode) || d(this._flags.mode)));
			else this.print_newline();
			this.print_token(R), this._flags.last_word = R.text;
			return
		}
		var A = "NONE";
		if (this._flags.last_token.type === L.END_BLOCK)
			if (this._previous_flags.inline_frame) A = "SPACE";
			else if (!q(R, ["else", "catch", "finally", "from"])) A = "NEWLINE";
		else if (this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this
			._options.brace_style === "none" && R.newlines) A = "NEWLINE";
		else A = "SPACE", this._output.space_before_token = !0;
		else if (this._flags.last_token.type === L.SEMICOLON && this._flags.mode === h.BlockStatement) A =
		"NEWLINE";
		else if (this._flags.last_token.type === L.SEMICOLON && e(this._flags.mode)) A = "SPACE";
		else if (this._flags.last_token.type === L.STRING) A = "NEWLINE";
		else if (this._flags.last_token.type === L.RESERVED || this._flags.last_token.type === L.WORD || this._flags
			.last_token.text === "*" && (Y(this._last_last_text, ["function", "yield"]) || this._flags.mode === h
				.ObjectLiteral && Y(this._last_last_text, ["{", ","]))) A = "SPACE";
		else if (this._flags.last_token.type === L.START_BLOCK)
			if (this._flags.inline_frame) A = "SPACE";
			else A = "NEWLINE";
		else if (this._flags.last_token.type === L.END_EXPR) this._output.space_before_token = !0, A = "NEWLINE";
		if (q(R, RR) && this._flags.last_token.text !== ")")
			if (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token
				.text === "export") A = "SPACE";
			else A = "NEWLINE";
		if (q(R, ["else", "catch", "finally"]))
			if ((!(this._flags.last_token.type === L.END_BLOCK && this._previous_flags.mode === h.BlockStatement) ||
					this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this
					._options.brace_style === "none" && R.newlines) && !this._flags.inline_frame) this
				.print_newline();
			else {
				this._output.trim(!0);
				var H = this._output.current_line;
				if (H.last() !== "}") this.print_newline();
				this._output.space_before_token = !0
			}
		else if (A === "NEWLINE") {
			if (q(this._flags.last_token, YR)) this._output.space_before_token = !0;
			else if (this._flags.last_token.text === "declare" && q(R, ["var", "let", "const"])) this._output
				.space_before_token = !0;
			else if (this._flags.last_token.type !== L.END_EXPR) {
				if ((this._flags.last_token.type !== L.START_EXPR || !q(R, ["var", "let", "const"])) && this._flags
					.last_token.text !== ":")
					if (y(R, "if") && y(R.previous, "else")) this._output.space_before_token = !0;
					else this.print_newline()
			} else if (q(R, RR) && this._flags.last_token.text !== ")") this.print_newline()
		} else if (this._flags.multiline_frame && d(this._flags.mode) && this._flags.last_token.text === "," && this
			._last_last_text === "}") this.print_newline();
		else if (A === "SPACE") this._output.space_before_token = !0;
		if (R.previous && (R.previous.type === L.WORD || R.previous.type === L.RESERVED)) this._output
			.space_before_token = !0;
		if (this.print_token(R), this._flags.last_word = R.text, R.type === L.RESERVED) {
			if (R.text === "do") this._flags.do_block = !0;
			else if (R.text === "if") this._flags.if_block = !0;
			else if (R.text === "import") this._flags.import_block = !0;
			else if (this._flags.import_block && y(R, "from")) this._flags.import_block = !1
		}
	};
	D.prototype.handle_semicolon = function(R) {
		if (this.start_of_statement(R)) this._output.space_before_token = !1;
		else this.handle_whitespace_and_comments(R);
		var I = this._tokens.peek();
		while (this._flags.mode === h.Statement && !(this._flags.if_block && y(I, "else")) && !this._flags.do_block)
			this.restore_mode();
		if (this._flags.import_block) this._flags.import_block = !1;
		this.print_token(R)
	};
	D.prototype.handle_string = function(R) {
		if (R.text.startsWith("`") && R.newlines === 0 && R.whitespace_before === "" && (R.previous.text === ")" ||
				this._flags.last_token.type === L.WORD));
		else if (this.start_of_statement(R)) this._output.space_before_token = !0;
		else if (this.handle_whitespace_and_comments(R), this._flags.last_token.type === L.RESERVED || this._flags
			.last_token.type === L.WORD || this._flags.inline_frame) this._output.space_before_token = !0;
		else if (this._flags.last_token.type === L.COMMA || this._flags.last_token.type === L.START_EXPR || this
			._flags.last_token.type === L.EQUALS || this._flags.last_token.type === L.OPERATOR) {
			if (!this.start_of_object_property()) this.allow_wrap_or_preserved_newline(R)
		} else if (R.text.startsWith("`") && this._flags.last_token.type === L.END_EXPR && (R.previous.text ===
				"]" || R.previous.text === ")") && R.newlines === 0) this._output.space_before_token = !0;
		else this.print_newline();
		this.print_token(R)
	};
	D.prototype.handle_equals = function(R) {
		if (this.start_of_statement(R));
		else this.handle_whitespace_and_comments(R);
		if (this._flags.declaration_statement) this._flags.declaration_assignment = !0;
		this._output.space_before_token = !0, this.print_token(R), this._output.space_before_token = !0
	};
	D.prototype.handle_comma = function(R) {
		if (this.handle_whitespace_and_comments(R, !0), this.print_token(R), this._output.space_before_token = !0,
			this._flags.declaration_statement) {
			if (e(this._flags.parent.mode)) this._flags.declaration_assignment = !1;
			if (this._flags.declaration_assignment) this._flags.declaration_assignment = !1, this.print_newline(!1,
				!0);
			else if (this._options.comma_first) this.allow_wrap_or_preserved_newline(R)
		} else if (this._flags.mode === h.ObjectLiteral || this._flags.mode === h.Statement && this._flags.parent
			.mode === h.ObjectLiteral) {
			if (this._flags.mode === h.Statement) this.restore_mode();
			if (!this._flags.inline_frame) this.print_newline()
		} else if (this._options.comma_first) this.allow_wrap_or_preserved_newline(R)
	};
	D.prototype.handle_operator = function(R) {
		var I = R.text === "*" && (q(this._flags.last_token, ["function", "yield"]) || Y(this._flags.last_token
				.type, [L.START_BLOCK, L.COMMA, L.END_BLOCK, L.SEMICOLON])),
			A = Y(R.text, ["-", "+"]) && (Y(this._flags.last_token.type, [L.START_BLOCK, L.START_EXPR, L.EQUALS, L
				.OPERATOR
			]) || Y(this._flags.last_token.text, RR) || this._flags.last_token.text === ",");
		if (this.start_of_statement(R));
		else {
			var H = !I;
			this.handle_whitespace_and_comments(R, H)
		}
		if (R.text === "*" && this._flags.last_token.type === L.DOT) {
			this.print_token(R);
			return
		}
		if (R.text === "::") {
			this.print_token(R);
			return
		}
		if (Y(R.text, ["-", "+"]) && this.start_of_object_property()) {
			this.print_token(R);
			return
		}
		if (this._flags.last_token.type === L.OPERATOR && Y(this._options.operator_position, YI)) this
			.allow_wrap_or_preserved_newline(R);
		if (R.text === ":" && this._flags.in_case) {
			if (this.print_token(R), this._flags.in_case = !1, this._flags.case_body = !0, this._tokens.peek()
				.type !== L.START_BLOCK) this.indent(), this.print_newline(), this._flags.case_block = !1;
			else this._flags.case_block = !0, this._output.space_before_token = !0;
			return
		}
		var S = !0,
			F = !0,
			W = !1;
		if (R.text === ":")
			if (this._flags.ternary_depth === 0) S = !1;
			else this._flags.ternary_depth -= 1, W = !0;
		else if (R.text === "?") this._flags.ternary_depth += 1;
		if (!A && !I && this._options.preserve_newlines && Y(R.text, n)) {
			var G = R.text === ":",
				T = G && W,
				N = G && !W;
			switch (this._options.operator_position) {
				case t.before_newline:
					if (this._output.space_before_token = !N, this.print_token(R), !G || T) this
						.allow_wrap_or_preserved_newline(R);
					this._output.space_before_token = !0;
					return;
				case t.after_newline:
					if (this._output.space_before_token = !0, !G || T)
						if (this._tokens.peek().newlines) this.print_newline(!1, !0);
						else this.allow_wrap_or_preserved_newline(R);
					else this._output.space_before_token = !1;
					this.print_token(R), this._output.space_before_token = !0;
					return;
				case t.preserve_newline:
					if (!N) this.allow_wrap_or_preserved_newline(R);
					S = !(this._output.just_added_newline() || N), this._output.space_before_token = S, this
						.print_token(R), this._output.space_before_token = !0;
					return
			}
		}
		if (I) {
			this.allow_wrap_or_preserved_newline(R), S = !1;
			var E = this._tokens.peek();
			F = E && Y(E.type, [L.WORD, L.RESERVED])
		} else if (R.text === "...") this.allow_wrap_or_preserved_newline(R), S = this._flags.last_token.type === L
			.START_BLOCK, F = !1;
		else if (Y(R.text, ["--", "++", "!", "~"]) || A) {
			if (this._flags.last_token.type === L.COMMA || this._flags.last_token.type === L.START_EXPR) this
				.allow_wrap_or_preserved_newline(R);
			if (S = !1, F = !1, R.newlines && (R.text === "--" || R.text === "++" || R.text === "~")) {
				var K = q(this._flags.last_token, YR) && R.newlines;
				if (K && (this._previous_flags.if_block || this._previous_flags.else_block)) this.restore_mode();
				this.print_newline(K, !0)
			}
			if (this._flags.last_token.text === ";" && e(this._flags.mode)) S = !0;
			if (this._flags.last_token.type === L.RESERVED) S = !0;
			else if (this._flags.last_token.type === L.END_EXPR) S = !(this._flags.last_token.text === "]" && (R
				.text === "--" || R.text === "++"));
			else if (this._flags.last_token.type === L.OPERATOR) {
				if (S = Y(R.text, ["--", "-", "++", "+"]) && Y(this._flags.last_token.text, ["--", "-", "++", "+"]),
					Y(R.text, ["+", "-"]) && Y(this._flags.last_token.text, ["--", "++"])) F = !0
			}
			if ((this._flags.mode === h.BlockStatement && !this._flags.inline_frame || this._flags.mode === h
					.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";"))
				this.print_newline()
		}
		this._output.space_before_token = this._output.space_before_token || S, this.print_token(R), this._output
			.space_before_token = F
	};
	D.prototype.handle_block_comment = function(R, I) {
		if (this._output.raw) {
			if (this._output.add_raw_token(R), R.directives && R.directives.preserve === "end") this._output.raw =
				this._options.test_output_raw;
			return
		}
		if (R.directives) {
			if (this.print_newline(!1, I), this.print_token(R), R.directives.preserve === "start") this._output
				.raw = !0;
			this.print_newline(!1, !0);
			return
		}
		if (!hR.newline.test(R.text) && !R.newlines) {
			this._output.space_before_token = !0, this.print_token(R), this._output.space_before_token = !0;
			return
		} else this.print_block_commment(R, I)
	};
	D.prototype.print_block_commment = function(R, I) {
		var A = AH(R.text),
			H, S = !1,
			F = !1,
			W = R.whitespace_before,
			G = W.length;
		if (this.print_newline(!1, I), this.print_token_line_indentation(R), this._output.add_token(A[0]), this
			.print_newline(!1, I), A.length > 1) {
			if (A = A.slice(1), S = HH(A, "*"), F = SH(A, W), S) this._flags.alignment = 1;
			for (H = 0; H < A.length; H++) {
				if (S) this.print_token_line_indentation(R), this._output.add_token(eA(A[H]));
				else if (F && A[H]) this.print_token_line_indentation(R), this._output.add_token(A[H].substring(G));
				else this._output.current_line.set_indent(-1), this._output.add_token(A[H]);
				this.print_newline(!1, I)
			}
			this._flags.alignment = 0
		}
	};
	D.prototype.handle_comment = function(R, I) {
		if (R.newlines) this.print_newline(!1, I);
		else this._output.trim(!0);
		this._output.space_before_token = !0, this.print_token(R), this.print_newline(!1, I)
	};
	D.prototype.handle_dot = function(R) {
		if (this.start_of_statement(R));
		else this.handle_whitespace_and_comments(R, !0);
		if (this._flags.last_token.text.match("^[0-9]+$")) this._output.space_before_token = !0;
		if (q(this._flags.last_token, YR)) this._output.space_before_token = !1;
		else this.allow_wrap_or_preserved_newline(R, this._flags.last_token.text === ")" && this._options
			.break_chained_methods);
		if (this._options.unindent_chained_methods && this._output.just_added_newline()) this.deindent();
		this.print_token(R)
	};
	D.prototype.handle_unknown = function(R, I) {
		if (this.print_token(R), R.text[R.text.length - 1] === `
`) this.print_newline(!1, I)
	};
	D.prototype.handle_eof = function(R) {
		while (this._flags.mode === h.Statement) this.restore_mode();
		this.handle_whitespace_and_comments(R)
	};
	LH.Beautifier = D
});
var CI = X((eH, zR) => {
	var WH = DI().Beautifier,
		UH = ER().Options;

	function hH(R, I) {
		var A = new WH(R, I);
		return A.beautify()
	}
	zR.exports = hH;
	zR.exports.defaultOptions = function() {
		return new UH
	}
});
var yR = X((YH, XI) => {
	var MI = LR().Options;

	function qI(R) {
		MI.call(this, R, "css"), this.selector_separator_newline = this._get_boolean("selector_separator_newline", !0),
			this.newline_between_rules = this._get_boolean("newline_between_rules", !0);
		var I = this._get_boolean("space_around_selector_separator");
		this.space_around_combinator = this._get_boolean("space_around_combinator") || I;
		var A = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none",
		"preserve-inline"]);
		this.brace_style = "collapse";
		for (var H = 0; H < A.length; H++)
			if (A[H] !== "expand") this.brace_style = "collapse";
			else this.brace_style = A[H]
	}
	qI.prototype = new MI;
	YH.Options = qI
});
var ZI = X((JH, JI) => {
	var GH = yR().Options,
		DH = HR().Output,
		CH = FR().InputScanner,
		MH = WR().Directives,
		EI = new MH(/\/\*/, /\*\//),
		PI = /\r\n|[\r\n]/,
		qH = /\r\n|[\r\n]/g,
		TR = /\s/,
		XH = /(?:\s|\n)+/g,
		EH = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g,
		PH = /\/\/(?:[^\n\r\u2028\u2029]*)/g;

	function x(R, I) {
		this._source_text = R || "", this._options = new GH(I), this._ch = null, this._input = null, this
			.NESTED_AT_RULE = {
				page: !0,
				"font-face": !0,
				keyframes: !0,
				media: !0,
				supports: !0,
				document: !0
			}, this.CONDITIONAL_GROUP_RULE = {
				media: !0,
				supports: !0,
				document: !0
			}, this.NON_SEMICOLON_NEWLINE_PROPERTY = ["grid-template-areas", "grid-template"]
	}
	x.prototype.eatString = function(R) {
		var I = "";
		this._ch = this._input.next();
		while (this._ch) {
			if (I += this._ch, this._ch === "\\") I += this._input.next();
			else if (R.indexOf(this._ch) !== -1 || this._ch === `
`) break;
			this._ch = this._input.next()
		}
		return I
	};
	x.prototype.eatWhitespace = function(R) {
		var I = TR.test(this._input.peek()),
			A = 0;
		while (TR.test(this._input.peek()))
			if (this._ch = this._input.next(), R && this._ch === `
`) {
				if (A === 0 || A < this._options.max_preserve_newlines) A++, this._output.add_new_line(!0)
			} return I
	};
	x.prototype.foundNestedPseudoClass = function() {
		var R = 0,
			I = 1,
			A = this._input.peek(I);
		while (A) {
			if (A === "{") return !0;
			else if (A === "(") R += 1;
			else if (A === ")") {
				if (R === 0) return !1;
				R -= 1
			} else if (A === ";" || A === "}") return !1;
			I++, A = this._input.peek(I)
		}
		return !1
	};
	x.prototype.print_string = function(R) {
		this._output.set_indent(this._indentLevel), this._output.non_breaking_space = !0, this._output.add_token(R)
	};
	x.prototype.preserveSingleSpace = function(R) {
		if (R) this._output.space_before_token = !0
	};
	x.prototype.indent = function() {
		this._indentLevel++
	};
	x.prototype.outdent = function() {
		if (this._indentLevel > 0) this._indentLevel--
	};
	x.prototype.beautify = function() {
		if (this._options.disabled) return this._source_text;
		var R = this._source_text,
			I = this._options.eol;
		if (I === "auto") {
			if (I = `
`, R && PI.test(R || "")) I = R.match(PI)[0]
		}
		R = R.replace(qH, `
`);
		var A = R.match(/^[\t ]*/)[0];
		this._output = new DH(this._options, A), this._input = new CH(R), this._indentLevel = 0, this._nestedLevel =
			0, this._ch = null;
		var H = 0,
			S = !1,
			F = !1,
			W = !1,
			G = !1,
			T = !1,
			N = this._ch,
			E = !1,
			K, O, B;
		while (!0) {
			if (K = this._input.read(XH), O = K !== "", B = N, this._ch = this._input.next(), this._ch === "\\" &&
				this._input.hasNext()) this._ch += this._input.next();
			if (N = this._ch, !this._ch) break;
			else if (this._ch === "/" && this._input.peek() === "*") {
				this._output.add_new_line(), this._input.back();
				var i = this._input.read(EH),
					AR = EI.get_directives(i);
				if (AR && AR.ignore === "start") i += EI.readIgnored(this._input);
				this.print_string(i), this.eatWhitespace(!0), this._output.add_new_line()
			} else if (this._ch === "/" && this._input.peek() === "/") this._output.space_before_token = !0, this
				._input.back(), this.print_string(this._input.read(PH)), this.eatWhitespace(!0);
			else if (this._ch === "$") {
				this.preserveSingleSpace(O), this.print_string(this._ch);
				var c = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
				if (c.match(/[ :]$/)) c = this.eatString(": ").replace(/\s+$/, ""), this.print_string(c), this
					._output.space_before_token = !0;
				if (H === 0 && c.indexOf(":") !== -1) F = !0, this.indent()
			} else if (this._ch === "@")
				if (this.preserveSingleSpace(O), this._input.peek() === "{") this.print_string(this._ch + this
					.eatString("}"));
				else {
					this.print_string(this._ch);
					var u = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
					if (u.match(/[ :]$/)) u = this.eatString(": ").replace(/\s+$/, ""), this.print_string(u), this
						._output.space_before_token = !0;
					if (H === 0 && u.indexOf(":") !== -1) F = !0, this.indent();
					else if (u in this.NESTED_AT_RULE) {
						if (this._nestedLevel += 1, u in this.CONDITIONAL_GROUP_RULE) W = !0
					} else if (H === 0 && !F) G = !0
				}
			else if (this._ch === "#" && this._input.peek() === "{") this.preserveSingleSpace(O), this.print_string(
				this._ch + this.eatString("}"));
			else if (this._ch === "{") {
				if (F) F = !1, this.outdent();
				if (G = !1, W) W = !1, S = this._indentLevel >= this._nestedLevel;
				else S = this._indentLevel >= this._nestedLevel - 1;
				if (this._options.newline_between_rules && S) {
					if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") this._output
						.ensure_empty_line_above("/", ",")
				}
				if (this._output.space_before_token = !0, this._options.brace_style === "expand") this._output
					.add_new_line(), this.print_string(this._ch), this.indent(), this._output.set_indent(this
						._indentLevel);
				else {
					if (B === "(") this._output.space_before_token = !1;
					else if (B !== ",") this.indent();
					this.print_string(this._ch)
				}
				this.eatWhitespace(!0), this._output.add_new_line()
			} else if (this._ch === "}") {
				if (this.outdent(), this._output.add_new_line(), B === "{") this._output.trim(!0);
				if (F) this.outdent(), F = !1;
				if (this.print_string(this._ch), S = !1, this._nestedLevel) this._nestedLevel--;
				if (this.eatWhitespace(!0), this._output.add_new_line(), this._options.newline_between_rules && !
					this._output.just_added_blankline()) {
					if (this._input.peek() !== "}") this._output.add_new_line(!0)
				}
				if (this._input.peek() === ")") {
					if (this._output.trim(!0), this._options.brace_style === "expand") this._output.add_new_line(!0)
				}
			} else if (this._ch === ":") {
				for (var DR = 0; DR < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; DR++)
					if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[DR])) {
						E = !0;
						break
					} if ((S || W) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input
					.lookBack("(") && !G && H === 0) {
					if (this.print_string(":"), !F) F = !0, this._output.space_before_token = !0, this
						.eatWhitespace(!0), this.indent()
				} else {
					if (this._input.lookBack(" ")) this._output.space_before_token = !0;
					if (this._input.peek() === ":") this._ch = this._input.next(), this.print_string("::");
					else this.print_string(":")
				}
			} else if (this._ch === '"' || this._ch === "'") {
				var cI = B === '"' || B === "'";
				this.preserveSingleSpace(cI || O), this.print_string(this._ch + this.eatString(this._ch)), this
					.eatWhitespace(!0)
			} else if (this._ch === ";")
				if (E = !1, H === 0) {
					if (F) this.outdent(), F = !1;
					if (G = !1, this.print_string(this._ch), this.eatWhitespace(!0), this._input.peek() !== "/")
						this._output.add_new_line()
				} else this.print_string(this._ch), this.eatWhitespace(!0), this._output.space_before_token = !0;
			else if (this._ch === "(")
				if (this._input.lookBack("url")) {
					if (this.print_string(this._ch), this.eatWhitespace(), H++, this.indent(), this._ch = this
						._input.next(), this._ch === ")" || this._ch === '"' || this._ch === "'") this._input
				.back();
					else if (this._ch) {
						if (this.print_string(this._ch + this.eatString(")")), H) H--, this.outdent()
					}
				} else {
					var vR = !1;
					if (this._input.lookBack("with")) vR = !0;
					if (this.preserveSingleSpace(O || vR), this.print_string(this._ch), F && B === "$" && this
						._options.selector_separator_newline) this._output.add_new_line(), T = !0;
					else this.eatWhitespace(), H++, this.indent()
				}
			else if (this._ch === ")") {
				if (H) H--, this.outdent();
				if (T && this._input.peek() === ";" && this._options.selector_separator_newline) T = !1, this
					.outdent(), this._output.add_new_line();
				this.print_string(this._ch)
			} else if (this._ch === ",")
				if (this.print_string(this._ch), this.eatWhitespace(!0), this._options.selector_separator_newline &&
					(!F || T) && H === 0 && !G) this._output.add_new_line();
				else this._output.space_before_token = !0;
			else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !F && H === 0) {
				if (this._options.space_around_combinator) this._output.space_before_token = !0, this.print_string(
					this._ch), this._output.space_before_token = !0;
				else if (this.print_string(this._ch), this.eatWhitespace(), this._ch && TR.test(this._ch)) this
					._ch = ""
			} else if (this._ch === "]") this.print_string(this._ch);
			else if (this._ch === "[") this.preserveSingleSpace(O), this.print_string(this._ch);
			else if (this._ch === "=") {
				if (this.eatWhitespace(), this.print_string("="), TR.test(this._ch)) this._ch = ""
			} else if (this._ch === "!" && !this._input.lookBack("\\")) this._output.space_before_token = !0, this
				.print_string(this._ch);
			else {
				var uI = B === '"' || B === "'";
				if (this.preserveSingleSpace(uI || O), this.print_string(this._ch), !this._output
					.just_added_newline() && this._input.peek() === `
` && E) this._output.add_new_line()
			}
		}
		var iI = this._output.get_code(I);
		return iI
	};
	JH.Beautifier = x
});
var $I = X((RS, fR) => {
	var $H = ZI().Beautifier,
		QH = yR().Options;

	function NH(R, I) {
		var A = new $H(R, I);
		return A.beautify()
	}
	fR.exports = NH;
	fR.exports.defaultOptions = function() {
		return new QH
	}
});
var OR = X((VH, VI) => {
	var QI = LR().Options;

	function NI(R) {
		if (QI.call(this, R, "html"), this.templating.length === 1 && this.templating[0] === "auto") this.templating = [
			"django", "erb", "handlebars", "php"
		];
		this.indent_inner_html = this._get_boolean("indent_inner_html"), this.indent_body_inner_html = this
			._get_boolean("indent_body_inner_html", !0), this.indent_head_inner_html = this._get_boolean(
				"indent_head_inner_html", !0), this.indent_handlebars = this._get_boolean("indent_handlebars", !0), this
			.wrap_attributes = this._get_selection("wrap_attributes", ["auto", "force", "force-aligned",
				"force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"
			]), this.wrap_attributes_min_attrs = this._get_number("wrap_attributes_min_attrs", 2), this
			.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size), this
			.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]), this.inline = this._get_array(
				"inline", ["a", "abbr", "area", "audio", "b", "bdi", "bdo", "br", "button", "canvas", "cite", "code",
					"data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd",
					"keygen", "label", "map", "mark", "math", "meter", "noscript", "object", "output", "progress", "q",
					"ruby", "s", "samp", "select", "small", "span", "strong", "sub", "sup", "svg", "template",
					"textarea", "time", "u", "var", "video", "wbr", "text", "acronym", "big", "strike", "tt"
				]), this.inline_custom_elements = this._get_boolean("inline_custom_elements", !0), this.void_elements =
			this._get_array("void_elements", ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen",
				"link", "menuitem", "meta", "param", "source", "track", "wbr", "!doctype", "?xml", "basefont",
				"isindex"
			]), this.unformatted = this._get_array("unformatted", []), this.content_unformatted = this._get_array(
				"content_unformatted", ["pre", "textarea"]), this.unformatted_content_delimiter = this._get_characters(
				"unformatted_content_delimiter"), this.indent_scripts = this._get_selection("indent_scripts", ["normal",
				"keep", "separate"
			])
	}
	NI.prototype = new QI;
	VH.Options = NI
});
var xR = X((fH, wR) => {
	var BI = a().Tokenizer,
		bR = a().TOKEN,
		BH = WR().Directives,
		zH = NR().TemplatablePattern,
		yH = k().Pattern,
		C = {
			TAG_OPEN: "TK_TAG_OPEN",
			TAG_CLOSE: "TK_TAG_CLOSE",
			CONTROL_FLOW_OPEN: "TK_CONTROL_FLOW_OPEN",
			CONTROL_FLOW_CLOSE: "TK_CONTROL_FLOW_CLOSE",
			ATTRIBUTE: "TK_ATTRIBUTE",
			EQUALS: "TK_EQUALS",
			VALUE: "TK_VALUE",
			COMMENT: "TK_COMMENT",
			TEXT: "TK_TEXT",
			UNKNOWN: "TK_UNKNOWN",
			START: bR.START,
			RAW: bR.RAW,
			EOF: bR.EOF
		},
		jI = new BH(/<\!--/, /-->/),
		$ = function(R, I) {
			BI.call(this, R, I), this._current_tag_name = "";
			var A = new zH(this._input).read_options(this._options),
				H = new yH(this._input);
			if (this.__patterns = {
					word: A.until(/[\n\r\t <]/),
					word_control_flow_close_excluded: A.until(/[\n\r\t <}]/),
					single_quote: A.until_after(/'/),
					double_quote: A.until_after(/"/),
					attribute: A.until(/[\n\r\t =>]|\/>/),
					element_name: A.until(/[\n\r\t >\/]/),
					angular_control_flow_start: H.matching(/\@[a-zA-Z]+[^({]*[({]/),
					handlebars_comment: H.starting_with(/{{!--/).until_after(/--}}/),
					handlebars: H.starting_with(/{{/).until_after(/}}/),
					handlebars_open: H.until(/[\n\r\t }]/),
					handlebars_raw_close: H.until(/}}/),
					comment: H.starting_with(/<!--/).until_after(/-->/),
					cdata: H.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
					conditional_comment: H.starting_with(/<!\[/).until_after(/]>/),
					processing: H.starting_with(/<\?/).until_after(/\?>/)
				}, this._options.indent_handlebars) this.__patterns.word = this.__patterns.word.exclude("handlebars"),
				this.__patterns.word_control_flow_close_excluded = this.__patterns.word_control_flow_close_excluded
				.exclude("handlebars");
			if (this._unformatted_content_delimiter = null, this._options.unformatted_content_delimiter) {
				var S = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
				this.__patterns.unformatted_content_delimiter = H.matching(S).until_after(S)
			}
		};
	$.prototype = new BI;
	$.prototype._is_comment = function(R) {
		return !1
	};
	$.prototype._is_opening = function(R) {
		return R.type === C.TAG_OPEN || R.type === C.CONTROL_FLOW_OPEN
	};
	$.prototype._is_closing = function(R, I) {
		return R.type === C.TAG_CLOSE && (I && ((R.text === ">" || R.text === "/>") && I.text[0] === "<" || R
			.text === "}}" && I.text[0] === "{" && I.text[1] === "{")) || R.type === C.CONTROL_FLOW_CLOSE && (R
			.text === "}" && I.text.endsWith("{"))
	};
	$.prototype._reset = function() {
		this._current_tag_name = ""
	};
	$.prototype._get_next_token = function(R, I) {
		var A = null;
		this._readWhitespace();
		var H = this._input.peek();
		if (H === null) return this._create_token(C.EOF, "");
		return A = A || this._read_open_handlebars(H, I), A = A || this._read_attribute(H, R, I), A = A || this
			._read_close(H, I), A = A || this._read_script_and_style(H, R), A = A || this._read_control_flows(H, I),
			A = A || this._read_raw_content(H, R, I), A = A || this._read_content_word(H, I), A = A || this
			._read_comment_or_cdata(H), A = A || this._read_processing(H), A = A || this._read_open(H, I), A = A ||
			this._create_token(C.UNKNOWN, this._input.next()), A
	};
	$.prototype._read_comment_or_cdata = function(R) {
		var I = null,
			A = null,
			H = null;
		if (R === "<") {
			var S = this._input.peek(1);
			if (S === "!")
				if (A = this.__patterns.comment.read(), A) {
					if (H = jI.get_directives(A), H && H.ignore === "start") A += jI.readIgnored(this._input)
				} else A = this.__patterns.cdata.read();
			if (A) I = this._create_token(C.COMMENT, A), I.directives = H
		}
		return I
	};
	$.prototype._read_processing = function(R) {
		var I = null,
			A = null,
			H = null;
		if (R === "<") {
			var S = this._input.peek(1);
			if (S === "!" || S === "?") A = this.__patterns.conditional_comment.read(), A = A || this.__patterns
				.processing.read();
			if (A) I = this._create_token(C.COMMENT, A), I.directives = H
		}
		return I
	};
	$.prototype._read_open = function(R, I) {
		var A = null,
			H = null;
		if (!I || I.type === C.CONTROL_FLOW_OPEN) {
			if (R === "<") {
				if (A = this._input.next(), this._input.peek() === "/") A += this._input.next();
				A += this.__patterns.element_name.read(), H = this._create_token(C.TAG_OPEN, A)
			}
		}
		return H
	};
	$.prototype._read_open_handlebars = function(R, I) {
		var A = null,
			H = null;
		if (!I || I.type === C.CONTROL_FLOW_OPEN) {
			if ((this._options.templating.includes("angular") || this._options.indent_handlebars) && R === "{" &&
				this._input.peek(1) === "{")
				if (this._options.indent_handlebars && this._input.peek(2) === "!") A = this.__patterns
					.handlebars_comment.read(), A = A || this.__patterns.handlebars.read(), H = this._create_token(C
						.COMMENT, A);
				else A = this.__patterns.handlebars_open.read(), H = this._create_token(C.TAG_OPEN, A)
		}
		return H
	};
	$.prototype._read_control_flows = function(R, I) {
		var A = "",
			H = null;
		if (!this._options.templating.includes("angular")) return H;
		if (R === "@") {
			if (A = this.__patterns.angular_control_flow_start.read(), A === "") return H;
			var S = A.endsWith("(") ? 1 : 0,
				F = 0;
			while (!(A.endsWith("{") && S === F)) {
				var W = this._input.next();
				if (W === null) break;
				else if (W === "(") S++;
				else if (W === ")") F++;
				A += W
			}
			H = this._create_token(C.CONTROL_FLOW_OPEN, A)
		} else if (R === "}" && I && I.type === C.CONTROL_FLOW_OPEN) A = this._input.next(), H = this._create_token(
			C.CONTROL_FLOW_CLOSE, A);
		return H
	};
	$.prototype._read_close = function(R, I) {
		var A = null,
			H = null;
		if (I && I.type === C.TAG_OPEN) {
			if (I.text[0] === "<" && (R === ">" || R === "/" && this._input.peek(1) === ">")) {
				if (A = this._input.next(), R === "/") A += this._input.next();
				H = this._create_token(C.TAG_CLOSE, A)
			} else if (I.text[0] === "{" && R === "}" && this._input.peek(1) === "}") this._input.next(), this
				._input.next(), H = this._create_token(C.TAG_CLOSE, "}}")
		}
		return H
	};
	$.prototype._read_attribute = function(R, I, A) {
		var H = null,
			S = "";
		if (A && A.text[0] === "<") {
			if (R === "=") H = this._create_token(C.EQUALS, this._input.next());
			else if (R === '"' || R === "'") {
				var F = this._input.next();
				if (R === '"') F += this.__patterns.double_quote.read();
				else F += this.__patterns.single_quote.read();
				H = this._create_token(C.VALUE, F)
			} else if (S = this.__patterns.attribute.read(), S)
				if (I.type === C.EQUALS) H = this._create_token(C.VALUE, S);
				else H = this._create_token(C.ATTRIBUTE, S)
		}
		return H
	};
	$.prototype._is_content_unformatted = function(R) {
		return this._options.void_elements.indexOf(R) === -1 && (this._options.content_unformatted.indexOf(R) !== -
			1 || this._options.unformatted.indexOf(R) !== -1)
	};
	$.prototype._read_raw_content = function(R, I, A) {
		var H = "";
		if (A && A.text[0] === "{") H = this.__patterns.handlebars_raw_close.read();
		else if (I.type === C.TAG_CLOSE && I.opened.text[0] === "<" && I.text[0] !== "/") {
			var S = I.opened.text.substr(1).toLowerCase();
			if (this._is_content_unformatted(S)) H = this._input.readUntil(new RegExp("</" + S + "[\\n\\r\\t ]*?>",
				"ig"))
		}
		if (H) return this._create_token(C.TEXT, H);
		return null
	};
	$.prototype._read_script_and_style = function(R, I) {
		if (I.type === C.TAG_CLOSE && I.opened.text[0] === "<" && I.text[0] !== "/") {
			var A = I.opened.text.substr(1).toLowerCase();
			if (A === "script" || A === "style") {
				var H = this._read_comment_or_cdata(R);
				if (H) return H.type = C.TEXT, H;
				var S = this._input.readUntil(new RegExp("</" + A + "[\\n\\r\\t ]*?>", "ig"));
				if (S) return this._create_token(C.TEXT, S)
			}
		}
		return null
	};
	$.prototype._read_content_word = function(R, I) {
		var A = "";
		if (this._options.unformatted_content_delimiter) {
			if (R === this._options.unformatted_content_delimiter[0]) A = this.__patterns
				.unformatted_content_delimiter.read()
		}
		if (!A) A = I && I.type === C.CONTROL_FLOW_OPEN ? this.__patterns.word_control_flow_close_excluded.read() :
			this.__patterns.word.read();
		if (A) return this._create_token(C.TEXT, A);
		return null
	};
	fH.Tokenizer = $;
	fH.TOKEN = C
});
var OI = X((cH, fI) => {
	var wH = OR().Options,
		xH = HR().Output,
		KH = xR().Tokenizer,
		M = xR().TOKEN,
		zI = /\r\n|[\r\n]/,
		vH = /\r\n|[\r\n]/g,
		j = function(R, I) {
			this.indent_level = 0, this.alignment_size = 0, this.max_preserve_newlines = R.max_preserve_newlines, this
				.preserve_newlines = R.preserve_newlines, this._output = new xH(R, I)
		};
	j.prototype.current_line_has_match = function(R) {
		return this._output.current_line.has_match(R)
	};
	j.prototype.set_space_before_token = function(R, I) {
		this._output.space_before_token = R, this._output.non_breaking_space = I
	};
	j.prototype.set_wrap_point = function() {
		this._output.set_indent(this.indent_level, this.alignment_size), this._output.set_wrap_point()
	};
	j.prototype.add_raw_token = function(R) {
		this._output.add_raw_token(R)
	};
	j.prototype.print_preserved_newlines = function(R) {
		var I = 0;
		if (R.type !== M.TEXT && R.previous.type !== M.TEXT) I = R.newlines ? 1 : 0;
		if (this.preserve_newlines) I = R.newlines < this.max_preserve_newlines + 1 ? R.newlines : this
			.max_preserve_newlines + 1;
		for (var A = 0; A < I; A++) this.print_newline(A > 0);
		return I !== 0
	};
	j.prototype.traverse_whitespace = function(R) {
		if (R.whitespace_before || R.newlines) {
			if (!this.print_preserved_newlines(R)) this._output.space_before_token = !0;
			return !0
		}
		return !1
	};
	j.prototype.previous_token_wrapped = function() {
		return this._output.previous_token_wrapped
	};
	j.prototype.print_newline = function(R) {
		this._output.add_new_line(R)
	};
	j.prototype.print_token = function(R) {
		if (R.text) this._output.set_indent(this.indent_level, this.alignment_size), this._output.add_token(R.text)
	};
	j.prototype.indent = function() {
		this.indent_level++
	};
	j.prototype.deindent = function() {
		if (this.indent_level > 0) this.indent_level--, this._output.set_indent(this.indent_level, this
			.alignment_size)
	};
	j.prototype.get_full_indent = function(R) {
		if (R = this.indent_level + (R || 0), R < 1) return "";
		return this._output.get_indent_string(R)
	};
	var mH = function(R) {
			var I = null,
				A = R.next;
			while (A.type !== M.EOF && R.closed !== A) {
				if (A.type === M.ATTRIBUTE && A.text === "type") {
					if (A.next && A.next.type === M.EQUALS && A.next.next && A.next.next.type === M.VALUE) I = A.next
						.next.text;
					break
				}
				A = A.next
			}
			return I
		},
		dH = function(R, I) {
			var A = null,
				H = null;
			if (!I.closed) return null;
			if (R === "script") A = "text/javascript";
			else if (R === "style") A = "text/css";
			if (A = mH(I) || A, A.search("text/css") > -1) H = "css";
			else if (A.search(
					/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/
					) > -1) H = "javascript";
			else if (A.search(/(text|application|dojo)\/(x-)?(html)/) > -1) H = "html";
			else if (A.search(/test\/null/) > -1) H = "null";
			return H
		};

	function IR(R, I) {
		return I.indexOf(R) !== -1
	}

	function gH(R, I, A) {
		this.parent = R || null, this.tag = I ? I.tag_name : "", this.indent_level = A || 0, this.parser_token = I ||
			null
	}

	function p(R) {
		this._printer = R, this._current_frame = null
	}
	p.prototype.get_parser_token = function() {
		return this._current_frame ? this._current_frame.parser_token : null
	};
	p.prototype.record_tag = function(R) {
		var I = new gH(this._current_frame, R, this._printer.indent_level);
		this._current_frame = I
	};
	p.prototype._try_pop_frame = function(R) {
		var I = null;
		if (R) I = R.parser_token, this._printer.indent_level = R.indent_level, this._current_frame = R.parent;
		return I
	};
	p.prototype._get_frame = function(R, I) {
		var A = this._current_frame;
		while (A) {
			if (R.indexOf(A.tag) !== -1) break;
			else if (I && I.indexOf(A.tag) !== -1) {
				A = null;
				break
			}
			A = A.parent
		}
		return A
	};
	p.prototype.try_pop = function(R, I) {
		var A = this._get_frame([R], I);
		return this._try_pop_frame(A)
	};
	p.prototype.indent_to_tag = function(R) {
		var I = this._get_frame(R);
		if (I) this._printer.indent_level = I.indent_level
	};

	function V(R, I, A, H) {
		this._source_text = R || "", I = I || {}, this._js_beautify = A, this._css_beautify = H, this._tag_stack = null;
		var S = new wH(I, "html");
		this._options = S, this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 5) === "force", this
			._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline",
			this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned", this
			._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple", this
			._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 8) === "preserve", this
			._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned"
	}
	V.prototype.beautify = function() {
		if (this._options.disabled) return this._source_text;
		var R = this._source_text,
			I = this._options.eol;
		if (this._options.eol === "auto") {
			if (I = `
`, R && zI.test(R)) I = R.match(zI)[0]
		}
		R = R.replace(vH, `
`);
		var A = R.match(/^[\t ]*/)[0],
			H = {
				text: "",
				type: ""
			},
			S = new yI(this._options),
			F = new j(this._options, A),
			W = new KH(R, this._options).tokenize();
		this._tag_stack = new p(F);
		var G = null,
			T = W.next();
		while (T.type !== M.EOF) {
			if (T.type === M.TAG_OPEN || T.type === M.COMMENT) G = this._handle_tag_open(F, T, S, H, W), S = G;
			else if (T.type === M.ATTRIBUTE || T.type === M.EQUALS || T.type === M.VALUE || T.type === M.TEXT && !S
				.tag_complete) G = this._handle_inside_tag(F, T, S, H);
			else if (T.type === M.TAG_CLOSE) G = this._handle_tag_close(F, T, S);
			else if (T.type === M.TEXT) G = this._handle_text(F, T, S);
			else if (T.type === M.CONTROL_FLOW_OPEN) G = this._handle_control_flow_open(F, T);
			else if (T.type === M.CONTROL_FLOW_CLOSE) G = this._handle_control_flow_close(F, T);
			else F.add_raw_token(T);
			H = G, T = W.next()
		}
		var N = F._output.get_code(I);
		return N
	};
	V.prototype._handle_control_flow_open = function(R, I) {
		var A = {
			text: I.text,
			type: I.type
		};
		if (R.set_space_before_token(I.newlines || I.whitespace_before !== "", !0), I.newlines) R
			.print_preserved_newlines(I);
		else R.set_space_before_token(I.newlines || I.whitespace_before !== "", !0);
		return R.print_token(I), R.indent(), A
	};
	V.prototype._handle_control_flow_close = function(R, I) {
		var A = {
			text: I.text,
			type: I.type
		};
		if (R.deindent(), I.newlines) R.print_preserved_newlines(I);
		else R.set_space_before_token(I.newlines || I.whitespace_before !== "", !0);
		return R.print_token(I), A
	};
	V.prototype._handle_tag_close = function(R, I, A) {
		var H = {
			text: I.text,
			type: I.type
		};
		if (R.alignment_size = 0, A.tag_complete = !0, R.set_space_before_token(I.newlines || I
				.whitespace_before !== "", !0), A.is_unformatted) R.add_raw_token(I);
		else {
			if (A.tag_start_char === "<") {
				if (R.set_space_before_token(I.text[0] === "/", !0), this
					._is_wrap_attributes_force_expand_multiline && A.has_wrapped_attrs) R.print_newline(!1)
			}
			R.print_token(I)
		}
		if (A.indent_content && !(A.is_unformatted || A.is_content_unformatted)) R.indent(), A.indent_content = !1;
		if (!A.is_inline_element && !(A.is_unformatted || A.is_content_unformatted)) R.set_wrap_point();
		return H
	};
	V.prototype._handle_inside_tag = function(R, I, A, H) {
		var S = A.has_wrapped_attrs,
			F = {
				text: I.text,
				type: I.type
			};
		if (R.set_space_before_token(I.newlines || I.whitespace_before !== "", !0), A.is_unformatted) R
			.add_raw_token(I);
		else if (A.tag_start_char === "{" && I.type === M.TEXT)
			if (R.print_preserved_newlines(I)) I.newlines = 0, R.add_raw_token(I);
			else R.print_token(I);
		else {
			if (I.type === M.ATTRIBUTE) R.set_space_before_token(!0);
			else if (I.type === M.EQUALS) R.set_space_before_token(!1);
			else if (I.type === M.VALUE && I.previous.type === M.EQUALS) R.set_space_before_token(!1);
			if (I.type === M.ATTRIBUTE && A.tag_start_char === "<") {
				if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) R
					.traverse_whitespace(I), S = S || I.newlines !== 0;
				if (this._is_wrap_attributes_force && A.attr_count >= this._options.wrap_attributes_min_attrs && (H
						.type !== M.TAG_OPEN || this._is_wrap_attributes_force_expand_multiline)) R.print_newline(!
					1), S = !0
			}
			R.print_token(I), S = S || R.previous_token_wrapped(), A.has_wrapped_attrs = S
		}
		return F
	};
	V.prototype._handle_text = function(R, I, A) {
		var H = {
			text: I.text,
			type: "TK_CONTENT"
		};
		if (A.custom_beautifier_name) this._print_custom_beatifier_text(R, I, A);
		else if (A.is_unformatted || A.is_content_unformatted) R.add_raw_token(I);
		else R.traverse_whitespace(I), R.print_token(I);
		return H
	};
	V.prototype._print_custom_beatifier_text = function(R, I, A) {
		var H = this;
		if (I.text !== "") {
			var S = I.text,
				F, W = 1,
				G = "",
				T = "";
			if (A.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") F = this
				._js_beautify;
			else if (A.custom_beautifier_name === "css" && typeof this._css_beautify === "function") F = this
				._css_beautify;
			else if (A.custom_beautifier_name === "html") F = function(i, AR) {
				var c = new V(i, AR, H._js_beautify, H._css_beautify);
				return c.beautify()
			};
			if (this._options.indent_scripts === "keep") W = 0;
			else if (this._options.indent_scripts === "separate") W = -R.indent_level;
			var N = R.get_full_indent(W);
			if (S = S.replace(/\n[ \t]*$/, ""), A.custom_beautifier_name !== "html" && S[0] === "<" && S.match(
					/^(<!--|<!\[CDATA\[)/)) {
				var E = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(S);
				if (!E) {
					R.add_raw_token(I);
					return
				}
				if (G = N + E[1] + `
`, S = E[4], E[5]) T = N + E[5];
				if (S = S.replace(/\n[ \t]*$/, ""), E[2] || E[3].indexOf(`
`) !== -1) {
					if (E = E[3].match(/[ \t]+$/), E) I.whitespace_before = E[0]
				}
			}
			if (S)
				if (F) {
					var K = function() {
						this.eol = `
`
					};
					K.prototype = this._options.raw_options;
					var O = new K;
					S = F(N + S, O)
				} else {
					var B = I.whitespace_before;
					if (B) S = S.replace(new RegExp(`
(` + B + ")?", "g"), `
`);
					S = N + S.replace(/\n/g, `
` + N)
				} if (G)
				if (!S) S = G + T;
				else S = G + S + `
` + T;
			if (R.print_newline(!1), S) I.text = S, I.whitespace_before = "", I.newlines = 0, R.add_raw_token(I), R
				.print_newline(!0)
		}
	};
	V.prototype._handle_tag_open = function(R, I, A, H, S) {
		var F = this._get_tag_open_token(I);
		if ((A.is_unformatted || A.is_content_unformatted) && !A.is_empty_element && I.type === M.TAG_OPEN && !F
			.is_start_tag) R.add_raw_token(I), F.start_tag_token = this._tag_stack.try_pop(F.tag_name);
		else {
			if (R.traverse_whitespace(I), this._set_tag_position(R, I, F, A, H), !F.is_inline_element) R
				.set_wrap_point();
			R.print_token(I)
		}
		if (F.is_start_tag && this._is_wrap_attributes_force) {
			var W = 0,
				G;
			do {
				if (G = S.peek(W), G.type === M.ATTRIBUTE) F.attr_count += 1;
				W += 1
			} while (G.type !== M.EOF && G.type !== M.TAG_CLOSE)
		}
		if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this
			._is_wrap_attributes_preserve_aligned) F.alignment_size = I.text.length + 1;
		if (!F.tag_complete && !F.is_unformatted) R.alignment_size = F.alignment_size;
		return F
	};
	var yI = function(R, I, A) {
		if (this.parent = I || null, this.text = "", this.type = "TK_TAG_OPEN", this.tag_name = "", this
			.is_inline_element = !1, this.is_unformatted = !1, this.is_content_unformatted = !1, this
			.is_empty_element = !1, this.is_start_tag = !1, this.is_end_tag = !1, this.indent_content = !1, this
			.multiline_content = !1, this.custom_beautifier_name = null, this.start_tag_token = null, this
			.attr_count = 0, this.has_wrapped_attrs = !1, this.alignment_size = 0, this.tag_complete = !1, this
			.tag_start_char = "", this.tag_check = "", !A) this.tag_complete = !0;
		else {
			var H;
			if (this.tag_start_char = A.text[0], this.text = A.text, this.tag_start_char === "<") H = A.text.match(
				/^<([^\s>]*)/), this.tag_check = H ? H[1] : "";
			else if (H = A.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/), this.tag_check = H ? H[1] : "", (A.text
					.startsWith("{{#>") || A.text.startsWith("{{~#>")) && this.tag_check[0] === ">")
				if (this.tag_check === ">" && A.next !== null) this.tag_check = A.next.text.split(" ")[0];
				else this.tag_check = A.text.split(">")[1];
			if (this.tag_check = this.tag_check.toLowerCase(), A.type === M.COMMENT) this.tag_complete = !0;
			this.is_start_tag = this.tag_check.charAt(0) !== "/", this.tag_name = !this.is_start_tag ? this
				.tag_check.substr(1) : this.tag_check, this.is_end_tag = !this.is_start_tag || A.closed && A.closed
				.text === "/>";
			var S = 2;
			if (this.tag_start_char === "{" && this.text.length >= 3) {
				if (this.text.charAt(2) === "~") S = 3
			}
			this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (!R.indent_handlebars || this.text
				.length < 3 || /[^#\^]/.test(this.text.charAt(S)))
		}
	};
	V.prototype._get_tag_open_token = function(R) {
		var I = new yI(this._options, this._tag_stack.get_parser_token(), R);
		return I.alignment_size = this._options.wrap_attributes_indent_size, I.is_end_tag = I.is_end_tag || IR(I
				.tag_check, this._options.void_elements), I.is_empty_element = I.tag_complete || I.is_start_tag && I
			.is_end_tag, I.is_unformatted = !I.tag_complete && IR(I.tag_check, this._options.unformatted), I
			.is_content_unformatted = !I.is_empty_element && IR(I.tag_check, this._options.content_unformatted), I
			.is_inline_element = IR(I.tag_name, this._options.inline) || this._options.inline_custom_elements && I
			.tag_name.includes("-") || I.tag_start_char === "{", I
	};
	V.prototype._set_tag_position = function(R, I, A, H, S) {
		if (!A.is_empty_element)
			if (A.is_end_tag) A.start_tag_token = this._tag_stack.try_pop(A.tag_name);
			else {
				if (this._do_optional_end_element(A)) {
					if (!A.is_inline_element) R.print_newline(!1)
				}
				if (this._tag_stack.record_tag(A), (A.tag_name === "script" || A.tag_name === "style") && !(A
						.is_unformatted || A.is_content_unformatted)) A.custom_beautifier_name = dH(A.tag_check, I)
			} if (IR(A.tag_check, this._options.extra_liners)) {
			if (R.print_newline(!1), !R._output.just_added_blankline()) R.print_newline(!0)
		}
		if (A.is_empty_element) {
			if (A.tag_start_char === "{" && A.tag_check === "else") {
				this._tag_stack.indent_to_tag(["if", "unless", "each"]), A.indent_content = !0;
				var F = R.current_line_has_match(/{{#if/);
				if (!F) R.print_newline(!1)
			}
			if (A.tag_name === "!--" && S.type === M.TAG_CLOSE && H.is_end_tag && A.text.indexOf(`
`) === -1);
			else {
				if (!(A.is_inline_element || A.is_unformatted)) R.print_newline(!1);
				this._calcluate_parent_multiline(R, A)
			}
		} else if (A.is_end_tag) {
			var W = !1;
			if (W = A.start_tag_token && A.start_tag_token.multiline_content, W = W || !A.is_inline_element && !(H
					.is_inline_element || H.is_unformatted) && !(S.type === M.TAG_CLOSE && A.start_tag_token ===
				H) && S.type !== "TK_CONTENT", A.is_content_unformatted || A.is_unformatted) W = !1;
			if (W) R.print_newline(!1)
		} else {
			if (A.indent_content = !A.custom_beautifier_name, A.tag_start_char === "<") {
				if (A.tag_name === "html") A.indent_content = this._options.indent_inner_html;
				else if (A.tag_name === "head") A.indent_content = this._options.indent_head_inner_html;
				else if (A.tag_name === "body") A.indent_content = this._options.indent_body_inner_html
			}
			if (!(A.is_inline_element || A.is_unformatted) && (S.type !== "TK_CONTENT" || A.is_content_unformatted))
				R.print_newline(!1);
			this._calcluate_parent_multiline(R, A)
		}
	};
	V.prototype._calcluate_parent_multiline = function(R, I) {
		if (I.parent && R._output.just_added_newline() && !((I.is_inline_element || I.is_unformatted) && I.parent
				.is_inline_element)) I.parent.multiline_content = !0
	};
	var lH = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure",
			"footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "menu", "nav", "ol", "p",
			"pre", "section", "table", "ul"
		],
		pH = ["a", "audio", "del", "ins", "map", "noscript", "video"];
	V.prototype._do_optional_end_element = function(R) {
		var I = null;
		if (R.is_empty_element || !R.is_start_tag || !R.parent) return;
		if (R.tag_name === "body") I = I || this._tag_stack.try_pop("head");
		else if (R.tag_name === "li") I = I || this._tag_stack.try_pop("li", ["ol", "ul", "menu"]);
		else if (R.tag_name === "dd" || R.tag_name === "dt") I = I || this._tag_stack.try_pop("dt", ["dl"]), I =
			I || this._tag_stack.try_pop("dd", ["dl"]);
		else if (R.parent.tag_name === "p" && lH.indexOf(R.tag_name) !== -1) {
			var A = R.parent.parent;
			if (!A || pH.indexOf(A.tag_name) === -1) I = I || this._tag_stack.try_pop("p")
		} else if (R.tag_name === "rp" || R.tag_name === "rt") I = I || this._tag_stack.try_pop("rt", ["ruby",
			"rtc"]), I = I || this._tag_stack.try_pop("rp", ["ruby", "rtc"]);
		else if (R.tag_name === "optgroup") I = I || this._tag_stack.try_pop("optgroup", ["select"]);
		else if (R.tag_name === "option") I = I || this._tag_stack.try_pop("option", ["select", "datalist",
			"optgroup"
		]);
		else if (R.tag_name === "colgroup") I = I || this._tag_stack.try_pop("caption", ["table"]);
		else if (R.tag_name === "thead") I = I || this._tag_stack.try_pop("caption", ["table"]), I = I || this
			._tag_stack.try_pop("colgroup", ["table"]);
		else if (R.tag_name === "tbody" || R.tag_name === "tfoot") I = I || this._tag_stack.try_pop("caption", [
			"table"
		]), I = I || this._tag_stack.try_pop("colgroup", ["table"]), I = I || this._tag_stack.try_pop("thead", [
			"table"
		]), I = I || this._tag_stack.try_pop("tbody", ["table"]);
		else if (R.tag_name === "tr") I = I || this._tag_stack.try_pop("caption", ["table"]), I = I || this
			._tag_stack.try_pop("colgroup", ["table"]), I = I || this._tag_stack.try_pop("tr", ["table", "thead",
				"tbody", "tfoot"
			]);
		else if (R.tag_name === "th" || R.tag_name === "td") I = I || this._tag_stack.try_pop("td", ["table",
			"thead", "tbody", "tfoot", "tr"
		]), I = I || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]);
		return R.parent = this._tag_stack.get_parser_token(), I
	};
	cH.Beautifier = V
});
var bI = X((IS, KR) => {
	var iH = OI().Beautifier,
		sH = OR().Options;

	function kH(R, I, A, H) {
		var S = new iH(R, I, A, H);
		return S.beautify()
	}
	KR.exports = kH;
	KR.exports.defaultOptions = function() {
		return new sH
	}
});
var mI = X((oH, GR) => {
	var wI = CI(),
		xI = $I(),
		KI = bI();

	function vI(R, I, A, H) {
		return A = A || wI, H = H || xI, KI(R, I, A, H)
	}
	vI.defaultOptions = KI.defaultOptions;
	oH.js = wI;
	oH.css = xI;
	oH.html = vI
});
var lI = X((AS, gI) => {
	function dI(R, I, A) {
		var H = function(S, F) {
			return R.js_beautify(S, F)
		};
		return H.js = R.js_beautify, H.css = I.css_beautify, H.html = A.html_beautify, H.js_beautify = R.js_beautify, H
			.css_beautify = I.css_beautify, H.html_beautify = A.html_beautify, H
	}
	if (typeof define === "function" && define.amd) define(["./lib/beautify", "./lib/beautify-css",
		"./lib/beautify-html"
	], function(R, I, A) {
		return dI(R, I, A)
	});
	else(function(R) {
		var I = mI();
		I.js_beautify = I.js, I.css_beautify = I.css, I.html_beautify = I.html, R.exports = dI(I, I, I)
	})(gI)
});
var pI = _I(lI(), 1),
	SS = pI.default;
export {
	SS as
	default
};</script>
		<script type="blob-module" name="codepad" remote="../modules/client/codepad.js">import { useStyledTags } from "@std/ima-utils";
import { useCustomStyledTag } from "@std/ima-utils";
import { css, finish, useShadowStyles, tryCatch } from "@std/utils";

import acorn from "@std/js-parser";
import formatter from "@std/formatter";
import { getModuleEditorRoot } from "module-editor";

const FONT_SIZE = 11;
const LINE_HEIGHT = 1.25;
const CHUNK_SIZE = 20;

const t = useStyledTags({ shadow_root: getModuleEditorRoot });

const CodepadEditor = useCustomStyledTag(
	"codepad-editor",
	function ({ $listen }) {
		return {
			connected() {
				this.dispatchEvent(new CustomEvent("mount"));
			},

			disconnected() {
				this.dispatchEvent(new CustomEvent("unmount"));
			},
		};
	},
	{
		shadow_root: getModuleEditorRoot,
	},
);

function highlightSource(formatted_code) {
	const start_time = performance.now();
	const chunks = [];
	let current_chunk_content = [];
	let line_count = 0;
	let parsing_failed = false;
	let error_pos = null;
	let ast;

	// Create a mapping of character positions to highlight classes
	const highlights = new Map();

	try {
		// Parse the code and collect token information
		const tokens = [];
		const comments = [];

		ast = acorn.parse(formatted_code, {
			ecmaVersion: "2022",
			sourceType: "module",
			onToken: tokens,
			onComment: comments,
		});

		// Map comments
		comments.forEach((comment) => {
			for (let i = comment.start; i < comment.end; i++) {
				highlights.set(i, "hl-comment");
			}
		});

		// Define keywords manually to be safe
		const keywords = new Set([
			"const",
			"let",
			"var",
			"function",
			"async",
			"await",
			"return",
			"if",
			"else",
			"for",
			"while",
			"do",
			"switch",
			"case",
			"default",
			"try",
			"catch",
			"finally",
			"throw",
			"new",
			"delete",
			"typeof",
			"instanceof",
			"in",
			"of",
			"class",
			"extends",
			"super",
			"static",
			"import",
			"export",
			"from",
			"as",
			"default",
			"this",
			"break",
			"continue",
			"debugger",
			"with",
			"yield",
		]);

		// Map tokens
		tokens.forEach((token) => {
			const start = token.start;
			const end = token.end;

			if (token.type.keyword || keywords.has(token.value)) {
				// Keywords
				for (let i = start; i < end; i++) {
					highlights.set(i, "hl-keyword");
				}
			} else if (token.type.label === "string") {
				// String literals
				for (let i = start; i < end; i++) {
					highlights.set(i, "hl-string");
				}
			} else if (token.type.label === "num") {
				// Number literals
				for (let i = start; i < end; i++) {
					highlights.set(i, "hl-number");
				}
			} else if (
				token.value === "true" ||
				token.value === "false" ||
				token.value === "null" ||
				token.value === "undefined"
			) {
				// Boolean and null literals
				for (let i = start; i < end; i++) {
					highlights.set(i, "hl-literal");
				}
			}
		});
	} catch (error) {
		// If parsing fails, mark the entire code as error
		error_pos = error.loc;
		parsing_failed = true;
		for (let i = 0; i < formatted_code.length; i++) {
			highlights.set(i, "hl-error");
		}
	}

	// Build content array
	let processed_characters = "";
	let current_class = null;

	function processCharacters() {
		if (processed_characters) {
			if (current_class) {
				current_chunk_content.push(
					t.span(
						{
							class: current_class,
						},
						processed_characters,
					),
				);
			} else {
				current_chunk_content.push(processed_characters);
			}
			processed_characters = "";
		}
	}

	function processChunk() {
		processCharacters();
		chunks.push(
			t.pre(
				{
					class: parsing_failed ? "code-chunk hl-error-chunk" : "code-chunk",
				},
				...current_chunk_content,
			),
		);
		current_chunk_content = [];
		line_count = 0;
	}

	for (let i = 0; i < formatted_code.length; i++) {
		const char = formatted_code[i];
		const highlight_class = highlights.get(i);

		// If class changes, flush current text
		if (highlight_class !== current_class) {
			processCharacters();
			current_class = highlight_class;
		}

		processed_characters += char;

		// Handle chunking
		if (char === "\n") {
			line_count++;
			if (line_count === CHUNK_SIZE) {
				processChunk();
			}
		}
	}

	// Add remaining chunk if any
	if (current_chunk_content.length > 0 || processed_characters) {
		// Handle trailing newline before flushing
		if (formatted_code.endsWith("\n") && !processed_characters.endsWith("\n")) {
			processed_characters += "\n";
		}
		processChunk();
	}

	// After all chunks are created, check if we need to add br to the last chunk
	if (chunks.length > 0 && formatted_code.endsWith("\n")) {
		const last_chunk = chunks[chunks.length - 1];
		last_chunk.appendChild(t.br());
	}

	const end_time = performance.now();
	console.log(`Chunk generation took ${end_time - start_time} milliseconds for ${chunks.length} chunks`);

	return [chunks, error_pos, ast];
}

export async function Codepad({ module, ...props }) {
	const root = getModuleEditorRoot();
	useShadowStyles(root, default_theme, "codepad-editor-theme");

	const [source, error] = await tryCatch(async () => {
		const response = await fetch(module.blob_url);
		const source = await response.text();
		return source;
	});

	const editor_ref = {
		current: null,
	};
	const textarea_ref = {
		current: null,
	};
	const content_ref = {
		current: null,
	};

	const chunk_data = new Map();

	let formatted_code = formatter.js(source, {
		indent_char: "\t",
		wrap_line_length: "128",
	});

	let original_source = formatted_code;

	let [chunk_elements, error_pos, ast] = highlightSource(formatted_code);
	console.log(module.name, ast);
	let intersection_observer = null;

	let has_changes = false;

	let last_save_mode = null;

	function observeChunkElements() {
		const chunk_els = editor_ref.current.querySelectorAll(".code-chunk");

		if (chunk_els.length > 0) {
			intersection_observer = new IntersectionObserver(
				(entries) => {
					entries.forEach((entry) => {
						const chunk = entry.target;

						if (entry.isIntersecting) {
							// Code chunk is visible - restore content
							if (chunk_data.has(chunk)) {
								const { children } = chunk_data.get(chunk);
								chunk.replaceChildren(...children);
								chunk.style.removeProperty("min-height");
								chunk.style.removeProperty("min-width");
							}
						} else {
							// Code chunk is not visible - store content and set fixed height
							if (!chunk_data.has(chunk)) {
								// Store the actual DOM children
								chunk_data.set(chunk, {
									children: Array.from(chunk.childNodes).map((node) => node.cloneNode(true)),
								});
							}

							chunk.style.minHeight = `${chunk.offsetHeight}px`;
							chunk.style.minWidth = `${chunk.offsetWidth}px`;
							chunk.replaceChildren(); // Clear all children
						}
					});
				},
				{
					threshold: 0,
				},
			);

			chunk_els.forEach((chunk) => {
				intersection_observer.observe(chunk);
			});
		}
	}

	async function saveModule() {
		const updated_source = textarea_ref.current.value;

		// Update the blob_modules Map in the blob module loader
		if (window.__blob_modules__ && window.__blob_modules__.has(module.module_name)) {
			window.__blob_modules__.set(module.module_name, updated_source);
		}

		// Check if we can save individual module files
		if (
			window.__blob_module_loader_settings__.prefers_remote_modules &&
			location.origin === "file://" &&
			globalThis.__sys &&
			module.remote_url
		) {
			// Check if the URL is not hosted externally
			const is_external = module.remote_url.startsWith("https://") || module.remote_url.startsWith("http://");

			if (!is_external) {
				let module_full_path;

				if (module.remote_url.startsWith("file://")) {
					// Absolute file:// URL - extract the path
					module_full_path = module.remote_url.replace("file://", "");
				} else if (module.remote_url.startsWith("/")) {
					// Absolute path from root
					console.warn("Served from server so we can't save it — an API for this server needs to be provided.");
				} else {
					// Relative path
					try {
						module_full_path = await __sys.invoke("file.resolve", module.remote_url);
					} catch (error) {
						console.error(`Failed to resolve module path ${module.remote_url}:`, error);
					}
				}

				if (module_full_path) {
					try {
						await __sys.invoke("file.write", module_full_path, updated_source);
						last_save_mode = "remote";
						console.log(`Saved module file: ${module_full_path}`);

						// Reset the has_changes flag
						has_changes = false;
						original_source = updated_source;
						return;
					} catch (error) {
						console.error(`Failed to save module file ${module_full_path}:`, error);
						// Fall back to saving the whole HTML file
					}
				}
			}
		}

		// If not, update the script tag content
		const script_tags = document.querySelectorAll('script[type="blob-module"]');
		const target_script = Array.from(script_tags).find((script) => script.getAttribute("name") === module.module_name);

		if (target_script) {
			target_script.textContent = updated_source;
		}

		// Handle special case for blob-module-loader
		if (module.module_name === "blob-module-loader") {
			const loader_script = document.getElementById("blob-module-loader");
			if (loader_script) {
				loader_script.textContent = updated_source;
			}
		}

		// Fallback: Save the HTML file
		try {
			window.saveHtmlFile();
			last_save_mode = "local";
			console.log(`Saved full html from module: ${module.module_name}`);
		} catch (error) {
			console.error(`Failed to save html from module: ${module.module_name}:`, error);
		}

		// Reset the has_changes flag
		has_changes = false;
		original_source = updated_source;
	}

	function handleTextareaInput() {
		const updated_source = textarea_ref.current.value;
		[chunk_elements, error_pos] = highlightSource(updated_source);
		content_ref.current.replaceChildren(...chunk_elements);

		has_changes = updated_source !== original_source;

		observeChunkElements();
	}

	function handleKeyDown(e) {
		if (e.key === "Tab") {
			e.preventDefault();
			e.stopPropagation();

			const textarea = textarea_ref.current;

			// Use execCommand to insert tab while preserving undo history
			if (document.execCommand) {
				document.execCommand("insertText", false, "\t");
			} else {
				// Fallback for browsers that don't support execCommand
				const start = textarea.selectionStart;
				const end = textarea.selectionEnd;
				const value = textarea.value;
				textarea.value = value.substring(0, start) + "\t" + value.substring(end);
				textarea.selectionStart = textarea.selectionEnd = start + 1;
			}

			// Trigger the input event to update syntax highlighting
			textarea.dispatchEvent(
				new Event("input", {
					bubbles: true,
				}),
			);
		}
	}

	return CodepadEditor(
		{
			...props,
			ref: editor_ref,
			styles: {
				key: "codepad-editor",
				css: `
					& {
						display: block;
						position: relative;
						width: 100%;
						height: 100%;
						padding: 11px;
						overflow: scroll;
					}
				`,
			},
			onmount() {
				if (textarea_ref.current) {
					textarea_ref.current.value = formatted_code;
				}
				observeChunkElements();
			},
			onunmount() {
				if (intersection_observer) {
					intersection_observer.disconnect();
					intersection_observer = null;
				}
			},
		},
		t.div(
			{
				styles: {
					key: "codepad-header",
					css: css`
						& {
							position: sticky;
							height: 0px;
							width: 100%;
							/*top: 11px;*/
							top: 0;
							left: 0;
							z-index: 1;
						}
					`,
				},
			},
			t.div(
				{
					styles: {
						key: "codepad-header-bar",
						css: css`
							& {
								position: absolute;
								display: flex;
								justify-content: space-between;
								align-items: center;
								height: fit-content;
								width: 100%;
								top: 0;
								left: 0;
							}
						`,
					},
				},
				t.div(
					module.name,
					() => (has_changes ? "*" : ""),
					() =>
						window.__blob_module_loader_settings__.prefers_remote_modules && module.remote_url !== null
							? last_save_mode
								? ` (${last_save_mode})`
								: ` (remote: ${module.remote_url})`
							: " (local)",
				),
				t.button(
					{
						style: () => `display: ${has_changes ? "block" : "none"};`,
						onclick: saveModule,
					},
					"save",
				),
			),
		),
		t.div(
			{
				styles: {
					key: "codepad-wrapper",
					css: `
						& {
							position: relative;
							width: 100%;
							height: fit-content;
							min-height: 100%;
							width: fit-content;
							min-width: 100%;
						}
					`,
				},
			},
			t.div(
				{
					ref: content_ref,
					styles: {
						key: "codepad-content",
						css: `
							& {
								position: relative;
								user-select: none;
								pointer-events: none;
								width: fit-content;
								height: fit-content;
								min-width: 100%;
								min-height: 100%;
								font-size: ${FONT_SIZE}px;
								line-height: ${LINE_HEIGHT};
								padding-top: ${LINE_HEIGHT * FONT_SIZE * 1.5}px;
								padding-bottom: calc(100vh - ${LINE_HEIGHT * FONT_SIZE * 6}px);
							}
						`,
					},
				},
				...chunk_elements,
			),
			t.textarea({
				ref: textarea_ref,
				spellcheck: "false",
				oninput: handleTextareaInput,
				onkeydown: handleKeyDown,
				styles: {
					key: "codepad-textarea",
					css: `
						& {
							position: absolute;
							top: 0;
							left: 0;
							width: 100%;
							height: 100%;
							white-space: nowrap;
							overflow: hidden;
							word-wrap: normal;
							resize: none;
							color: transparent;
							background: transparent;
							font-size: ${FONT_SIZE}px;
							line-height: ${LINE_HEIGHT};
							padding-top: ${LINE_HEIGHT * FONT_SIZE * 1.5}px;
							padding-bottom: calc(100vh - ${LINE_HEIGHT * FONT_SIZE * 6}px);
						}

						&:focus {
							outline: none;
						}
					`,
				},
			}),
			t.div({
				class: "hl-error-indicator",
				styles: {
					key: "codepad-error-indicator",
					css: `
						& {
							position: absolute;
							width: 100%;
							left: 0;
							transform: translateY(50%);
							pointer-events: none;
						}
					`,
				},
				style: () => `
					display: ${error_pos ? "block" : "none"};
					height: ${LINE_HEIGHT * FONT_SIZE}px;
					top: ${error_pos && error_pos.line * LINE_HEIGHT * FONT_SIZE - 1}px;
				`,
			}),
		),
	);
}

const default_theme = css`
	codepad-editor {
		background-color: black;
		scrollbar-width: thin;
		scrollbar-color: #444444 #1a1a1a;
	}

	codepad-editor::-webkit-scrollbar {
		width: 8px;
		height: 8px;
	}

	codepad-editor::-webkit-scrollbar-track {
		background: #000;
	}

	codepad-editor::-webkit-scrollbar-thumb {
		background: #444444;
	}

	codepad-editor::-webkit-scrollbar-thumb:hover {
		background: #505050;
	}

	codepad-editor::-webkit-scrollbar-corner {
		background: #000;
	}

	codepad-editor textarea {
		caret-color: #cacaca;
		tab-size: 3;
	}

	codepad-editor textarea::selection {
		background-color: #cacaca;
		color: black;
	}

	codepad-editor [styles-key="codepad-header-bar"] {
		background-color: var(--color-highlight);
		color: black;
	}

	codepad-editor [styles-key="codepad-header-bar"] button:hover {
		background-color: white;
	}

	/*
	// Color scheme
	*/

	codepad-editor .code-chunk {
		color: #ffffff;
		tab-size: 3;
	}

	.hl-literal,
	.hl-number,
	.hl-string {
		color: #d0d0d0;
	}

	.hl-string .hl-subst {
		color: #ffffff;
	}

	.hl-comment {
		color: var(--color-highlight);
	}

	.hl-keyword {
		color: #a0a0a0;
	}

	.hl-error-indicator {
		background-color: red;
		mix-blend-mode: exclusion;
	}
`;
</script>
		<script type="blob-module" name="module-editor" remote="../modules/client/module-editor.js">import {
	useTags
} from "@std/ima";
import {
	css,
	finish,
	useShadowStyles
} from "@std/utils";
import {
	Codepad
} from "codepad";

const {
	div,
	pre,
	button
} = useTags();

let module_editor_root = null;
let show_module_editor = false;

export function getModuleEditorRoot() {
	return module_editor_root;
}

export async function showModuleEditor() {
	if (module_editor_root !== null) {
		show_module_editor = !show_module_editor;
		return;
	}

	show_module_editor = true;

	let host = document.getElementById("module-editor-host");

	if (!host) {
		host = div({
			id: "module-editor-host",
		});

		document.body.appendChild(host);
	}

	await finish();

	// Create shadow DOM
	module_editor_root = host.attachShadow({
		mode: "open",
	});

	// Load styles to shadow DOM
	const base_styles = document.querySelector('style[name="base"]')?.textContent || "";
	useShadowStyles(module_editor_root, base_styles, "base");
	useShadowStyles(module_editor_root, theme, "theme");

	// Mount the module editor
	module_editor_root.appendChild(await ModuleEditor());
}

function sortModules(modules) {
	return modules.sort((a, b) => {
		// Disabled modules always last
		if (a.is_disabled && !b.is_disabled) return 1;
		if (!a.is_disabled && b.is_disabled) return -1;

		// module-loader always first (among enabled modules)
		if (a.name === "module-loader") return -1;
		if (b.name === "module-loader") return 1;

		// main always second (among enabled modules)
		if (a.name === "main") return -1;
		if (b.name === "main") return 1;

		// @std/ modules always last (among enabled modules)
		const a_is_std = a.name.startsWith("@std/");
		const b_is_std = b.name.startsWith("@std/");

		if (a_is_std && !b_is_std) return 1;
		if (!a_is_std && b_is_std) return -1;

		// If both are @std/ or both are regular modules, sort alphabetically
		return a.name.localeCompare(b.name);
	});
}

async function ModuleEditor() {
	const blob_module_loader_script = document.getElementById("module-loader");
	const loader_blob = new Blob([blob_module_loader_script.textContent], {
		type: "text/javascript",
	});
	const modules = [{
			name: "module-loader",
			module_name: "module-loader",
			blob_url: blob_module_loader_script ? URL.createObjectURL(loader_blob) : "",
			remote_url: null,
			src_bytes: blob_module_loader_script ? loader_blob.size : 0,
			is_disabled: false,
			is_visible: true,
		},
		...Array.from(window.__blob_module_map__.entries()).map(([name, module], index) => {
			return {
				name,
				...module,
				is_visible: true,
			};
		}),
		// .filter((module) => !module.is_disabled),
	];

	console.log(modules);

	let active_tab = "main";
	let code_panels = [];

	for (let module of modules.filter((module) => !module.is_disabled)) {
		code_panels.push(
			await Codepad({
				module,
				style: () => `display: ${active_tab === module.name ? "block" : "none"}`,
			}),
		);
	}

	return div({
			id: "module-editor",
			style: () => `display: ${show_module_editor ? "flex" : "none"}`,
		},
		div({
				id: "sidebar",
			},
			div({
					id: "corner",
				},
				"modules",
			),
			...sortModules(modules).map((module) => {
				return button({
						class: "sidebar-item",
						disabled: module.is_disabled ? true : null,
						"data-active": () => active_tab === module.name,
						onclick() {
							active_tab = module.name;
						},
					},
					module.name,
				);
			}),
		),
		div({
				id: "main-panel",
			},
			code_panels,
		),
	);
}

const theme = css`
	:host {
		--color-highlight: #aafee7;
	}

	#module-editor {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		background: #333;
		color: white;
		display: flex;
		-webkit-font-smoothing: ${window.devicePixelRatio > 1 ? "antialiased" : "none"};
		z-index: 99999;
		padding: 10px;
	}

	#corner {
		display: none;
		color: transparent;
		background: transparent;
	}

	#sidebar {
		width: fit-content;
		max-width: 200px;
		flex-shrink: 0;
		height: 100%;
		display: flex;
		flex-direction: column;
		justify-content: flex-start;
		gap: 4px;
		font-family: var(--font-monospace);
		font-size: 11px;
		line-height: 1.25;
		background: #333;
		overflow: scroll;
	}

	#sidebar::-webkit-scrollbar {
		width: 8px;
		height: 8px;
	}

	#sidebar::-webkit-scrollbar-track {
		background: #333;
	}

	#sidebar::-webkit-scrollbar-thumb {
		background: #444444;
	}

	#sidebar::-webkit-scrollbar-thumb:hover {
		background: #505050;
	}

	#sidebar::-webkit-scrollbar-corner {
		background: #333;
	}

	#sidebar .sidebar-item {
		color: white;
	}

	#sidebar .sidebar-item[disabled] {
		opacity: 0.25;
	}

	#sidebar .sidebar-item:hover {
		background: #cacaca;
		color: black;
	}

	#sidebar .sidebar-item[data-active="true"] {
		background: #cacaca;
		color: black;
	}

	#main-panel {
		position: relative;
		width: 100%;
		flex-grow: 1;
		height: 100%;
		font-family: var(--font-monospace);
		font-size: 11px;
		line-height: 1.25;
		display: flex;
		flex-direction: column;
		gap: 22px;
		overflow: hidden;
	}
`;</script>
		<!-- Tooling (disabled) -->
		<script type="blob-module" name="tsc" remote="file:///Users/fernando/repos/om/user/spaces/blank/tsc.js" disabled="" nodownload=""></script>
		<script type="blob-module" name="assemblyscript" remote="https://cdn.jsdelivr.net/npm/assemblyscript@0.28.4/dist/assemblyscript.js" disabled="" nodownload=""></script>
		<script type="blob-module" name="asc" remote="https://cdn.jsdelivr.net/npm/assemblyscript@0.28.4/dist/asc.js" disabled="" nodownload=""></script>
		<script type="blob-module" name="binaryen" remote="https://cdn.jsdelivr.net/npm/binaryen@123.0.0-nightly.20250530/index.js" disabled="" nodownload=""></script>
		<script type="blob-module" name="long" remote="https://cdn.jsdelivr.net/npm/long@5.2.4/index.js" disabled="" nodownload=""></script>
	</head>
	<body style=""><div id="module-editor-host"></div>


<main styles-key="main-wrapper"><div styles-key="key-is-always-required"><span>0.363</span></div></main>

</body></html>
